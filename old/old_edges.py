

import numpy as np
import scipy as sp
import time  as tt 
import datetime as dt
import multiprocessing as mp
import old_reflection_coefficient as rc
import numpy.linalg as nla

import scipy.io as sio
import scipy.interpolate as spi
import scipy.optimize as spo
import scipy.special as scs

import matplotlib.pyplot as plt
import matplotlib as mpl

import astropy.units as apu
import astropy.time as apt
import astropy.coordinates as apc

import ephem as eph	# to install, at the bash terminal type $ conda install ephem
#import emcee as ec
import healpy as hp
import pickle

from os import listdir, makedirs, system
from os.path import exists
from os.path import expanduser
from astropy.io import fits
from scipy import stats

import h5py
#import corner
import re

import matplotlib.colors as colors
import matplotlib.cm as cm

from math import floor


# Determining home folder
home_folder = expanduser("~")


import os, sys
edges_folder       = os.environ['EDGES_vol1']









def antenna_s11_correction(band, folder_name, av_trace_index=np.arange(0,2), save='no', save_raw='no', plot='no', T_switch_low1=0):
	"""
	band: 'high_band', or 'low_band'
	folder_name: '2015_157_03_51_s11'
	av_trace_index: np.arange(1000, 2000)
	"""


	# Good night time data for day 2015_157:
	# index = np.arange(1800, 2600); index = np.append(index, np.arange(3300,4000)); index = np.append(index, np.arange(4800,5400)); index = np.append(index, np.arange(6200,6500))

	# Good night time data for day 2015_212: BLADE !!
	# index = np.arange(2500, 3100)

	# Good night time data for day 2015_264: BLADE !!
	# index = np.arange(1000, 1600); index = np.append(index, np.arange(2400, 3000)); index = np.append(index, np.arange(3800, 4329)); 



	# High-band or Low-band
	if band == 'high_band':
		root_path = home_folder + '/DATA/EDGES/calibration/antenna_s11/high_band1/'
	if band == 'low_band':
		root_path = home_folder + '/DATA/EDGES/calibration/antenna_s11/low_band1/'		
	if band == 'low_band2':
		root_path = home_folder + '/DATA/EDGES/calibration/antenna_s11/low_band2/'
		
	if band == 'mid_band':
		root_path = home_folder + '/DATA/EDGES/calibration/antenna_s11/mid_band/'	

	raw_path  = root_path + 's11/raw/' + folder_name + '/'
	corr_path = root_path + 's11/corrected/' + folder_name + '/'
	plot_path = root_path + 'plots/' + folder_name + '/'




	# listing files to be processed
	full_list = listdir(raw_path)
	full_list.sort()
	


	l1 = []
	l2 = []
	l3 = []
	l4 = []
	vf = []
	for i in range(len(full_list)):

		if "input1" in full_list[i]:
			l1.append(full_list[i])

		if "input2" in full_list[i]:
			l2.append(full_list[i])

		if "input3" in full_list[i]:
			l3.append(full_list[i])	

		if "input4" in full_list[i]:
			l4.append(full_list[i])

		if "voltage" in full_list[i]:
			vf = full_list[i]	

	l = min([len(l1), len(l2), len(l3), len(l4)])
	# l = 10



	# loading temperature-humidity data
	if l > 1:
		Trec, Twea, Hwea = switch_weather_temperature(raw_path + vf) 
	elif l == 1:
		Trec=np.array([34])
		Twea=np.array([34])
		Hwea=np.array([0])



	# dew-point temperature
	b   = 18.678
	c   = 257.14 
	y   = np.log(Hwea/100) + (b * Twea) / (c + Twea)
	Tdp = (c * y) / (b - y) 




	# reflection references
	oref =  1*np.ones(151)
	sref = -1*np.ones(151)
	lref =  0*np.ones(151)




	# creating empty arrays
	date_time_array = np.zeros([l, 6])
	oraw_array      = np.zeros([l, 151]) + 0j
	sraw_array      = np.zeros([l, 151]) + 0j
	lraw_array      = np.zeros([l, 151]) + 0j
	araw_array      = np.zeros([l, 151]) + 0j
	acorr1_array    = np.zeros([l, 151]) + 0j
	acorr2_array    = np.zeros([l, 151]) + 0j




	# correct and store measurements
	for i in range(l):

		print('trace ' + str(i) + ' of ' + str(l))

		# reading measurements from ith cycle
		oi, f = rc.s1p_read(raw_path + l1[i])
		si, f = rc.s1p_read(raw_path + l2[i])
		li, f = rc.s1p_read(raw_path + l3[i])
		ai, f = rc.s1p_read(raw_path + l4[i])


		# appending measurements to arrays
		oraw_array[i,:] = oi
		sraw_array[i,:] = si
		lraw_array[i,:] = li
		araw_array[i,:] = ai


		# first correction
		aic  = rc.de_embed(oref, sref, lref, oi, si, li, ai)
		acorr1_array[i,:] = aic[0]


		# storing date/time
		date_time_array[i, 0] = int(l1[i][16:20])
		date_time_array[i, 1] = int(l1[i][20:22])
		date_time_array[i, 2] = int(l1[i][22:24]) 
		date_time_array[i, 3] = int(l1[i][25:27]) 
		date_time_array[i, 4] = int(l1[i][27:29]) 
		date_time_array[i, 5] = int(l1[i][29:31]) 


		# switch correction
		if band == 'high_band':
			aicc = high_band_switch_correction(aic[0], Trec[i]) # it returns a tuple





		if band == 'low_band':

			#if (date_time_array[i,0] + (date_time_array[i,1] /12)) < (2017 + (5/12)):
				#print('\n Switch Correction Low-Band 1 Receiver 2015-09\n')

				#if T_switch_low1==0:
					#aicc = low_band_switch_correction(aic[0], Trec[i], f_in = f)
				#else:
					#aicc = low_band_switch_correction(aic[0], T_switch_low1, f_in = f)



			#if (date_time_array[i,0] + (date_time_array[i,1] /12)) > (2017 + (5/12)):
				##print('\n Switch Correction Low-Band 1 Receiver 2017-05\n')
				##aicc = low_band1_switch_correction_2017_05_25C(aic[0], f_in = f)

				#print('\n Switch Correction Low-Band 1 Receiver 2017-07\n')
				#LAB_REP = 1
				#aicc    = low_band1_switch_correction_2017_07_25C(aic[0], f_in = f, repetition=LAB_REP)


			aicc = low_band1_switch_correction_2017_08_15C_25C_35C(aic[0], f_in = f, Tswitch = 25)






		if band == 'low_band2':
			print('\n Switch Correction Low-Band 2 Receiver 2016-06\n')
			aicc = low_band_switch_correction_june_2016(aic[0], f_in = f)  # This is the right function to use
			#temp = low_band_switch_correction_september_2016(aic[0], f_in = f)


		acorr2_array[i,:] = aicc[0]





	# average measurements
	if l>1:
		av_ar         = np.mean(araw_array,   axis=0)
		av_ac1        = np.mean(acorr1_array, axis=0)
		av_ac2        = np.mean(acorr2_array, axis=0)
		av_ac2_better = np.mean(acorr2_array[av_trace_index,:], axis=0)

	elif l == 1:
		av_ar = araw_array[0,:]
		av_ac1 = acorr1_array[0,:]
		av_ac2 = acorr2_array[0,:]
		av_ac2_better = acorr2_array[0,:]


	output_av_ac2 = np.array([f, np.real(av_ac2_better), np.imag(av_ac2_better)]).T
	env = np.array([Trec, Twea, Hwea, Tdp]).T
	output_auxiliary = np.append(date_time_array, env[0:l,:], axis=1) 
	#output_auxiliary = Trec

	#print(env[0:l,:].shape)

	# saving average corrected measurement
	if save == 'yes':


		# creating folder if necessary
		if not exists(corr_path):
			makedirs(corr_path)

		np.savetxt(corr_path + 'average_' + folder_name + '.txt', output_av_ac2, header='freq [Hz]\tre(antenna_s11)\tim(antenna_s11)')
		np.savetxt(corr_path + 'dataset_' + folder_name + '_magnitude_linear_50-200MHz.txt', np.abs(acorr2_array))
		np.savetxt(corr_path + 'dataset_' + folder_name + '_phase_deg_50-200MHz.txt',        (180/np.pi) * np.unwrap(np.angle(acorr2_array)))
		np.savetxt(corr_path + 'dataset_' + folder_name + '_UTCDateTime_Tswitch_Tamb_Hamb_Tdp.txt', output_auxiliary)


		if save_raw == 'yes':
			np.savetxt(corr_path + 'open_raw_dataset_' + folder_name +  '_magnitude_linear_50-200MHz.txt', np.abs(oraw_array))
			np.savetxt(corr_path + 'open_raw_dataset_' + folder_name +  '_phase_deg_50-200MHz.txt',        (180/np.pi) * np.unwrap(np.angle(oraw_array)))

			np.savetxt(corr_path + 'short_raw_dataset_' + folder_name + '_magnitude_linear_50-200MHz.txt', np.abs(sraw_array))
			np.savetxt(corr_path + 'short_raw_dataset_' + folder_name + '_phase_deg_50-200MHz.txt',        (180/np.pi) * np.unwrap(np.angle(sraw_array)))			

			np.savetxt(corr_path + 'load_raw_dataset_' + folder_name +  '_magnitude_linear_50-200MHz.txt', np.abs(lraw_array))
			np.savetxt(corr_path + 'load_raw_dataset_' + folder_name +  '_phase_deg_50-200MHz.txt',        (180/np.pi) * np.unwrap(np.angle(lraw_array)))

			np.savetxt(corr_path + 'ant_raw_dataset_' + folder_name +  '_magnitude_linear_50-200MHz.txt', np.abs(araw_array))
			np.savetxt(corr_path + 'ant_raw_dataset_' + folder_name +  '_phase_deg_50-200MHz.txt',        (180/np.pi) * np.unwrap(np.angle(araw_array)))			


	# plotting
	if plot == 'yes':


		# creating folder if necessary
		if not exists(plot_path):
			makedirs(plot_path)





		# figure 1
		plt.close()
		f1  = plt.figure(num=1, figsize=(13, 7))
		ax1 = f1.add_subplot(111)
		ax2 = ax1.twinx()

		line1 = ax1.plot(np.arange(l)+1, Trec[0:l], 'b',   label='temp. switch')
		line2 = ax1.plot(np.arange(l)+1, Twea[0:l], 'g',   label='temp. environment')
		line3 = ax2.plot(np.arange(l)+1, Hwea[0:l], 'r--', label='hum. environment')
		line4 = ax1.plot(np.arange(l)+1, Tdp[0:l],  'k',   label='dew point temp.')

		ladded = line1+line2+line3+line4
		lab = [k.get_label() for k in ladded]
		ax1.legend(ladded, lab, loc=0)

		ax1.set_xlabel('trace number')
		ax1.set_ylabel('temperature [$^o$C]', color='k')
		ax2.set_ylabel('humidity [%]', color='k')
		ax1.set_xlim([0, l+1])
		ax1.set_ylim([-10, 60])
		ax2.set_ylim([0, 100])
		ax1.set_yticks(np.arange(-10,70,10))
		ax1.grid()
		f1.suptitle(folder_name, fontsize=20)

		# saving plot
		plt.savefig(plot_path + 'summary1_' + folder_name + '.png', bbox_inches='tight')

		plt.close()







		# figure 2
		plt.close()
		f1 = plt.figure(num=1, figsize=(12, 8))

		ax1 = f1.add_axes([0.05, 0.5, 0.33, 0.37])
		ax1.plot(f/1e6, 20*np.log10(np.abs(av_ac2_better)))
		ax1.grid()
		ax1.set_ylabel('magnitude [dB]')
		if band == 'high_band':
			ax1.set_xlim([90, 200])
		elif band == 'low_band':
			ax1.set_xlim([50, 100])
		ax1.set_ylim([-20, 0])


		ax2 = f1.add_axes([0.55, 0.5, 0.33, 0.37])
		ax2.plot(f/1e6, (180/np.pi)*np.unwrap(np.angle(av_ac2_better))+360)
		ax2.grid()
		ax2.set_ylabel('phase [deg]')
		if band == 'high_band':
			ax2.set_xlim([90, 200])
			ax2.set_ylim([-500, 100])

		elif band == 'low_band':
			ax2.set_xlim([50, 100])
			ax2.set_ylim([-200, 400])

		ax3 = f1.add_axes([0.05, 0.05, 0.33, 0.37])
		if band == 'high_band':
			ext = [90, 200, l+0.5, 0.5]
			i1  = 40
			i2  = -1
		elif band == 'low_band':
			ext = [50, 100, l+0.5, 0.5]
			i1  = 0
			i2  = 51

		im = ax3.imshow(20*np.log10(np.abs(acorr2_array[:,i1:i2])) - 20*np.log10(np.abs(av_ac2_better[i1:i2])), aspect='auto', interpolation='nearest', extent = ext)
		im.set_clim([-0.05, 0.05])
		ax3.set_xlabel('frequency [MHz]')
		ax3.set_ylabel('trace number')
		cbaxes = f1.add_axes([0.39, 0.05, 0.015, 0.37])
		cb = plt.colorbar(im, cax=cbaxes)
		cb.set_label('$\Delta$ magnitude [dB]')


		ax4 = f1.add_axes([0.55, 0.05, 0.33, 0.37])
		if band == 'high_band':
			ext = [90, 200, l+0.5, 0.5]
		elif band == 'low_band':
			ext = [50, 100, l+0.5, 0.5]
		im = ax4.imshow((180/np.pi)*np.unwrap(np.angle(acorr2_array[:,i1:i2])) - (180/np.pi)*np.unwrap(np.angle(av_ac2_better[i1:i2])), aspect='auto', interpolation='nearest', extent = ext)
		im.set_clim([-0.4, 0.4])
		ax4.set_xlabel('frequency [MHz]')
		ax4.set_ylabel('trace number')
		cbaxes = f1.add_axes([0.89, 0.05, 0.015, 0.37])
		cb = plt.colorbar(im, cax=cbaxes)
		cb.set_label('$\Delta$ phase [deg]')

		f1.suptitle(folder_name, fontsize=20)


		# saving plot
		plt.savefig(plot_path + 'summary2_' + folder_name + '.png', bbox_inches='tight')
		plt.close()








		# figure 3
		xx = l
		aa = 2500
		bb = 3100
		cc = 1900


		plt.close()
		f1 = plt.figure(num=1, figsize=(20, 12))

		ax1 = f1.add_subplot(3,1,1)
		line1 = ax1.plot( 20*np.log10(np.abs(acorr2_array[0:xx, 60]))  - 20*np.log10(np.abs(av_ac2_better[60]))  + 4 * 0.1, label='110 MHz' )   
		line2 = ax1.plot( 20*np.log10(np.abs(acorr2_array[0:xx, 80]))  - 20*np.log10(np.abs(av_ac2_better[80]))  + 3 * 0.1, label='130 MHz' ) 
		line3 = ax1.plot( 20*np.log10(np.abs(acorr2_array[0:xx, 100])) - 20*np.log10(np.abs(av_ac2_better[100])) + 2 * 0.1, label='150 MHz' )
		line4 = ax1.plot( 20*np.log10(np.abs(acorr2_array[0:xx, 120])) - 20*np.log10(np.abs(av_ac2_better[120])) + 1 * 0.1, label='170 MHz' )
		line5 = ax1.plot( 20*np.log10(np.abs(acorr2_array[0:xx, 140])) - 20*np.log10(np.abs(av_ac2_better[140])) + 0 * 0.1, label='190 MHz' )

		ladded = line1+line2+line3+line4+line5
		lab = [k.get_label() for k in ladded]
		ax1.legend(ladded, lab, bbox_to_anchor=(1, 1.2), ncol=5)

		ax1.set_ylim([-0.05, 0.45])
		ax1.set_yticks([-0.05, 0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45])
		ax1.set_yticklabels(['','','','','','','','','','',''])
		ax1.grid()
		ax1.set_ylabel('$\Delta$ magnitude [dB]   (0.05 dB per division)')



		ax2 = f1.add_subplot(3,1,2)		
		ax2.plot( (180/np.pi) * ( np.angle(acorr2_array[0:xx, 60])  - np.angle(av_ac2_better[60]) )  + 4 * 1 )
		ax2.plot( (180/np.pi) * ( np.angle(acorr2_array[0:xx, 80])  - np.angle(av_ac2_better[80]) )  + 3 * 1 )
		ax2.plot( (180/np.pi) * ( np.angle(acorr2_array[0:xx, 100]) - np.angle(av_ac2_better[100]) ) + 2 * 1 )
		ax2.plot( (180/np.pi) * ( np.angle(acorr2_array[0:xx, 120]) - np.angle(av_ac2_better[120]) ) + 1 * 1 )
		ax2.plot( (180/np.pi) * ( np.angle(acorr2_array[0:xx, 140]) - np.angle(av_ac2_better[140]) ) + 0 * 1 )


		ax2.set_ylim([-0.5, 4.5])
		ax2.set_yticks([-0.5, 0, 0.5, 1, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5])
		ax2.set_yticklabels(['','','','','','','','','','',''])
		ax2.grid()
		ax2.set_ylabel('$\Delta$ phase [ $^o$ ]   (0.5$^o$ per division)')



		ax3 = f1.add_subplot(3,1,3)	
		line1 = ax3.plot( Twea[0:xx], label='temp. environment' )
		line2 = ax3.plot( Tdp[0:xx],  label='dew point temp.' )
		ax3.grid()
		ax3.set_ylabel('temperature [$^o$C]')
		ax3.set_xlabel('trace number')

		ladded = line1+line2
		lab = [k.get_label() for k in ladded]
		ax3.legend(ladded, lab, loc=0)

		# saving plot
		plt.savefig(plot_path + 'summary3_' + folder_name + '.png', bbox_inches='tight')
		plt.close()






		# figure 4
		plt.close()
		f1 = plt.figure(num=1, figsize=(18, 14))

		ax1 = f1.add_subplot(5,2,1) 
		line1 = ax1.plot( Twea[av_trace_index], 20*np.log10(np.abs(acorr2_array[av_trace_index, 60]))  - 20*np.log10(np.abs(av_ac2_better[60])),  'b.', label='110 MHz' )
		ax1.grid()
		ax1.set_ylim([-0.1, 0.1])
		ax1.set_ylabel('110 MHz [dB]')
		ax1.set_title('$\Delta$ MAGNITUDE')

		ax3 = f1.add_subplot(5,2,3)
		line3 = ax3.plot( Twea[av_trace_index], 20*np.log10(np.abs(acorr2_array[av_trace_index, 80]))  - 20*np.log10(np.abs(av_ac2_better[80])),  'g.', label='130 MHz' )
		ax3.grid()
		ax3.set_ylabel('130 MHz [dB]')
		ax3.set_ylim([-0.1, 0.1])


		ax5 = f1.add_subplot(5,2,5)
		line5 = ax5.plot( Twea[av_trace_index], 20*np.log10(np.abs(acorr2_array[av_trace_index, 100])) - 20*np.log10(np.abs(av_ac2_better[100])), 'r.', label='150 MHz' )
		ax5.grid()
		ax5.set_ylabel('150 MHz [dB]')
		ax5.set_ylim([-0.1, 0.1])

		ax7 = f1.add_subplot(5,2,7)
		line7 = ax7.plot( Twea[av_trace_index], 20*np.log10(np.abs(acorr2_array[av_trace_index, 120])) - 20*np.log10(np.abs(av_ac2_better[120])), 'c.', label='170 MHz' )
		ax7.grid()
		ax7.set_ylabel('170 MHz [dB]')
		ax7.set_ylim([-0.1, 0.1])

		ax9 = f1.add_subplot(5,2,9)
		line9 = ax9.plot( Twea[av_trace_index], 20*np.log10(np.abs(acorr2_array[av_trace_index, 140])) - 20*np.log10(np.abs(av_ac2_better[140])), 'm.', label='190 MHz' )
		ax9.grid()
		ax9.set_ylabel('190 MHz [dB]')
		ax9.set_ylim([-0.1, 0.1])
		ax9.set_xlabel('temperature [ $^o$C ]')



		ax2 = f1.add_subplot(5,2,2) 
		ax2.plot( Twea[av_trace_index], (180/np.pi) * ( np.angle(acorr2_array[av_trace_index, 60])  - np.angle(av_ac2_better[60]) ),   'b.', label='110 MHz' )
		ax2.grid()
		ax2.set_ylim([-1, 1])
		ax2.set_ylabel('110 MHz [ $^o$ ]')
		ax2.set_title('$\Delta$ PHASE')

		ax4 = f1.add_subplot(5,2,4) 
		ax4.plot( Twea[av_trace_index], (180/np.pi) * ( np.angle(acorr2_array[av_trace_index, 80])  - np.angle(av_ac2_better[80]) ),   'g.', label='130 MHz' )
		ax4.grid()
		ax4.set_ylabel('130 MHz [ $^o$ ]')
		ax4.set_ylim([-1, 1])

		ax6 = f1.add_subplot(5,2,6) 
		ax6.plot( Twea[av_trace_index], (180/np.pi) * ( np.angle(acorr2_array[av_trace_index, 100])  - np.angle(av_ac2_better[100]) ), 'r.', label='150 MHz' )
		ax6.grid()
		ax6.set_ylabel('150 MHz [ $^o$ ]')
		ax6.set_ylim([-1, 1])

		ax8 = f1.add_subplot(5,2,8) 
		ax8.plot( Twea[av_trace_index], (180/np.pi) * ( np.angle(acorr2_array[av_trace_index, 120])  - np.angle(av_ac2_better[120]) ), 'c.', label='170 MHz' )
		ax8.grid()
		ax8.set_ylabel('170 MHz [ $^o$ ]')
		ax8.set_ylim([-1, 1])

		ax10 = f1.add_subplot(5,2,10) 
		ax10.plot( Twea[av_trace_index], (180/np.pi) * ( np.angle(acorr2_array[av_trace_index, 140])  - np.angle(av_ac2_better[140]) ), 'm.', label='190 MHz' )
		ax10.grid()
		ax10.set_ylabel('190 MHz [ $^o$ ]')
		ax10.set_ylim([-1, 1])

		ax10.set_xlabel('temperature [ $^o$C ]')


		# saving plot
		plt.savefig(plot_path + 'summary4_' + folder_name + '.png', bbox_inches='tight')
		plt.close()




	# returning corrected data, frequency, temperature, humidity, and semi-corrected data
	return (output_av_ac2, output_auxiliary, acorr2_array, f, acorr1_array, araw_array, av_ac2, av_ac1, av_ar) #, temp, hum, acorr1_array)









def high_band_switch_correction(ant_s11, sw_temp):


	# loading fit parameters
	data_path = home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_march_2015/antenna/switch_parameters/';

	par_15    = np.genfromtxt(data_path + 'parameters_receiver_15degC.txt')
	par_25    = np.genfromtxt(data_path + 'parameters_receiver_25degC.txt')
	par_35    = np.genfromtxt(data_path + 'parameters_receiver_35degC.txt')




	# frequency
	f = np.arange(50,200.1,0.25)



	# fit degree
	deg = 10



	# evaluating S-parameters
	s11_mag_15    = np.polyval(par_15[:,0], f/150)
	s11_ang_15    = np.polyval(par_15[:,1], f/150)
	s12s21_mag_15 = np.polyval(par_15[:,2], f/150)
	s12s21_ang_15 = np.polyval(par_15[:,3], f/150)
	s22_mag_15    = np.polyval(par_15[:,4], f/150)
	s22_ang_15    = np.polyval(par_15[:,5], f/150)

	s11_mag_25    = np.polyval(par_25[:,0], f/150)
	s11_ang_25    = np.polyval(par_25[:,1], f/150)
	s12s21_mag_25 = np.polyval(par_25[:,2], f/150)
	s12s21_ang_25 = np.polyval(par_25[:,3], f/150)
	s22_mag_25    = np.polyval(par_25[:,4], f/150)
	s22_ang_25    = np.polyval(par_25[:,5], f/150)

	s11_mag_35    = np.polyval(par_35[:,0], f/150)
	s11_ang_35    = np.polyval(par_35[:,1], f/150)
	s12s21_mag_35 = np.polyval(par_35[:,2], f/150)
	s12s21_ang_35 = np.polyval(par_35[:,3], f/150)
	s22_mag_35    = np.polyval(par_35[:,4], f/150)
	s22_ang_35    = np.polyval(par_35[:,5], f/150)



	# switch temperatures
	temp_all = np.genfromtxt(data_path + 'switch_temperatures.txt')
	temp15   = temp_all[0]
	temp25   = temp_all[1]
	temp35   = temp_all[2]






	# intermediate array
	new_s11_mag    = np.zeros(len(f))
	new_s11_ang    = np.zeros(len(f))
	new_s12s21_mag = np.zeros(len(f))
	new_s12s21_ang = np.zeros(len(f))
	new_s22_mag    = np.zeros(len(f))
	new_s22_ang    = np.zeros(len(f))







	# inter (extra) polating switch S-parameters to input temperature

	if (sw_temp <= temp25):
		for i in range(len(f)):

			p = np.polyfit(np.array([temp15, temp25]), np.array([s11_mag_15[i], s11_mag_25[i]]), 1)
			new_s11_mag[i] = np.polyval(p, sw_temp)


			p = np.polyfit(np.array([temp15, temp25]), np.array([s11_ang_15[i], s11_ang_25[i]]), 1)
			new_s11_ang[i] = np.polyval(p, sw_temp)


			p = np.polyfit(np.array([temp15, temp25]), np.array([s12s21_mag_15[i], s12s21_mag_25[i]]), 1)
			new_s12s21_mag[i] = np.polyval(p, sw_temp)

			p = np.polyfit(np.array([temp15, temp25]), np.array([s12s21_ang_15[i], s12s21_ang_25[i]]), 1)
			new_s12s21_ang[i] = np.polyval(p, sw_temp)


			p = np.polyfit(np.array([temp15, temp25]), np.array([s22_mag_15[i], s22_mag_25[i]]), 1)
			new_s22_mag[i] = np.polyval(p, sw_temp)

			p = np.polyfit(np.array([temp15, temp25]), np.array([s22_ang_15[i], s22_ang_25[i]]), 1)
			new_s22_ang[i] = np.polyval(p, sw_temp)




	if (sw_temp > temp25):
		for i in range(len(f)):

			p = np.polyfit(np.array([temp25, temp35]), np.array([s11_mag_25[i], s11_mag_35[i]]), 1)
			new_s11_mag[i] = np.polyval(p, sw_temp)


			p = np.polyfit(np.array([temp25, temp35]), np.array([s11_ang_25[i], s11_ang_35[i]]), 1)
			new_s11_ang[i] = np.polyval(p, sw_temp)


			p = np.polyfit(np.array([temp25, temp35]), np.array([s12s21_mag_25[i], s12s21_mag_35[i]]), 1)
			new_s12s21_mag[i] = np.polyval(p, sw_temp)

			p = np.polyfit(np.array([temp25, temp35]), np.array([s12s21_ang_25[i], s12s21_ang_35[i]]), 1)
			new_s12s21_ang[i] = np.polyval(p, sw_temp)


			p = np.polyfit(np.array([temp25, temp35]), np.array([s22_mag_25[i], s22_mag_35[i]]), 1)
			new_s22_mag[i] = np.polyval(p, sw_temp)

			p = np.polyfit(np.array([temp25, temp35]), np.array([s22_ang_25[i], s22_ang_35[i]]), 1)
			new_s22_ang[i] = np.polyval(p, sw_temp)




	# modeling new corrections in frequency
	p_new_s11_mag    = np.polyfit(f/150, new_s11_mag, deg)
	p_new_s11_ang    = np.polyfit(f/150, new_s11_ang, deg)
	p_new_s12s21_mag = np.polyfit(f/150, new_s12s21_mag, deg)
	p_new_s12s21_ang = np.polyfit(f/150, new_s12s21_ang, deg)
	p_new_s22_mag    = np.polyfit(f/150, new_s22_mag, deg)
	p_new_s22_ang    = np.polyfit(f/150, new_s22_ang, deg)

	sw_s11_mag    = np.polyval(p_new_s11_mag,    f/150);
	sw_s11_ang    = np.polyval(p_new_s11_ang,    f/150);
	sw_s12s21_mag = np.polyval(p_new_s12s21_mag, f/150);
	sw_s12s21_ang = np.polyval(p_new_s12s21_ang, f/150);
	sw_s22_mag    = np.polyval(p_new_s22_mag,    f/150);
	sw_s22_ang    = np.polyval(p_new_s22_ang,    f/150);




	# combine computed complex S-parameters
	# new_s11    = new_s11_mag    * (np.cos(new_s11_ang)    + 1j*np.sin(new_s11_ang))
	# new_s12s21 = new_s12s21_mag * (np.cos(new_s12s21_ang) + 1j*np.sin(new_s12s21_ang))
	# new_s22    = new_s22_mag    * (np.cos(new_s22_ang)    + 1j*np.sin(new_s22_ang))




	# combine computed complex S-parameters
	sw_s11    = sw_s11_mag    * (np.cos(sw_s11_ang)    + 1j*np.sin(sw_s11_ang))
	sw_s12s21 = sw_s12s21_mag * (np.cos(sw_s12s21_ang) + 1j*np.sin(sw_s12s21_ang))
	sw_s22    = sw_s22_mag    * (np.cos(sw_s22_ang)    + 1j*np.sin(sw_s22_ang))



	# corrected antenna S11
	corr_ant_s11 = rc.gamma_de_embed(sw_s11, sw_s12s21, sw_s22, ant_s11)



	# returns corrected antenna measurement
	return (corr_ant_s11, sw_s11, sw_s12s21, sw_s22)

















def low_band_switch_correction(ant_s11, temp_sw, f_in = np.zeros([0,1])):


	# Paths
	data_path_15 = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band1/2015_08_25C/data/s11/raw/20150905/switch15degC/'
	data_path_25 = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band1/2015_08_25C/data/s11/raw/20150903/switch25degC/'
	data_path_35 = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band1/2015_08_25C/data/s11/raw/20150905/switch35degC/'


	# Measurements at 15degC 
	o_sw_m15, fd  = rc.s1p_read(data_path_15 + 'open.S1P')
	s_sw_m15, fd  = rc.s1p_read(data_path_15 + 'short.S1P')
	l_sw_m15, fd  = rc.s1p_read(data_path_15 + 'load.S1P')

	o_sw_in15, fd = rc.s1p_read(data_path_15 + 'open_input.S1P')
	s_sw_in15, fd = rc.s1p_read(data_path_15 + 'short_input.S1P')
	l_sw_in15, fd = rc.s1p_read(data_path_15 + 'load_input.S1P')	


	# Measurements at 25degC 
	o_sw_m25, fd  = rc.s1p_read(data_path_25 + 'open.S1P')
	s_sw_m25, fd  = rc.s1p_read(data_path_25 + 'short.S1P')
	l_sw_m25, fd  = rc.s1p_read(data_path_25 + 'load.S1P')

	o_sw_in25, fd = rc.s1p_read(data_path_25 + 'open_input.S1P')
	s_sw_in25, fd = rc.s1p_read(data_path_25 + 'short_input.S1P')
	l_sw_in25, fd = rc.s1p_read(data_path_25 + 'load_input.S1P')	


	# Measurements at 35degC 
	o_sw_m35, fd  = rc.s1p_read(data_path_35 + 'open.S1P')
	s_sw_m35, fd  = rc.s1p_read(data_path_35 + 'short.S1P')
	l_sw_m35, fd  = rc.s1p_read(data_path_35 + 'load.S1P')

	o_sw_in35, fd = rc.s1p_read(data_path_35 + 'open_input.S1P')
	s_sw_in35, fd = rc.s1p_read(data_path_35 + 'short_input.S1P')
	l_sw_in35, fd = rc.s1p_read(data_path_35 + 'load_input.S1P')	




	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(fd))
	s_sw = -1 * np.ones(len(fd))
	l_sw =  0 * np.ones(len(fd))	



	# Correction at the switch -- 15degC
	o_m15, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m15, s_sw_m15, l_sw_m15, o_sw_in15)
	s_m15, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m15, s_sw_m15, l_sw_m15, s_sw_in15)
	l_m15, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m15, s_sw_m15, l_sw_m15, l_sw_in15)


	# Correction at the switch -- 25degC
	o_m25, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m25, s_sw_m25, l_sw_m25, o_sw_in25)
	s_m25, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m25, s_sw_m25, l_sw_m25, s_sw_in25)
	l_m25, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m25, s_sw_m25, l_sw_m25, l_sw_in25)


	# Correction at the switch -- 35degC
	o_m35, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m35, s_sw_m35, l_sw_m35, o_sw_in35)
	s_m35, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m35, s_sw_m35, l_sw_m35, s_sw_in35)
	l_m35, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m35, s_sw_m35, l_sw_m35, l_sw_in35)






	# Correction at the input
	resistance_male15 = 50.13
	resistance_male25 = 50.12
	resistance_male35 = 50.11
	oa15, sa15, la15 = rc.agilent_85033E(fd, resistance_male15, 1)
	oa25, sa25, la25 = rc.agilent_85033E(fd, resistance_male25, 1)
	oa35, sa35, la35 = rc.agilent_85033E(fd, resistance_male35, 1)


	xx, s11_15, s12s21_15, s22_15 = rc.de_embed(oa15, sa15, la15, o_m15, s_m15, l_m15, o_m15)
	xx, s11_25, s12s21_25, s22_25 = rc.de_embed(oa25, sa25, la25, o_m25, s_m25, l_m25, o_m25)
	xx, s11_35, s12s21_35, s22_35 = rc.de_embed(oa35, sa35, la35, o_m35, s_m35, l_m35, o_m35)



	# Switch temperatures
	temp15 = 18.67
	temp25 = 27.16 
	temp35 = 35.31






	# interpolated arrays

	real_s11_eval    = np.zeros(len(fd))
	imag_s11_eval    = np.zeros(len(fd))
	real_s12s21_eval = np.zeros(len(fd))
	imag_s12s21_eval = np.zeros(len(fd))
	real_s22_eval    = np.zeros(len(fd))
	imag_s22_eval    = np.zeros(len(fd))


	for i in range(201):


		if temp_sw < temp25:

			temp_array = np.array([temp15, temp25])

			real_s11 = np.real(np.array([s11_15[i], s11_25[i]]))
			imag_s11 = np.imag(np.array([s11_15[i], s11_25[i]]))

			real_s12s21 = np.real(np.array([s12s21_15[i], s12s21_25[i]]))
			imag_s12s21 = np.imag(np.array([s12s21_15[i], s12s21_25[i]]))

			real_s22 = np.real(np.array([s22_15[i], s22_25[i]]))
			imag_s22 = np.imag(np.array([s22_15[i], s22_25[i]]))		





			p = np.polyfit(temp_array, real_s11, 1)
			real_s11_eval[i] = np.polyval(p, temp_sw)

			p = np.polyfit(temp_array, imag_s11, 1)
			imag_s11_eval[i] = np.polyval(p, temp_sw)			

			p = np.polyfit(temp_array, real_s12s21, 1)
			real_s12s21_eval[i] = np.polyval(p, temp_sw)

			p = np.polyfit(temp_array, imag_s12s21, 1)
			imag_s12s21_eval[i] = np.polyval(p, temp_sw)	

			p = np.polyfit(temp_array, real_s22, 1)
			real_s22_eval[i] = np.polyval(p, temp_sw)

			p = np.polyfit(temp_array, imag_s22, 1)
			imag_s22_eval[i] = np.polyval(p, temp_sw)	



		if temp_sw >= temp25:

			temp_array = np.array([temp25, temp35])

			real_s11 = np.real(np.array([s11_25[i], s11_35[i]]))
			imag_s11 = np.imag(np.array([s11_25[i], s11_35[i]]))

			real_s12s21 = np.real(np.array([s12s21_25[i], s12s21_35[i]]))
			imag_s12s21 = np.imag(np.array([s12s21_25[i], s12s21_35[i]]))

			real_s22 = np.real(np.array([s22_25[i], s22_35[i]]))
			imag_s22 = np.imag(np.array([s22_25[i], s22_35[i]]))		





			p = np.polyfit(temp_array, real_s11, 1)
			real_s11_eval[i] = np.polyval(p, temp_sw)

			p = np.polyfit(temp_array, imag_s11, 1)
			imag_s11_eval[i] = np.polyval(p, temp_sw)			

			p = np.polyfit(temp_array, real_s12s21, 1)
			real_s12s21_eval[i] = np.polyval(p, temp_sw)

			p = np.polyfit(temp_array, imag_s12s21, 1)
			imag_s12s21_eval[i] = np.polyval(p, temp_sw)	

			p = np.polyfit(temp_array, real_s22, 1)
			real_s22_eval[i] = np.polyval(p, temp_sw)

			p = np.polyfit(temp_array, imag_s22, 1)
			imag_s22_eval[i] = np.polyval(p, temp_sw)	



	# Final smoothing
	fdn     = fd/75e6

	if len(f_in) > 10:
		if f_in[0] > 1e5:
			fn_in = f_in/75e6
		elif f_in[0] < 300:
			fn_in = f_in/75
	else:
		fn_in = fdn



	p = np.polyfit(fdn, real_s11_eval, 7)
	fit_real_s11 = np.polyval(p, fn_in)

	p = np.polyfit(fdn, imag_s11_eval, 7)
	fit_imag_s11 = np.polyval(p, fn_in)


	p = np.polyfit(fdn, real_s12s21_eval, 7)
	fit_real_s12s21 = np.polyval(p, fn_in)

	p = np.polyfit(fdn, imag_s12s21_eval, 7)
	fit_imag_s12s21 = np.polyval(p, fn_in)


	p = np.polyfit(fdn, real_s22_eval, 7)
	fit_real_s22 = np.polyval(p, fn_in)

	p = np.polyfit(fdn, imag_s22_eval, 7)
	fit_imag_s22 = np.polyval(p, fn_in)


	fit_s11    = fit_real_s11    + 1j*fit_imag_s11
	fit_s12s21 = fit_real_s12s21 + 1j*fit_imag_s12s21
	fit_s22    = fit_real_s22    + 1j*fit_imag_s22





	# Corrected antenna S11
	corr_ant_s11 = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, ant_s11)



	return (corr_ant_s11, fit_s11, fit_s12s21, fit_s22)


































def switch_weather_temperature(voltage_file):

	vf    = np.genfromtxt(voltage_file)

	vfT   = vf.T
	VTrec = vfT[2]
	VHwea = vfT[3] 
	VTwea = vfT[4] 


	#VTrec = vf[:,2]
	#VHwea = vf[:,3]
	#VTwea = vf[:,4]


	# voltage to resistance
	R0 = 36000
	Rrec = (VTrec * R0) / (5 - VTrec)
	Rwea = (VTwea * R0) / (5 - VTwea)


	# resistance to temperature
	Trec = temperature_thermistor_omega_ON_930_44006(Rrec, unit='C')
	Twea = temperature_thermistor_omega_ON_930_44006(Rwea, unit='C')



	# voltage to humidity
	mV    = VHwea * 1000.0 * 1.5
	RHwea = humidity_sensor_HM1500LF(mV, Twea)


	# output quantities
	return (Trec, Twea, RHwea)




def temperature_thermistor_omega_ON_930_44006(R, unit):

	# Steinhart-Hart coefficients
	a1 = 0.001296751267466723
	a2 = 0.00019737361897609893
	a3 = 3.0403175473012516e-7


	# TK in Kelvin
	TK = 1/(a1 + a2*np.log(R) + a3*(np.log(R))**3)

	# Kelvin or Celsius
	if unit == 'K':
		T = TK
	if unit == 'C':
		T = TK - 273.15

	return T




def temperature_thermistor_oven_industries_TR136_170(R, unit):

	# Steinhart-Hart coefficients
	a1 = 1.03514e-3
	a2 = 2.33825e-4
	a3 = 7.92467e-8


	# TK in Kelvin
	TK = 1/(a1 + a2*np.log(R) + a3*(np.log(R))**3)

	# Kelvin or Celsius
	if unit == 'K':
		T = TK
	if unit == 'C':
		T = TK - 273.15

	return T




def humidity_sensor_HM1500LF(mV, T):

	# Uncorrected relative humidity (RH in %)
	c1 = -1.91e-9
	c2 =  1.33e-5
	c3 =  9.56e-3
	c4 = -2.16e1
	RHwea_unc = c1*(mV**3) + c2*(mV**2) + c3*(mV**1) + c4


	# Corrected relative humidity
	return RHwea_unc + (T - 23.0)*0.05






















##### check this function against the equivalent function in decode.c
def acq_lookup_table(symbol_in):

	if (ord(symbol_in) >= ord('A')) and (ord(symbol_in) <= ord('Z')):
		value_out = ord(symbol_in) - ord('A')

	if (ord(symbol_in) >= ord('a')) and (ord(symbol_in) <= ord('z')):
		value_out = ord(symbol_in) - ord('a') + 26

	elif (ord(symbol_in) >= ord('0')) and (ord(symbol_in) <= ord('9')):
		value_out = ord(symbol_in) - ord('0') + 52

	elif (symbol_in == '+'):
		value_out = 62

	elif (symbol_in == '/'):
		value_out = 63

	else:
		value_out = -1 

	return value_out 








#### finish this function following equivalent function for MATLAB, and using lookup table above #####
def acq2level1(file_name, ambient_temp, hot_temp):


	tload = ambient_temp
	tcal  = hot_temp

	nchannels = 16384*2.0
	max_freq  = 200.0
	nta       = 0
	nanc      = 13
	nchunk    = 2000

	fstep     = max_freq/nchannels
	freqs     = np.arange(0, max_freq, fstep)

	line_ancillary = np.zeros(nanc)

	dates_vector   = np.zeros((5, nchunk))
	dates          = np.zeros(nchunk)

	waterfall   = np.zeros((nchannels, nchunk))
	waterfall_0 = np.zeros((nchannels, nchunk))
	waterfall_1 = np.zeros((nchannels, nchunk))
	waterfall_2 = np.zeros((nchannels, nchunk))






	bSpec = 0
	nLine = 0
	f = open(file_name, 'rb')

	while 1:

		# missing all error checks 

		#if nLine > 0:


		line = f.readline()	
		line_dec = line.decode()	

		if ((line_dec[0] != '*') & (line_dec[0] != '\n') & (line_dec[0] != '#')):

			split_line = line_dec.split
			split_date = split_line.split(':')	

			# Spectrum
			spec = split_line[-1]

			# here. Adapt 'decode.c' for it to work with Python, or maybe do this processing completely in Python


	return 0




def RFI_flagging(f, data_array, poly_degree=10, l_bins=1000, Pw_poly_degree=120):

	# Basic definitions
	fn = (f - 140) / 60
	D = data_array.shape
	if len(D) == 1:
		ls = D[0]
		spectrum = data_array
	elif len(D) == 2:
		ls = D[1]
		spectrum = np.mean(data_array, axis = 0)

	W  = np.ones(ls)     # Weight vector


	# Initializing flags and vectors	
	ready         = 'no'
	old_sum_flag  = 0
	spectrum_temp = spectrum
	fn_temp       = fn


	# Flagging
	index = 0
	while (ready == 'no'): # and (index < 10):

		# Model fitting
		fit    = np.polyfit(fn_temp, spectrum_temp, poly_degree)
		model  = np.polyval(fit, fn)
		R      = spectrum - model

		# Noise characterization
		n_bins = int(len(model) / l_bins)
		residual_numerator_bins   = np.zeros(n_bins)
		residual_denominator_bins = np.zeros(n_bins)			

		for i in range(ls):

			i2 = int(i / l_bins)
			if (i2 < n_bins):
				i3 = i2
			elif (i2 == n_bins): # special treatment for points in the last incomplete pixel (they are pushed to previous pixel)
				i3 = i2 - 1					

			residual_numerator_bins[i3]   = residual_numerator_bins[i3]   + W[i] * R[i]**2
			residual_denominator_bins[i3] = residual_denominator_bins[i3] + W[i]

		noise_bins = np.sqrt(residual_numerator_bins / residual_denominator_bins) # 1-sigma noise in each bin



		# Checking every value in the row for RFI
		number_of_std = 3.5
		sum_flag      = 0
		spectrum_temp = np.zeros(0)
		fn_temp       = np.zeros(0)

		for k in range(ls):

			k2 = int(k / l_bins)
			if (k2 < n_bins):
				k3 = k2
			elif (k2 == n_bins):
				k3 = k2 - 1				

			if (np.abs(spectrum[k] - model[k])    > number_of_std * noise_bins[k3]) or (spectrum[k] == 0):	
				W[k]  = 0
				sum_flag = sum_flag + 1

			elif (np.abs(spectrum[k] - model[k]) <= number_of_std * noise_bins[k3]) and (spectrum[k] != 0):
				spectrum_temp = np.append(spectrum_temp, spectrum[k])
				fn_temp  = np.append(fn_temp, fn[k])

		# Checking if convergence is achieved
		if sum_flag <= old_sum_flag: # if sum of flagged points does not increase (it might even decrease as the identification is refined)
			ready = 'yes'

		elif sum_flag > old_sum_flag:
			old_sum_flag = sum_flag


		# print(index)
		index = index + 1





	# Flagging based on total power
	if len(D) == 2:	

		# Basic definitions
		lp             = D[0]		
		Pw             = np.sum(data_array * W, axis = 1)
		tp             = (np.arange(len(Pw))/len(Pw) - 0.5)/10   # between -0.05 and 0.05
		W2             = np.ones(lp)     # Weight vector

		# Initializing flags and vectors	
		ready         = 'no'
		old_sum_flag  = 0
		Pw_temp       = Pw
		tp_temp       = tp		

		index2 = 0
		while (ready == 'no'):

			# Model fitting
			fit      = np.polyfit(tp_temp, Pw_temp, Pw_poly_degree)
			Pw_model = np.polyval(fit, tp)
			R2       = Pw - Pw_model


			# Noise characterization
			noise = np.sqrt(np.sum(W2*R2**2)/np.sum(W2))
			#print(noise)

			# Checking every value in the row for RFI
			number_of_std = 3.5
			sum_flag      = 0
			Pw_temp       = np.zeros(0)
			tp_temp       = np.zeros(0)

			for k in range(lp):

				if np.abs(R2[k])   > number_of_std * noise:	
					W2[k]  = 0
					sum_flag = sum_flag + 1
					#print(sum_flag)

				elif np.abs(R2[k]) <= number_of_std * noise:
					Pw_temp = np.append(Pw_temp, Pw[k])
					tp_temp = np.append(tp_temp, tp[k])

			# Checking if convergence is achieved		
			if sum_flag == old_sum_flag:
				ready = 'yes'
				#print('jajaja')

			elif sum_flag != old_sum_flag:
				old_sum_flag = sum_flag
				#print('jojojoj')


			#print(index2)
			index2 = index2 + 1


	# Final Weight Array
	if len(D) == 1:
		WW = W

	elif len(D) == 2:
		WW = np.ones(D)
		WW = ((WW * W).T * W2).T



	return  WW



def RFI_flagging_single_spectrum(f, d, w, poly_terms = 15, Nsigma = 5):

	"""
	This function eliminates data points that could be attributed to RFI based on the standard deviation of the data after removing a polynomial

	Input:
	------
	f: frequency vector. Nominally in MHz, but it doesn't really matter.
	d: data vector.
	w: weight vector, potentially with zeros.

	Output:
	-------
	ww: output weight vector, similar to the input vector but with more zeros, the ones that are outside X\sigma from the mean.

	"""

	# Weight matrix
	W = np.diag(w)


	# Model fit
	p, m, rms, cov = fit_polynomial_fourier('EDGES_polynomial', f, d, poly_terms, Weights = W)



	# Weighted mean of residuals
	average = np.sum(w*(d-m)) / np.sum(w)



	# Unbiased Weighted Sample Standard Deviation
	# from: https://en.wikipedia.org/wiki/Mean_square_weighted_deviation
	# ------------------------------------------------------------------

	# Sum of square differences
	diff_square = np.sum( w*((d-m)**2) )

	# Front factor
	front_factor = np.sum(w) / (  (np.sum(w))**2 - np.sum(w**2)  )

	# Unbiased Weighted Sample Standard Deviation
	STD = np.sqrt( front_factor * diff_square )
	print(STD)


	# Flagging out spikes
	new_w = w
	for i in range(len(f)):
		if w[i] > 0:
			if np.abs(d[i] - m[i]) > Nsigma*STD :
				new_w[i] = 0



	return new_w, m






def frequency_edges(flow, fhigh):
	"""
	Last modification: May 24, 2015.

	This function returns the raw EDGES frequency array, in MHz.

	Definition:
	freqs, index_flow, index_fhigh = frequency_edges(flow, fhigh)

	Input parameters:
	flow: low-end limit of frequency range, in MHz
	fhigh: high-end limit of frequency range, in MHz

	Output parameters:
	freqs: full frequency array from 0 to 200 MHz, at raw resolution
	index_flow: index of flow
	index_fhigh: index of fhigh

	Usage:
	freqs, index_flow, index_fhigh = frequency_edges(90, 190)
	"""

	# Full frequency vector
	nchannels = 16384*2
	max_freq = 200
	fstep = max_freq/nchannels
	freqs = np.arange(0, max_freq, fstep)

	# Indices of frequency limits
	if (flow < 0) or (flow >= max(freqs)) or (fhigh < 0) or (fhigh >= max(freqs)):
		print('ERROR. Limits are 0 MHz and ' + str(max(freqs)) + ' MHz')
	else:
		for i in range(len(freqs)-1):
			if (freqs[i] <= flow) and (freqs[i+1] >= flow):
				index_flow = i
			if (freqs[i] <= fhigh) and (freqs[i+1] >= fhigh):
				index_fhigh = i

		return freqs, index_flow, index_fhigh







def utc2lst(utc_time_array, LONG_float):
	"""
	Last modification: May 29, 2015.

	This function converts an Nx6 array of floats or integers representing UTC date/time, to a 1D array of LST date/time.

	Definition:
	LST = utc2lst(utc_time_array, LONG_float)

	Input parameters:
	utc_time_array: Nx6 array of floats or integers, where each row is of the form [yyyy, mm, dd, HH, MM, SS]. It can also be a 6-element 1D array.
	LONG_float: terrestrial longitude of observatory (float) in degrees.

	Output parameters:
	LST: 1D array of LST dates/times

	Usage:
	LST = utc2lst(utc_time_array, -27.5)
	"""

	# converting input array to "int"
	uta = utc_time_array.astype(int)



	# compatibility for 1D inputs (only 1 array of date/time), and 2D (N arrays of date/time)
	if uta.ndim == 1:
		len_array = 1
	if uta.ndim == 2:
		len_array = len(uta)



	# converting UTC to LST
	LST = np.zeros(len_array)

	for i in range(len_array):
		if uta.ndim == 1:
			yyyy = uta[0]
			mm   = uta[1]
			dd   = uta[2]
			HH   = uta[3]
			MM   = uta[4]
			SS   = uta[5]

		elif uta.ndim == 2:
			yyyy = uta[i,0]
			mm   = uta[i,1]
			dd   = uta[i,2]
			HH   = uta[i,3]
			MM   = uta[i,4]
			SS   = uta[i,5]


		# time stamp in python "datetime" format
		udt = dt.datetime(yyyy, mm, dd, HH, MM, SS)

		# python "datetime" to astropy "Time" format
		t = apt.Time(udt, format='datetime', scale='utc')

		# necessary approximation to compute sidereal time
		t.delta_ut1_utc = 0

		# LST at longitude LONG_float, in degrees
		LST_object = t.sidereal_time('apparent', str(LONG_float)+'d', model='IAU2006A')
		LST[i] = LST_object.value


	return LST






def fit_polynomial_fourier(model_type, xdata, ydata, nterms, Weights=1, plot='no', fr=150, df=10, zr=8, dz=2, z_alpha=0, anastasia_model_number=0, jordan_model_number=0, xi_min=0.9, jordan_tau_e_min=0.02, jordan_tau_e_max=0.25, gaussian_flatness_tau=0, gaussian_flatness_tilt=0, external_model_in_K=0):
	"""
	Last modification: May 24, 2015.

	This function computes a Least-Squares fit to data using the QR decomposition method.
	Two models are supported: 'polynomial', and 'fourier'.
	If P is the total number of parameters (P = nterms), the 'polynomial' model is: ydata = a0 + a1*xdata + a2*xdata**2 + ... + (aP-1)*xdata**(P-1).
	The 'fourier' model is: ydata = a0 + (a1*np.cos(1*xdata) + a2*np.sin(1*xdata)) + ... + ((aP-2)*np.cos(((P-1)/2)*xdata) + (aP-1)*np.sin(((P-1)/2)*xdata)).

	Definition:
	param, model, rms, cov = fit_polynomial_fourier(model_type, xdata, ydata, nterms, plot='no')

	Input parameters:
	model_type: 'polynomial', 'EDGES_polynomial', or 'fourier'
	xdata: 1D array of independent measurements, of length N, properly normalized to optimize the fit
	ydata: 1D array of dependent measurements, of length N
	nterms: total number of fit coefficients for baseline
	W: matrix of weights, expressed as the inverse of a covariance matrix. It doesn't have to be normalized to anything in particular. Relative weights are OK.
	plot: flag to plot measurements along with fit, and residuals. Use plot='yes' for plotting

	Output parameters:
	param: 1D array of fit parameters, in increasing order, i.e., [a0, a1, ... , aP-1]
	model: 1D array of length N, of model evaluated at fit parameters
	rms: RMS of residuals
	cov: covariance matrix of fit parameters, organized following 'param' array

	Usage:
	param, model, rms, cov = fit_polynomial_fourier('fourier', (f_MHz-150)/50, measured_spectrum, 11, plot='no')

	"""



	# initializing "design" matrix
	AT  = np.zeros((nterms, len(xdata)))

	# initializing auxiliary output array	
	aux = (0, 0)


	# assigning basis functions
	if model_type == 'polynomial':
		for i in range(nterms):
			AT[i,:] = xdata**i



	if model_type == 'fourier':
		AT[0,:] = np.ones(len(xdata))
		for i in range(int((nterms-1)/2)):
			AT[2*i+1,:] = np.cos((i+1)*xdata)
			AT[2*i+2,:] = np.sin((i+1)*xdata)



	if (model_type == 'EDGES_polynomial') or (model_type == 'EDGES_polynomial_plus_gaussian_frequency') or (model_type == 'EDGES_polynomial_plus_gaussian_redshift') or (model_type == 'EDGES_polynomial_plus_tanh') or (model_type == 'EDGES_polynomial_plus_anastasia')  or (model_type == 'EDGES_polynomial_plus_jordan') or (model_type == 'EDGES_polynomial_plus_external'):
		for i in range(nterms):
			AT[i,:] = xdata**(-2.49+i)
			
			
			
	if (model_type == 'LINLOG'):		
		for i in range(nterms):
			AT[i,:] = (xdata**(-2.33))  *  ((np.log(xdata))**i)



	# Physical model from Memo 172
	if (model_type == 'Physical_model') or (model_type == 'Physical_model_plus_gaussian_frequency') or (model_type == 'Physical_model_plus_gaussian_redshift') or (model_type == 'Physical_model_plus_tanh') or (model_type == 'Physical_model_plus_anastasia') or (model_type == 'Physical_model_plus_jordan') or (model_type == 'Physical_model_plus_external'):
		if nterms >= 3:
		#if (nterms == 4) or (nterms == 5):
			AT = np.zeros((nterms,len(xdata)))
			AT[0,:] = xdata**(-2.6)
			AT[1,:] = np.log(xdata) * xdata**(-2.6)
			AT[2,:] = (np.log(xdata))**2 * xdata**(-2.6)

			if nterms >= 4:
				AT[3,:] = xdata**(-4.6)
				if nterms == 5:
					AT[4,:] = xdata**(-2)


		else:
			print('ERROR: For the Physical model it has to be 4 or 5 terms.')
			AT = 0



	# nterms ONLY includes the number of parameters for the baseline.

	# Gaussian in frequency
	if (model_type == 'EDGES_polynomial_plus_gaussian_frequency') or (model_type == 'Physical_model_plus_gaussian_frequency'):

		# Regular Gaussian in frequency
		if gaussian_flatness_tau == 0:
			gaussian_function, xHI, z = model_eor(xdata, T21=1, model_type='gaussian_frequency', fr=fr, df=df)
			aux                       = (z, xHI)
			AT                        = np.append(AT, gaussian_function.reshape(1,-1), axis=0)


		# Flattened Gaussian in frequency
		elif gaussian_flatness_tau > 0:
			#print('HOLE')
			gaussian_function, xHI, z = model_eor(xdata, T21=1, model_type='gaussian_flattened_1', fr=fr, df=df, tau0=gaussian_flatness_tau, tilt=gaussian_flatness_tilt)
			aux                       = (z, xHI)
			AT                        = np.append(AT, gaussian_function.reshape(1,-1), axis=0)






	# Gaussian in redshift
	if (model_type == 'EDGES_polynomial_plus_gaussian_redshift') or (model_type == 'Physical_model_plus_gaussian_redshift'):
		gaussian_function, xHI, z = model_eor(xdata, T21=1, model_type='gaussian_redshift', zr=zr, dz=dz, z_alpha=z_alpha, dz_accuracy_skewed_gaussian=0.0025)
		aux                       = (z, xHI)
		AT                        = np.append(AT, gaussian_function.reshape(1,-1), axis=0)



	# Tanh
	if (model_type == 'EDGES_polynomial_plus_tanh') or (model_type == 'Physical_model_plus_tanh'):
		tanh_function, xHI, z = model_eor(xdata, T21=1, zr=zr, dz=dz)
		aux                   = (z, xHI)
		AT                    = np.append(AT, tanh_function.reshape(1,-1), axis=0)




	if (model_type == 'EDGES_polynomial_plus_anastasia') or (model_type == 'Physical_model_plus_anastasia'):
		model_in_K, ao = model_eor_anastasia(anastasia_model_number, xdata)   # xdata: frequency in MHz, model_in_K: it is in K
		aux            = ao
		AT             = np.append(AT, model_in_K.reshape(1,-1), axis=0)




	if (model_type == 'EDGES_polynomial_plus_jordan') or (model_type == 'Physical_model_plus_jordan'):
		model_in_K, ao = model_eor_jordan(jordan_model_number, xdata, xi_min=xi_min, tau_e_min=jordan_tau_e_min, tau_e_max=jordan_tau_e_max)   # xdata: frequency in MHz, model_in_K: it is in K
		aux            = ao
		print('---------------------------------------------')
		AT             = np.append(AT, model_in_K.reshape(1,-1), axis=0)



	if (model_type == 'EDGES_polynomial_plus_external') or (model_type == 'Physical_model_plus_external'):
		aux            = 0
		AT             = np.append(AT, external_model_in_K.reshape(1,-1), axis=0)






	# Applying General Least Squares Formalism, and Solving using QR decomposition
	# ----------------------------------------------------------------------------
	# ----------------------------------------------------------------------------
	# See: http://www2.imm.dtu.dk/pubdb/views/edoc_download.php/2804/pdf/imm2804.pdf

	# if no weights are given
	if np.isscalar(Weights):
		W = np.eye(len(xdata))

	# if a vector is given
	elif np.ndim(Weights) == 1:
		W = np.diag(Weights)

	# if a matrix is given
	elif np.ndim(Weights) == 2:
		W = Weights


	# sqrt of weight matrix
	sqrtW = np.sqrt(W)


	# transposing matrices so 'frequency' dimension is along columns
	A     = AT.T
	ydata = np.reshape(ydata, (-1,1))


	# A and ydata "tilde"
	WA     = np.dot(sqrtW, A)
	Wydata = np.dot(sqrtW, ydata)


	# solving system using 'short' QR decomposition (see R. Butt, Num. Anal. Using MATLAB)
	Q1, R1      = sp.linalg.qr(WA, mode='economic') # returns

	#print(R1)
	#print(np.dot(Q1.T, Wydata))
	param       = sp.linalg.solve(R1, np.dot(Q1.T, Wydata))

	model       = np.dot(A, param)
	error       = ydata - model
	DF          = len(xdata)-len(param)-1
	wMSE        = (1/DF) * np.dot(error.T, np.dot(W, error))  # This is correct because we also have the Weight matrix in the (AT * W * A)^-1.
	wRMS        = np.sqrt( np.dot(error.T, np.dot(W, error)) / np.sum(np.diag(W)))
	#inv_pre_cov = np.linalg.lstsq(np.dot(R1.T, R1), np.eye(nterms))   # using "lstsq" to compute the inverse: inv_pre_cov = (R1.T * R1) ^ -1
	#cov         = MSE * inv_pre_cov[0]
	inv_pre_cov = np.linalg.inv(np.dot(R1.T, R1))
	cov         = wMSE * inv_pre_cov



	# back to input format
	ydata = ydata.flatten()
	model = model.flatten()
	param = param.flatten()





	# plotting ?
	if plot == 'yes':
		plt.close()

		plt.subplot(3,1,1)
		plt.plot(xdata, ydata, 'b')
		plt.plot(xdata, model, 'r.')

		plt.subplot(3,1,2)
		plt.plot(xdata, ydata-model, 'b')

		plt.subplot(3,1,3)
		plt.errorbar(np.arange(len(param)), param, np.sqrt(np.diag(cov)), marker='o')
		plt.xlim([-1, len(param)])

		plt.show()

	return param, model, wRMS, cov, wMSE, aux     # wMSE = reduced chi square










def model_evaluate(model_type, par, xdata, fr=150, df=10, zr=8, dz=2, z_alpha=0, anastasia_model_number=0, jordan_model_number=0, gaussian_flatness_tau=0, gaussian_flatness_tilt=0):
	"""
	Last modification: May 24, 2015.

	This function evaluates 'polynomial' or 'fourier' models at array 'xdata', using parameters 'par'.
	It is a direct complement to the function 'fit_polynomial_fourier'.
	If P is the total number of parameters, the 'polynomial' model is: model = a0 + a1*xdata + a2*xdata**2 + ... + (aP-1)*xdata**(P-1).
	The 'fourier' model is: model = a0 + (a1*np.cos(1*xdata) + a2*np.sin(1*xdata)) + ... + ((aP-2)*np.cos(((P-1)/2)*xdata) + (aP-1)*np.sin(((P-1)/2)*xdata)).

	Definition:
	model = model_evaluate(model_type, par, xdata)

	Input parameters:
	model_type: 'polynomial', 'EDGES_polynomial', or 'fourier'
	par: 1D array of parameters, in increasing order, i.e., [a0, a1, ... , aP-1]
	xdata: 1D array of the independent variable

	Output parameters:
	model: 1D array with model

	Usage:
	model = model_evaluate('fourier', par_array, fn)
	"""


	if model_type == 'polynomial':
		summ = 0
		for i in range(len(par)):
			summ = summ + par[i] * xdata**i




	elif model_type == 'fourier':
		summ = par[0]

		n_cos_sin = int((len(par)-1)/2)
		for i in range(n_cos_sin):
			icos = 2*i + 1
			isin = 2*i + 2
			summ = summ + par[icos] * np.cos((i+1)*xdata) + par[isin] * np.sin((i+1)*xdata)




	elif (model_type == 'EDGES_polynomial'):
		summ = 0
		for i in range(len(par)):
			summ = summ + par[i] * xdata**(-2.5+i)





	elif (model_type == 'LINLOG'):
		summ = 0
		for i in range(len(par)):
			summ = summ      +      par[i] * (xdata**(-2.5)) * ((np.log(xdata))**i)
			
			
			
			
			

	elif (model_type == 'EDGES_polynomial_plus_gaussian_frequency') or (model_type == 'EDGES_polynomial_plus_gaussian_redshift') or (model_type == 'EDGES_polynomial_plus_tanh') or (model_type == 'EDGES_polynomial_plus_anastasia') or (model_type == 'EDGES_polynomial_plus_jordan'):
		summ = 0
		for i in range(len(par)-1):  # Here is the difference with the case above. The last parameters is the amplitude of the Gaussian/Tanh.
			summ = summ + par[i] * xdata**(-2.5+i)



	# Physical model from Memo 172
	elif (model_type == 'Physical_model'):
		summ = 0
		basis = np.zeros((5,len(xdata)))
		basis[0,:] = xdata**(-2.5)
		basis[1,:] = np.log(xdata) * xdata**(-2.5)
		basis[2,:] = (np.log(xdata))**2 * xdata**(-2.5)
		basis[3,:] = xdata**(-4.5)
		basis[4,:] = xdata**(-2)		

		for i in range(len(par)):
			summ = summ + par[i] * basis[i,:]



	# Physical model from Memo 172
	elif (model_type == 'Physical_model_plus_gaussian_frequency') or (model_type == 'Physical_model_plus_gaussian_redshift') or (model_type == 'Physical_model_plus_tanh') or (model_type == 'Physical_model_plus_anastasia') or (model_type == 'Physical_model_plus_jordan'):
		summ = 0
		basis = np.zeros((5,len(xdata)))
		basis[0,:] = xdata**(-2.5)
		basis[1,:] = np.log(xdata) * xdata**(-2.5)
		basis[2,:] = (np.log(xdata))**2 * xdata**(-2.5)
		basis[3,:] = xdata**(-4.5)
		basis[4,:] = xdata**(-2)		

		for i in range(len(par)-1):  # Here is the difference with the case above. The last parameters is the amplitude of the Gaussian/Tanh.
			summ = summ + par[i] * basis[i,:]                




	else:
		summ = 0




	if (model_type == 'EDGES_polynomial_plus_gaussian_frequency') or (model_type == 'Physical_model_plus_gaussian_frequency'):
		if gaussian_flatness_tau == 0:
			gaussian_function, xHI, z = model_eor(xdata, T21=1, model_type='gaussian_frequency', fr=fr, df=df)

		elif gaussian_flatness_tau > 0:
			gaussian_function, xHI, z = model_eor(xdata, T21=1, model_type='gaussian_flattened_1', fr=fr, df=df, tau0=gaussian_flatness_tau, tilt=gaussian_flatness_tilt)

		summ = summ + par[-1] * gaussian_function




	if (model_type == 'EDGES_polynomial_plus_gaussian_redshift') or (model_type == 'Physical_model_plus_gaussian_redshift'):
		gaussian_function, xHI, z = model_eor(xdata, T21=1, model_type='gaussian_redshift', zr=zr, dz=dz, z_alpha=z_alpha)
		summ = summ + par[-1] * gaussian_function




	if (model_type == 'EDGES_polynomial_plus_tanh') or (model_type == 'Physical_model_plus_tanh'):
		tanh_function, xHI, z = model_eor(xdata, T21=1, zr=zr, dz=dz)
		summ = summ + par[-1] * tanh_function




	if (model_type == 'EDGES_polynomial_plus_anastasia') or (model_type == 'Physical_model_plus_anastasia'):
		model_in_K = model_eor_anastasia(anastasia_model_number, xdata)   # xdata: frequency in MHz, model_in_K: it is in K
		summ = summ + par[-1] * model_in_K




	if (model_type == 'EDGES_polynomial_plus_jordan') or (model_type == 'Physical_model_plus_jordan'):
		model_in_K = model_eor_jordan(jordan_model_number, xdata)   # xdata: frequency in MHz, model_in_K: it is in K
		summ = summ + par[-1] * model_in_K




	model = summ
	return model










def modeling_antenna_s11(band, antenna, year, day, model_type='polynomial', nterms=10, save='no', plots='no'):
	"""

	"""


	if (band == 'high_band_2015'):

		# Paths
		path_data = home_folder + '/DATA/EDGES/calibration/s11/high_band/corrected/'
		path_save = home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_march_2015/antenna/models/parameters/'		



		# Fourpoint
		if antenna == 'fourpoint':
			if (year == '2015') and (day == '109'):
				d = np.genfromtxt(path_data + '2015_109_07_39/average_2015_109_07_39.txt')

			if (year == '2015') and (day == '119'):
				d = np.genfromtxt(path_data + '2015_119_13_04/average_2015_119_13_04.txt')

			if (year == '2015') and (day == '120'):
				d = np.genfromtxt(path_data + '2015_120_14_05/average_2015_120_14_05.txt')			

			if (year == '2015') and (day == '123'):
				d = np.genfromtxt(path_data + '2015_123_14_32/average_2015_123_14_32.txt')

			if (year == '2015') and (day == '124'):
				d = np.genfromtxt(path_data + '2015_124_13_27/average_2015_124_13_27.txt')

			if (year == '2015') and (day == '157'):
				d = np.genfromtxt(path_data + '2015_157_03_51/average_2015_157_03_51.txt')		

			# Data arrays
			f    = d[40:140,0]/1e6  # 90-190 MHz
			fn   = (f-140)/60
			rs11 = d[40:140,1]
			is11 = d[40:140,2]





		# Blade
		if antenna == 'blade':
			if day != 'average':
				if (year == '2015') and (day == '212'):
					d = np.genfromtxt(path_data + '2015_212_18_55/average_2015_212_18_55.txt')		

				if (year == '2015') and (day == '262'):
					d = np.genfromtxt(path_data + '2015_262_19_14/average_2015_262_19_14.txt')

				# Data arrays
				f    = d[40:140,0]/1e6  # 90-190 MHz
				fn   = (f-140)/60
				rs11 = d[40:140,1]
				is11 = d[40:140,2]


			elif day == 'average':
				d1 = np.genfromtxt(path_data + '2015_212_18_55/average_2015_212_18_55.txt')
				d2 = np.genfromtxt(path_data + '2015_262_19_14/average_2015_262_19_14.txt')

				# Data arrays
				f    = d1[40:140,0]/1e6  # 90-190 MHz
				fn   = (f-140)/60

				rs11_1 = d1[40:140,1]
				is11_1 = d1[40:140,2]

				rs11_2 = d2[40:140,1]
				is11_2 = d2[40:140,2]

				rs11 = np.mean([rs11_1, rs11_2], axis=0)
				is11 = np.mean([is11_1, is11_2], axis=0)





	if (band == 'low_band') and (antenna == 'blade'):

		# Paths
		path_data = home_folder + '/DATA/EDGES/calibration/antenna_s11/low_band1/s11/corrected/'
		path_save = home_folder + '/DATA/EDGES/calibration/antenna_s11/low_band1/parameters/'


		# Blade
		if day != 'average':


			# Original Ground Plane
			# -------------------------
			# 2015
			if (year == '2015') and (day == '289'):
				d  = np.genfromtxt(path_data + '2015_289_21_27/average_2015_289_21_27.txt')
				dc = d[0:51,:] # 50-100 MHz

			elif (year == '2015') and (day == '342'):
				d  = np.genfromtxt(path_data + '2015_342_03_14/average_2015_342_03_14.txt')
				dc = d[0:51,:] # 50-100 MHz

			# 2016	
			elif (year == '2016') and (day == '175'):
				d  = np.genfromtxt(path_data + '2016_175_00/average_2016_175_00.txt')
				dc = d[0:51,:] # 50-100 MHz

			elif (year == '2016') and (day == '177'):
				d  = np.genfromtxt(path_data + '2016_177_00/average_2016_177_00.txt')
				dc = d[0:51,:] # 50-100 MHz

			# Extended Ground Plane
			# --------------------------
			elif (year == '2016') and (day == '243'):
				d  = np.genfromtxt(path_data + '2016_243/average_2016_243.txt')				
				dc = d[0:51,:] # 50-100 MHz

			# 2017
			elif (year == '2017') and (day == '93'):
				d  = np.genfromtxt(path_data + '20170403_average/S11_blade_low_band_2017_093.txt')
				dc = d[0:51,:] # 50-100 MHz


			# After Reinstalling Receiver following Lab Calibration at ASU, 2017-05-25C
			# -------------------------------------------------------------------------
			elif (year == '2017') and (day == '153'):
				d  = np.genfromtxt(path_data + 'low1_20170602_night3/S11_blade_low_band_2017_153_NIGHT.txt')
				dc = d[0:71,:] # 50-120 MHz



			# Data arrays
			f    = dc[:,0]/1e6  # 50-100 MHz
			rs11 = dc[:,1]
			is11 = dc[:,2]
			fn   = (f-75)/25






		elif day == 'average':
			d1 = np.genfromtxt(path_data + '2015_289_21_27/average_2015_289_21_27.txt')
			d2 = np.genfromtxt(path_data + '2015_342_03_14/average_2015_342_03_14.txt')

			# Data arrays
			f    = d1[0:51,0]/1e6  # 50-100 MHz
			fn   = (f-75)/25

			rs11_1 = d1[0:51,1]
			is11_1 = d1[0:51,2]			

			rs11_2 = d2[0:51,1]
			is11_2 = d2[0:51,2]				

			rs11 = np.mean([rs11_1, rs11_2], axis=0)
			is11 = np.mean([is11_1, is11_2], axis=0)





	if (band == 'low_band2') and (antenna == 'blade'):

		# Paths
		path_data = home_folder + '/DATA/EDGES/calibration/antenna_s11/low_band2/s11/corrected/'
		path_save = home_folder + '/DATA/EDGES/calibration/antenna_s11/low_band2/parameters/'


		# Blade

		# NS antenna
		if (year == '2017') and (day == '82'):
			d = np.genfromtxt(path_data + 'low2-thur-03/average_low2-thur-03.txt')

		if (year == '2017') and (day == '87'):
			d = np.genfromtxt(path_data + 'low2-mar28-1/average_low2-mar28-1.txt')



		# EW antenna
		if (year == '2017') and (day == '153'):
			#d = np.genfromtxt(path_data + 'low2-thur-03/S11_low2-thur-03.txt')
			d = np.genfromtxt(path_data + 'low2_20170602_friday_reconnect_after_vnainpit3/S11_blade_low_band_2017_153_NORMAL.txt')		


		# EW antenna with NO SHIELD
		if (year == '2017') and (day == '180'):
			d = np.genfromtxt(path_data + '2017-06-29-low2-noshield_average/S11_blade_low_band_2017_180_NO_SHIELD.txt')


		# Data arrays
		f    = d[0:51,0]/1e6  # 50-100 MHz
		fn   = (f-75)/25
		rs11 = d[0:51,1]
		is11 = d[0:51,2]	








	# Modeling real and imaginary parts
	re_fit   = fit_polynomial_fourier(model_type, fn, rs11, nterms, plot='no')
	re_par   = re_fit[0]
	re_model = re_fit[1]
	re_rms   = re_fit[2]
	re_cov   = re_fit[3]

	im_fit   = fit_polynomial_fourier(model_type, fn, is11, nterms, plot='no')
	im_par   = im_fit[0]
	im_model = im_fit[1]
	im_rms   = im_fit[2]
	im_cov   = im_fit[3]	



	# Magnitude and phase representation
	data      = rs11 + 1j*is11	
	mag_data  = np.abs(data)
	ang_data  = np.unwrap(np.angle(data))

	model     = re_model + 1j*im_model
	mag_model = np.abs(model)
	ang_model = np.unwrap(np.angle(model))





	# RMS
	RMS_mag = np.std(20*np.log10(mag_data) - 20*np.log10(mag_model))
	RMS_ang = np.std((180/np.pi)*ang_data - (180/np.pi)*ang_model)
	print(str(round(RMS_mag,4)) + ' dB')
	print(str(round(RMS_ang,4)) + ' deg')




	# Plot
	if plots == 'yes':
		plt.close()
		f1 = plt.figure(1, figsize=[14,10])

		plt.subplot(2,2,1)
		plt.plot(f, 20*np.log10(mag_data),'r')
		plt.plot(f, 20*np.log10(mag_model),'b')
		plt.ylabel('magnitude [dB]')

		plt.subplot(2,2,3)
		plt.plot(f, 20*np.log10(mag_data) - 20*np.log10(mag_model),'r')
		plt.xlabel('frequency [MHz]')
		plt.ylabel('$\Delta$ magnitude [dB]')
		plt.ylim([-0.02, 0.02])
		plt.text(76,0.012, 'RMS: ' + str(np.round(RMS_mag,3)) + ' dB', fontsize=18)

		plt.subplot(2,2,2)
		plt.plot(f, (180/np.pi)*ang_data,'r')
		plt.plot(f, (180/np.pi)*ang_model,'b')
		plt.ylabel('phase [deg]')

		plt.subplot(2,2,4)
		plt.plot(f, (180/np.pi)*ang_data - (180/np.pi)*ang_model,'r')
		plt.xlabel('frequency [MHz]')
		plt.ylabel('$\Delta$ phase [deg]')
		plt.ylim([-0.2, 0.2])
		plt.text(76,0.12, 'RMS: ' + str(np.round(RMS_ang,3)) + ' deg', fontsize=18)


		if band == 'low_band':
			band_title = 'Low-Band 1'

		if band == 'low_band2':
			band_title = 'Low-Band 2'

		plt.suptitle(band_title + ',  ' + year + '-' + day + ',  ' + str(nterms) + '-term ' + model_type, fontsize=26)

		plt.savefig(path_save + 'plots/' + band + '_' + year + '_' + day + '_' + str(nterms) + 'terms_' + model_type + '.pdf', bbox_inches='tight')
		plt.close()






	# Fit parameters
	par = np.array([re_par, im_par]).T


	# Saving
	if save == 'yes':
		if day != 'average':
			np.savetxt(path_save + 'par_antenna_s11_' + band + '_' + year + '_' + day + '_' + str(nterms) + 'terms_' + model_type + '.txt', par)

		elif day == 'average':
			np.savetxt(path_save + 'par_antenna_s11_' + band + '_' + antenna + '_average_' + str(nterms) + 'terms_' + model_type + '.txt', par)


	return 1








def models_antenna_s11(band, antenna, f, antenna_s11_day = 262, model_type='polynomial', MC_mag='no', MC_ang='no', sigma_mag=0.0001, sigma_ang_deg=0.1, plots='no'):
	"""
	Last modification: Feb 26, 2016.

	This function evaluates the antenna S11 model at frequency 'f', in MHz.

	Definition:
	ra = models_antenna_s11(path_file, band, f, year, day, model_type='fourier', plots='no')

	Input parameters:
	path_file
	band
	f: 1D frequency array, in MHz
	year: string
	day: string


	Output parameters:
	ra: 1D array, antenna S11
	"""






	# Path and frequency
	if band == 'high_band_2015':

		# Path
		path_antenna_s11_high_band = home_folder + '/DATA/EDGES/calibration/antenna_s11/high_band1/parameters/'

		# Files
		if antenna == 'fourpoint':
			path_file = path_antenna_s11_high_band + 'par_antenna_s11_high_band_2015_157_12terms_polynomial.txt'

		elif (antenna == 'blade') and (antenna_s11_day == 212):
			path_file = path_antenna_s11_high_band + 'par_antenna_s11_high_band_2015_2015_212_16terms_polynomial.txt'

		elif (antenna == 'blade') and (antenna_s11_day == 262):
			path_file = path_antenna_s11_high_band + 'par_antenna_s11_high_band_2015_2015_262_16terms_polynomial.txt'

		elif (antenna == 'blade') and (antenna_s11_day == 'average'):
			path_file = path_antenna_s11_high_band + 'par_antenna_s11_high_band_2015_blade_average_16terms_polynomial.txt'

		# Normalized frequency
		fn = (f - 140)/60





	if band == 'low_band_2015':

		# USE 13 terms for all, over 50-100 MHz,   and 14 terms for 50-120 MHz


		# Path
		path_antenna_s11_low_band  = home_folder + '/DATA/EDGES/calibration/antenna_s11/low_band1/parameters/'

		# Files



		# Original Ground Plane
		# --------------------------------------
		# 2015
		if antenna_s11_day == 289:
			path_file = path_antenna_s11_low_band + 'par_antenna_s11_low_band_2015_289_13terms_polynomial.txt'
			print('13 terms in antenna S11 polynomial fit')

		if antenna_s11_day == 342:
			path_file = path_antenna_s11_low_band + 'par_antenna_s11_low_band_2015_342_13terms_polynomial.txt'
			print('13 terms in antenna S11 polynomial fit')

		if antenna_s11_day == 'average':  # Average of 289 and 342
			path_file = path_antenna_s11_low_band + 'par_antenna_s11_low_band_blade_average_10terms_polynomial.txt'


		# 2016
		if antenna_s11_day == 175:
			path_file = path_antenna_s11_low_band + 'par_antenna_s11_low_band_2016_175_13terms_polynomial.txt'
			print('13 terms in antenna S11 polynomial fit')

		if antenna_s11_day == 177:
			path_file = path_antenna_s11_low_band + 'par_antenna_s11_low_band_2016_177_13terms_polynomial.txt'
			print('13 terms in antenna S11 polynomial fit')


		# Extended Ground Plane
		# ---------------------------------------
		if antenna_s11_day == 243:
			path_file = path_antenna_s11_low_band + 'par_antenna_s11_low_band_2016_243_13terms_polynomial.txt'
			print('13 terms in antenna S11 polynomial fit')


		# 2017
		if antenna_s11_day == 93:
			path_file = path_antenna_s11_low_band + 'par_antenna_s11_low_band_2017_93_13terms_polynomial.txt'
			print('13 terms in antenna S11 polynomial fit')



		# After reinstalling receiver following receiver calibration at ASU 2017-05-25C
		# -----------------------------------------------------------------------------

		# This model fit goes over 50-120 MHz !!!!!!
		if antenna_s11_day == 153:
			path_file = path_antenna_s11_low_band + 'par_antenna_s11_low_band_2017_153_14terms_polynomial.txt'



		# Normalized frequency
		fn = (f - 75)/25
















	if band == 'low_band2_2017':

		# Path
		path_antenna_s11_low_band  = home_folder + '/DATA/EDGES/calibration/antenna_s11/low_band2/parameters/'

		# Files

		# Antenna in NS orientation
		if antenna_s11_day == 82:
			path_file = path_antenna_s11_low_band + 'par_antenna_s11_low_band2_2017_82_11terms_polynomial.txt'

		if antenna_s11_day == 87:
			path_file = path_antenna_s11_low_band + 'par_antenna_s11_low_band2_2017_87_13terms_polynomial.txt'
			print('13 terms in antenna S11 polynomial fit')
			#path_file = path_antenna_s11_low_band + 'par_antenna_s11_low_band2_2017_87_12terms_polynomial.txt'
			#path_file = path_antenna_s11_low_band + 'par_antenna_s11_low_band2_2017_87_11terms_polynomial.txt'
			#print('11 terms in antenna S11 polynomial fit')
			#path_file = path_antenna_s11_low_band + 'par_antenna_s11_low_band2_2017_87_10terms_polynomial.txt'
			#print('10 terms in antenna S11 polynomial fit')
			#path_file = path_antenna_s11_low_band + 'par_antenna_s11_low_band2_2017_87_9terms_polynomial.txt'
			#print('9 terms in antenna S11 polynomial fit')
			#path_file = path_antenna_s11_low_band + 'par_antenna_s11_low_band2_2017_87_8terms_polynomial.txt'



		# Antenna in EW orientation
		if antenna_s11_day == 153:
			#path_file = path_antenna_s11_low_band + 'par_antenna_s11_low_band2_2017_153_13terms_polynomial.txt'
			#path_file = path_antenna_s11_low_band + 'par_antenna_s11_low_band2_2017_153_12terms_polynomial.txt'
			#path_file = path_antenna_s11_low_band + 'par_antenna_s11_low_band2_2017_153_11terms_polynomial.txt'
			path_file = path_antenna_s11_low_band + 'par_antenna_s11_low_band2_2017_153_10terms_polynomial.txt'
			print('10 terms in antenna S11 polynomial fit')
			#path_file = path_antenna_s11_low_band + 'par_antenna_s11_low_band2_2017_153_9terms_polynomial.txt'

		# Antenna in EW orientation NO SHIELD
		if antenna_s11_day == 180:
			path_file = path_antenna_s11_low_band + 'par_antenna_s11_low_band2_2017_180_9terms_polynomial.txt'
			print('9 terms in antenna S11 polynomial fit')

			#path_file = path_antenna_s11_low_band + 'par_antenna_s11_low_band2_2017_180_13terms_polynomial.txt'
			#print('13 terms in antenna S11 polynomial fit')



		# Normalized frequency
		fn = (f - 75)/25





	# Loading parameters
	# par = np.genfromtxt(path_par + 'par_antenna_s11_' + year + '_' + day + '.txt')
	par = np.genfromtxt(path_file)
	par_re = par[:,0]
	par_im = par[:,1]


	# Evaluating models
	re = model_evaluate(model_type, par_re, fn)
	im = model_evaluate(model_type, par_im, fn)


	# Complex
	ra = re + 1j*im



	# Monte Carlo realizations
	# MC_mag='no', MC_ang='no', sigma_mag=0.0001, sigma_ang_deg=0.1
	if (MC_mag == 'yes') or (MC_ang == 'yes'):

		# Magnitude and angle
		abs_s11 = np.abs(ra)
		ang_s11 = np.angle(ra)


		# Uncertainty in magnitude
		if MC_mag == 'yes':
			noise     = np.random.uniform(np.zeros(len(f)), np.ones(len(f))) - 0.5
			nterms    = np.random.randint(1,16) # up to 15 terms
			par_poly  = np.polyfit(f/200, noise, nterms-1)
			poly      = np.polyval(par_poly, f/200)
			RMS       = np.sqrt(np.sum(np.abs(poly)**2)/len(poly))
			norm_poly = poly/RMS  # normalize to have RMS of ONE

			#sigma_mag = 0.0001	
			abs_s11   = abs_s11 + norm_poly*sigma_mag*np.random.normal()


		# Uncertainty in phase
		if MC_ang == 'yes':
			noise     = np.random.uniform(np.zeros(len(f)), np.ones(len(f))) - 0.5
			nterms    = np.random.randint(1,16) # up to 15 terms
			par_poly  = np.polyfit(f/200, noise, nterms-1)
			poly      = np.polyval(par_poly, f/200)
			RMS       = np.sqrt(np.sum(np.abs(poly)**2)/len(poly))
			norm_poly = poly/RMS  # normalize to have RMS of ONE

			#sigma_ang_deg = 0.1
			sigma_ang     = (np.pi/180)*sigma_ang_deg
			ang_s11       = ang_s11 + norm_poly*sigma_ang*np.random.normal()


		# MC realization of the antenna reflection coefficient
		ra = abs_s11 * (np.cos(ang_s11) + 1j*np.sin(ang_s11))






	# Plot
	if plots == 'yes':

		plt.close()
		f1 = plt.figure(1)

		plt.subplot(2,1,1)
		plt.plot(f, 20*np.log10(np.abs(ra)),'b')
		plt.ylabel('magnitude [dB]')
		plt.grid()


		plt.subplot(2,1,2)
		plt.plot(f, (180/np.pi)*np.unwrap(np.angle(ra)),'b')
		plt.ylabel('phase [deg]')
		plt.xlabel('frequency [MHz]')
		plt.grid()

	return ra












def level1_MAT(file_name, plot='no'):
	"""
	Last modification: May 24, 2015.

	This function loads the antenna temperature and date/time from MAT files produced by the MATLAB function acq2level1.m

	Definition:
	ds, dd = level1_MAT(file_name, plot='no')

	Input parameters:
	file_name: path and name of MAT file
	plot: flag for plotting spectrum data. Use plot='yes' for plotting

	Output parameters:
	ds: 2D spectra array
	dd: Nx6 date/time array

	Usage:
	ds, dd = level1_MAT('/file.MAT', plot='yes')
	"""


	# loading data and extracting main array
	d = sio.loadmat(file_name)
	darray = d['array']

	# extracting spectra and date/time
	ds = darray[0,0]
	dd = darray[0,1]

	# plotting ?
	if plot == 'yes':
		plt.imshow(ds, aspect = 'auto', vmin = 0, vmax = 2000)
		plt.xlabel('frequency channels')
		plt.ylabel('trace')
		plt.colorbar()
		plt.show()

	return ds, dd





def level1_MAT_three_loads(file_name, plot='no'):
	"""
	Last modification: July 2, 2015.

	This function loads the antenna, ambient, and hot measurements, and date/time from MAT files produced by the MATLAB function acq2level1_three_loads.m

	Definition:
	dant, damb, dhot, dd = level1_MAT_three_loads(file_name, plot='no')

	Input parameters:
	file_name: path and name of MAT file
	plot: flag for plotting spectrum data. Use plot='yes' for plotting

	Output parameters:
	dant: 2D antenna array
	damb: 2D ambient array
	dhot: 2D hot array
	dd: Nx6 date/time array

	Usage:
	dant, damb, dhot, dd = level1_MAT_three_loads('/file.MAT', plot='yes')
	"""


	# loading data and extracting main array
	d = sio.loadmat(file_name)
	darray = d['array']

	# extracting spectra and date/time
	dant = darray[0,0]
	damb = darray[0,1]
	dhot = darray[0,2]
	dd   = darray[0,3]

	# plotting ?
	if plot == 'yes':
		plt.subplot(3,1,1)
		plt.imshow(dant, aspect = 'auto', vmin = 0, vmax = 2000)
		#plt.xlabel('frequency channels')
		plt.ylabel('trace, Antenna')
		plt.colorbar()

		plt.subplot(3,1,2)
		plt.imshow(damb, aspect = 'auto', vmin = 0, vmax = 2000)
		#plt.xlabel('frequency channels')
		plt.ylabel('trace, Ambient')
		plt.colorbar()

		plt.subplot(3,1,3)
		plt.imshow(dhot, aspect = 'auto', vmin = 0, vmax = 2000)
		plt.xlabel('frequency channels')
		plt.ylabel('trace, Hot')
		plt.colorbar()


		plt.show()

	return dant, damb, dhot, dd





def average_calibration_spectrum(spectrum_files, resistance_file, start_percent=0, plot='no'):
	"""
	Last modification: May 24, 2015.

	This function loads and averages (in time) calibration data (ambient, hot, open, shorted, simulators, etc.) in MAT format produced by the "acq2level1.m" MATLAB program. It also returns the average physical temperature of the corresponding calibrator, measured with an Oven Industries TR136-170 thermistor.

	Definition:
	av_ta, av_temp = average_calibration_spectrum(spectrum_files, resistance_file, start_percentage=0, plot='no')

	Input parameters:
	spectrum_files: string, or list of strings, with the paths and names of spectrum files to process
	resistance_file: string, or list, with the path and name of resistance file to process
	start_percent: percentage of initial data to dismiss, for both, spectra and resistance
	plot: flag for plotting representative data cuts. Use plot='yes' for plotting

	Output parameters:
	av_ta: average spectrum at raw frequency resolution, starting at 0 Hz
	av_temp: average physical temperature

	Usage:
	spec_file1 = '/file1.mat'
	spec_file2 = '/file2.mat'
	spec_files = [spec_file1, spec_file2]
	res_file = 'res_file.txt'
	av_ta, av_temp = average_calibration_spectrum(spec_files, res_file, start_percentage=10, plot='yes')
	"""



	# spectra
	for i in range(len(spectrum_files)):
		tai, xxx = level1_MAT(spectrum_files[i], plot='no')
		if i == 0:
			ta = tai
		elif i > 0:
			ta = np.concatenate((ta, tai), axis=0)

	index_start_spectra = int((start_percent/100)*len(ta[:,0]))
	ta_sel = ta[index_start_spectra::,:]
	av_ta = np.mean(ta_sel, axis=0)



	# temperature
	if isinstance(resistance_file, list):
		for i in range(len(resistance_file)):
			if i == 0:
				R = np.genfromtxt(resistance_file[i])
			else:	
				R = np.concatenate((R, np.genfromtxt(resistance_file[i])), axis=0)
	else:
		R = np.genfromtxt(resistance_file)


	temp = temperature_thermistor_oven_industries_TR136_170(R, 'K')
	index_start_temp = int((start_percent/100)*len(temp))
	temp_sel = temp[index_start_temp::]
	av_temp = np.mean(temp_sel)




	# plot
	if plot == 'yes':
		plt.close()
		plt.subplot(2,2,1)
		plt.plot(ta[:,30000],'r')
		plt.plot([index_start_spectra, index_start_spectra],[min(ta[:,30000])-5, max(ta[:,30000])+5], 'k--')
		plt.ylabel('spectral temperature')
		plt.ylim([min(ta[:,30000])-5, max(ta[:,30000])+5])

		plt.subplot(2,2,2)
		plt.plot(ta_sel[:,30000],'r')
		plt.ylim([min(ta[:,30000])-5, max(ta[:,30000])+5])

		plt.subplot(2,2,3)
		plt.plot(temp,'r')
		plt.plot([index_start_temp, index_start_temp],[min(temp)-5, max(temp)+5], 'k--')
		plt.xlabel('sample')
		plt.ylabel('physical temperature')
		plt.ylim([min(temp)-5, max(temp)+5])

		plt.subplot(2,2,4)
		plt.plot(temp_sel,'r')
		plt.xlabel('sample')
		plt.ylim([min(temp)-5, max(temp)+5])

	return av_ta, av_temp








def calibration_processing_high_band_2015_25degC(flow=90, fhigh=190, save='no', save_folder=0):
	"""
	Last modification: March 6, 2018.

	This function produces model parameters for spectra and S11 calibration data corresponding to the high-band 2015 receiver.

	Definition:
	out = calibration_processing_high_band_2015_25degC(flow, fhigh, save='no')

	Input parameters:
	flow: low-frequency limit of the calibration modeling, in MHz
	fhigh: high-frequency limit of the calibration modeling, in MHz
	save: flag for saving parameters. Use save='yes' for saving

	Output parameters:
	out: parameters of spectra and S11 models

	Usage:
	out = calibration_processing_high_band_2015_25degC(90, 190, save='no')
	"""



	# Main folder
	main_folder     = home_folder + '/DATA/EDGES/calibration/receiver_calibration/high_band1/2015_03_25C/'



	# Paths for source data
	path_spectra    = main_folder + '/data/spectra/300_350/'
	path_resistance = main_folder + '/data/resistance/corrected/'
	path_s11        = main_folder + '/data/S11/corrected_delay/'  # it is recommended to use files with load delay



	# Creating output folders
	if save == 'yes':

		if not exists(main_folder + 'results/' + save_folder + '/temp/'):
			makedirs(main_folder + 'results/' + save_folder + '/temp/')

		if not exists(main_folder + 'results/' + save_folder + '/spectra/'):
			makedirs(main_folder + 'results/' + save_folder + '/spectra/')

		if not exists(main_folder + 'results/' + save_folder + '/s11/'):
			makedirs(main_folder + 'results/' + save_folder + '/s11/')

		if not exists(main_folder + 'results/' + save_folder + '/data/'):
			makedirs(main_folder + 'results/' + save_folder + '/data/')

		if not exists(main_folder + 'results/' + save_folder + '/calibration_files/'):
			makedirs(main_folder + 'results/' + save_folder + '/calibration_files/')			

		if not exists(main_folder + 'results/' + save_folder + '/plots/'):
			makedirs(main_folder + 'results/' + save_folder + '/plots/')


		# Output folders
		path_par_temp    = main_folder + 'results/' + save_folder + '/temp/'
		path_par_spectra = main_folder + 'results/' + save_folder + '/spectra/'
		path_par_s11     = main_folder + 'results/' + save_folder + '/s11/'
		path_data        = main_folder + 'results/' + save_folder + '/data/'






	# Spectra/resistance files

	# Ambient
	file_amb1 = path_spectra + 'level1_ambient_load_2015_070_01_300_350.mat'
	file_amb2 = path_spectra + 'level1_ambient_load_2015_071_00_300_350.mat'
	spec_amb  = [file_amb1, file_amb2]
	res_amb   = path_resistance + 'resistance_ambient_load_20150310.txt'


	# Hot
	file_hot1 = path_spectra + 'level1_hot_load_2015_074_04_300_350.mat'
	file_hot2 = path_spectra + 'level1_hot_load_2015_075_00_300_350.mat'
	spec_hot  = [file_hot1, file_hot2]
	res_hot   = path_resistance + 'resistance_hot_load_20150314.txt'


	# Open
	file_open1 = path_spectra + 'level1_open_cable_hires_2015_086_07_300_350.mat'
	file_open2 = path_spectra + 'level1_open_cable_hires_2015_087_00_300_350.mat'
	spec_open  = [file_open1, file_open2]
	res_open   = path_resistance + 'resistance_open_cable_hires_20150327.txt'


	# Shorted
	file_shorted1 = path_spectra + 'level1_shorted_cable_hires_2015_087_15_300_350.mat'
	file_shorted2 = path_spectra + 'level1_shorted_cable_hires_2015_088_00_300_350.mat'
	spec_shorted  = [file_shorted1, file_shorted2]
	res_shorted   = path_resistance + 'resistance_shorted_cable_hires_20150328.txt'


	# Simu1
	file_simu11   = path_spectra + 'level1_simulator1_hires_2015_088_18_300_350.mat'
	file_simu12   = path_spectra + 'level1_simulator1_hires_2015_089_00_300_350.mat'
	spec_simu1    = [file_simu11, file_simu12]
	res_simu1     = path_resistance + 'resistance_simulator1_hires_20150329.txt'


	# Simu2
	file_simu21   = path_spectra + 'level1_simulator2_2015_075_22_300_350.mat'
	file_simu22   = path_spectra + 'level1_simulator2_2015_076_00_300_350.mat'
	file_simu23   = path_spectra + 'level1_simulator2_2015_077_00_300_350.mat'
	spec_simu2    = [file_simu21, file_simu22, file_simu23]
	res_simu2     = path_resistance + 'resistance_simulator2_20150316.txt'






	# Average calibration spectra / physical temperature 
	# Percentage of initial data to leave out
	percent = 10
	ssa,  phys_temp_amb     = average_calibration_spectrum(spec_amb,     res_amb,     percent, plot='no')
	ssh,  phys_temp_hot     = average_calibration_spectrum(spec_hot,     res_hot,     percent, plot='no')
	sso,  phys_temp_open    = average_calibration_spectrum(spec_open,    res_open,    percent, plot='no')
	sss,  phys_temp_shorted = average_calibration_spectrum(spec_shorted, res_shorted, percent, plot='no')
	sss1, phys_temp_simu1   = average_calibration_spectrum(spec_simu1,   res_simu1,   percent, plot='no')
	sss2, phys_temp_simu2   = average_calibration_spectrum(spec_simu2,   res_simu2,   percent, plot='no')



	# EDGES frequency
	ff, ilow, ihigh = frequency_edges(flow, fhigh)



	# Data selection
	fe  = ff[ilow:ihigh+1]
	sa  = ssa[ilow:ihigh+1]
	sh  = ssh[ilow:ihigh+1]
	so  = sso[ilow:ihigh+1]
	ss  = sss[ilow:ihigh+1]
	ss1 = sss1[ilow:ihigh+1]  # just averaging of data, no modeling of simulators
	ss2 = sss2[ilow:ihigh+1]  # just averaging of data, no modeling of simulators



	# Spectra modeling
	fen = (fe-140)/60
	fit_spec_amb     = fit_polynomial_fourier('polynomial', fen, sa,  5,   plot='no')
	fit_spec_hot     = fit_polynomial_fourier('polynomial', fen, sh,  5,   plot='no')
	fit_spec_open    = fit_polynomial_fourier('fourier',    fen, so,  41, plot='no')
	fit_spec_shorted = fit_polynomial_fourier('fourier',    fen, ss,  41, plot='no')
	fit_spec_simu1   = fit_polynomial_fourier('fourier',    fen, ss1, 17,  plot='no')
	fit_spec_simu2   = fit_polynomial_fourier('fourier',    fen, ss2, 23,  plot='no') 







	# Loading S11 data
	out1, out2, out3 = load_high_band_calibration_s11(flow=flow, fhigh=fhigh, calibration_temperature=25)


	f_s11       = np.real(out1[0])
	s11_LNA     = out1[1]
	s11_amb     = out1[2]
	s11_hot     = out1[3]

	f_s11_hires = np.real(out2[0])
	s11_open    = out2[1]
	s11_shorted = out2[2]
	s11_simu1   = out2[3]
	s11_simu2   = out2[4]

	f_sr        = np.real(out3[0])
	s11_sr      = out3[1]
	s12s21_sr   = out3[2]
	s22_sr      = out3[3]



	# LNA
	s11_LNA_mag = np.abs(s11_LNA)
	s11_LNA_ang = np.unwrap(np.angle(s11_LNA))

	# Ambient
	s11_amb_mag = np.abs(s11_amb)
	s11_amb_ang = np.unwrap(np.angle(s11_amb))

	# Hot
	s11_hot_mag = np.abs(s11_hot)
	s11_hot_ang = np.unwrap(np.angle(s11_hot))


	# Open
	s11_open_mag    = np.abs(s11_open)
	s11_open_ang    = np.unwrap(np.angle(s11_open))

	# Shorted
	s11_shorted_mag = np.abs(s11_shorted)
	s11_shorted_ang = np.unwrap(np.angle(s11_shorted))

	# Simulator1
	s11_simu1_mag   = np.abs(s11_simu1)
	s11_simu1_ang   = np.unwrap(np.angle(s11_simu1))

	# Simulator2
	s11_simu2_mag   = np.abs(s11_simu2)
	s11_simu2_ang   = np.unwrap(np.angle(s11_simu2))


	# sr-s11
	s11_sr_mag    = np.abs(s11_sr)
	s11_sr_ang    = np.unwrap(np.angle(s11_sr))

	# sr-s12s21
	s12s21_sr_mag = np.abs(s12s21_sr)
	s12s21_sr_ang = np.unwrap(np.angle(s12s21_sr))

	# sr-s22
	s22_sr_mag    = np.abs(s22_sr)
	s22_sr_ang    = np.unwrap(np.angle(s22_sr))















	# Modeling S11

	fit_s11_LNA_mag     = fit_polynomial_fourier('fourier', (f_s11-140)/60, s11_LNA_mag, 17, plot='no')  # rms residuals at 2e-3 dB with 9 terms
	fit_s11_LNA_ang     = fit_polynomial_fourier('fourier', (f_s11-140)/60, s11_LNA_ang, 17, plot='no')  # rms residuals at 0.02 deg with 9 terms

	fit_s11_amb_mag     = fit_polynomial_fourier('fourier', (f_s11-140)/60, s11_amb_mag, 27, plot='no') # rms residuals at 5e-4 dB level with 15 terms
	fit_s11_amb_ang     = fit_polynomial_fourier('fourier', (f_s11-140)/60, s11_amb_ang, 27, plot='no') # rms residuals at 0.004 deg with 9 terms

	fit_s11_hot_mag     = fit_polynomial_fourier('fourier', (f_s11-140)/60, s11_hot_mag, 27, plot='no') # rms residuals at 5e-4 dB level with 15 terms
	fit_s11_hot_ang     = fit_polynomial_fourier('fourier', (f_s11-140)/60, s11_hot_ang, 27, plot='no') # rms residuals at 0.004 deg with 9 terms



	fit_s11_open_mag    = fit_polynomial_fourier('fourier',    (f_s11_hires-140)/60, s11_open_mag, 27, plot='no')  # rms residuals at the 1e-5 dB with 61 terms
	fit_s11_open_ang    = fit_polynomial_fourier('fourier',    (f_s11_hires-140)/60, s11_open_ang, 27, plot='no')  # rms residuals at the 1e-4 deg with 61 terms

	fit_s11_shorted_mag = fit_polynomial_fourier('fourier',    (f_s11_hires-140)/60, s11_shorted_mag, 27, plot='no') # rms residuals at the 1e-5 dB with 61 terms
	fit_s11_shorted_ang = fit_polynomial_fourier('fourier',    (f_s11_hires-140)/60, s11_shorted_ang, 27, plot='no') # rms residuals at the 1e-4 deg with 61 terms



	fit_s11_sr_mag      = fit_polynomial_fourier('polynomial', (f_sr-140)/60, s11_sr_mag, 15, plot='no')
	fit_s11_sr_ang      = fit_polynomial_fourier('polynomial', (f_sr-140)/60, s11_sr_ang, 15, plot='no')

	fit_s12s21_sr_mag   = fit_polynomial_fourier('polynomial', (f_sr-140)/60, s12s21_sr_mag, 15, plot='no')
	fit_s12s21_sr_ang   = fit_polynomial_fourier('polynomial', (f_sr-140)/60, s12s21_sr_ang, 15, plot='no')

	fit_s22_sr_mag      = fit_polynomial_fourier('polynomial', (f_sr-140)/60, s22_sr_mag, 15, plot='no')
	fit_s22_sr_ang      = fit_polynomial_fourier('polynomial', (f_sr-140)/60, s22_sr_ang, 15, plot='no')



	fit_s11_simu1_mag   = fit_polynomial_fourier('fourier',   (f_s11_hires-140)/60, s11_simu1_mag, 27, plot='no')
	fit_s11_simu1_ang   = fit_polynomial_fourier('fourier',   (f_s11_hires-140)/60, s11_simu1_ang, 27, plot='no')

	fit_s11_simu2_mag   = fit_polynomial_fourier('fourier',   (f_s11_hires-140)/60, s11_simu2_mag, 27, plot='no')
	fit_s11_simu2_ang   = fit_polynomial_fourier('fourier',   (f_s11_hires-140)/60, s11_simu2_ang, 27, plot='no')






	# Saving output parameters
	if save == 'yes':


		# Average spectra data in frequency range selected
		spectra = np.array([fe, sa, sh, so, ss, ss1, ss2]).T

		# S11 data in frequency range selected
		s11_1 = np.array([f_s11, s11_LNA_mag, s11_LNA_ang, s11_amb_mag, s11_amb_ang, s11_hot_mag, s11_hot_ang]).T
		s11_2 = np.array([f_s11_hires, s11_open_mag, s11_open_ang, s11_shorted_mag, s11_shorted_ang, s11_simu1_mag, s11_simu1_ang, s11_simu2_mag, s11_simu2_ang]).T
		s11_3 = np.array([f_sr, s11_sr_mag, s11_sr_ang, s12s21_sr_mag, s12s21_sr_ang, s22_sr_mag, s22_sr_ang]).T


		# RMS residuals
		RMS_spectra = np.zeros((6,1))
		RMS_s11     = np.zeros((20,1))

		# Spectra
		RMS_spectra[0, 0] = fit_spec_amb[2]
		RMS_spectra[1, 0] = fit_spec_hot[2]
		RMS_spectra[2, 0] = fit_spec_open[2]
		RMS_spectra[3, 0] = fit_spec_shorted[2]
		RMS_spectra[4, 0] = fit_spec_simu1[2]
		RMS_spectra[5, 0] = fit_spec_simu2[2]

		# S11
		RMS_s11[0, 0]  = fit_s11_LNA_mag[2]
		RMS_s11[1, 0]  = fit_s11_LNA_ang[2]
		RMS_s11[2, 0]  = fit_s11_amb_mag[2]
		RMS_s11[3, 0]  = fit_s11_amb_ang[2]
		RMS_s11[4, 0]  = fit_s11_hot_mag[2]
		RMS_s11[5, 0]  = fit_s11_hot_ang[2]
		RMS_s11[6, 0]  = fit_s11_open_mag[2]
		RMS_s11[7, 0]  = fit_s11_open_ang[2]
		RMS_s11[8, 0]  = fit_s11_shorted_mag[2]
		RMS_s11[9, 0]  = fit_s11_shorted_ang[2]
		RMS_s11[10, 0] = fit_s11_sr_mag[2]
		RMS_s11[11, 0] = fit_s11_sr_ang[2]
		RMS_s11[12, 0] = fit_s12s21_sr_mag[2]
		RMS_s11[13, 0] = fit_s12s21_sr_ang[2]
		RMS_s11[14, 0] = fit_s22_sr_mag[2]
		RMS_s11[15, 0] = fit_s22_sr_ang[2]
		RMS_s11[16, 0] = fit_s11_simu1_mag[2]
		RMS_s11[17, 0] = fit_s11_simu1_ang[2]
		RMS_s11[18, 0] = fit_s11_simu2_mag[2]
		RMS_s11[19, 0] = fit_s11_simu2_ang[2]



		# Formating fit parameters

		# Physical temperature
		phys_temp = np.zeros((6,1))
		phys_temp[0,0] = phys_temp_amb
		phys_temp[1,0] = phys_temp_hot
		phys_temp[2,0] = phys_temp_open
		phys_temp[3,0] = phys_temp_shorted
		phys_temp[4,0] = phys_temp_simu1
		phys_temp[5,0] = phys_temp_simu2


		# Spectra
		par_spec_amb        = np.reshape(fit_spec_amb[0],        (-1,1))
		par_spec_hot        = np.reshape(fit_spec_hot[0],        (-1,1))
		par_spec_open       = np.reshape(fit_spec_open[0],       (-1,1))
		par_spec_shorted    = np.reshape(fit_spec_shorted[0],    (-1,1))
		par_spec_simu1      = np.reshape(fit_spec_simu1[0],      (-1,1))
		par_spec_simu2      = np.reshape(fit_spec_simu2[0],      (-1,1))

		# S11
		par_s11_LNA_mag     = np.reshape(fit_s11_LNA_mag[0],     (-1,1))
		par_s11_LNA_ang     = np.reshape(fit_s11_LNA_ang[0],     (-1,1))
		par_s11_amb_mag     = np.reshape(fit_s11_amb_mag[0],     (-1,1))
		par_s11_amb_ang     = np.reshape(fit_s11_amb_ang[0],     (-1,1))
		par_s11_hot_mag     = np.reshape(fit_s11_hot_mag[0],     (-1,1))
		par_s11_hot_ang     = np.reshape(fit_s11_hot_ang[0],     (-1,1))
		par_s11_open_mag    = np.reshape(fit_s11_open_mag[0],    (-1,1))
		par_s11_open_ang    = np.reshape(fit_s11_open_ang[0],    (-1,1))
		par_s11_shorted_mag = np.reshape(fit_s11_shorted_mag[0], (-1,1))
		par_s11_shorted_ang = np.reshape(fit_s11_shorted_ang[0], (-1,1))

		par_s11_sr_mag      = np.reshape(fit_s11_sr_mag[0],      (-1,1))
		par_s11_sr_ang      = np.reshape(fit_s11_sr_ang[0],      (-1,1))
		par_s12s21_sr_mag   = np.reshape(fit_s12s21_sr_mag[0],   (-1,1))
		par_s12s21_sr_ang   = np.reshape(fit_s12s21_sr_ang[0],   (-1,1))
		par_s22_sr_mag      = np.reshape(fit_s22_sr_mag[0],      (-1,1))
		par_s22_sr_ang      = np.reshape(fit_s22_sr_ang[0],      (-1,1))

		par_s11_simu1_mag   = np.reshape(fit_s11_simu1_mag[0],   (-1,1))
		par_s11_simu1_ang   = np.reshape(fit_s11_simu1_ang[0],   (-1,1))
		par_s11_simu2_mag   = np.reshape(fit_s11_simu2_mag[0],   (-1,1))
		par_s11_simu2_ang   = np.reshape(fit_s11_simu2_ang[0],   (-1,1))



		# Saving

		np.savetxt(path_data + 'average_spectra_300_350.txt', spectra)

		np.savetxt(path_data + 's11_1.txt', s11_1)
		np.savetxt(path_data + 's11_2.txt', s11_2)
		np.savetxt(path_data + 's11_3.txt', s11_3)

		np.savetxt(path_par_temp    + 'physical_temperatures.txt', phys_temp)

		np.savetxt(path_par_spectra + 'par_spec_amb.txt',     par_spec_amb)
		np.savetxt(path_par_spectra + 'par_spec_hot.txt',     par_spec_hot)
		np.savetxt(path_par_spectra + 'par_spec_open.txt',    par_spec_open)
		np.savetxt(path_par_spectra + 'par_spec_shorted.txt', par_spec_shorted)
		np.savetxt(path_par_spectra + 'par_spec_simu1.txt',   par_spec_simu1)
		np.savetxt(path_par_spectra + 'par_spec_simu2.txt',   par_spec_simu2)
		np.savetxt(path_par_spectra + 'RMS_spec.txt',         RMS_spectra)

		np.savetxt(path_par_s11 + 'par_s11_LNA_mag.txt',      par_s11_LNA_mag)
		np.savetxt(path_par_s11 + 'par_s11_LNA_ang.txt',      par_s11_LNA_ang)
		np.savetxt(path_par_s11 + 'par_s11_amb_mag.txt',      par_s11_amb_mag)
		np.savetxt(path_par_s11 + 'par_s11_amb_ang.txt',      par_s11_amb_ang)
		np.savetxt(path_par_s11 + 'par_s11_hot_mag.txt',      par_s11_hot_mag)
		np.savetxt(path_par_s11 + 'par_s11_hot_ang.txt',      par_s11_hot_ang)
		np.savetxt(path_par_s11 + 'par_s11_open_mag.txt',     par_s11_open_mag)
		np.savetxt(path_par_s11 + 'par_s11_open_ang.txt',     par_s11_open_ang)
		np.savetxt(path_par_s11 + 'par_s11_shorted_mag.txt',  par_s11_shorted_mag)
		np.savetxt(path_par_s11 + 'par_s11_shorted_ang.txt',  par_s11_shorted_ang)

		np.savetxt(path_par_s11 + 'par_s11_sr_mag.txt',       par_s11_sr_mag)
		np.savetxt(path_par_s11 + 'par_s11_sr_ang.txt',       par_s11_sr_ang)
		np.savetxt(path_par_s11 + 'par_s12s21_sr_mag.txt',    par_s12s21_sr_mag)
		np.savetxt(path_par_s11 + 'par_s12s21_sr_ang.txt',    par_s12s21_sr_ang)
		np.savetxt(path_par_s11 + 'par_s22_sr_mag.txt',       par_s22_sr_mag)
		np.savetxt(path_par_s11 + 'par_s22_sr_ang.txt',       par_s22_sr_ang)

		np.savetxt(path_par_s11 + 'par_s11_simu1_mag.txt',    par_s11_simu1_mag)
		np.savetxt(path_par_s11 + 'par_s11_simu1_ang.txt',    par_s11_simu1_ang)
		np.savetxt(path_par_s11 + 'par_s11_simu2_mag.txt',    par_s11_simu2_mag)
		np.savetxt(path_par_s11 + 'par_s11_simu2_ang.txt',    par_s11_simu2_ang)

		np.savetxt(path_par_s11 + 'RMS_s11.txt',       	      RMS_s11)



	# End
	print('Files processed.')

	return 1











def calibration_processing_high_band_2015_35degC(flow=90, fhigh=190, save='no'):
	"""
	Last modification: March 18, 2016.

	This function produces model parameters for spectra and S11 calibration data corresponding to the high-band 2015 receiver.

	Definition:
	out = calibration_processing_high_band_2015_35degC(flow, fhigh, save='no')

	Input parameters:
	flow: low-frequency limit of the calibration modeling, in MHz
	fhigh: high-frequency limit of the calibration modeling, in MHz
	save: flag for saving parameters. Use save='yes' for saving

	Output parameters:
	out: parameters of spectra and S11 models

	Usage:
	out = calibration_processing_high_band_2015_35degC(90, 190, save='no')
	"""



	# Paths
	path_root_data  = home_folder + '/DATA'
	path_root_files = home_folder + '/WORK'

	# Paths for source data
	path_spectra    = path_root_data  + '/EDGES/spectra/level1/calibration_march_2015/300_350/35degC/'
	path_resistance = path_root_files + '/EDGES/receiver_calibration/calibration_march_2015/LNA/resistance/' 
	path_s11        = path_root_files + '/EDGES/receiver_calibration/calibration_march_2015/LNA/S11/corrected_delay/'  # it is recommended to use files with load delay


	# Paths for output parameters
	path_par_temp    = path_root_files + '/EDGES/receiver_calibration/calibration_march_2015/LNA/models/35degC/temp/'
	path_par_spectra = path_root_files + '/EDGES/receiver_calibration/calibration_march_2015/LNA/models/35degC/spectra/'
	path_par_s11     = path_root_files + '/EDGES/receiver_calibration/calibration_march_2015/LNA/models/35degC/s11/'

	# Path for average data
	path_data        = path_root_files + '/EDGES/receiver_calibration/calibration_march_2015/LNA/models/35degC/data/'




	# Spectra/resistance files

	# Ambient
	file_amb1 = path_spectra + 'level1_ambient_load_35degC_2015_081_21_300_350.mat' #'level1_ambient_load_2015_070_01_300_350.mat'
	file_amb2 = path_spectra + 'level1_ambient_load_35degC_2015_082_00_300_350.mat' #'level1_ambient_load_2015_071_00_300_350.mat'
	spec_amb  = [file_amb1, file_amb2]
	res_amb   = path_resistance + 'resistance_ambient_load_35degC_20150322.txt'


	# Hot
	file_hot1 = path_spectra + 'level1_hot_load_35degC_2015_084_02_300_350.mat' #'level1_hot_load_2015_074_04_300_350.mat'
	file_hot2 = path_spectra + 'level1_hot_load_35degC_2015_085_00_300_350.mat' #'level1_hot_load_2015_075_00_300_350.mat'
	spec_hot  = [file_hot1, file_hot2]
	res_hot   = path_resistance + 'resistance_hot_load_35degC_20150324.txt'


	# Open
	file_open1 = path_spectra + 'level1_open_cable_35degC_second_measurement_2015_093_02_300_350.mat'    #'level1_open_cable_hires_2015_086_07_300_350.mat'
	#file_open2 = path_spectra + 'level1_open_cable_hires_2015_087_00_300_350.mat'
	spec_open  = [file_open1]
	res_open   = path_resistance + 'resistance_open_cable_35degC_second_measurement_20150402.txt'


	# Shorted
	file_shorted1 = path_spectra + 'level1_shorted_cable_35degC_second_measurement_2015_093_15_300_350.mat'  #'level1_shorted_cable_hires_2015_087_15_300_350.mat'
	#file_shorted2 = path_spectra + 'level1_shorted_cable_hires_2015_088_00_300_350.mat'
	spec_shorted  = [file_shorted1]
	res_shorted   = path_resistance + 'resistance_shorted_cable_35degC_second_measurement_20150403.txt'


	# Simu1
	file_simu11   = path_spectra + 'level1_simulator1_35degC_2015_091_18_300_350.mat'   #'level1_simulator1_hires_2015_088_18_300_350.mat'
	file_simu12   = path_spectra + 'level1_simulator1_35degC_2015_092_00_300_350.mat'   #'level1_simulator1_hires_2015_089_00_300_350.mat'
	spec_simu1    = [file_simu11, file_simu12]
	res_simu1     = path_resistance + 'resistance_simulator1_35degC_20150401.txt'


	# Simu2
	file_simu21   = path_spectra + 'level1_simulator2_35degC_2015_092_02_300_350.mat'  #'level1_simulator2_2015_075_22_300_350.mat'
	file_simu22   = path_spectra + 'level1_simulator2_35degC_2015_093_00_300_350.mat'  #level1_simulator2_2015_076_00_300_350.mat'
	spec_simu2    = [file_simu21, file_simu22]
	res_simu2     = path_resistance + 'resistance_simulator2_35degC_20150401.txt'






	# Average calibration spectra / physical temperature 
	# Percentage of initial data to leave out
	percent = 5  # 5% is fine 
	ssa,  phys_temp_amb     = average_calibration_spectrum(spec_amb,     res_amb,     percent, plot='no')
	ssh,  phys_temp_hot     = average_calibration_spectrum(spec_hot,     res_hot,     percent, plot='no')
	sso,  phys_temp_open    = average_calibration_spectrum(spec_open,    res_open,    percent, plot='no')
	sss,  phys_temp_shorted = average_calibration_spectrum(spec_shorted, res_shorted, percent, plot='no')
	sss1, phys_temp_simu1   = average_calibration_spectrum(spec_simu1,   res_simu1,   percent, plot='no')
	sss2, phys_temp_simu2   = average_calibration_spectrum(spec_simu2,   res_simu2,   percent, plot='no')



	# EDGES frequency
	ff, ilow, ihigh = frequency_edges(flow, fhigh)



	# Data selection
	fe  = ff[ilow:ihigh+1]
	sa  = ssa[ilow:ihigh+1]
	sh  = ssh[ilow:ihigh+1]
	so  = sso[ilow:ihigh+1]
	ss  = sss[ilow:ihigh+1]
	ss1 = sss1[ilow:ihigh+1]  # just averaging of data, no modeling of simulators
	ss2 = sss2[ilow:ihigh+1]  # just averaging of data, no modeling of simulators



	# Spectra modeling
	fen = (fe-140)/60
	fit_spec_amb     = fit_polynomial_fourier('polynomial', fen, sa,  5,   plot='no')
	fit_spec_hot     = fit_polynomial_fourier('polynomial', fen, sh,  5,   plot='no')
	fit_spec_open    = fit_polynomial_fourier('fourier',    fen, so,  121, plot='no')
	fit_spec_shorted = fit_polynomial_fourier('fourier',    fen, ss,  121, plot='no')
	fit_spec_simu1   = fit_polynomial_fourier('fourier',    fen, ss1, 17,  plot='no')
	fit_spec_simu2   = fit_polynomial_fourier('fourier',    fen, ss2, 23,  plot='no') 







	# Loading S11 data
	out1, out2, out3 = load_high_band_calibration_s11(flow=flow, fhigh=fhigh, calibration_temperature=35)

	f_s11       = np.real(out1[0])
	s11_LNA     = out1[1]
	s11_amb     = out1[2]
	s11_hot     = out1[3]

	f_s11_hires = np.real(out2[0])
	s11_open    = out2[1]
	s11_shorted = out2[2]
	s11_simu1   = out2[3]
	s11_simu2   = out2[4]

	f_sr        = np.real(out3[0])
	s11_sr      = out3[1]
	s12s21_sr   = out3[2]
	s22_sr      = out3[3]



	# LNA
	s11_LNA_mag = np.abs(s11_LNA)
	s11_LNA_ang = np.unwrap(np.angle(s11_LNA))

	# Ambient
	s11_amb_mag = np.abs(s11_amb)
	s11_amb_ang = np.unwrap(np.angle(s11_amb))

	# Hot
	s11_hot_mag = np.abs(s11_hot)
	s11_hot_ang = np.unwrap(np.angle(s11_hot))


	# Open
	s11_open_mag    = np.abs(s11_open)
	s11_open_ang    = np.unwrap(np.angle(s11_open))

	# Shorted
	s11_shorted_mag = np.abs(s11_shorted)
	s11_shorted_ang = np.unwrap(np.angle(s11_shorted))

	# Simulator1
	s11_simu1_mag   = np.abs(s11_simu1)
	s11_simu1_ang   = np.unwrap(np.angle(s11_simu1))

	# Simulator2
	s11_simu2_mag   = np.abs(s11_simu2)
	s11_simu2_ang   = np.unwrap(np.angle(s11_simu2))


	# sr-s11
	s11_sr_mag    = np.abs(s11_sr)
	s11_sr_ang    = np.unwrap(np.angle(s11_sr))

	# sr-s12s21
	s12s21_sr_mag = np.abs(s12s21_sr)
	s12s21_sr_ang = np.unwrap(np.angle(s12s21_sr))

	# sr-s22
	s22_sr_mag    = np.abs(s22_sr)
	s22_sr_ang    = np.unwrap(np.angle(s22_sr))















	# Modeling S11

	fit_s11_LNA_mag     = fit_polynomial_fourier('fourier', (f_s11-140)/60, s11_LNA_mag, 27, plot='no')  # rms residuals at 2e-3 dB with 9 terms
	fit_s11_LNA_ang     = fit_polynomial_fourier('fourier', (f_s11-140)/60, s11_LNA_ang, 27, plot='no')  # rms residuals at 0.02 deg with 9 terms

	fit_s11_amb_mag     = fit_polynomial_fourier('fourier', (f_s11-140)/60, s11_amb_mag, 27, plot='no') # rms residuals at 5e-4 dB level with 15 terms
	fit_s11_amb_ang     = fit_polynomial_fourier('fourier', (f_s11-140)/60, s11_amb_ang, 27, plot='no') # rms residuals at 0.004 deg with 9 terms

	fit_s11_hot_mag     = fit_polynomial_fourier('fourier', (f_s11-140)/60, s11_hot_mag, 27, plot='no') # rms residuals at 5e-4 dB level with 15 terms
	fit_s11_hot_ang     = fit_polynomial_fourier('fourier', (f_s11-140)/60, s11_hot_ang, 27, plot='no') # rms residuals at 0.004 deg with 9 terms



	fit_s11_open_mag    = fit_polynomial_fourier('fourier',    (f_s11_hires-140)/60, s11_open_mag, 27, plot='no')  # rms residuals at the 1e-5 dB with 61 terms
	fit_s11_open_ang    = fit_polynomial_fourier('fourier',    (f_s11_hires-140)/60, s11_open_ang, 27, plot='no')  # rms residuals at the 1e-4 deg with 61 terms

	fit_s11_shorted_mag = fit_polynomial_fourier('fourier',    (f_s11_hires-140)/60, s11_shorted_mag, 27, plot='no') # rms residuals at the 1e-5 dB with 61 terms
	fit_s11_shorted_ang = fit_polynomial_fourier('fourier',    (f_s11_hires-140)/60, s11_shorted_ang, 27, plot='no') # rms residuals at the 1e-4 deg with 61 terms



	fit_s11_sr_mag      = fit_polynomial_fourier('polynomial', (f_sr-140)/60, s11_sr_mag, 15, plot='no')
	fit_s11_sr_ang      = fit_polynomial_fourier('polynomial', (f_sr-140)/60, s11_sr_ang, 15, plot='no')

	fit_s12s21_sr_mag   = fit_polynomial_fourier('polynomial', (f_sr-140)/60, s12s21_sr_mag, 15, plot='no')
	fit_s12s21_sr_ang   = fit_polynomial_fourier('polynomial', (f_sr-140)/60, s12s21_sr_ang, 15, plot='no')

	fit_s22_sr_mag      = fit_polynomial_fourier('polynomial', (f_sr-140)/60, s22_sr_mag, 15, plot='no')
	fit_s22_sr_ang      = fit_polynomial_fourier('polynomial', (f_sr-140)/60, s22_sr_ang, 15, plot='no')



	fit_s11_simu1_mag   = fit_polynomial_fourier('fourier',   (f_s11_hires-140)/60, s11_simu1_mag, 27, plot='no')
	fit_s11_simu1_ang   = fit_polynomial_fourier('fourier',   (f_s11_hires-140)/60, s11_simu1_ang, 27, plot='no')

	fit_s11_simu2_mag   = fit_polynomial_fourier('fourier',   (f_s11_hires-140)/60, s11_simu2_mag, 27, plot='no')
	fit_s11_simu2_ang   = fit_polynomial_fourier('fourier',   (f_s11_hires-140)/60, s11_simu2_ang, 27, plot='no')






	# Saving output parameters
	if save == 'yes':


		# Average spectra data in frequency range selected
		spectra = np.array([fe, sa, sh, so, ss, ss1, ss2]).T

		# S11 data in frequency range selected
		s11_1 = np.array([f_s11, s11_LNA_mag, s11_LNA_ang, s11_amb_mag, s11_amb_ang, s11_hot_mag, s11_hot_ang]).T
		s11_2 = np.array([f_s11_hires, s11_open_mag, s11_open_ang, s11_shorted_mag, s11_shorted_ang, s11_simu1_mag, s11_simu1_ang, s11_simu2_mag, s11_simu2_ang]).T
		s11_3 = np.array([f_sr, s11_sr_mag, s11_sr_ang, s12s21_sr_mag, s12s21_sr_ang, s22_sr_mag, s22_sr_ang]).T


		# RMS residuals
		RMS_spectra = np.zeros((6,1))
		RMS_s11     = np.zeros((20,1))

		# Spectra
		RMS_spectra[0, 0] = fit_spec_amb[2]
		RMS_spectra[1, 0] = fit_spec_hot[2]
		RMS_spectra[2, 0] = fit_spec_open[2]
		RMS_spectra[3, 0] = fit_spec_shorted[2]
		RMS_spectra[4, 0] = fit_spec_simu1[2]
		RMS_spectra[5, 0] = fit_spec_simu2[2]

		# S11
		RMS_s11[0, 0]  = fit_s11_LNA_mag[2]
		RMS_s11[1, 0]  = fit_s11_LNA_ang[2]
		RMS_s11[2, 0]  = fit_s11_amb_mag[2]
		RMS_s11[3, 0]  = fit_s11_amb_ang[2]
		RMS_s11[4, 0]  = fit_s11_hot_mag[2]
		RMS_s11[5, 0]  = fit_s11_hot_ang[2]
		RMS_s11[6, 0]  = fit_s11_open_mag[2]
		RMS_s11[7, 0]  = fit_s11_open_ang[2]
		RMS_s11[8, 0]  = fit_s11_shorted_mag[2]
		RMS_s11[9, 0]  = fit_s11_shorted_ang[2]
		RMS_s11[10, 0] = fit_s11_sr_mag[2]
		RMS_s11[11, 0] = fit_s11_sr_ang[2]
		RMS_s11[12, 0] = fit_s12s21_sr_mag[2]
		RMS_s11[13, 0] = fit_s12s21_sr_ang[2]
		RMS_s11[14, 0] = fit_s22_sr_mag[2]
		RMS_s11[15, 0] = fit_s22_sr_ang[2]
		RMS_s11[16, 0] = fit_s11_simu1_mag[2]
		RMS_s11[17, 0] = fit_s11_simu1_ang[2]
		RMS_s11[18, 0] = fit_s11_simu2_mag[2]
		RMS_s11[19, 0] = fit_s11_simu2_ang[2]



		# Formating fit parameters

		# Physical temperature
		phys_temp = np.zeros((6,1))
		phys_temp[0,0] = phys_temp_amb
		phys_temp[1,0] = phys_temp_hot
		phys_temp[2,0] = phys_temp_open
		phys_temp[3,0] = phys_temp_shorted
		phys_temp[4,0] = phys_temp_simu1
		phys_temp[5,0] = phys_temp_simu2


		# Spectra
		par_spec_amb        = np.reshape(fit_spec_amb[0],        (-1,1))
		par_spec_hot        = np.reshape(fit_spec_hot[0],        (-1,1))
		par_spec_open       = np.reshape(fit_spec_open[0],       (-1,1))
		par_spec_shorted    = np.reshape(fit_spec_shorted[0],    (-1,1))
		par_spec_simu1      = np.reshape(fit_spec_simu1[0],      (-1,1))
		par_spec_simu2      = np.reshape(fit_spec_simu2[0],      (-1,1))

		# S11
		par_s11_LNA_mag     = np.reshape(fit_s11_LNA_mag[0],     (-1,1))
		par_s11_LNA_ang     = np.reshape(fit_s11_LNA_ang[0],     (-1,1))
		par_s11_amb_mag     = np.reshape(fit_s11_amb_mag[0],     (-1,1))
		par_s11_amb_ang     = np.reshape(fit_s11_amb_ang[0],     (-1,1))
		par_s11_hot_mag     = np.reshape(fit_s11_hot_mag[0],     (-1,1))
		par_s11_hot_ang     = np.reshape(fit_s11_hot_ang[0],     (-1,1))
		par_s11_open_mag    = np.reshape(fit_s11_open_mag[0],    (-1,1))
		par_s11_open_ang    = np.reshape(fit_s11_open_ang[0],    (-1,1))
		par_s11_shorted_mag = np.reshape(fit_s11_shorted_mag[0], (-1,1))
		par_s11_shorted_ang = np.reshape(fit_s11_shorted_ang[0], (-1,1))

		par_s11_sr_mag      = np.reshape(fit_s11_sr_mag[0],      (-1,1))
		par_s11_sr_ang      = np.reshape(fit_s11_sr_ang[0],      (-1,1))
		par_s12s21_sr_mag   = np.reshape(fit_s12s21_sr_mag[0],   (-1,1))
		par_s12s21_sr_ang   = np.reshape(fit_s12s21_sr_ang[0],   (-1,1))
		par_s22_sr_mag      = np.reshape(fit_s22_sr_mag[0],      (-1,1))
		par_s22_sr_ang      = np.reshape(fit_s22_sr_ang[0],      (-1,1))

		par_s11_simu1_mag   = np.reshape(fit_s11_simu1_mag[0],   (-1,1))
		par_s11_simu1_ang   = np.reshape(fit_s11_simu1_ang[0],   (-1,1))
		par_s11_simu2_mag   = np.reshape(fit_s11_simu2_mag[0],   (-1,1))
		par_s11_simu2_ang   = np.reshape(fit_s11_simu2_ang[0],   (-1,1))



		# Saving

		np.savetxt(path_data + 'average_spectra_300_350.txt', spectra)

		np.savetxt(path_data + 's11_1.txt', s11_1)
		np.savetxt(path_data + 's11_2.txt', s11_2)
		np.savetxt(path_data + 's11_3.txt', s11_3)

		np.savetxt(path_par_temp    + 'physical_temperatures.txt', phys_temp)

		np.savetxt(path_par_spectra + 'par_spec_amb.txt',     par_spec_amb)
		np.savetxt(path_par_spectra + 'par_spec_hot.txt',     par_spec_hot)
		np.savetxt(path_par_spectra + 'par_spec_open.txt',    par_spec_open)
		np.savetxt(path_par_spectra + 'par_spec_shorted.txt', par_spec_shorted)
		np.savetxt(path_par_spectra + 'par_spec_simu1.txt',   par_spec_simu1)
		np.savetxt(path_par_spectra + 'par_spec_simu2.txt',   par_spec_simu2)
		np.savetxt(path_par_spectra + 'RMS_spec.txt',         RMS_spectra)

		np.savetxt(path_par_s11 + 'par_s11_LNA_mag.txt',      par_s11_LNA_mag)
		np.savetxt(path_par_s11 + 'par_s11_LNA_ang.txt',      par_s11_LNA_ang)
		np.savetxt(path_par_s11 + 'par_s11_amb_mag.txt',      par_s11_amb_mag)
		np.savetxt(path_par_s11 + 'par_s11_amb_ang.txt',      par_s11_amb_ang)
		np.savetxt(path_par_s11 + 'par_s11_hot_mag.txt',      par_s11_hot_mag)
		np.savetxt(path_par_s11 + 'par_s11_hot_ang.txt',      par_s11_hot_ang)
		np.savetxt(path_par_s11 + 'par_s11_open_mag.txt',     par_s11_open_mag)
		np.savetxt(path_par_s11 + 'par_s11_open_ang.txt',     par_s11_open_ang)
		np.savetxt(path_par_s11 + 'par_s11_shorted_mag.txt',  par_s11_shorted_mag)
		np.savetxt(path_par_s11 + 'par_s11_shorted_ang.txt',  par_s11_shorted_ang)

		np.savetxt(path_par_s11 + 'par_s11_sr_mag.txt',       par_s11_sr_mag)
		np.savetxt(path_par_s11 + 'par_s11_sr_ang.txt',       par_s11_sr_ang)
		np.savetxt(path_par_s11 + 'par_s12s21_sr_mag.txt',    par_s12s21_sr_mag)
		np.savetxt(path_par_s11 + 'par_s12s21_sr_ang.txt',    par_s12s21_sr_ang)
		np.savetxt(path_par_s11 + 'par_s22_sr_mag.txt',       par_s22_sr_mag)
		np.savetxt(path_par_s11 + 'par_s22_sr_ang.txt',       par_s22_sr_ang)

		np.savetxt(path_par_s11 + 'par_s11_simu1_mag.txt',    par_s11_simu1_mag)
		np.savetxt(path_par_s11 + 'par_s11_simu1_ang.txt',    par_s11_simu1_ang)
		np.savetxt(path_par_s11 + 'par_s11_simu2_mag.txt',    par_s11_simu2_mag)
		np.savetxt(path_par_s11 + 'par_s11_simu2_ang.txt',    par_s11_simu2_ang)

		np.savetxt(path_par_s11 + 'RMS_s11.txt',       	      RMS_s11)



	# End
	print('Files processed.')

	return 1













def MC_LNA_high_band_uncertainty_propagation(function, folder_name, nMC, quiet_loud_sky='quiet', antenna_S11_mag =-15, good_bad_antenna_phase='bad_phase', MC_antenna_S11_mag='no', MC_antenna_S11_ang='no', MC_std_ant_mag_factor=1, MC_std_ant_ang_factor=1, receiver_reflection='actual', MC_spectra_noise=np.zeros(6), MC_s11_noise=np.zeros(20), MC_s11_syst=np.zeros(20), systematic_s11='uncorrelated', MC_temp=np.zeros(6)):







	# High band
	band = 'high_band'



	# Frequency
	f, il, ih = frequency_edges(90, 190)
	fe = f[il:ih+1]
	fn = (fe - 140)/60



	# Fiducial LNA calibration quantities
	calibration_temperature = 25
	models_fiducial = models_LNA(band, calibration_temperature, fe, spectra_data_model='model', receiver_reflection=receiver_reflection)

	rl_fiducial     = models_fiducial[0]
	sca_fiducial    = models_fiducial[1]
	off_fiducial    = models_fiducial[2]
	TU_fiducial     = models_fiducial[3]
	TC_fiducial     = models_fiducial[4]
	TS_fiducial     = models_fiducial[5]



	# Input antenna temperature
	Tfg    = model_foreground_high_band(fe, quiet_loud_sky=quiet_loud_sky)
	Ta_cal = Tfg



	# Binning fiducial antenna temperature
	samples_per_bin = 64
	weights_array = np.ones(len(fe))
	fb, Ta_cal_bin, count = spectral_binning(fe, Ta_cal, weights_array, samples_per_bin) 






	# Antenna reflection coefficient
	mag   = 10**(antenna_S11_mag/20)   # fiducial is -15 dB

	if good_bad_antenna_phase == 'good_phase':
		ang  = (np.pi/180) * 1*(250 - (500/200) * fe)  # good case
	elif good_bad_antenna_phase == 'bad_phase':
		ang  = (np.pi/180) * 2*(250 - (500/200) * fe)  # bad  case

	rant  = mag * (np.cos(ang) + 1j * np.sin(ang))





	# Uncalibrated antenna temperature
	Ta_unc = uncalibrated_antenna_temperature(Ta_cal, rant, rl_fiducial, sca_fiducial, off_fiducial, TU_fiducial, TC_fiducial, TS_fiducial)



	# -----------------------------------------------------------------------
	# MC Section ------------------------------------------------------------
	# -----------------------------------------------------------------------

	# Initializing storage arrays
	rl_MC            = np.zeros([nMC, len(fe)]) + 0j
	sca_MC           = np.zeros([nMC, len(fe)])
	off_MC           = np.zeros([nMC, len(fe)])
	TU_MC            = np.zeros([nMC, len(fe)])
	TC_MC            = np.zeros([nMC, len(fe)])
	TS_MC            = np.zeros([nMC, len(fe)])
	Ta_cal_MC        = np.zeros([nMC, len(fb)])
	DTa_cal_MC       = np.zeros([nMC, len(fb)])
	DTa_cal_MC_1term = np.zeros([nMC, len(fb)])
	DTa_cal_MC_2term = np.zeros([nMC, len(fb)])
	DTa_cal_MC_3term = np.zeros([nMC, len(fb)])
	DTa_cal_MC_4term = np.zeros([nMC, len(fb)])
	DTa_cal_MC_5term = np.zeros([nMC, len(fb)])
	DTa_cal_MC_6term = np.zeros([nMC, len(fb)])
	DTa_cal_MC_7term = np.zeros([nMC, len(fb)])



	for i in range(nMC):

		print('repetition ' + str(i+1) + ' of ' + str(nMC))

		# LNA calibration quantities
		models = models_LNA(band, calibration_temperature, fe, spectra_data_model='model', receiver_reflection=receiver_reflection, MC_spectra_noise=MC_spectra_noise, MC_s11_noise=MC_s11_noise, MC_s11_syst=MC_s11_syst, systematic_s11=systematic_s11, MC_temp=MC_temp)

		rl_MC[i, :]  = models[0]
		sca_MC[i, :] = models[1]
		off_MC[i, :] = models[2]
		TU_MC[i, :]  = models[3]
		TC_MC[i, :]  = models[4]
		TS_MC[i, :]  = models[5]



		# MC Antenna S11
		if (MC_antenna_S11_mag == 'yes') or (MC_antenna_S11_ang == 'yes'):			
			if MC_antenna_S11_mag == 'yes':
				std_mag = np.abs(10**(-15.005/20) - 10**(-15/20))   # 1sigma of 0.005 dB at -15 dB
				err_mag = np.random.normal(0, MC_std_ant_mag_factor * std_mag)
				mag_MC  = mag + err_mag
			if MC_antenna_S11_mag == 'no':
				mag_MC = mag

			if MC_antenna_S11_ang == 'yes':
				std_ang = (np.pi/180) * np.abs(0.015/(10**(antenna_S11_mag/20)))     # FLAT IN FREQUENCY, CHANGE FOR REAL ANTENNA S11
				err_ang = np.random.normal(0, MC_std_ant_ang_factor * std_ang)
				ang_MC  = ang + err_ang
			if MC_antenna_S11_ang == 'no':
				ang_MC  = ang

			rant_MC  = mag_MC * (np.cos(ang_MC) + 1j * np.sin(ang_MC))


		elif (MC_antenna_S11_mag == 'no') and (MC_antenna_S11_ang == 'no'):
			rant_MC = rant 




		# Calibrated antenna temperature
		Ta_cal_recovered                = calibrated_antenna_temperature(Ta_unc, rant_MC, rl_MC[i, :], sca_MC[i, :], off_MC[i, :], TU_MC[i, :], TC_MC[i, :], TS_MC[i, :])
		fb, Ta_cal_recovered_bin, count = spectral_binning(fe, Ta_cal_recovered, weights_array, samples_per_bin)
		Ta_cal_MC[i, :]                 = Ta_cal_recovered_bin
		DTa_cal_MC[i, :]                = Ta_cal_recovered_bin - Ta_cal_bin



		# Removing structure
		if function == 'poly':

			fbn = (fb-140)/60


			for k in [1,2,3,4,5,6,7]:


				par_removal   = np.polyfit(fbn, DTa_cal_MC[i, :], k-1)
				model_removal = np.polyval(par_removal, fbn)

				if k == 1:
					DTa_cal_MC_1term[i, :] = DTa_cal_MC[i, :] - model_removal

				if k == 2:
					DTa_cal_MC_2term[i, :] = DTa_cal_MC[i, :] - model_removal

				if k == 3:
					DTa_cal_MC_3term[i, :] = DTa_cal_MC[i, :] - model_removal

				if k == 4:
					DTa_cal_MC_4term[i, :] = DTa_cal_MC[i, :] - model_removal

				if k == 5:
					DTa_cal_MC_5term[i, :] = DTa_cal_MC[i, :] - model_removal

				if k == 6:
					DTa_cal_MC_6term[i, :] = DTa_cal_MC[i, :] - model_removal

				if k == 7:
					DTa_cal_MC_7term[i, :] = DTa_cal_MC[i, :] - model_removal




		if function == 'edges_poly':

			fbn = fb/140


			for k in [1,2,3,4,5,6,7]:


				par_removal   = np.polyfit(fbn, (fbn**2.5)*DTa_cal_MC[i, :], k-1)    
				model_removal = (fbn**(-2.5))*np.polyval(par_removal, fbn)

				# TRADITIONAL POLYNOMIAL
				# USE NORMALIZATION (FB-140)/60
				#par_removal   = np.polyfit(fbn, DTa_cal_MC[i, :], k-1)
				#model_removal = np.polyval(par_removal, fbn)

				if k == 1:
					DTa_cal_MC_1term[i, :] = DTa_cal_MC[i, :] - model_removal

				if k == 2:
					DTa_cal_MC_2term[i, :] = DTa_cal_MC[i, :] - model_removal

				if k == 3:
					DTa_cal_MC_3term[i, :] = DTa_cal_MC[i, :] - model_removal

				if k == 4:
					DTa_cal_MC_4term[i, :] = DTa_cal_MC[i, :] - model_removal

				if k == 5:
					DTa_cal_MC_5term[i, :] = DTa_cal_MC[i, :] - model_removal

				if k == 6:
					DTa_cal_MC_6term[i, :] = DTa_cal_MC[i, :] - model_removal

				if k == 7:
					DTa_cal_MC_7term[i, :] = DTa_cal_MC[i, :] - model_removal




		if function == 'log':

			fbn = fb/140


			for k in [1,2,3,4,5,6,7]:


				par_removal   = np.polyfit(np.log(fbn), np.log(Ta_cal_MC[i, :]), k-1) 
				model_removal = np.exp(np.polyval(par_removal, np.log(fbn)))

				if k == 1:
					DTa_cal_MC_1term[i, :] = Ta_cal_MC[i, :] - model_removal

				if k == 2:
					DTa_cal_MC_2term[i, :] = Ta_cal_MC[i, :] - model_removal

				if k == 3:
					DTa_cal_MC_3term[i, :] = Ta_cal_MC[i, :] - model_removal

				if k == 4:
					DTa_cal_MC_4term[i, :] = Ta_cal_MC[i, :] - model_removal

				if k == 5:
					DTa_cal_MC_5term[i, :] = Ta_cal_MC[i, :] - model_removal

				if k == 6:
					DTa_cal_MC_6term[i, :] = Ta_cal_MC[i, :] - model_removal

				if k == 7:
					DTa_cal_MC_7term[i, :] = Ta_cal_MC[i, :] - model_removal








	# Saving data
	root_path = home_folder + '/'
	full_path = root_path + 'DATA/EDGES/uncertainty_propagation/high_band/' + folder_name + '/'
	if not exists(full_path):
		makedirs(full_path)

	np.savetxt(full_path + 'freq.txt',        np.reshape(fb, (-1,1)))		
	np.savetxt(full_path + 'Tant.txt',        Ta_cal_MC.T)
	np.savetxt(full_path + 'DTant.txt',       DTa_cal_MC.T)
	np.savetxt(full_path + 'DTant_1term.txt', DTa_cal_MC_1term.T)
	np.savetxt(full_path + 'DTant_2term.txt', DTa_cal_MC_2term.T)
	np.savetxt(full_path + 'DTant_3term.txt', DTa_cal_MC_3term.T)
	np.savetxt(full_path + 'DTant_4term.txt', DTa_cal_MC_4term.T)
	np.savetxt(full_path + 'DTant_5term.txt', DTa_cal_MC_5term.T)
	np.savetxt(full_path + 'DTant_6term.txt', DTa_cal_MC_6term.T)
	np.savetxt(full_path + 'DTant_7term.txt', DTa_cal_MC_7term.T)






	return 1





















def MC_high_band_correction_of_residuals(path, model, folder_name, NNin=47, flow_110MHz = 'NO', save='yes'):

	# THIS FUNCTION CORRECTS THE COMPUTATION OF RESIDUALS DONE WITH FUNCTION:
	# " MC_LNA_high_band_uncertainty_propagation "



	# Ambient S11 Mag
	# path = home_folder + '/DATA/EDGES/uncertainty_propagation/high_band/loud_sky_polynomials_edges/s11_amb_mag/'
	#
	# model: 'polynomial', 'EDGES_polynomial'

	ff  = np.genfromtxt(path + 'freq.txt')	
	DD  = np.genfromtxt(path + 'DTant.txt')




	# If computing 95% RMS between 110 and 190 MHz 
	if flow_110MHz == 'YES':
		f = ff[51::]
		D = DD[51::,:]
	else:
		f = ff
		D = DD




	# Output vector of 95% RMS residuals
	RMS_95_All = np.zeros(8)


	# Index value for 95% RMS in residual distributions
	if len(D[0,:]) == 5000:
		NN = 4750   # 68% 3400
	else:
		NN = NNin



	# Residual arrays
	D1 = np.zeros((len(D[:,0]), len(D[0,:])))
	D2 = np.zeros((len(D[:,0]), len(D[0,:])))
	D3 = np.zeros((len(D[:,0]), len(D[0,:])))
	D4 = np.zeros((len(D[:,0]), len(D[0,:])))
	D5 = np.zeros((len(D[:,0]), len(D[0,:])))
	D6 = np.zeros((len(D[:,0]), len(D[0,:])))
	D7 = np.zeros((len(D[:,0]), len(D[0,:])))



	# Computing residuals
	for k in [0, 1, 2, 3, 4, 5, 6, 7]:

		#print('NTERMS: ' + str(k))		
		for i in range(len(D[0,:])):

			# Model to be fit to residuals
			if k == 0:
				m = np.zeros(len(f))			

			elif k > 0:
				p, m, rms, cov = fit_polynomial_fourier(model, f/140, D[:,i], k)

				if k == 1:
					D1[:,i] = D[:,i] - m

				if k == 2:
					D2[:,i] = D[:,i] - m

				if k == 3:
					D3[:,i] = D[:,i] - m

				if k == 4:
					D4[:,i] = D[:,i] - m

				if k == 5:
					D5[:,i] = D[:,i] - m

				if k == 6:
					D6[:,i] = D[:,i] - m

				if k == 7:
					D7[:,i] = D[:,i] - m




			# Computing and accumulating RMS residuals
			if i == 0:
				RMS_MC = np.sqrt( np.sum(  (D[:,i]-m)**2 ) / len(f) )

			elif i>0:
				RMS_MC = np.append(RMS_MC, np.sqrt( np.sum(  (D[:,i]-m)**2 ) / len(f) ))


		# Computing 95% RMS values from distributions
		RMS_95 = int(round(1000 * np.sort( RMS_MC )[NN]))
		RMS_95_All[k] = RMS_95



	#print('NTERMS: ' + str(k) + ', RMS_95: ' + str(RMS_95))
	print('-----------------------------------------')
	print(str(RMS_95_All))




	# Saving residuals
	if save == 'yes':
		root_path = home_folder + '/'
		full_path = root_path + 'DATA/EDGES/uncertainty_propagation/high_band/correct_residuals/' + folder_name + '/'
		if not exists(full_path):
			makedirs(full_path)

		#np.savetxt(full_path + 'freq.txt',        np.reshape(f, (-1,1)))		
		#np.savetxt(full_path + 'Tant.txt',        Ta_cal_MC.T)
		#np.savetxt(full_path + 'DTant.txt',       DTa_cal_MC.T)
		np.savetxt(full_path + 'DTant_1term.txt', D1)
		np.savetxt(full_path + 'DTant_2term.txt', D2)
		np.savetxt(full_path + 'DTant_3term.txt', D3)
		np.savetxt(full_path + 'DTant_4term.txt', D4)
		np.savetxt(full_path + 'DTant_5term.txt', D5)
		np.savetxt(full_path + 'DTant_6term.txt', D6)
		np.savetxt(full_path + 'DTant_7term.txt', D7)




	return RMS_95_All, D1, D2, D3, D4, D5, D6, D7



































def simulated_antenna_temperature(band, beam_case, sky_model, flow, fhigh, fstep, extra_flag, index_inband=2.4, index_outband=2.6, fixed_beam_frequency='no', save='yes'):
	"""
	Last modification: May 3, 2015.

	flow:  100  (number, not string)
	fhigh: 200  (number, not string)
	fstep:   1  (number, not string)
	band: 'high_band', 'low_band'
	beam_case: 'cosine square', 'fourpoint_infinite', 'blade_infinite'
	sky_model:  'gsm', or 'scaled_haslam'
	fixed_beam_frequency: 'no', 150   # MHz
	freq_array: np.arange(110,191,1)
	"""	


	# Data paths
	path_root     = home_folder + '/DATA/'
	path_data     = path_root + 'EDGES/beam_convolution/'
	path_GSM_file = path_data + 'gsm/data_hdf5/GSM_dataset_40_200_MHz.hdf5'
	path_save     = path_data + 'sky_convolved_beam/' + band + '/'


	# Frequency vector
	freq_array = np.arange(flow, fhigh+fstep, fstep)


	# Beam selection
	if beam_case == 'fourpoint_infinite':
		beam = FEKO_high_band_fourpoint_beam(frequency_interpolation='yes', frequency=freq_array)

	elif beam_case == 'blade_infinite':
		beam = CST_high_band_blade_beam(frequency_interpolation='yes', frequency=freq_array)

	elif beam_case == 'blade_plus_shaped_finite':
		beam = FEKO_high_band_blade_beam_plus_shaped_finite_ground_plane(frequency_interpolation='yes', frequency=freq_array, AZ_antenna_axis=-6)


	# Beam coordinates
	AZ_beam             = np.arange(0,360)
	EL_beam             = np.arange(0, 91)
	AZ_beam_array       = np.tile(AZ_beam,91)
	EL_beam_array       = np.repeat(EL_beam,360)
	AZ_EL_beam_original = np.array([AZ_beam_array, EL_beam_array]).T



	# Loading GSM and Galactic Coordinates, Healpix RING format
	lon, lat, RA, DEC, freq_gsm, gsm_data = GSM_HDF5_read(path_GSM_file, print_keys='no')
	GALAC_COORD_object = apc.SkyCoord(lon, lat, frame='galactic', unit='deg')  # defaults to ICRS frame



	# EDGES location	
	EDGES_lat_deg  = -26.714778
	EDGES_lon_deg  = 116.605528 
	EDGES_location = apc.EarthLocation(lat=EDGES_lat_deg*apu.deg, lon=EDGES_lon_deg*apu.deg)


	# Initializing output quantities
	Tant = np.zeros((72, len(freq_array)))
	LST  = np.zeros(72)





	# Looping over frequency
	for j in range(len(freq_array)):


		# Loading sky data
		freq_iter = freq_array[j]
		FREQ      = str(freq_iter)
		if len(FREQ) == 2:
			FREQ = '0' + FREQ		

		# Global Sky Model
		if sky_model == 'gsm':
			sky = gsm_data[:,freq_iter-40]   # index 0 is 40 MHz
			print(freq_gsm[freq_iter-40])
			sky_model_index = sky_model

		# Scaled Haslam Map (Galactic Coordinates, Healpix RING format)
		if sky_model == 'scaled_haslam':
			sky = scaled_haslam_map(freq_iter, band_deg=10, index_inband=index_inband, index_outband=index_outband)
			sky_model_index = sky_model + '_' + str(index_inband) + '_' + str(index_outband) 

		# 45-408 MHz original Sky Model
		if sky_model == '45_408_MHz_original':
			sky = sky_model_45_408_MHz(freq_iter, maps_45_408='original')
			sky_model_index = '45_408_MHz_original' 

		# 45-408 MHz GSM Sky Model
		if sky_model == '45_408_MHz_gsm':
			sky = sky_model_45_408_MHz(freq_iter, maps_45_408='gsm')
			sky_model_index = '45_408_MHz_gsm' 



		# Reference observation time. At this time, the LST is 0.1666 (00:10 Hrs LST) at the EDGES location
		Time_iter    = np.array([2014, 1, 1, 9, 39, 42])     
		Time_iter_dt = dt.datetime(Time_iter[0], Time_iter[1], Time_iter[2], Time_iter[3], Time_iter[4], Time_iter[5]) 		



		# Looping over LST 
		for i in range(72):


			print('')
			print('------------------')
			print('Frequency: ' + FREQ + ' MHz. LST: ' + str(i+1) + ' of 72'  )
			print('------------------')				


			# Advancing time ( 19:57 minutes UTC correspond to 20 minutes LST )
			minutes_offset = 19
			seconds_offset = 57
			if i > 0:
				Time_iter_dt = Time_iter_dt + dt.timedelta(minutes = minutes_offset, seconds = seconds_offset)
				Time_iter    = np.array([Time_iter_dt.year, Time_iter_dt.month, Time_iter_dt.day, Time_iter_dt.hour, Time_iter_dt.minute, Time_iter_dt.second]) 

			# LST 
			LST[i] = utc2lst(Time_iter, EDGES_lon_deg)				



			# Local coordinates corresponding to galactic coordinates
			print('hola')
			altaz          = GALAC_COORD_object.transform_to(apc.AltAz(location=EDGES_location, obstime=apt.Time(Time_iter_dt, format='datetime')))
			AZ             = np.asarray(altaz.az)
			EL             = np.asarray(altaz.alt)
			print('chao')


			# Selecting coordinates and sky data above the horizon
			AZ_above_horizon        = AZ[EL>=0]
			EL_above_horizon        = EL[EL>=0]
			AZ_EL_sky_above_horizon = np.array([AZ_above_horizon, EL_above_horizon]).T
			sky_above_horizon       = sky[EL>=0]	



			# Evaluating beam at local coordinates above horizon
			if (beam_case == 'fourpoint_infinite') or (beam_case == 'blade_infinite') or (beam_case == 'blade_plus_shaped_finite'):
				if fixed_beam_frequency == 'no':
					flag_fixed_beam = ''
					beam_original   = beam[j,:,:].reshape(1,-1)[0]
				else:
					flag_fixed_beam = '_fixed_beam_' + str(round(fixed_beam_frequency,1)) + '_MHz' 
					freq_index      = (fixed_beam_frequency - flow) / fstep
					beam_original   = beam[freq_index,:,:].reshape(1,-1)[0]

				beam_above_horizon  = spi.griddata(AZ_EL_beam_original, beam_original, AZ_EL_sky_above_horizon, method='cubic')  # interpolated beam



			elif beam_case == 'cosine_square':
				beam_above_horizon = np.cos((np.pi/180)*(90-EL_above_horizon))**2



			# Index without nans
			no_nan_array_beam = np.ones(len(AZ_above_horizon)) - np.isnan(beam_above_horizon)
			index_no_nan_beam = np.nonzero(no_nan_array_beam)[0]

			no_nan_array_sky = np.ones(len(AZ_above_horizon)) - np.isnan(sky_above_horizon)
			index_no_nan_sky = np.nonzero(no_nan_array_sky)[0]

			index_no_nan = np.intersect1d(index_no_nan_beam, index_no_nan_sky)




			# Convolution between beam and sky
			Numerator   = np.sum(sky_above_horizon[index_no_nan]*beam_above_horizon[index_no_nan])
			Denominator = np.sum(beam_above_horizon[index_no_nan])



			# Antenna temperature
			Tant[i, j] = Numerator/Denominator


	# Saving data
	if save == 'yes':
		filename = path_save + band + '_' + sky_model_index + '_' + beam_case + '_flow_' + str(flow) + '_fhigh_' + str(fhigh) + '_fstep_' + str(fstep) + flag_fixed_beam + extra_flag + '.txt'
		data_array = np.concatenate((LST.reshape(-1,1), Tant), axis=1)
		np.savetxt(filename, data_array)		


	return LST, Tant















def spectral_binning_old(fe_raw, sp_raw, npoints):
	"""
	REMINDER: At the moment, this function doesn't handle WEIGHTS !!!
	"""

	flag = 1
	count = -1
	while flag == 1:
		count = count + 1
		if count == 0:
			if (len(sp_raw) % npoints) == 0:
				flag = 0
				fe_binned = np.mean(np.reshape(fe_raw, (-1, npoints)), axis=1)
				sp_binned = np.mean(np.reshape(sp_raw, (-1, npoints)), axis=1)

		else:
			if (len(sp_raw[0:(-count)]) % npoints) == 0:
				flag = 0
				fe_binned = np.mean(np.reshape(fe_raw[0:-count], (-1, npoints)), axis=1)
				sp_binned = np.mean(np.reshape(sp_raw[0:-count], (-1, npoints)), axis=1)

	print('')			
	print('------------------------------------------------------------------')
	print('REMINDER: At the moment, this function doesn\'t handle WEIGHTS !!!')
	print('------------------------------------------------------------------')			

	return fe_binned, sp_binned, count









def spectral_binning(fe_raw, sp_raw, we_raw, npoints):


	# Remove end points to allow exact binning of "npoints"
	fe_raw_new = fe_raw
	sp_raw_new = sp_raw
	we_raw_new = we_raw
	flag  =  1
	count =  0

	while flag == 1:

		if (len(fe_raw_new) % npoints) == 0:
			flag = 0

		elif (len(fe_raw_new) % npoints) != 0:
			count = count+1
			fe_raw_new =  fe_raw[0:-count]
			sp_raw_new =  sp_raw[0:-count]
			we_raw_new =  we_raw[0:-count]

	#print(count)
	#print(len(fe_raw))
	#print(len(fe_raw_new))




	# Binning data that are different from zero
	fe_binned = np.mean(np.reshape(fe_raw_new, (-1, npoints)), axis=1)
	sp_binned = np.zeros(len(fe_binned))
	we_binned = np.zeros(len(fe_binned))

	sp_block  = np.reshape(sp_raw_new, (-1, npoints))
	we_block  = np.reshape(we_raw_new, (-1, npoints))


	for k in range(len(fe_binned)):

		flag_j = 0
		for j in range(npoints):

			if sp_block[k,j] != 0:
				if flag_j == 0:
					sp_bin_all = sp_block[k,j]
					we_bin_all = we_block[k,j]
					flag_j = 1
				elif flag_j > 0:
					sp_bin_all = np.append(sp_bin_all, sp_block[k,j])
					we_bin_all = np.append(we_bin_all, we_block[k,j])


		# If there are no points in bin a zero is returned for sp_binned and we_binned
		if flag_j == 0:
			we_binned[k] = 0
			sp_binned[k] = 0

		else:			
			we_binned[k] = np.sum(we_bin_all) 
			sp_binned[k] = np.sum(sp_bin_all * we_bin_all) / we_binned[k]


	# Returning binned frequency (in even steps given by 'npoints'), data (using only those different from zero), and weights (total number of raw points per bin)



	return fe_binned, sp_binned, we_binned












def spectral_binning_fixed_frequency(fstart, fstop, fstep, freq_in, spectrum_in, weights_in):

	"""
	This function computes a binned spectrum for a specific, regular, bin frequency vector
	"""

	# Arrays of binned frequency, spectrum and weights
	#freq_binned     = np.arange(np.min(fstart), fstop+(fstep/2), fstep)
	freq_binned     = np.arange(fstart, fstop+(fstep/2), fstep)
	spectrum_binned = np.zeros(len(freq_binned))
	weights_binned  = np.zeros(len(freq_binned))

	spectrum_aa = np.zeros(len(freq_binned))

	# Looping over arrays
	for j in range(len(freq_binned)):


		# Identifying data in bins
		df = freq_in - freq_binned[j]
		spectrum_array = spectrum_in[(df >= -fstep/2) & (df < fstep/2) & (spectrum_in != 0) & (weights_in > 0)]
		weights_array  =  weights_in[(df >= -fstep/2) & (df < fstep/2) & (spectrum_in != 0) & (weights_in > 0)]

		# Compute bins if there are data
		weights_bin  = np.sum(weights_array)
		if weights_bin > 0:
			spectrum_bin = np.sum(spectrum_array*weights_array) / weights_bin

			# Storing binned data in array
			spectrum_binned[j] = spectrum_bin
			weights_binned[j]  = weights_bin

		spectrum_aa[j] = np.sum(spectrum_array)


	return freq_binned, spectrum_binned, weights_binned, spectrum_aa








def spectral_binning_number_of_samples(freq_in, spectrum_in, weights_in, nsamples=64):

	flag_start = 0
	i = 0
	for j in range(len(freq_in)):

		if i == 0:
			sum_fre = 0
			sum_num = 0
			sum_den = 0

		if (i >= 0) and (i < nsamples):

			sum_fre = sum_fre + freq_in[j]
			#if spectrum_in[j]  0:
			sum_num = sum_num + spectrum_in[j]*weights_in[j]
			sum_den = sum_den + weights_in[j]

			av_fr_temp = sum_fre / nsamples
			if sum_den > 0:
				av_sp_temp = sum_num / sum_den
			else:
				av_sp_temp = 0


		if i < (nsamples-1):
			i = i+1

		elif i == (nsamples-1):
			if flag_start == 0:
				av_fr = av_fr_temp
				av_sp = av_sp_temp
				av_we = sum_den
				flag_start = 1

			elif flag_start > 0:
				av_fr = np.append(av_fr, av_fr_temp)
				av_sp = np.append(av_sp, av_sp_temp)
				av_we = np.append(av_we, sum_den)

			i = 0


	return av_fr, av_sp, av_we












def level3_to_level4(band, receiver_temperature, temp_correction, version, antenna, antenna_s11_day, ground_loss_type, ground_loss_percent, Tambient = 300, save_flag = ''):

	"""
	band:                   'high_band' or 'low_band'
	receiver_temperature:   25 or 'measured_receiver_temperature'
	temp_correction:        'full', or 'half' 
	version:                'v1', etc
	antenna:                'fourpoint' or 'blade'          
	antenna_s11_day:        For high-band fourpoint: 109, 119, 120, 123, 124, best=157. For high-band blade: 212, best=262. For low-band: 282 ???
	ground_loss_type:       'Alan', 'Tom', 'value'
	ground_loss_percent:    0.0 or 0.5
	save_flag:              Anything that identifies better the saved file.
	"""	

	# Loading data
	path_file = home_folder + '/DATA/EDGES/spectra/level3/' + band + '/old/' + band + '_' + version + '_' + antenna + '.hdf5'
	f, ta_all, m_all, w_all = level3read(path_file)


	# Data calibration -------------------------
	# ------------------------------------------
	# ------------------------------------------

	# Computing combined losses
	cg = combined_gain(band, f, antenna_s11_day = antenna_s11_day, flag_ground_loss = 1, ground_loss_type = ground_loss_type, ground_loss_percent = ground_loss_percent, flag_antenna_loss = 1, flag_balun_connector_loss = 1)
	#cg = combined_gain(band, f, antenna_s11_day = antenna_s11_day, flag_ground_loss = 1, flag_antenna_loss = 1, flag_balun_connector_loss = 1)

	# Calibration is not corrected based on receiver temperature
	if receiver_temperature == 25:
		save_flag_recv = 'not_corrected'
		ta_cal = data_calibration(band, receiver_temperature, ta_all, f, antenna, antenna_s11_day = antenna_s11_day, combined_gain = cg, Tambient = Tambient, high_band_cal_file = 1, beam_factor = 1)
		#tc = data_calibration('high_band', RecTemp, t_2D[k,:], fin, 'blade', antenna_s11_day = 'average', combined_gain = cg, high_band_cal_file = 1, beam_factor = beam_factor) 

	# Calibration is corrected based on receiver temperature
	elif receiver_temperature == 'measured_receiver_temperature':

		ta_cal    = np.zeros((len(ta_all[:,0,0]), len(ta_all[0,:,0]), len(ta_all[0,0,:])))


		# Looping over LST
		for k in range(len(m_all[:,0,0])):           # range(20): #

			# Looping over days
			for j in range(len(m_all[0,:,0])):   # range(20): #

				# Calibrating data if receiver temperatures are "reasonable"
				if (m_all[k,j,11] >= 15) and (m_all[k,j,11] <= 35) and (m_all[k,j,12] >= 15) and (m_all[k,j,12] <= 35) and (np.sum(w_all[k,j,:]) > 0):
					# if full delta-temp correction then divide by 1, if half delta-temp correction divide by 2
					if temp_correction == 'full':
						Trec = m_all[k,j,12] + (m_all[k,j,11]-m_all[k,j,12])/1
						save_flag_recv = 'full_correction'

					elif temp_correction == 'half':
						Trec = m_all[k,j,12] + (m_all[k,j,11]-m_all[k,j,12])/2
						save_flag_recv = 'half_correction'

					print('LST: ' + str(round((1/6) + k*24/72,2)) + ' Hr,   Day: ' + str(j) + ',  Receiver Temperature: ' + str(round(Trec,2)) + ' degC')
					ta_cal[k,j,:] = data_calibration(band, Trec, ta_all[k,j,:], f, antenna, antenna_s11_day = antenna_s11_day, combined_gain = cg, Tambient = Tambient, high_band_cal_file = 1, beam_factor = 1)
				else:
					ta_cal[k,j,:] = np.zeros(len(ta_all[0,0,:]))
					w_all[k,j,:]  = np.zeros(len(ta_all[0,0,:]))


	# Template of ones and zeros
	Z = np.zeros((len(ta_all[:,0,0]), len(ta_all[0,:,0]), len(ta_all[0,0,:])))
	Z[np.nonzero(w_all)] = 1



	# Calibrated data with zero temperature at index with zero weight
	ta_new = ta_cal*Z



	# Binning data and more RFI cleaning
	tnr_all = np.zeros((len(ta_new[:,0,0]), len(ta_new[0,:,0]), 250))
	wnr_all = np.zeros((len(ta_new[:,0,0]), len(ta_new[0,:,0]), 250))

	for j in range(len(ta_new[:,0,0])):
		for i in range(len(ta_new[0,:,0])):

			if (np.sum(w_all[j,i,:]) > 100) and (np.sum(ta_new[j,i,:]) > 100):

				#print('Binning traces at LST bin ' + str(j+1) + ' of 72')
				fb, tb, wb = spectral_binning_fixed_frequency(90.2, 190.0, 0.4, f, ta_new[j,i,:], w_all[j,i,:])
				tnr, wnr   = RFI_cleaning_std(fb, tb, wb, df_MHz = 20, npar = 3, n_sigma = 2.5)

				tnr_all[j,i,:] = tnr
				wnr_all[j,i,:] = wnr



	# Cleaning DTV
	tnr_all2 = np.zeros((len(ta_new[:,0,0]), len(ta_new[0,:,0]), 250))
	wnr_all2 = np.zeros((len(ta_new[:,0,0]), len(ta_new[0,:,0]), 250))
	for j in range(len(tnr_all[:,0,0])):
		tnr_all2[j,:,:], wnr_all2[j,:,:] = RFI_DTV_removal(fb, tnr_all[j,:,:], wnr_all[j,:,:])		



	# Save
	path_save = home_folder + '/DATA/EDGES/spectra/level4/' + band + '/'
	if ground_loss_type == 'value':
		save_file = path_save + band + '_' + version + '_' + antenna + '_s11day_' + str(antenna_s11_day) + '_recv_temp_' + save_flag_recv + '_tambient_' + str(Tambient) + '_ground_loss_percent_' + str(ground_loss_percent) + save_flag + '.hdf5'
	else:
		save_file = path_save + band + '_' + version + '_' + antenna + '_s11day_' + str(antenna_s11_day) + '_recv_temp_' + save_flag_recv + '_tambient_' + str(Tambient) + '_ground_loss_' + str(ground_loss_type) + save_flag + '.hdf5'

	with h5py.File(save_file, 'w') as hf:
		hf.create_dataset('frequency',           data = fb)
		hf.create_dataset('antenna_temperature', data = tnr_all2)
		hf.create_dataset('metadata',            data = m_all)
		hf.create_dataset('weights',             data = wnr_all2)		


	return fb, tnr_all, m_all, wnr_all














def model_foreground_high_band(fe, option='gsm_cosine_square', quiet_loud_sky='quiet'):
	"""

	"""




	# Paths
	path_root = home_folder + ''

	path_data = path_root + '/WORK/EDGES/sky_convolved_beam/results/'





	# Loading data
	if option == 'gsm_cosine_square':
		foreground = np.genfromtxt(path_data + 'gsm_1.0HRres_high_band_cosine_square.txt')


	# Quiet or Loud sky
	if quiet_loud_sky == 'quiet':
		foreground_raw = foreground[19, 1::]   # 1.7  LST

	if quiet_loud_sky == 'loud':
		foreground_raw = foreground[11, 1::]   # 17.7 LST	






	# Modeling foreground
	v_raw = np.arange(90, 191, 1)
	v0    = 150

	log_v_raw  = np.log10(v_raw/v0)
	log_fg_raw = np.log10(foreground_raw)

	deg_poly = 3  # with a third degree polynomial, the RMS for the cosine square model gets below 1e-4 K
	par      = np.polyfit(log_v_raw, log_fg_raw, deg_poly)	



	# Evaluating model at raw frequency 
	log_fg_model_raw = np.polyval(par, log_v_raw)
	fg_model_raw     = 10**log_fg_model_raw

	# Computing RMS of the fit
	RMS = np.sqrt(np.sum((foreground_raw - fg_model_raw)**2)/len(foreground_raw))


	# Evaluating model at input frequency
	log_v_model  = np.log10(fe/v0)
	log_fg_model = np.polyval(par, log_v_model)
	fg_model     = 10**log_fg_model 




	# Foreground model
	Tfg = fg_model


	return Tfg	







def frequency2redshift(fe):
	"""

	"""
	# Constants and definitions
	c    = 299792458	# wikipedia, m/s
	f21  = 1420.40575177e6  # wikipedia,    
	l21  = c / f21          # frequency to wavelength, as emitted 
	l    = c / (fe * 1e6)   # frequency to wavelength, observed. fe comes in MHz but it has to be converted to Hertz
	z    = (l - l21) / l21  # wavelegth to redshift	

	return z





def redshift2frequency(z):
	"""

	"""
	# Constants and definitions
	c    = 299792458	# wikipedia, m/s
	f21  = 1420.40575177e6  # wikipedia,    
	l21  = c / f21          # frequency to wavelength, as emitted
	l    = l21 * (1 + z)
	f    = c / (l * 1e6)
	return f












def model_eor(f, T21=0.027, model_type='tanh', fr=150, df=10, zr=8, dz=2, z_alpha=0, dz_accuracy_skewed_gaussian=0.0025, tau0=1, tilt=0):
	"""

	"""



	# Conversion to redshift
	z   = frequency2redshift(f)
	xHI = np.zeros(len(z))

	if (model_type == 'gaussian_flattened_1') or (model_type == 'gaussian_flattened_2'):
		Teor = model_eor_flattened_gaussian(f, model_type=int(model_type[-1]), T21=T21, vr=fr, dv=df, tau0=tau0, tilt=tilt)




	# EoR model
	if model_type == 'tanh':
		xHI  = model_xHI(z, zr, dz)
		Teor = T21 * np.sqrt( (1+z) / 10 ) * xHI



	# Gaussian in frequency
	elif model_type == 'gaussian_frequency':
		xHI  = np.zeros(len(z))
		gaussian_sigma_df = df / (2*np.sqrt(2*np.log(2)))   # dv is the FWHM
		Teor = T21 * np.exp(  -((f - fr)**2)/(2*gaussian_sigma_df**2)   )



	# Gaussian in redshift
	elif model_type == 'gaussian_redshift':
		if np.isscalar(z) == True:
			xHI = 0

		elif np.isscalar(z) == False:
			xHI = np.zeros(len(z))




		# Perfect Gaussian
		if z_alpha == 0:
			gaussian_sigma_dz = dz / (2*np.sqrt(2*np.log(2)))   # dz is the FWHM
			Teor              = T21 * np.exp(  -((z - zr)**2)/(2*gaussian_sigma_dz**2)   )	


		# Skewed Gaussian
		elif z_alpha != 0:

			#dz_off = 0.02
			dz_off = 0
			dzz    = dz #0
			zr0    = np.min(z) + (np.max(z)-np.min(z)) / 2

			# Longer redshift vector used during finding minimum and width
			zz = np.arange( 1, 40, dz_accuracy_skewed_gaussian/3 )



			#print('XXXX')
			flag   = 0
			count  = 0
			dz_skewed_old = 0
			while flag == 0:
				count = count + 1
				#print(count)

				dzz               = dzz + dz_off
				gaussian_sigma_dz = dzz / (2*np.sqrt(2*np.log(2)))   # dz is the FWHM
				gaussian_part     = np.exp(  -((zz - zr0)**2)/(2*gaussian_sigma_dz**2)   )			
				skewness_part     = 1 + scs.erf(    (z_alpha/np.sqrt(2)) * ((zz - zr0)/gaussian_sigma_dz)    )   # https://en.wikipedia.org/wiki/Skew_normal_distribution
				Teor_pre          = gaussian_part * skewness_part
				peak_value        = np.max(np.abs(Teor_pre))
				#print(peak_value)
				Teor_norm         = Teor_pre / peak_value				
				zsel              = zz[Teor_norm > 0.5]  # Defining FWHM

				dz_skewed = np.max(zsel) - np.min(zsel)
				# print([str(dz_off) + ' ' + str(dz_skewed) + ' ' + str(np.max(zsel)) + ' ' + str(np.min(zsel))])
				# DO NOT USE if (dz_skewed + 2*dz_off > dz) and (dz_skewed - 2*dz_off < dz):
				#print([dz_skewed - dz_skewed_old, 1])


				if (np.abs(dz_skewed - dz_skewed_old) > 1e-6):

					if (np.abs(dz - dz_skewed) <= dz_accuracy_skewed_gaussian):
						flag = 1

					else:

						dz_off_old    = np.copy(dz_off)                    # offset of previous iteration

						if count == 1:
							offset_factor = 1
						elif count > 1:
							offset_factor = dz_off / (dz_skewed - dz_skewed_old)


						dz_off        = offset_factor * (dz - dz_skewed)   # 2
						#print([dz-dz_skewed, dz_skewed - dz_skewed_old, dz_off])

						dz_skewed_old = np.copy(dz_skewed)
				else:
					flag=1


			#print([dz-dz_skewed])


			# Evaluating skewed Gaussian at the original redshift vector, with desired FWHM and minimum redshift
			zr1  = zz[Teor_norm==np.max(Teor_norm)][0]  # Redshift of the minimum
			#print(zr1)
			zr2  = zr - (zr1-zr0)
			#zr2 = zr0			


			gaussian_sigma_dz = dzz / (2*np.sqrt(2*np.log(2)))  # dzz is the width of the last iteration before dz_skewed >= dz
			gaussian_part     = np.exp(  -((z - zr2)**2)/(2*gaussian_sigma_dz**2)   )
			skewness_part     = 1 + scs.erf(    (z_alpha/np.sqrt(2)) * ((z - zr2)/gaussian_sigma_dz)    )   # https://en.wikipedia.org/wiki/Skew_normal_distribution
			Teor_pre          = gaussian_part * skewness_part
			Teor_norm         = Teor_pre / peak_value			

			Teor = T21 * Teor_norm

			#print(Teor_pre)
			#print(peak_value)


	return Teor, xHI, z









def model_xHI(z, zr, dz):
	"""

	"""
	return (1/2) * ( 1 + np.tanh( (z-zr) / dz) )




def model_eor_plus_foregrounds(v, poly_par, foreground_model='Physical_model', T21=0.03, zr=8, dz=1, v0=200):
	"""


	"""

	# EoR model
	T_eor, xHI, z = model_eor(v, T21=T21, zr=zr, dz=dz)



	# Foregrounds model
	T_foreground = model_evaluate(foreground_model, poly_par, v/v0)



	# Adding the two models
	model_total = T_eor + T_foreground

	return model_total









def chi_square_eor_plus_foregrounds(v, data, noise, model):
	"""

	"""

	# Full model
	T21 = 0.027      # this is not a fit parameter
	T21_params  = np.insert(params, 0, T21)
	model_total = model_eor_plus_polynomial(T21_params, fe)

	# Chi square
	chi_square  = np.sum((data - model_total)**2)

	return chi_square











def chi_square_minimization_eor_only_grid_method(fe, data):

	ZR_array = np.arange(6.5, 14.9, 0.1)
	DZ_array = np.arange(0.05,  5.05, 0.05)

	chi_square_matrix = np.zeros((len(DZ_array), len(ZR_array)))

	minimum_chi_square = 1e10
	for j in range(len(DZ_array)):
		for i in range(len(ZR_array)):

			ZR = ZR_array[i]
			DZ = DZ_array[j]

			modeled_spectrum        = model_eor(fe, T21 = 0.027, zr = ZR, dz = DZ)	
			chi_square              = np.sum( (data - modeled_spectrum)**2 )
			chi_square_matrix[j, i] = chi_square

			if chi_square < minimum_chi_square:
				minimum_chi_square = chi_square
				best_fit_ZR = ZR
				best_fit_DZ = DZ
				best_fit = (best_fit_ZR, best_fit_DZ, minimum_chi_square)


	return best_fit, chi_square_matrix




























































def low_band_s11_calibration_measurements(temperature_LNA='25degC', flag=''):

	# Paths
	root_path    = '/Volumes/WORK/'

	LNA1_path           = root_path + 'EDGES/calibration_august_2015/LNA/S11/raw/20150828/LNA/'
	LNA2_path           = root_path + 'EDGES/calibration_august_2015/LNA/S11/raw/20150831/LNA/'
	LNA3_path           = root_path + 'EDGES/calibration_august_2015/LNA/S11/raw/20150901/LNA/'	
	LNA4_path           = root_path + 'EDGES/calibration_august_2015/LNA/S11/raw/20150902/LNA/'	
	LNA5_path           = root_path + 'EDGES/calibration_august_2015/LNA/S11/raw/20150903/LNA/'	
	LNA6_path           = root_path + 'EDGES/calibration_august_2015/LNA/S11/raw/20150905/LNA/'

	#LNA7_path           = root_path + 'EDGES/calibration_august_2015/LNA/S11/raw/20150916/LNA/'

	ambient_path        = root_path + 'EDGES/calibration_august_2015/LNA/S11/raw/20150902/ambient/'
	hot_path            = root_path + 'EDGES/calibration_august_2015/LNA/S11/raw/20150903/hot/'
	open_cable_path     = root_path + 'EDGES/calibration_august_2015/LNA/S11/raw/20150901/open/'
	shorted_cable_path  = root_path + 'EDGES/calibration_august_2015/LNA/S11/raw/20150831/shorted/'
	simu1_path          = root_path + 'EDGES/calibration_august_2015/LNA/S11/raw/20150905/simulator1/'
	simu2_path          = root_path + 'EDGES/calibration_august_2015/LNA/S11/raw/20150828/simulator2/'

	#simu2_long_path     = root_path + 'EDGES/calibration_august_2015/LNA/S11/raw/20150915/simulator2_long/'


	sr_path             = root_path + 'EDGES/calibration_june_2015/LNA/S11/raw/20150621/others/'

	save_path           = root_path + 'EDGES/calibration_august_2015/LNA/S11/corrected/'






	# LNA 1
	o_m1, f   = rc.s1p_read(LNA1_path + 'open_-35dBm_100av.S1P')
	s_m1, f   = rc.s1p_read(LNA1_path + 'short_-35dBm_100av.S1P')
	l_m1, f   = rc.s1p_read(LNA1_path + 'load_-35dBm_100av.S1P')
	lna_m1, f = rc.s1p_read(LNA1_path + 'LNA1_-35dBm_100av.S1P')

	# LNA 2
	o_m2, f   = rc.s1p_read(LNA2_path + 'open_-35dBm_100av.S1P')
	s_m2, f   = rc.s1p_read(LNA2_path + 'short_-35dBm_100av.S1P')
	l_m2, f   = rc.s1p_read(LNA2_path + 'load_-35dBm_100av.S1P')
	lna_m2, f = rc.s1p_read(LNA2_path + 'LNA_-35dBm_100av.S1P')

	# LNA 3
	o_m3, f   = rc.s1p_read(LNA3_path + 'open_-35dBm_100av.S1P')
	s_m3, f   = rc.s1p_read(LNA3_path + 'short_-35dBm_100av.S1P')
	l_m3, f   = rc.s1p_read(LNA3_path + 'load_-35dBm_100av.S1P')
	lna_m3, f = rc.s1p_read(LNA3_path + 'LNA_-35dBm_100av.S1P')

	# LNA 4
	o_m4, f   = rc.s1p_read(LNA4_path + 'open_-35dBm_100av.S1P')
	s_m4, f   = rc.s1p_read(LNA4_path + 'short_-35dBm_100av.S1P')
	l_m4, f   = rc.s1p_read(LNA4_path + 'load_-35dBm_100av.S1P')
	lna_m4, f = rc.s1p_read(LNA4_path + 'LNA_-35dBm_100av.S1P')

	# LNA 5
	o_m5, f   = rc.s1p_read(LNA5_path + 'open_-35dBm_100av.S1P')
	s_m5, f   = rc.s1p_read(LNA5_path + 'short_-35dBm_100av.S1P')
	l_m5, f   = rc.s1p_read(LNA5_path + 'load_-35dBm_100av.S1P')
	lna_m5, f = rc.s1p_read(LNA5_path + 'LNA_-35dBm_100av.S1P')

	# LNA 6
	o_m6, f   = rc.s1p_read(LNA6_path + 'open_-35dBm_100av.S1P')
	s_m6, f   = rc.s1p_read(LNA6_path + 'short_-35dBm_100av.S1P')
	l_m6, f   = rc.s1p_read(LNA6_path + 'load_-35dBm_100av.S1P')
	lna_m6, f = rc.s1p_read(LNA6_path + 'LNA_-35dBm_100av.S1P')




	## LNA 7
	#o_m7, f   = rc.s1p_read(LNA7_path + 'open_-35dBm_100av.S1P')
	#s_m7, f   = rc.s1p_read(LNA7_path + 'short_-35dBm_100av.S1P')
	#l_m7, f   = rc.s1p_read(LNA7_path + 'load_-35dBm_100av.S1P')
	#lna_m7, f = rc.s1p_read(LNA7_path + 'LNA_-35dBm_100av.S1P')	





	# Models
	resistance_of_match = 49.98 # female
	md = 1
	oa, sa, la = rc.agilent_85033E(f, resistance_of_match, md)	



	# Correction 
	lna1c, x1,x2,x3 = rc.de_embed(oa, sa, la, o_m1, s_m1, l_m1, lna_m1)
	lna2c, x1,x2,x3 = rc.de_embed(oa, sa, la, o_m2, s_m2, l_m2, lna_m2)
	lna3c, x1,x2,x3 = rc.de_embed(oa, sa, la, o_m3, s_m3, l_m3, lna_m3)
	lna4c, x1,x2,x3 = rc.de_embed(oa, sa, la, o_m4, s_m4, l_m4, lna_m4)
	lna5c, x1,x2,x3 = rc.de_embed(oa, sa, la, o_m5, s_m5, l_m5, lna_m5)
	lna6c, x1,x2,x3 = rc.de_embed(oa, sa, la, o_m6, s_m6, l_m6, lna_m6)

	#lna7c, x1,x2,x3 = rc.de_embed(oa, sa, la, o_m7, s_m7, l_m7, lna_m7)


	# Average
	lnac = np.mean(np.array([lna1c, lna2c, lna3c, lna4c, lna5c, lna6c]), axis=0)
	#lnac = lna7c












	# Calibration Devices


	# Reflection references
	oref =  1*np.ones(201)
	sref = -1*np.ones(201)
	lref =  0*np.ones(201)



	# Ambient
	o_sw, f  = rc.s1p_read(ambient_path + 'open.S1P')
	s_sw, f  = rc.s1p_read(ambient_path + 'short.S1P')
	l_sw, f  = rc.s1p_read(ambient_path + 'load.S1P')
	amb_m, f = rc.s1p_read(ambient_path + 'ambient_input.S1P')

	amb, x1,x2,x2  = rc.de_embed(oref, sref, lref, o_sw, s_sw, l_sw, amb_m)
	ambc, x1,x2,x2 = low_band_switch_correction(amb, 27)







	# Hot
	o_sw, f  = rc.s1p_read(hot_path + 'open.S1P')
	s_sw, f  = rc.s1p_read(hot_path + 'short.S1P')
	l_sw, f  = rc.s1p_read(hot_path + 'load.S1P')
	hot_m, f = rc.s1p_read(hot_path + 'hot_input.S1P')

	hot, x1,x2,x2  = rc.de_embed(oref, sref, lref, o_sw, s_sw, l_sw, hot_m)
	hotc, x1,x2,x2 = low_band_switch_correction(hot, 27)	







	# Open Cable
	o_sw, f = rc.s1p_read(open_cable_path + 'open.S1P')
	s_sw, f = rc.s1p_read(open_cable_path + 'short.S1P')
	l_sw, f = rc.s1p_read(open_cable_path + 'load.S1P')
	oc_m, f = rc.s1p_read(open_cable_path + 'open_cable_input.S1P')

	oc, x1,x2,x2  = rc.de_embed(oref, sref, lref, o_sw, s_sw, l_sw, oc_m)
	occ, x1,x2,x2 = low_band_switch_correction(oc, 27)	








	# Shorted Cable
	o_sw, f = rc.s1p_read(shorted_cable_path + 'open.S1P')
	s_sw, f = rc.s1p_read(shorted_cable_path + 'short.S1P')
	l_sw, f = rc.s1p_read(shorted_cable_path + 'load.S1P')
	sc_m, f = rc.s1p_read(shorted_cable_path + 'shorted_cable_input.S1P')

	sc, x1,x2,x2  = rc.de_embed(oref, sref, lref, o_sw, s_sw, l_sw, sc_m)
	scc, x1,x2,x2 = low_band_switch_correction(sc, 27)	








	# Simulator 1
	o_sw, f = rc.s1p_read(simu1_path + 'open.S1P')
	s_sw, f = rc.s1p_read(simu1_path + 'short.S1P')
	l_sw, f = rc.s1p_read(simu1_path + 'load.S1P')
	s1_m, f = rc.s1p_read(simu1_path + 'simulator1_input.S1P')

	s1, x1,x2,x2  = rc.de_embed(oref, sref, lref, o_sw, s_sw, l_sw, s1_m)
	s1c, x1,x2,x2 = low_band_switch_correction(s1, 27)	



	# Simulator 2
	o_sw, f = rc.s1p_read(simu2_long_path + 'open.S1P')
	s_sw, f = rc.s1p_read(simu2_long_path + 'short.S1P')
	l_sw, f = rc.s1p_read(simu2_long_path + 'load.S1P')
	s2_m, f = rc.s1p_read(simu2_long_path + 'simulator2_long_input.S1P')

	s2, x1,x2,x2  = rc.de_embed(oref, sref, lref, o_sw, s_sw, l_sw, s2_m)
	s2c, x1,x2,x2 = low_band_switch_correction(s2, 27)






	# Semi-rigid cable

	# Measurements
	osrm, f   = rc.s1p_read(sr_path + 'open_sr_0dBm_500av.S1P')
	ssrm, f   = rc.s1p_read(sr_path + 'short_sr_0dBm_500av.S1P')
	lsrm, f   = rc.s1p_read(sr_path + 'load_sr_REPETITION_2_0dBm_500av.S1P')	# This file is better, the measurement was done properly	

	# Models of standards
	resistance_of_match = 50.11 # male
	md = 1
	oa, sa, la = rc.agilent_85033E(f, resistance_of_match, md)

	# Correction
	xxx, s11_sr, s12s21_sr, s22_sr = rc.de_embed(oa, sa, la, osrm, ssrm, lsrm, osrm)





	# Output file
	temp = np.array([  f/1e6, np.real(lnac), np.imag(lnac), \
	                   np.real(ambc),     np.imag(ambc),     np.real(hotc),         np.imag(hotc), \
	                   np.real(occ),      np.imag(occ),      np.real(scc),          np.imag(scc),  \
	                   np.real(s11_sr),   np.imag(s11_sr),   np.real(s12s21_sr),    np.imag(s12s21_sr), np.real(s22_sr), np.imag(s22_sr), \
	                   np.real(s1c),      np.imag(s1c),      np.real(s2c),          np.imag(s2c)  ])

	output_file = temp.T
	output_file_str = save_path + 's11_calibration_low_band_LNA' + temperature_LNA + '_' + tt.strftime('%Y-%m-%d-%H-%M-%S') + flag + '.txt'
	np.savetxt(output_file_str, output_file)

	print('File saved to: ' + output_file_str)	






	return output_file















def calibration_processing_low_band1_2015_08_25C(flow, fhigh, save='no', save_folder=0):
	"""
	Last modification: September 09, 2015.

	This function produces model parameters for spectra and S11 calibration data corresponding to the low-band 2015 receiver.

	Definition:
	out = calibration_processing_low_band_2015_25degC(flow, fhigh, save='no')

	Input parameters:
	flow: low-frequency limit of the calibration modeling, in MHz
	fhigh: high-frequency limit of the calibration modeling, in MHz
	save: flag for saving parameters. Use save='yes' for saving

	Output parameters:
	out: parameters of spectra and S11 models

	Usage:
	out = calibration_processing_low_band_2015_25degC(50, 100, save='no')
	"""




	# Main folder
	main_folder     = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band1/2015_08_25C/'


	# Paths for source data
	path_spectra    = main_folder + 'data/spectra/try2/300_350/'
	path_resistance = main_folder + 'data/resistance/corrected/'
	path_s11        = main_folder + 'data/s11/corrected/'


	# Creating output folders
	if save == 'yes':

		if not exists(main_folder + 'results/' + save_folder + '/temp/'):
			makedirs(main_folder + 'results/' + save_folder + '/temp/')

		if not exists(main_folder + 'results/' + save_folder + '/spectra/'):
			makedirs(main_folder + 'results/' + save_folder + '/spectra/')

		if not exists(main_folder + 'results/' + save_folder + '/s11/'):
			makedirs(main_folder + 'results/' + save_folder + '/s11/')

		if not exists(main_folder + 'results/' + save_folder + '/data/'):
			makedirs(main_folder + 'results/' + save_folder + '/data/')

		if not exists(main_folder + 'results/' + save_folder + '/calibration_files/'):
			makedirs(main_folder + 'results/' + save_folder + '/calibration_files/')			

		if not exists(main_folder + 'results/' + save_folder + '/plots/'):
			makedirs(main_folder + 'results/' + save_folder + '/plots/')


		# Output folders
		path_par_temp    = main_folder + 'results/' + save_folder + '/temp/'
		path_par_spectra = main_folder + 'results/' + save_folder + '/spectra/'
		path_par_s11     = main_folder + 'results/' + save_folder + '/s11/'
		path_data        = main_folder + 'results/' + save_folder + '/data/'






	# Spectra/resistance files

	# Ambient
	file_amb1 = path_spectra + 'level1_ambient_25degC_2015_245_02_300_350.mat'
	file_amb2 = path_spectra + 'level1_ambient_25degC_2015_246_00_300_350.mat'	
	spec_amb  = [file_amb1, file_amb2]
	res_amb   = path_resistance + 'ambient_2015_245_02.txt'


	# Hot
	file_hot1 = path_spectra + 'level1_hot_25degC_2015_246_04_300_350.mat'
	file_hot2 = path_spectra + 'level1_hot_25degC_2015_247_00_300_350.mat'	
	spec_hot  = [file_hot1, file_hot2]
	res_hot   = path_resistance + 'hot_2015_246_04.txt'


	# Open
	file_open1 = path_spectra + 'level1_open_25degC_2015_243_14_300_350.mat'
	file_open2 = path_spectra + 'level1_open_25degC_2015_244_00_300_350.mat'
	file_open3 = path_spectra + 'level1_open_25degC_2015_245_00_300_350.mat'	
	spec_open  = [file_open1, file_open2, file_open3]
	res_open   = path_resistance + 'open_2015_243_14.txt'


	# Shorted
	file_shorted1 = path_spectra + 'level1_shorted_25degC_2015_241_04_300_350.mat'
	file_shorted2 = path_spectra + 'level1_shorted_25degC_2015_242_00_300_350.mat'
	file_shorted3 = path_spectra + 'level1_shorted_25degC_2015_243_00_300_350.mat'	
	spec_shorted  = [file_shorted1, file_shorted2, file_shorted3]
	res_shorted   = path_resistance + 'shorted_2015_241_04.txt'


	# Simu1
	file_simu11   = path_spectra + 'level1_simulator1_25degC_2015_247_22_300_350.mat'
	file_simu12   = path_spectra + 'level1_simulator1_25degC_2015_248_00_300_350.mat'
	file_simu13   = path_spectra + 'level1_simulator1_25degC_2015_249_00_300_350.mat'	
	spec_simu1    = [file_simu11, file_simu12, file_simu13]
	res_simu1     = path_resistance + 'simulator1_2015_247_22.txt'


	## Simu2
	#file_simu21   = path_spectra + 'level1_simulator2_25degC_2015_240_04_300_350.mat'
	#file_simu22   = path_spectra + 'level1_simulator2_25degC_2015_241_00_300_350.mat'
	#spec_simu2    = [file_simu21, file_simu22]
	#res_simu2     = path_resistance + 'simulator2_2015_240_04.txt'


	# Simu2
	file_simu21   = path_spectra + 'level1_simulator2_long_25degC_2015_255_02_300_350.mat'
	file_simu22   = path_spectra + 'level1_simulator2_long_25degC_2015_256_00_300_350.mat'
	file_simu23   = path_spectra + 'level1_simulator2_long_25degC_2015_257_00_300_350.mat'	
	spec_simu2    = [file_simu21, file_simu22, file_simu23]
	res_simu2     = path_resistance + 'simulator2_long_2015_255_02.txt'




	# Average calibration spectra / physical temperature
	# Percentage of initial data to leave out
	percent = 10
	ssa,  phys_temp_amb     = average_calibration_spectrum(spec_amb,     res_amb,     1*percent, plot='no')
	ssh,  phys_temp_hot     = average_calibration_spectrum(spec_hot,     res_hot,     1*percent, plot='no')
	sso,  phys_temp_open    = average_calibration_spectrum(spec_open,    res_open,    1*percent, plot='no')
	sss,  phys_temp_shorted = average_calibration_spectrum(spec_shorted, res_shorted, 1*percent, plot='no')
	sss1, phys_temp_simu1   = average_calibration_spectrum(spec_simu1,   res_simu1,   1*percent, plot='no')
	sss2, phys_temp_simu2   = average_calibration_spectrum(spec_simu2,   res_simu2,   5*percent, plot='no')




	# Data selection
	ff, ilow, ihigh = frequency_edges(flow, fhigh)
	fe  = ff[ilow:ihigh+1]
	sa  = ssa[ilow:ihigh+1]
	sh  = ssh[ilow:ihigh+1]
	so  = sso[ilow:ihigh+1]
	ss  = sss[ilow:ihigh+1]
	ss1 = sss1[ilow:ihigh+1]  # just averaging of data, no modeling of simulators
	ss2 = sss2[ilow:ihigh+1]  # just averaging of data, no modeling of simulators	




	# Spectra modeling
	fen = (fe-75)/25
	fit_spec_amb     = fit_polynomial_fourier('polynomial', fen, sa,  5,   plot='no')  # 7
	fit_spec_hot     = fit_polynomial_fourier('polynomial', fen, sh,  5,   plot='no')  # 7
	fit_spec_open    = fit_polynomial_fourier('fourier',    fen, so,  27,  plot='no')  # 27 
	fit_spec_shorted = fit_polynomial_fourier('fourier',    fen, ss,  27,  plot='no')  # 27
	fit_spec_simu1   = fit_polynomial_fourier('polynomial', fen, ss1, 7,   plot='no')
	fit_spec_simu2   = fit_polynomial_fourier('polynomial', fen, ss2, 11,  plot='no') 





	# Loading S11 data
	#s11 = np.genfromtxt(path_s11 + 's11_calibration_low_band_LNA25degC_2015-09-07-07-44-05.txt')
	s11 = np.genfromtxt(path_s11 + 's11_calibration_low_band_LNA25degC_2015-09-16-12-30-29_simulator2_long.txt')


	for i in range(len(s11[:,0])):
		if (s11[i,0] <= flow) and (s11[i+1,0] > flow):
			index_low = i
		if (s11[i-1,0] < fhigh) and (s11[i,0] >= fhigh):
			index_high = i
	index_s11 = np.arange(index_low, index_high+1)

	# Frequency / complex data
	f_s11         = s11[index_s11, 0]
	s11_LNA       = s11[index_s11, 1]  + 1j*s11[index_s11, 2]
	s11_amb       = s11[index_s11, 3]  + 1j*s11[index_s11, 4]
	s11_hot       = s11[index_s11, 5]  + 1j*s11[index_s11, 6]
	s11_open      = s11[index_s11, 7]  + 1j*s11[index_s11, 8]
	s11_shorted   = s11[index_s11, 9]  + 1j*s11[index_s11, 10]
	s11_sr        = s11[index_s11, 11] + 1j*s11[index_s11, 12]
	s12s21_sr     = s11[index_s11, 13] + 1j*s11[index_s11, 14]
	s22_sr        = s11[index_s11, 15] + 1j*s11[index_s11, 16]
	s11_simu1     = s11[index_s11, 17] + 1j*s11[index_s11, 18]
	s11_simu2     = s11[index_s11, 19] + 1j*s11[index_s11, 20]

	# LNA
	s11_LNA_mag     = np.abs(s11_LNA)
	s11_LNA_ang     = np.unwrap(np.angle(s11_LNA))

	# Ambient
	s11_amb_mag     = np.abs(s11_amb)
	s11_amb_ang     = np.unwrap(np.angle(s11_amb))

	# Hot
	s11_hot_mag     = np.abs(s11_hot)
	s11_hot_ang     = np.unwrap(np.angle(s11_hot))

	# Open
	s11_open_mag    = np.abs(s11_open)
	s11_open_ang    = np.unwrap(np.angle(s11_open))

	# Shorted
	s11_shorted_mag = np.abs(s11_shorted)
	s11_shorted_ang = np.unwrap(np.angle(s11_shorted))

	# sr-s11
	s11_sr_mag      = np.abs(s11_sr)
	s11_sr_ang      = np.unwrap(np.angle(s11_sr))

	# sr-s12s21
	s12s21_sr_mag   = np.abs(s12s21_sr)
	s12s21_sr_ang   = np.unwrap(np.angle(s12s21_sr))

	# sr-s22
	s22_sr_mag      = np.abs(s22_sr)
	s22_sr_ang      = np.unwrap(np.angle(s22_sr))

	# Simu1
	s11_simu1_mag   = np.abs(s11_simu1)
	s11_simu1_ang   = np.unwrap(np.angle(s11_simu1))

	# Simu2
	s11_simu2_mag   = np.abs(s11_simu2)
	s11_simu2_ang   = np.unwrap(np.angle(s11_simu2))




	# Modeling S11

	f_s11n = (f_s11-75)/25

	fit_s11_LNA_mag     = fit_polynomial_fourier('polynomial', f_s11n, s11_LNA_mag,     11, plot='no')  # 9
	fit_s11_LNA_ang     = fit_polynomial_fourier('polynomial', f_s11n, s11_LNA_ang,     11, plot='no')  # 9

	fit_s11_amb_mag     = fit_polynomial_fourier('fourier',    f_s11n, s11_amb_mag,     27, plot='no')  # 15
	fit_s11_amb_ang     = fit_polynomial_fourier('fourier',    f_s11n, s11_amb_ang,     27, plot='no')  # 15

	fit_s11_hot_mag     = fit_polynomial_fourier('fourier',    f_s11n, s11_hot_mag,     27, plot='no')  # 15 
	fit_s11_hot_ang     = fit_polynomial_fourier('fourier',    f_s11n, s11_hot_ang,     27, plot='no')  # 15

	fit_s11_open_mag    = fit_polynomial_fourier('fourier',    f_s11n, s11_open_mag,    27, plot='no')  # 31
	fit_s11_open_ang    = fit_polynomial_fourier('fourier',    f_s11n, s11_open_ang,    27, plot='no')  # 31

	fit_s11_shorted_mag = fit_polynomial_fourier('fourier',    f_s11n, s11_shorted_mag, 27, plot='no')  # 31
	fit_s11_shorted_ang = fit_polynomial_fourier('fourier',    f_s11n, s11_shorted_ang, 27, plot='no')  # 31

	fit_s11_sr_mag      = fit_polynomial_fourier('polynomial', f_s11n, s11_sr_mag,       7, plot='no')  # 7
	fit_s11_sr_ang      = fit_polynomial_fourier('polynomial', f_s11n, s11_sr_ang,       7, plot='no')  # 7

	fit_s12s21_sr_mag   = fit_polynomial_fourier('polynomial', f_s11n, s12s21_sr_mag,   21, plot='no')  # 21
	fit_s12s21_sr_ang   = fit_polynomial_fourier('polynomial', f_s11n, s12s21_sr_ang,   21, plot='no')  # 9

	fit_s22_sr_mag      = fit_polynomial_fourier('polynomial', f_s11n, s22_sr_mag,       7, plot='no')  # 7
	fit_s22_sr_ang      = fit_polynomial_fourier('polynomial', f_s11n, s22_sr_ang,       7, plot='no')  # 7

	fit_s11_simu1_mag   = fit_polynomial_fourier('polynomial', f_s11n, s11_simu1_mag,    7, plot='no')  # 17
	fit_s11_simu1_ang   = fit_polynomial_fourier('polynomial', f_s11n, s11_simu1_ang,    7, plot='no')  # 17

	fit_s11_simu2_mag   = fit_polynomial_fourier('polynomial', f_s11n, s11_simu2_mag,    7, plot='no')  # 17
	fit_s11_simu2_ang   = fit_polynomial_fourier('polynomial', f_s11n, s11_simu2_ang,    7, plot='no')  # 17






	# Saving output parameters
	if save == 'yes':


		# Average spectra data in frequency range selected
		spectra = np.array([fe, sa, sh, so, ss, ss1, ss2]).T		

		# RMS residuals
		RMS_spectra = np.zeros((6,1))
		RMS_s11     = np.zeros((20,1))

		# Spectra
		RMS_spectra[0, 0] = fit_spec_amb[2]
		RMS_spectra[1, 0] = fit_spec_hot[2]
		RMS_spectra[2, 0] = fit_spec_open[2]
		RMS_spectra[3, 0] = fit_spec_shorted[2]
		RMS_spectra[4, 0] = fit_spec_simu1[2]
		RMS_spectra[5, 0] = fit_spec_simu2[2]

		# S11
		RMS_s11[0, 0]  = fit_s11_LNA_mag[2]
		RMS_s11[1, 0]  = fit_s11_LNA_ang[2]
		RMS_s11[2, 0]  = fit_s11_amb_mag[2]
		RMS_s11[3, 0]  = fit_s11_amb_ang[2]
		RMS_s11[4, 0]  = fit_s11_hot_mag[2]
		RMS_s11[5, 0]  = fit_s11_hot_ang[2]
		RMS_s11[6, 0]  = fit_s11_open_mag[2]
		RMS_s11[7, 0]  = fit_s11_open_ang[2]
		RMS_s11[8, 0]  = fit_s11_shorted_mag[2]
		RMS_s11[9, 0]  = fit_s11_shorted_ang[2]
		RMS_s11[10, 0] = fit_s11_sr_mag[2]
		RMS_s11[11, 0] = fit_s11_sr_ang[2]
		RMS_s11[12, 0] = fit_s12s21_sr_mag[2]
		RMS_s11[13, 0] = fit_s12s21_sr_ang[2]
		RMS_s11[14, 0] = fit_s22_sr_mag[2]
		RMS_s11[15, 0] = fit_s22_sr_ang[2]
		RMS_s11[16, 0] = fit_s11_simu1_mag[2]
		RMS_s11[17, 0] = fit_s11_simu1_ang[2]
		RMS_s11[18, 0] = fit_s11_simu2_mag[2]
		RMS_s11[19, 0] = fit_s11_simu2_ang[2]



		# Formating fit parameters

		# Physical temperature
		phys_temp = np.zeros((6,1))
		phys_temp[0,0] = phys_temp_amb
		phys_temp[1,0] = phys_temp_hot
		phys_temp[2,0] = phys_temp_open
		phys_temp[3,0] = phys_temp_shorted
		phys_temp[4,0] = phys_temp_simu1
		phys_temp[5,0] = phys_temp_simu2		


		# Spectra
		par_spec_amb        = np.reshape(fit_spec_amb[0],        (-1,1))
		par_spec_hot        = np.reshape(fit_spec_hot[0],        (-1,1))
		par_spec_open       = np.reshape(fit_spec_open[0],       (-1,1))
		par_spec_shorted    = np.reshape(fit_spec_shorted[0],    (-1,1))
		par_spec_simu1      = np.reshape(fit_spec_simu1[0],      (-1,1))
		par_spec_simu2      = np.reshape(fit_spec_simu2[0],      (-1,1))

		# S11
		par_s11_LNA_mag     = np.reshape(fit_s11_LNA_mag[0],     (-1,1))
		par_s11_LNA_ang     = np.reshape(fit_s11_LNA_ang[0],     (-1,1))
		par_s11_amb_mag     = np.reshape(fit_s11_amb_mag[0],     (-1,1))
		par_s11_amb_ang     = np.reshape(fit_s11_amb_ang[0],     (-1,1))
		par_s11_hot_mag     = np.reshape(fit_s11_hot_mag[0],     (-1,1))
		par_s11_hot_ang     = np.reshape(fit_s11_hot_ang[0],     (-1,1))
		par_s11_open_mag    = np.reshape(fit_s11_open_mag[0],    (-1,1))
		par_s11_open_ang    = np.reshape(fit_s11_open_ang[0],    (-1,1))
		par_s11_shorted_mag = np.reshape(fit_s11_shorted_mag[0], (-1,1))
		par_s11_shorted_ang = np.reshape(fit_s11_shorted_ang[0], (-1,1))

		par_s11_sr_mag      = np.reshape(fit_s11_sr_mag[0],      (-1,1))
		par_s11_sr_ang      = np.reshape(fit_s11_sr_ang[0],      (-1,1))
		par_s12s21_sr_mag   = np.reshape(fit_s12s21_sr_mag[0],   (-1,1))
		par_s12s21_sr_ang   = np.reshape(fit_s12s21_sr_ang[0],   (-1,1))
		par_s22_sr_mag      = np.reshape(fit_s22_sr_mag[0],      (-1,1))
		par_s22_sr_ang      = np.reshape(fit_s22_sr_ang[0],      (-1,1))

		par_s11_simu1_mag   = np.reshape(fit_s11_simu1_mag[0],   (-1,1))
		par_s11_simu1_ang   = np.reshape(fit_s11_simu1_ang[0],   (-1,1))
		par_s11_simu2_mag   = np.reshape(fit_s11_simu2_mag[0],   (-1,1))
		par_s11_simu2_ang   = np.reshape(fit_s11_simu2_ang[0],   (-1,1))




		# Saving

		np.savetxt(path_data + 'average_spectra_300_350.txt', spectra)

		np.savetxt(path_par_temp    + 'physical_temperatures.txt', phys_temp)

		np.savetxt(path_par_spectra + 'par_spec_amb.txt',     par_spec_amb)
		np.savetxt(path_par_spectra + 'par_spec_hot.txt',     par_spec_hot)
		np.savetxt(path_par_spectra + 'par_spec_open.txt',    par_spec_open)
		np.savetxt(path_par_spectra + 'par_spec_shorted.txt', par_spec_shorted)
		np.savetxt(path_par_spectra + 'par_spec_simu1.txt',   par_spec_simu1)
		np.savetxt(path_par_spectra + 'par_spec_simu2.txt',   par_spec_simu2)
		np.savetxt(path_par_spectra + 'RMS_spec.txt',         RMS_spectra)

		np.savetxt(path_par_s11 + 'par_s11_LNA_mag.txt',      par_s11_LNA_mag)
		np.savetxt(path_par_s11 + 'par_s11_LNA_ang.txt',      par_s11_LNA_ang)
		np.savetxt(path_par_s11 + 'par_s11_amb_mag.txt',      par_s11_amb_mag)
		np.savetxt(path_par_s11 + 'par_s11_amb_ang.txt',      par_s11_amb_ang)
		np.savetxt(path_par_s11 + 'par_s11_hot_mag.txt',      par_s11_hot_mag)
		np.savetxt(path_par_s11 + 'par_s11_hot_ang.txt',      par_s11_hot_ang)
		np.savetxt(path_par_s11 + 'par_s11_open_mag.txt',     par_s11_open_mag)
		np.savetxt(path_par_s11 + 'par_s11_open_ang.txt',     par_s11_open_ang)
		np.savetxt(path_par_s11 + 'par_s11_shorted_mag.txt',  par_s11_shorted_mag)
		np.savetxt(path_par_s11 + 'par_s11_shorted_ang.txt',  par_s11_shorted_ang)

		np.savetxt(path_par_s11 + 'par_s11_sr_mag.txt',       par_s11_sr_mag)
		np.savetxt(path_par_s11 + 'par_s11_sr_ang.txt',       par_s11_sr_ang)
		np.savetxt(path_par_s11 + 'par_s12s21_sr_mag.txt',    par_s12s21_sr_mag)
		np.savetxt(path_par_s11 + 'par_s12s21_sr_ang.txt',    par_s12s21_sr_ang)
		np.savetxt(path_par_s11 + 'par_s22_sr_mag.txt',       par_s22_sr_mag)
		np.savetxt(path_par_s11 + 'par_s22_sr_ang.txt',       par_s22_sr_ang)

		np.savetxt(path_par_s11 + 'par_s11_simu1_mag.txt',    par_s11_simu1_mag)
		np.savetxt(path_par_s11 + 'par_s11_simu1_ang.txt',    par_s11_simu1_ang)
		np.savetxt(path_par_s11 + 'par_s11_simu2_mag.txt',    par_s11_simu2_mag)
		np.savetxt(path_par_s11 + 'par_s11_simu2_ang.txt',    par_s11_simu2_ang)

		np.savetxt(path_par_s11 + 'RMS_s11.txt',       	      RMS_s11)


	# End
	print('Files processed.')

	return 1













def data_calibration(band, receiver_temperature, Tant_unc, fe, antenna, antenna_s11_day = 262, combined_gain = 1, Tambient = 300, beam_factor = 1, cwterms=7, MC_receiver='no', MC_s11_ant_mag='no', MC_s11_ant_ang='no'):


	"""
	feb 26, 2016: THIS FUNCTION IS NOT BEING USED. MAYBE REMOVE ????

	"""




	#ff, il, ih = frequency_edges(flow, fhigh)
	#fe = ff[il:ih+1]
	s11_ant = models_antenna_s11(band, antenna, fe, antenna_s11_day=262, model_type='polynomial', MC_mag=MC_s11_ant_mag, MC_ang=MC_s11_ant_ang, sigma_mag=0.0001, sigma_ang_deg=0.1)



	# Receiver calibration quantities
	# low_band_cal_file = 1   -> cfit = wfit = 7
	# low_band_cal_file = 2   -> cfit = 6, wfit = 5
	s11_LNA, sca, off, TU, TC, TS = receiver_calibration_fast(band, fe, receiver_temperature = receiver_temperature, cwterms=cwterms, MC=MC_receiver)



	# Calibrated antenna temperature with losses
	Tant_cal_with_loss = calibrated_antenna_temperature(Tant_unc, s11_ant, s11_LNA, sca, off, TU, TC, TS)



	# Removing loss
	Tant_cal = (Tant_cal_with_loss - Tambient*(1-combined_gain))/combined_gain



	# Removing beam chromaticity
	Tsky = Tant_cal/beam_factor


	return Tsky













def combined_gain(band, fe, antenna_type='blade', antenna_s11_day=262, antenna_s11_Nfit=10, flag_ground_loss = 1, ground_loss_type = 'value', ground_loss_percent = 0.5, flag_antenna_loss = 1, flag_balun_connector_loss = 1, MC_ground_loss='no', MC_antenna_loss='no', MC_balun_connector_loss=[0,0,0,0,0,0,0,0]):



	# Ground losses
	# --------------------------------------------------------------
	if flag_ground_loss == 1:
		Gg = ground_loss(band, fe, model_type=ground_loss_type, ground_loss_percent=ground_loss_percent, MC=MC_ground_loss)
	elif flag_ground_loss == 0:
		Gg = 1



	# Antenna losses
	# --------------------------------------------------------------
	if flag_antenna_loss == 1:
		Ga = antenna_loss(band, fe, MC=MC_antenna_loss)
	elif flag_antenna_loss == 0:
		Ga = 1



	# Balun+connector losses
	# ---------------------------------------------------------------
	# Antenna S11		
	#s11_ant = models_antenna_s11(band, 'blade', fe, antenna_s11_day=antenna_s11_day, model_type='polynomial')
	s11_ant = models_antenna_s11_remove_delay(band, antenna_type, fe, antenna_s11_day = antenna_s11_day, model_type='polynomial', Nfit=antenna_s11_Nfit)


	if flag_balun_connector_loss == 1:
		Gb, Gc = balun_and_connector_loss(band, fe, s11_ant, MC=MC_balun_connector_loss)
	elif flag_balun_connector_loss == 0:
		Gb = 1
		Gc = 1



	# Combined gain (efficiency, between 0 and 1, close to 1) from all the factors
	cg = Ga*Gb*Gc*Gg




	return cg
















def level1_to_level2(band, year, day_hour, folder, flag, save='no'):




	# Paths and files
	path_level1      = home_folder + '/DATA/EDGES/spectra/level1/' + band + '/300_350/'
	path_logs        = home_folder + '/DATA/EDGES/spectra/auxiliary/'
	path_save        = home_folder + '/DATA/EDGES/spectra/level2/' + band + '/'

	level1_file      = path_level1 + 'level1_' + year + '_' + day_hour + '_300_350.mat'
	weather_file     = path_logs   + 'weather.txt'	

	if band == 'low_band':
		thermlog_file = path_logs + 'thermlog_low.txt'

	if band == 'high_band':
		thermlog_file = path_logs + 'thermlog.txt'





	# folder, flag = 'v0', 'v1', etc

	# Frequency and indices
	if band == 'low_band':
		flow  = 50
		fhigh = 100

	if band == 'high_band':
		flow  = 90
		fhigh = 190

	ff, il, ih = frequency_edges(flow, fhigh)
	fe = ff[il:ih+1]




	# Loading data
	ds, dd = level1_MAT(level1_file)
	Tant_unc = ds[:,il:ih+1]





	# RFI flagging
	W = RFI_flagging(fe, Tant_unc)



	# LST
	EDGES_longitude = 116.6
	LST = utc2lst(dd, EDGES_longitude)



	# Seconds into measurement
	seconds_data = 3600*dd[:,3].astype(float) + 60*dd[:,4].astype(float) + dd[:,5].astype(float)



	# Auxiliary data
	year_int     = int(year)
	day_int      = int(day_hour[0:3])
	fraction_int = int(day_hour[4::])	
	aux1, aux2   = auxiliary_data(weather_file, thermlog_file, band, year_int, day_int)



	# Interpolate data
	amb_temp_interp  = np.interp(seconds_data, aux1[:,0], aux1[:,1]) - 273.15
	amb_hum_interp   = np.interp(seconds_data, aux1[:,0], aux1[:,2])
	rec1_temp_interp = np.interp(seconds_data, aux1[:,0], aux1[:,3]) - 273.15
	rec2_temp_interp = np.interp(seconds_data, aux2[:,0], aux2[:,1])



	# Combined auxiliary array
	aux_raw = np.array([amb_temp_interp, amb_hum_interp, rec1_temp_interp, rec2_temp_interp])
	aux_raw = aux_raw.T	



	# Sun/Moon coordinates
	LAT = -26.7
	LON = 116.6
	sun_moon_azel = SUN_MOON_azel(LAT, LON, dd)
	# sun_azel = SUN_azel(dd)








	# Binning in LST 
	# --------------------------------------------
	# --------------------------------------------



	# Initializing array of averages
	mean_data   = np.zeros((0,len(fe)))
	weight_data = np.zeros((0,len(fe)))
	std_data    = np.zeros((0,len(fe)))
	LST_bins    = np.zeros((72,1))

	#sun_sum       = np.zeros((72,2))
	#sun_acc       = np.zeros((72,2))
	#sun_bins      = np.zeros((72,2))

	sun_moon_sum  = np.zeros((72,4))
	sun_moon_acc  = np.zeros((72,4))
	sun_moon_bins = np.zeros((72,4))

	aux_sum       = np.zeros((72,4))
	aux_acc       = np.zeros((72,4))
	aux_bins      = np.zeros((72,4))	

	N = np.zeros((72,1))



	for j in range(72):

		LST_bins[j,0] = (j/3) + 1/6

		B_Ta = np.zeros((0,len(fe)))
		B_W  = np.zeros((0,len(fe)))


		#for i in range(len(GHA)):
			#if (GHA[i] >= (j - 12.5)) and (GHA[i] < (j - 11.5)):
				#Tant_temp = Tant_cal[i,:].reshape((1,len(fe)))
				#W_temp    = W[i,:].reshape((1,len(fe)))
				#B_Ta      = np.append(B_Ta, Tant_temp, axis=0)
				#B_W       = np.append(B_W,  W_temp, axis=0)


		for i in range(len(LST)):
			if (LST[i] >= (j/3)) and (LST[i] < ((j+1)/3)):
				Tant_temp = Tant_unc[i,:].reshape((1,len(fe)))
				W_temp    = W[i,:].reshape((1,len(fe)))
				B_Ta      = np.append(B_Ta, Tant_temp, axis=0)
				B_W       = np.append(B_W,  W_temp, axis=0)

				#sun_sum[j,:] = sun_sum[j,:] + sun_azel[i,:]
				#sun_acc[j,:] = sun_acc[j,:] + 1

				sun_moon_sum[j,:] = sun_moon_sum[j,:] + sun_moon_azel[i,:]
				sun_moon_acc[j,:] = sun_moon_acc[j,:] + 1

				aux_sum[j,:] = aux_sum[j,:] + aux_raw[i,:]
				aux_acc[j,:] = aux_acc[j,:] + 1

				N[j,0] = N[j,0] + 1



		# Average Sun/Moon elevation
		#if (sun_acc[j,0] > 0) and (sun_acc[j,1] > 0):
			#sun_bins[j,:] = sun_sum[j,:] / sun_acc[j,:]

		if (sun_moon_acc[j,0] > 0) and (sun_moon_acc[j,1] > 0) and (sun_moon_acc[j,2] > 0) and (sun_moon_acc[j,3] > 0):
			sun_moon_bins[j,:] = sun_moon_sum[j,:] / sun_moon_acc[j,:]


		# Average auxiliary data
		if (aux_acc[j,0] > 0) and (aux_acc[j,1] > 0) and (aux_acc[j,2] > 0) and (aux_acc[j,3] > 0):
			aux_bins[j,:] = aux_sum[j,:] / aux_acc[j,:]		



		# Computing average at each LST (avoiding division by zero)		
		sum_Ta_temp = np.sum(B_Ta * B_W, axis=0)
		sum_W_temp  = np.sum(B_W, axis=0)

		mean_temp_1D         = np.zeros(len(fe))
		sum_residual_square  = np.zeros(len(fe))
		weight_temp_1D       = np.zeros(len(fe))
		std_temp_1D          = np.zeros(len(fe))



		# Compute the trace average if there is more than one available trace in this LST bin
		if (np.max(sum_W_temp) > 1) and (np.sum(sum_W_temp) > 1000):

			for k in range(len(fe)):
				if (sum_W_temp[k] > 0):
					mean_temp_1D[k]        = sum_Ta_temp[k] / sum_W_temp[k]
					sum_residual_square[k] = np.sum( B_W[:,k] * (B_Ta[:,k] - mean_temp_1D[k])**2)
					std_temp_1D[k]         = np.sqrt( sum_residual_square[k] / sum_W_temp[k] )


			# RFI flagging after averaging
			W_temp_1D      = RFI_flagging(fe, mean_temp_1D)			
			mean_temp_1D   = mean_temp_1D * W_temp_1D
			weight_temp_1D = sum_W_temp   * W_temp_1D
			std_temp_1D    = std_temp_1D  * W_temp_1D

			status = 'FINE.'

		elif (np.max(sum_W_temp) == 1):
			status = 'ONLY ONE TRACE. DISCARDED.'

		elif (np.max(sum_W_temp) == 0):
			status = 'NO TRACES. DISCARDED.'

		print('LST: ' + str(round(j/3 + 1/6,2)) + ',  N of spectra: ' + str(np.max(sum_W_temp)) + '. Status: ' + status)  



		# Storing average
		mean_temp   = mean_temp_1D.reshape((1,len(fe)))
		weight_temp = weight_temp_1D.reshape((1,len(fe))) 
		std_temp    = std_temp_1D.reshape((1,len(fe)))

		mean_data   = np.append(mean_data,   mean_temp,   axis=0)
		weight_data = np.append(weight_data, weight_temp, axis=0)
		std_data    = np.append(std_data,    std_temp,    axis=0)








	# Galactic Hour Angle
	LST_gc = 17 + (45/60) + (40.04/(60*60))    # LST of Galactic Center
	GHA  = LST_bins - LST_gc
	for i in range(len(GHA[:,0])):
		if GHA[i,0] < -12.0:
			GHA[i,0] = GHA[i,0] + 24	



	# Data
	fe_2D          = fe.reshape((-1,1))
	mean_data_2D   = mean_data.T
	weight_data_2D = weight_data.T
	std_data_2D    = std_data.T

	data           = np.concatenate((fe_2D, mean_data_2D),   axis=1)
	weight         = np.concatenate((fe_2D, weight_data_2D), axis=1)
	std            = np.concatenate((fe_2D, std_data_2D),    axis=1)



	# Metadata
	year_bins     = year_int     * np.ones((72,1))
	day_bins      = day_int      * np.ones((72,1))
	fraction_bins = fraction_int * np.ones((72,1))
	meta = np.concatenate((year_bins, day_bins, fraction_bins, LST_bins, GHA, sun_moon_bins, aux_bins), axis=1)



	# Save
	if save == 'yes':
		np.savetxt(path_save + folder + '/' + year + '_' + day_hour + '_LST_data_'    + flag + '.txt', data,   fmt='%1.8f')
		np.savetxt(path_save + folder + '/' + year + '_' + day_hour + '_LST_weight_'  + flag + '.txt', weight, fmt='%1.8f')
		np.savetxt(path_save + folder + '/' + year + '_' + day_hour + '_LST_std_'     + flag + '.txt', std,    fmt='%1.8f')
		np.savetxt(path_save + folder + '/' + year + '_' + day_hour + '_LST_meta_'    + flag + '.txt', meta,   fmt='%1.8f')


	return data, weight, std, meta






























def SUN_azel(LAT, LON, UTC_array):
	# 
	# Local coordinates of the Sun using Astropy
	#
	# EDGES_lat_deg = -26.7
	# EDGES_lon_deg = 116.6
	#


	# Location	
	Location = apc.EarthLocation(lat=LAT*apu.deg, lon=LON*apu.deg)

	# Compute local coordinates of Sun
	SH = UTC_array.shape

	if len(SH) == 2:
		AZ_EL = np.zeros((SH[0],2))

		for i in range(SH[0]): 
			time_dt    = dt.datetime(UTC_array[i,0], UTC_array[i,1], UTC_array[i,2], UTC_array[i,3], UTC_array[i,4], UTC_array[i,5]) 
			local_time = apt.Time(time_dt, format='datetime')
			altazframe = apc.AltAz(location=Location, obstime=local_time)
			SUN_altaz  = apc.get_sun(local_time).transform_to(altazframe)

			AZ         = np.asarray(SUN_altaz.az)
			EL         = np.asarray(SUN_altaz.alt)
			AZ_EL[i,0] = AZ
			AZ_EL[i,1] = EL

			print('AZ: ' + str(AZ[0]) + ', EL: ' + str(EL[0]))		

	elif len(SH) == 1:
		AZ_EL = np.zeros(2)

		time_dt    = dt.datetime(UTC_array[0], UTC_array[1], UTC_array[2], UTC_array[3], UTC_array[4], UTC_array[5]) 
		local_time = apt.Time(time_dt, format='datetime')
		altazframe = apc.AltAz(location=Location, obstime=local_time)
		SUN_altaz  = apc.get_sun(local_time).transform_to(altazframe)

		AZ         = np.asarray(SUN_altaz.az)
		EL         = np.asarray(SUN_altaz.alt)
		AZ_EL[0] = AZ
		AZ_EL[1] = EL

		print('AZ: ' + str(AZ[0]) + ', EL: ' + str(EL[0]))			

	return AZ_EL





def SUN_MOON_azel(LAT, LON, UTC_array):
	# 
	# Local coordinates of the Sun using Astropy
	#
	# EDGES_lat_deg = -26.7
	# EDGES_lon_deg = 116.6
	#	


	# Observation coordinates
	OBS_lat_deg = str(LAT) 
	OBS_lon_deg = str(LON) 
	#print(' ')
	#print('Observation Coordinates: ' + 'LAT: ' + OBS_lat_deg + ' LON: ' + OBS_lon_deg)
	#print('------------------------')

	OBS_location     = eph.Observer()
	OBS_location.lat = OBS_lat_deg 
	OBS_location.lon = OBS_lon_deg


	# Compute local coordinates of Sun and Moon
	SH = UTC_array.shape

	if len(SH) == 1:
		coord    = np.zeros(4)

		OBS_location.date = dt.datetime(UTC_array[0], UTC_array[1], UTC_array[2], UTC_array[3], UTC_array[4], UTC_array[5])
		Sun  = eph.Sun(OBS_location)
		Moon = eph.Moon(OBS_location)

		coord[0] = (180/np.pi)*eph.degrees(Sun.az)
		coord[1] = (180/np.pi)*eph.degrees(Sun.alt)		
		coord[2] = (180/np.pi)*eph.degrees(Moon.az)
		coord[3] = (180/np.pi)*eph.degrees(Moon.alt)


		#print('Sun AZ:  ' + str(round(coord[0],2))  + '      Sun EL:  ' + str(round(coord[1],2)))
		#print('Moon AZ: ' + str(round(coord[2],2))  + '      Moon EL: ' + str(round(coord[3],2)))

	elif len(SH) == 2:
		coord    = np.zeros((SH[0],4))
		for i in range(SH[0]):
			OBS_location.date = dt.datetime(UTC_array[i,0], UTC_array[i,1], UTC_array[i,2], UTC_array[i,3], UTC_array[i,4], UTC_array[i,5])
			Sun  = eph.Sun(OBS_location)
			Moon = eph.Moon(OBS_location)

			coord[i,0] = (180/np.pi)*eph.degrees(Sun.az)
			coord[i,1] = (180/np.pi)*eph.degrees(Sun.alt)		
			coord[i,2] = (180/np.pi)*eph.degrees(Moon.az)
			coord[i,3] = (180/np.pi)*eph.degrees(Moon.alt)


			#print('Sun AZ:  ' + str(round(coord[i,0],2))  + '      Sun EL:  ' + str(round(coord[i,1],2)))
			#print('Moon AZ: ' + str(round(coord[i,2],2))  + '      Moon EL: ' + str(round(coord[i,3],2)))
			#print('-------------------------------------')

	return coord











def auxiliary_data(weather_file, thermlog_file, band, year, day):

	# scp -P 64122 loco@150.101.175.77:/media/DATA/EDGES_data/weather.txt /home/raul/Desktop/
	# scp -P 64122 loco@150.101.175.77:/media/DATA/EDGES_data/thermlog.txt /home/raul/Desktop/

	# OR

	# scp raul@enterprise.sese.asu.edu:/data1/edges/data/2014_February_Boolardy/weather.txt Desktop/
	# scp raul@enterprise.sese.asu.edu:/data1/edges/data/2014_February_Boolardy/thermlog_low.txt Desktop/
	# scp raul@enterprise.sese.asu.edu:/data1/edges/data/2014_February_Boolardy/thermlog.txt Desktop/



	# Gather data from 'weather.txt' file
	f1 = open(weather_file,'r')		
	lines_all_1 = f1.readlines()

	array1        = np.zeros((0,4))

	if year == 2015:
		i1 = 92000   # ~ day 100
	elif year == 2016:
		i1 = 165097  # start of year 2016
	elif year == 2017:
		i1 = 261356  # start of year 2017


	line1         = lines_all_1[i1]
	year_iter_1   = int(line1[0:4])
	day_of_year_1 = int(line1[5:8])

	while (day_of_year_1 <= day) and (year_iter_1 <= year):

		if day_of_year_1 == day:
			#print(line1[0:17] + ' ' + line1[59:65] + ' ' + line1[88:93] + ' ' + line1[113:119])

			date_time = line1[0:17]
			ttt = date_time.split(':')			
			seconds = 3600*int(ttt[2]) + 60*int(ttt[3]) + int(ttt[4])			

			try:
				amb_temp  = float(line1[59:65])
			except ValueError:
				amb_temp  = 0

			try:
				amb_hum   = float(line1[88:93])
			except ValueError:
				amb_hum   = 0

			try:
				rec_temp  = float(line1[113:119])
			except ValueError:
				rec_temp  = 0				


			array1_temp1 = np.array([seconds, amb_temp, amb_hum, rec_temp])
			array1_temp2 = array1_temp1.reshape((1,-1))
			array1       = np.append(array1, array1_temp2, axis=0)

			print('weather time: ' + date_time)

		i1            = i1+1
		line1         = lines_all_1[i1]
		year_iter_1   = int(line1[0:4])
		day_of_year_1 = int(line1[5:8])






	# gather data from 'thermlog.txt' file
	f2            = open(thermlog_file,'r')
	lines_all_2   = f2.readlines()

	array2        = np.zeros((0,2))

	if (band == 'high_band') and (year == 2015):
		i2 = 24000    # ~ day 108

	elif (band == 'high_band') and (year == 2016):
		i2 = 58702    # beginning of year 2016

	elif (band == 'low_band') and (year == 2015):
		i2 = 0

	elif (band == 'low_band') and (year == 2016):
		i2 = 14920    # beginning of year 2016	

	elif (band == 'low_band') and (year == 2017):
		i2 = 59352    # beginning of year 2017			

	elif (band == 'low_band2') and (year == 2017):
		i2 = 97345    # beginning of year 2017




	line2         = lines_all_2[i2]
	year_iter_2   = int(line2[0:4])
	day_of_year_2 = int(line2[5:8])

	while (day_of_year_2 <= day) and (year_iter_2 <= year):

		if day_of_year_2 == day:
			#print(line2[0:17] + ' ' + line2[48:53])

			date_time = line2[0:17]
			ttt = date_time.split(':')			
			seconds = 3600*int(ttt[2]) + 60*int(ttt[3]) + int(ttt[4])			

			try:
				rec_temp  = float(line2[48:53])
			except ValueError:
				rec_temp  = 0



			array2_temp1 = np.array([seconds, rec_temp])
			array2_temp2 = array2_temp1.reshape((1,-1))
			array2       = np.append(array2, array2_temp2, axis=0)

			print('receiver temperature time: ' + date_time)

		i2            = i2+1
		line2         = lines_all_2[i2]
		year_iter_2   = int(line2[0:4])
		day_of_year_2 = int(line2[5:8])	



	return array1, array2












def load_high_band_calibration_s11(flow=90, fhigh=190, calibration_temperature = 25):

	# Paths
	path_root       = home_folder + ''
	path_s11        = path_root + '/DATA/EDGES/calibration/receiver_calibration/high_band1/2015_03_25C/data/S11/corrected_delay/' 



	# Data at low resolution (1 MHz)
	if calibration_temperature == 25:
		s11 = np.genfromtxt(path_s11 + 'calibration_S11_25degC.txt')
	elif calibration_temperature == 35:
		s11 = np.genfromtxt(path_s11 + 'calibration_S11_35degC.txt')

	for i in range(len(s11[:,0]-1)):
		if (s11[i,0] <= flow) and (s11[i+1,0] > flow):
			index_low = i
		if (s11[i,0] <= fhigh) and (s11[i+1,0] > fhigh):
			index_high = i+1
	index_s11 = np.arange(index_low, index_high+1)


	# Data at high resolution (~ 248 KHz)
	s11_hires = np.genfromtxt(path_s11 + 'calibration_S11_high_resolution.txt')
	for i in range(len(s11_hires[:,0])-1):
		if (s11_hires[i,0] <= flow) and (s11_hires[i+1,0] > flow):
			index_low = i
		if (s11_hires[i,0] <= fhigh) and (s11_hires[i+1,0] > fhigh):
			index_high = i+1
	index_s11_hires = np.arange(index_low, index_high+1)


	# Semi-rigid cable low resolution (1 MHz)
	spar_cable = np.genfromtxt(path_s11 + 'semi_rigid_s_parameters.txt')
	for i in range(len(spar_cable[:,0])-1):
		if (spar_cable[i,0] <= flow) and (spar_cable[i+1,0] > flow):
			index_low = i
		if (spar_cable[i,0] <= fhigh) and (spar_cable[i+1,0] > fhigh):
			index_high = i+1
	index_s11 = np.arange(index_low, index_high+1)





	# Frequency and complex data
	f_s11   = s11[index_s11, 0]
	s11_LNA = s11[index_s11, 1] + 1j*s11[index_s11, 2]
	s11_amb = s11[index_s11, 3] + 1j*s11[index_s11, 4]
	s11_hot = s11[index_s11, 5] + 1j*s11[index_s11, 6]

	f_s11_hires = s11_hires[index_s11_hires, 0]
	s11_open    = s11_hires[index_s11_hires, 1] + 1j*s11_hires[index_s11_hires, 2]
	s11_shorted = s11_hires[index_s11_hires, 3] + 1j*s11_hires[index_s11_hires, 4]
	s11_simu1   = s11_hires[index_s11_hires, 5] + 1j*s11_hires[index_s11_hires, 6]
	s11_simu2   = s11_hires[index_s11_hires, 7] + 1j*s11_hires[index_s11_hires, 8]

	f_sr      = spar_cable[index_s11, 0]
	s11_sr    = spar_cable[index_s11, 1] + 1j*spar_cable[index_s11, 2]
	s12s21_sr = spar_cable[index_s11, 3] + 1j*spar_cable[index_s11, 4]
	s22_sr    = spar_cable[index_s11, 5] + 1j*spar_cable[index_s11, 6]	



	# Output arrays
	out1 = np.array([f_s11, s11_LNA, s11_amb, s11_hot])
	out2 = np.array([f_s11_hires, s11_open, s11_shorted, s11_simu1, s11_simu2])
	out3 = np.array([f_sr, s11_sr, s12s21_sr, s22_sr])



	return out1, out2, out3

















def models_calibration_s11(band, folder, calibration_temperature, fe, hb_flow=90, hb_fhigh=190, receiver_reflection='actual', MC_s11_noise=np.zeros(20), MC_s11_syst=np.zeros(20), systematic_s11='uncorrelated', plots='no', plot_flag=''):


	common_path = home_folder + '/DATA/EDGES/calibration/receiver_calibration/'



	if band == 'high_band_2015':

		if calibration_temperature == 25:
			# Paths
			path_s11        = common_path + 'high_band1/2015_03_25C/data/s11/corrected/'
			path_par_s11    = common_path + 'high_band1/2015_03_25C/results/' + folder + '/s11/'			
			path_plot_save  = common_path + 'high_band1/2015_03_25C/results/' + folder + '/plots/'

		elif calibration_temperature == 35:
			# Paths
			path_s11        = common_path + 'high_band1/2015_03_35C/data/s11/corrected/'
			path_par_s11    = common_path + 'high_band1/2015_03_35C/results/' + folder + '/s11/'			
			path_plot_save  = common_path + 'high_band1/2015_03_35C/results/' + folder + '/plots/'




		# Loading raw data
		o1, o2, o3 = load_high_band_calibration_s11(flow=hb_flow, fhigh=hb_fhigh, calibration_temperature = calibration_temperature)

		f_s11_lores     = np.real(o1[0])
		s11_LNA_raw     = o1[1]
		s11_amb_raw     = o1[2]
		s11_hot_raw     = o1[3]

		f_s11_hires     = np.real(o2[0])
		s11_open_raw    = o2[1]
		s11_shorted_raw = o2[2]
		s11_simu1_raw   = o2[3]
		s11_simu2_raw   = o2[4]

		f_sr_lores      = np.real(o3[0])
		s11_sr_raw      = o3[1]
		s12s21_sr_raw   = o3[2]
		s22_sr_raw      = o3[3]


		# Normalized frequency
		f_s11_lores_n   = (f_s11_lores-140)/60
		f_s11_hires_n   = (f_s11_hires-140)/60
		f_sr_lores_n    = (f_sr_lores-140)/60
		fen             = (fe-140)/60		







	if band == 'high_band_2017':   # The loading of this file is just for plotting purposes. The actual output of the function comes from the "calibration processing" parameters

		if calibration_temperature == 25:
			# Paths
			path_s11        = common_path + 'high_band1/2017_01_25C/data/s11/corrected/'
			path_par_s11    = common_path + 'high_band1/2017_01_25C/results/' + folder + '/s11/'			
			path_plot_save  = common_path + 'high_band1/2017_01_25C/results/' + folder + '/plots/'

		# Data 
		#calfile = 's11_calibration_high_band_LNA25degC_2017-02-08-14-23-04_LNA1a.txt'
		calfile = 's11_calibration_high_band_LNA25degC_2017-02-15-13-53-40_LNAxR01.txt'
		s11             = np.genfromtxt(path_s11 + calfile)
		print(calfile)
		fs11            = s11[:, 0]
		fs11n           = (fs11-140)/60
		fen             = (fe-140)/60

		# Loading raw data				
		s11_LNA_raw       = s11[:, 1]  + 1j*s11[:, 2]
		s11_amb_raw       = s11[:, 3]  + 1j*s11[:, 4]
		s11_hot_raw       = s11[:, 5]  + 1j*s11[:, 6]
		s11_open_raw      = s11[:, 7]  + 1j*s11[:, 8]
		s11_shorted_raw   = s11[:, 9]  + 1j*s11[:, 10]
		s11_sr_raw        = s11[:, 11] + 1j*s11[:, 12]
		s12s21_sr_raw     = s11[:, 13] + 1j*s11[:, 14]
		s22_sr_raw        = s11[:, 15] + 1j*s11[:, 16]
		s11_simu1_raw     = s11[:, 19] + 1j*s11[:, 20]   # this is actually sim2 or sim2rep2
		s11_simu2_raw     = s11[:, 19] + 1j*s11[:, 20] 

		#s11_simu2r2_raw   = s11[:, 19] + 1j*s11[:, 20]













	if band == 'low_band_2015':

		# Paths
		path_s11        = common_path + 'low_band1/2015_08_25C/data/s11/corrected/'
		path_par_s11    = common_path + 'low_band1/2015_08_25C/results/' + folder + '/s11/'			
		path_plot_save  = common_path + 'low_band1/2015_08_25C/results/' + folder + '/plots/'

		# Data
		calfile         = 's11_calibration_low_band_LNA25degC_2015-09-16-12-30-29_simulator2_long.txt'
		s11             = np.genfromtxt(path_s11 + calfile)
		print(calfile)
		fs11            = s11[:, 0]
		fs11n           = (fs11-75)/25
		fen             = (fe-75)/25

		# Loading raw data				
		s11_LNA_raw       = s11[:, 1]  + 1j*s11[:, 2]
		s11_amb_raw       = s11[:, 3]  + 1j*s11[:, 4]
		s11_hot_raw       = s11[:, 5]  + 1j*s11[:, 6]
		s11_open_raw      = s11[:, 7]  + 1j*s11[:, 8]
		s11_shorted_raw   = s11[:, 9]  + 1j*s11[:, 10]
		s11_sr_raw        = s11[:, 11] + 1j*s11[:, 12]
		s12s21_sr_raw     = s11[:, 13] + 1j*s11[:, 14]
		s22_sr_raw        = s11[:, 15] + 1j*s11[:, 16]
		s11_simu1_raw     = s11[:, 17] + 1j*s11[:, 18]
		s11_simu2_raw     = s11[:, 19] + 1j*s11[:, 20]












	if band == 'low_band_2015_2017_05':

		# Paths
		path_s11        = common_path + 'low_band1/2017_05_25C/data/s11/corrected/'
		path_par_s11    = common_path + 'low_band1/2017_05_25C/results/' + folder + '/s11/'			
		path_plot_save  = common_path + 'low_band1/2017_05_25C/results/' + folder + '/plots/'


		# Data
		#calfile         = 's11_calibration_low_band_LNA25degC_2017-05-24-02-15-40.txt'
		calfile         = 's11_calibration_low_band_LNA25degC_2017-05-26-11-42-38_second_ambient_load.txt'
		s11             = np.genfromtxt(path_s11 + calfile)
		print(calfile)
		fs11            = s11[:, 0]
		fs11n           = (fs11-75)/25
		fen             = (fe-75)/25

		# Loading raw data				
		s11_LNA_raw       = s11[:, 1]  + 1j*s11[:, 2]
		s11_amb_raw       = s11[:, 3]  + 1j*s11[:, 4]
		s11_hot_raw       = s11[:, 5]  + 1j*s11[:, 6]
		s11_open_raw      = s11[:, 7]  + 1j*s11[:, 8]
		s11_shorted_raw   = s11[:, 9]  + 1j*s11[:, 10]
		s11_sr_raw        = s11[:, 11] + 1j*s11[:, 12]
		s12s21_sr_raw     = s11[:, 13] + 1j*s11[:, 14]
		s22_sr_raw        = s11[:, 15] + 1j*s11[:, 16]
		s11_simu1_raw     = s11[:, 17] + 1j*s11[:, 18]
		s11_simu2_raw     = s11[:, 19] + 1j*s11[:, 20]





	if band == 'low_band_2015_2017_09':

		# Paths
		path_s11        = common_path + 'low_band1/2017_09_25C/data/s11/corrected/'
		path_par_s11    = common_path + 'low_band1/2017_09_25C/results/' + folder + '/s11/'			
		path_plot_save  = common_path + 'low_band1/2017_09_25C/results/' + folder + '/plots/'


		# Data
		calfile         = 's11_calibration_low_band_LNA25degC_2017-10-07-22-03-04.txt'
		s11             = np.genfromtxt(path_s11 + calfile)
		print(calfile)
		fs11            = s11[:, 0]
		fs11n           = (fs11-75)/25
		fen             = (fe-75)/25

		# Loading raw data				
		s11_LNA_raw       = s11[:, 1]  + 1j*s11[:, 2]
		s11_amb_raw       = s11[:, 3]  + 1j*s11[:, 4]
		s11_hot_raw       = s11[:, 5]  + 1j*s11[:, 6]
		s11_open_raw      = s11[:, 7]  + 1j*s11[:, 8]
		s11_shorted_raw   = s11[:, 9]  + 1j*s11[:, 10]
		s11_sr_raw        = s11[:, 11] + 1j*s11[:, 12]
		s12s21_sr_raw     = s11[:, 13] + 1j*s11[:, 14]
		s22_sr_raw        = s11[:, 15] + 1j*s11[:, 16]
		s11_simu2_raw     = s11[:, 17] + 1j*s11[:, 18]
		s11_simu1_raw     = np.copy(s11_simu2_raw)











	if band == 'low_band2_2017':



		if calibration_temperature == 25:

			# Paths
			path_s11        = common_path + 'low_band2/2016_09_25C/data/s11/corrected/'
			path_par_s11    = common_path + 'low_band2/2016_09_25C/results/' + folder + '/s11/'			
			path_plot_save  = common_path + 'low_band2/2016_09_25C/results/' + folder + '/plots/'

			# Data (both files produce same results)
			#calfile = 's11_calibration_low_band_LNA25degC_2016-10-31-13-02-58.txt'     # best
			#calfile = 's11_calibration_low_band_LNA25degC_2016-10-31-17-50-22.txt'
			calfile = 's11_calibration_low_band_LNA25degC_2017-03-02-02-53-40_S11recv2017.txt'   # latest LNA s11


		if calibration_temperature == 15:

			# Paths
			path_s11        = common_path + 'low_band2/2016_11_15C/data/s11/corrected/'
			path_par_s11    = common_path + 'low_band2/2016_11_15C/results/' + folder + '/s11/'			
			path_plot_save  = common_path + 'low_band2/2016_11_15C/results/' + folder + '/plots/'

			# Data
			#calfile = 's11_calibration_low_band_LNA15degC_2016-12-14-23-01-53.txt'
			calfile = 's11_calibration_low_band_LNA15degC_2017-03-02-05-48-33_S11recv2017.txt'



		if calibration_temperature == 35:

			# Paths
			path_s11        = common_path + 'low_band2/2016_11_35C/data/s11/corrected/'
			path_par_s11    = common_path + 'low_band2/2016_11_35C/results/' + folder + '/s11/'			
			path_plot_save  = common_path + 'low_band2/2016_11_35C/results/' + folder + '/plots/'

			# Data
			#calfile = 's11_calibration_low_band_LNA35degC_2016-12-14-23-35-37.txt'
			calfile = 's11_calibration_low_band_LNA35degC_2017-03-03-20-52-01_S11recv2017.txt'







		s11             = np.genfromtxt(path_s11 + calfile)
		print(calfile)
		fs11            = s11[:, 0]
		fs11n           = (fs11-75)/25
		fen             = (fe-75)/25

		# Loading raw data				
		s11_LNA_raw       = s11[:, 1]  + 1j*s11[:, 2]
		s11_amb_raw       = s11[:, 3]  + 1j*s11[:, 4]
		s11_hot_raw       = s11[:, 5]  + 1j*s11[:, 6]
		s11_open_raw      = s11[:, 7]  + 1j*s11[:, 8]
		s11_shorted_raw   = s11[:, 9]  + 1j*s11[:, 10]
		s11_sr_raw        = s11[:, 11] + 1j*s11[:, 12]
		s12s21_sr_raw     = s11[:, 13] + 1j*s11[:, 14]
		s22_sr_raw        = s11[:, 15] + 1j*s11[:, 16]
		s11_simu1_raw     = s11[:, 17] + 1j*s11[:, 18]
		s11_simu2_raw     = s11[:, 19] + 1j*s11[:, 20]
		#s11_simu2_raw     = s11[:, 21] + 1j*s11[:, 22]







	if band == 'mid_band_2017':

		if calibration_temperature == 25:

			# Paths
			path_s11        = common_path + 'mid_band/2017_11_15C_25C_35C/data/s11/corrected/'
			path_par_s11    = common_path + 'mid_band/2017_11_15C_25C_35C/results/' + folder + '/s11/'			
			path_plot_save  = common_path + 'mid_band/2017_11_15C_25C_35C/results/' + folder + '/plots/'

			# Data
			calfile = 's11_calibration_mid_band_LNA25degC_2017-11-22-18-38-14.txt'
			


		s11             = np.genfromtxt(path_s11 + calfile)
		print(calfile)
		fs11            = s11[:, 0]
		fs11n           = (fs11-75)/25
		fen             = (fe-75)/25

		# Loading raw data				
		s11_LNA_raw       = s11[:, 1]  + 1j*s11[:, 2]
		s11_amb_raw       = s11[:, 3]  + 1j*s11[:, 4]
		s11_hot_raw       = s11[:, 5]  + 1j*s11[:, 6]
		s11_open_raw      = s11[:, 7]  + 1j*s11[:, 8]
		s11_shorted_raw   = s11[:, 9]  + 1j*s11[:, 10]
		s11_sr_raw        = s11[:, 11] + 1j*s11[:, 12]
		s12s21_sr_raw     = s11[:, 13] + 1j*s11[:, 14]
		s22_sr_raw        = s11[:, 15] + 1j*s11[:, 16]
		s11_simu2_raw     = s11[:, 17] + 1j*s11[:, 18]
		s11_simu1_raw     = np.copy(s11_simu2_raw)
		#s11_simu2_raw     = s11[:, 19] + 1j*s11[:, 20]









	# LNA
	s11_LNA_mag_raw     = np.abs(s11_LNA_raw)
	s11_LNA_ang_raw     = np.unwrap(np.angle(s11_LNA_raw))

	# Ambient
	s11_amb_mag_raw     = np.abs(s11_amb_raw)
	s11_amb_ang_raw     = np.unwrap(np.angle(s11_amb_raw))

	# Hot
	s11_hot_mag_raw     = np.abs(s11_hot_raw)
	s11_hot_ang_raw     = np.unwrap(np.angle(s11_hot_raw))

	# Open
	s11_open_mag_raw    = np.abs(s11_open_raw)
	s11_open_ang_raw    = np.unwrap(np.angle(s11_open_raw))

	# Shorted
	s11_shorted_mag_raw = np.abs(s11_shorted_raw)
	s11_shorted_ang_raw = np.unwrap(np.angle(s11_shorted_raw))

	# sr-s11
	s11_sr_mag_raw      = np.abs(s11_sr_raw)
	s11_sr_ang_raw      = np.unwrap(np.angle(s11_sr_raw))

	# sr-s12s21
	s12s21_sr_mag_raw   = np.abs(s12s21_sr_raw)
	s12s21_sr_ang_raw   = np.unwrap(np.angle(s12s21_sr_raw))

	# sr-s22
	s22_sr_mag_raw      = np.abs(s22_sr_raw)
	s22_sr_ang_raw      = np.unwrap(np.angle(s22_sr_raw))

	# Simu1
	s11_simu1_mag_raw   = np.abs(s11_simu1_raw)
	s11_simu1_ang_raw   = np.unwrap(np.angle(s11_simu1_raw))

	# Simu2
	s11_simu2_mag_raw   = np.abs(s11_simu2_raw)
	s11_simu2_ang_raw   = np.unwrap(np.angle(s11_simu2_raw))		




	# Loading S11 parameters
	par_s11_LNA_mag     = np.genfromtxt(path_par_s11 + 'par_s11_LNA_mag.txt')
	par_s11_LNA_ang     = np.genfromtxt(path_par_s11 + 'par_s11_LNA_ang.txt')	
	par_s11_amb_mag     = np.genfromtxt(path_par_s11 + 'par_s11_amb_mag.txt')
	par_s11_amb_ang     = np.genfromtxt(path_par_s11 + 'par_s11_amb_ang.txt')
	par_s11_hot_mag     = np.genfromtxt(path_par_s11 + 'par_s11_hot_mag.txt')
	par_s11_hot_ang     = np.genfromtxt(path_par_s11 + 'par_s11_hot_ang.txt')
	par_s11_open_mag    = np.genfromtxt(path_par_s11 + 'par_s11_open_mag.txt')
	par_s11_open_ang    = np.genfromtxt(path_par_s11 + 'par_s11_open_ang.txt')
	par_s11_shorted_mag = np.genfromtxt(path_par_s11 + 'par_s11_shorted_mag.txt')
	par_s11_shorted_ang = np.genfromtxt(path_par_s11 + 'par_s11_shorted_ang.txt')

	par_s11_sr_mag      = np.genfromtxt(path_par_s11 + 'par_s11_sr_mag.txt')
	par_s11_sr_ang      = np.genfromtxt(path_par_s11 + 'par_s11_sr_ang.txt')
	par_s12s21_sr_mag   = np.genfromtxt(path_par_s11 + 'par_s12s21_sr_mag.txt')
	par_s12s21_sr_ang   = np.genfromtxt(path_par_s11 + 'par_s12s21_sr_ang.txt')
	par_s22_sr_mag      = np.genfromtxt(path_par_s11 + 'par_s22_sr_mag.txt')
	par_s22_sr_ang      = np.genfromtxt(path_par_s11 + 'par_s22_sr_ang.txt')

	par_s11_simu1_mag   = np.genfromtxt(path_par_s11 + 'par_s11_simu1_mag.txt')
	par_s11_simu1_ang   = np.genfromtxt(path_par_s11 + 'par_s11_simu1_ang.txt')
	par_s11_simu2_mag   = np.genfromtxt(path_par_s11 + 'par_s11_simu2_mag.txt')
	par_s11_simu2_ang   = np.genfromtxt(path_par_s11 + 'par_s11_simu2_ang.txt')

	#par_s11_simu2_mag   = np.genfromtxt(path_par_s11 + 'par_s11_simu2r2_mag.txt')
	#par_s11_simu2_ang   = np.genfromtxt(path_par_s11 + 'par_s11_simu2r2_ang.txt')	



	# Load noise RMS
	RMS_s11             = np.genfromtxt(path_par_s11 + 'RMS_s11.txt')
	RMS_s11_LNA_mag     = RMS_s11[0]
	RMS_s11_LNA_ang     = RMS_s11[1]
	RMS_s11_amb_mag     = RMS_s11[2]
	RMS_s11_amb_ang     = RMS_s11[3]
	RMS_s11_hot_mag     = RMS_s11[4]
	RMS_s11_hot_ang     = RMS_s11[5]
	RMS_s11_open_mag    = RMS_s11[6]
	RMS_s11_open_ang    = RMS_s11[7]
	RMS_s11_shorted_mag = RMS_s11[8]
	RMS_s11_shorted_ang = RMS_s11[9]
	RMS_s11_sr_mag      = RMS_s11[10]
	RMS_s11_sr_ang      = RMS_s11[11]
	RMS_s12s21_sr_mag   = RMS_s11[12]
	RMS_s12s21_sr_ang   = RMS_s11[13]
	RMS_s22_sr_mag      = RMS_s11[14]
	RMS_s22_sr_ang      = RMS_s11[15]
	RMS_s11_simu1_mag   = RMS_s11[16]
	RMS_s11_simu1_ang   = RMS_s11[17]
	RMS_s11_simu2_mag   = RMS_s11[18]
	RMS_s11_simu2_ang   = RMS_s11[19]		








	if band == 'high_band_2015':

		# Evaluating S11 models at raw frequency
		s11_LNA_mag_raw_model     = model_evaluate('fourier',    par_s11_LNA_mag,     f_s11_lores_n)
		s11_LNA_ang_raw_model     = model_evaluate('fourier',    par_s11_LNA_ang,     f_s11_lores_n)

		s11_amb_mag_raw_model     = model_evaluate('fourier',    par_s11_amb_mag,     f_s11_lores_n)
		s11_amb_ang_raw_model     = model_evaluate('fourier',    par_s11_amb_ang,     f_s11_lores_n)
		s11_hot_mag_raw_model     = model_evaluate('fourier',    par_s11_hot_mag,     f_s11_lores_n)
		s11_hot_ang_raw_model     = model_evaluate('fourier',    par_s11_hot_ang,     f_s11_lores_n)

		s11_open_mag_raw_model    = model_evaluate('fourier',    par_s11_open_mag,    f_s11_hires_n)
		s11_open_ang_raw_model    = model_evaluate('fourier',    par_s11_open_ang,    f_s11_hires_n)
		s11_shorted_mag_raw_model = model_evaluate('fourier',    par_s11_shorted_mag, f_s11_hires_n)
		s11_shorted_ang_raw_model = model_evaluate('fourier',    par_s11_shorted_ang, f_s11_hires_n)

		s11_sr_mag_raw_model      = model_evaluate('polynomial', par_s11_sr_mag,      f_sr_lores_n)
		s11_sr_ang_raw_model      = model_evaluate('polynomial', par_s11_sr_ang,      f_sr_lores_n)
		s12s21_sr_mag_raw_model   = model_evaluate('polynomial', par_s12s21_sr_mag,   f_sr_lores_n)
		s12s21_sr_ang_raw_model   = model_evaluate('polynomial', par_s12s21_sr_ang,   f_sr_lores_n)	
		s22_sr_mag_raw_model      = model_evaluate('polynomial', par_s22_sr_mag,      f_sr_lores_n)
		s22_sr_ang_raw_model      = model_evaluate('polynomial', par_s22_sr_ang,      f_sr_lores_n)		

		s11_simu1_mag_raw_model   = model_evaluate('fourier',    par_s11_simu1_mag,   f_s11_hires_n)     # for low-band the simulators are modeled with polynomials
		s11_simu1_ang_raw_model   = model_evaluate('fourier',    par_s11_simu1_ang,   f_s11_hires_n)
		s11_simu2_mag_raw_model   = model_evaluate('fourier',    par_s11_simu2_mag,   f_s11_hires_n)
		s11_simu2_ang_raw_model   = model_evaluate('fourier',    par_s11_simu2_ang,   f_s11_hires_n)




		# Evaluating S11 models at EDGES frequency

		# Magnitude of LNA S11
		if receiver_reflection == 'actual':
			s11_LNA_mag     = model_evaluate('fourier',    par_s11_LNA_mag,     fen)
		if receiver_reflection == 'minus30dB':
			s11_LNA_mag = 10**(-30/20) * np.ones(len(fen))

		s11_LNA_ang     = model_evaluate('fourier',    par_s11_LNA_ang,     fen)	                                                                  


		s11_amb_mag     = model_evaluate('fourier',    par_s11_amb_mag,     fen)
		s11_amb_ang     = model_evaluate('fourier',    par_s11_amb_ang,     fen)
		s11_hot_mag     = model_evaluate('fourier',    par_s11_hot_mag,     fen)
		s11_hot_ang     = model_evaluate('fourier',    par_s11_hot_ang,     fen)

		s11_open_mag    = model_evaluate('fourier',    par_s11_open_mag,    fen)
		s11_open_ang    = model_evaluate('fourier',    par_s11_open_ang,    fen)
		s11_shorted_mag = model_evaluate('fourier',    par_s11_shorted_mag, fen)
		s11_shorted_ang = model_evaluate('fourier',    par_s11_shorted_ang, fen)

		s11_sr_mag      = model_evaluate('polynomial', par_s11_sr_mag,      fen)
		s11_sr_ang      = model_evaluate('polynomial', par_s11_sr_ang,      fen)
		s12s21_sr_mag   = model_evaluate('polynomial', par_s12s21_sr_mag,   fen)
		s12s21_sr_ang   = model_evaluate('polynomial', par_s12s21_sr_ang,   fen)	
		s22_sr_mag      = model_evaluate('polynomial', par_s22_sr_mag,      fen)
		s22_sr_ang      = model_evaluate('polynomial', par_s22_sr_ang,      fen)	

		s11_simu1_mag   = model_evaluate('fourier',    par_s11_simu1_mag,   fen)     # for low-band the simulators are modeled with polynomials
		s11_simu1_ang   = model_evaluate('fourier',    par_s11_simu1_ang,   fen)
		s11_simu2_mag   = model_evaluate('fourier',    par_s11_simu2_mag,   fen)
		s11_simu2_ang   = model_evaluate('fourier',    par_s11_simu2_ang,   fen)









	if band == 'high_band_2017':

		# Evaluating S11 models at raw frequency
		s11_LNA_mag_raw_model     = model_evaluate('fourier',    par_s11_LNA_mag,     fs11n)
		s11_LNA_ang_raw_model     = model_evaluate('fourier',    par_s11_LNA_ang,     fs11n)

		s11_amb_mag_raw_model     = model_evaluate('fourier',    par_s11_amb_mag,     fs11n)
		s11_amb_ang_raw_model     = model_evaluate('fourier',    par_s11_amb_ang,     fs11n)
		s11_hot_mag_raw_model     = model_evaluate('fourier',    par_s11_hot_mag,     fs11n)
		s11_hot_ang_raw_model     = model_evaluate('fourier',    par_s11_hot_ang,     fs11n)

		s11_open_mag_raw_model    = model_evaluate('fourier',    par_s11_open_mag,    fs11n)
		s11_open_ang_raw_model    = model_evaluate('fourier',    par_s11_open_ang,    fs11n)
		s11_shorted_mag_raw_model = model_evaluate('fourier',    par_s11_shorted_mag, fs11n)
		s11_shorted_ang_raw_model = model_evaluate('fourier',    par_s11_shorted_ang, fs11n)

		s11_sr_mag_raw_model      = model_evaluate('polynomial', par_s11_sr_mag,      fs11n)
		s11_sr_ang_raw_model      = model_evaluate('polynomial', par_s11_sr_ang,      fs11n)
		s12s21_sr_mag_raw_model   = model_evaluate('polynomial', par_s12s21_sr_mag,   fs11n)
		s12s21_sr_ang_raw_model   = model_evaluate('polynomial', par_s12s21_sr_ang,   fs11n)	
		s22_sr_mag_raw_model      = model_evaluate('polynomial', par_s22_sr_mag,      fs11n)
		s22_sr_ang_raw_model      = model_evaluate('polynomial', par_s22_sr_ang,      fs11n)		

		s11_simu1_mag_raw_model   = model_evaluate('fourier',    par_s11_simu1_mag,   fs11n)  # they are both sim2 
		s11_simu1_ang_raw_model   = model_evaluate('fourier',    par_s11_simu1_ang,   fs11n) 
		s11_simu2_mag_raw_model   = model_evaluate('fourier',    par_s11_simu2_mag,   fs11n)
		s11_simu2_ang_raw_model   = model_evaluate('fourier',    par_s11_simu2_ang,   fs11n)




		# Evaluating S11 models at EDGES frequency

		# Magnitude of LNA S11
		if receiver_reflection == 'actual':
			s11_LNA_mag     = model_evaluate('fourier',    par_s11_LNA_mag,     fen)
		if receiver_reflection == 'minus30dB':
			s11_LNA_mag = 10**(-30/20) * np.ones(len(fen))

		s11_LNA_ang     = model_evaluate('fourier',    par_s11_LNA_ang,     fen)	                                                                  


		s11_amb_mag     = model_evaluate('fourier',    par_s11_amb_mag,     fen)
		s11_amb_ang     = model_evaluate('fourier',    par_s11_amb_ang,     fen)
		s11_hot_mag     = model_evaluate('fourier',    par_s11_hot_mag,     fen)
		s11_hot_ang     = model_evaluate('fourier',    par_s11_hot_ang,     fen)

		s11_open_mag    = model_evaluate('fourier',    par_s11_open_mag,    fen)
		s11_open_ang    = model_evaluate('fourier',    par_s11_open_ang,    fen)
		s11_shorted_mag = model_evaluate('fourier',    par_s11_shorted_mag, fen)
		s11_shorted_ang = model_evaluate('fourier',    par_s11_shorted_ang, fen)

		s11_sr_mag      = model_evaluate('polynomial', par_s11_sr_mag,      fen)
		s11_sr_ang      = model_evaluate('polynomial', par_s11_sr_ang,      fen)
		s12s21_sr_mag   = model_evaluate('polynomial', par_s12s21_sr_mag,   fen)
		s12s21_sr_ang   = model_evaluate('polynomial', par_s12s21_sr_ang,   fen)	
		s22_sr_mag      = model_evaluate('polynomial', par_s22_sr_mag,      fen)
		s22_sr_ang      = model_evaluate('polynomial', par_s22_sr_ang,      fen)	

		s11_simu1_mag   = model_evaluate('fourier',    par_s11_simu1_mag,   fen)     # for low-band the simulators are modeled with polynomials
		s11_simu1_ang   = model_evaluate('fourier',    par_s11_simu1_ang,   fen)
		s11_simu2_mag   = model_evaluate('fourier',    par_s11_simu2_mag,   fen)
		s11_simu2_ang   = model_evaluate('fourier',    par_s11_simu2_ang,   fen)















	if (band == 'low_band_2015') or (band == 'low_band2_2017'):

		# Evaluating S11 models at raw frequency
		s11_LNA_mag_raw_model     = model_evaluate('polynomial', par_s11_LNA_mag,     fs11n)
		s11_LNA_ang_raw_model     = model_evaluate('polynomial', par_s11_LNA_ang,     fs11n)

		s11_amb_mag_raw_model     = model_evaluate('fourier',    par_s11_amb_mag,     fs11n)
		s11_amb_ang_raw_model     = model_evaluate('fourier',    par_s11_amb_ang,     fs11n)
		s11_hot_mag_raw_model     = model_evaluate('fourier',    par_s11_hot_mag,     fs11n)
		s11_hot_ang_raw_model     = model_evaluate('fourier',    par_s11_hot_ang,     fs11n)

		s11_open_mag_raw_model    = model_evaluate('fourier',    par_s11_open_mag,    fs11n)
		s11_open_ang_raw_model    = model_evaluate('fourier',    par_s11_open_ang,    fs11n)
		s11_shorted_mag_raw_model = model_evaluate('fourier',    par_s11_shorted_mag, fs11n)
		s11_shorted_ang_raw_model = model_evaluate('fourier',    par_s11_shorted_ang, fs11n)

		s11_sr_mag_raw_model      = model_evaluate('polynomial', par_s11_sr_mag,      fs11n)
		s11_sr_ang_raw_model      = model_evaluate('polynomial', par_s11_sr_ang,      fs11n)
		s12s21_sr_mag_raw_model   = model_evaluate('polynomial', par_s12s21_sr_mag,   fs11n)
		s12s21_sr_ang_raw_model   = model_evaluate('polynomial', par_s12s21_sr_ang,   fs11n)
		s22_sr_mag_raw_model      = model_evaluate('polynomial', par_s22_sr_mag,      fs11n)
		s22_sr_ang_raw_model      = model_evaluate('polynomial', par_s22_sr_ang,      fs11n)

		s11_simu1_mag_raw_model   = model_evaluate('polynomial', par_s11_simu1_mag,   fs11n)
		s11_simu1_ang_raw_model   = model_evaluate('polynomial', par_s11_simu1_ang,   fs11n)
		s11_simu2_mag_raw_model   = model_evaluate('polynomial', par_s11_simu2_mag,   fs11n)
		s11_simu2_ang_raw_model   = model_evaluate('polynomial', par_s11_simu2_ang,   fs11n)	


		# Evaluating S11 models at EDGES frequency
		s11_LNA_mag     = model_evaluate('polynomial', par_s11_LNA_mag,     fen)
		s11_LNA_ang     = model_evaluate('polynomial', par_s11_LNA_ang,     fen)

		s11_amb_mag     = model_evaluate('fourier', par_s11_amb_mag,     fen)
		s11_amb_ang     = model_evaluate('fourier', par_s11_amb_ang,     fen)
		s11_hot_mag     = model_evaluate('fourier', par_s11_hot_mag,     fen)
		s11_hot_ang     = model_evaluate('fourier', par_s11_hot_ang,     fen)

		s11_open_mag    = model_evaluate('fourier',    par_s11_open_mag,    fen)
		s11_open_ang    = model_evaluate('fourier',    par_s11_open_ang,    fen)
		s11_shorted_mag = model_evaluate('fourier',    par_s11_shorted_mag, fen)
		s11_shorted_ang = model_evaluate('fourier',    par_s11_shorted_ang, fen)

		s11_sr_mag      = model_evaluate('polynomial', par_s11_sr_mag,      fen)
		s11_sr_ang      = model_evaluate('polynomial', par_s11_sr_ang,      fen)
		s12s21_sr_mag   = model_evaluate('polynomial', par_s12s21_sr_mag,   fen)
		s12s21_sr_ang   = model_evaluate('polynomial', par_s12s21_sr_ang,   fen)	
		s22_sr_mag      = model_evaluate('polynomial', par_s22_sr_mag,      fen)
		s22_sr_ang      = model_evaluate('polynomial', par_s22_sr_ang,      fen)	

		s11_simu1_mag   = model_evaluate('polynomial', par_s11_simu1_mag,   fen)
		s11_simu1_ang   = model_evaluate('polynomial', par_s11_simu1_ang,   fen)
		s11_simu2_mag   = model_evaluate('polynomial', par_s11_simu2_mag,   fen)
		s11_simu2_ang   = model_evaluate('polynomial', par_s11_simu2_ang,   fen)






	if (band == 'low_band_2015_2017_05') or (band == 'low_band_2015_2017_09'):

		# Evaluating S11 models at raw frequency
		s11_LNA_mag_raw_model     = model_evaluate('polynomial', par_s11_LNA_mag,     fs11n)
		s11_LNA_ang_raw_model     = model_evaluate('polynomial', par_s11_LNA_ang,     fs11n)

		s11_amb_mag_raw_model     = model_evaluate('fourier',    par_s11_amb_mag,     fs11n)
		s11_amb_ang_raw_model     = model_evaluate('fourier',    par_s11_amb_ang,     fs11n)
		s11_hot_mag_raw_model     = model_evaluate('fourier',    par_s11_hot_mag,     fs11n)
		s11_hot_ang_raw_model     = model_evaluate('fourier',    par_s11_hot_ang,     fs11n)

		s11_open_mag_raw_model    = model_evaluate('fourier',    par_s11_open_mag,    fs11n)
		s11_open_ang_raw_model    = model_evaluate('fourier',    par_s11_open_ang,    fs11n)
		s11_shorted_mag_raw_model = model_evaluate('fourier',    par_s11_shorted_mag, fs11n)
		s11_shorted_ang_raw_model = model_evaluate('fourier',    par_s11_shorted_ang, fs11n)

		s11_sr_mag_raw_model      = model_evaluate('polynomial', par_s11_sr_mag,      fs11n)
		s11_sr_ang_raw_model      = model_evaluate('polynomial', par_s11_sr_ang,      fs11n)
		s12s21_sr_mag_raw_model   = model_evaluate('polynomial', par_s12s21_sr_mag,   fs11n)
		s12s21_sr_ang_raw_model   = model_evaluate('polynomial', par_s12s21_sr_ang,   fs11n)
		s22_sr_mag_raw_model      = model_evaluate('polynomial', par_s22_sr_mag,      fs11n)
		s22_sr_ang_raw_model      = model_evaluate('polynomial', par_s22_sr_ang,      fs11n)

		s11_simu1_mag_raw_model   = model_evaluate('fourier', par_s11_simu1_mag,   fs11n)
		s11_simu1_ang_raw_model   = model_evaluate('fourier', par_s11_simu1_ang,   fs11n)
		s11_simu2_mag_raw_model   = model_evaluate('fourier', par_s11_simu2_mag,   fs11n)
		s11_simu2_ang_raw_model   = model_evaluate('fourier', par_s11_simu2_ang,   fs11n)



		# Evaluating S11 models at EDGES frequency
		s11_LNA_mag     = model_evaluate('polynomial', par_s11_LNA_mag,     fen)
		s11_LNA_ang     = model_evaluate('polynomial', par_s11_LNA_ang,     fen)

		s11_amb_mag     = model_evaluate('fourier',    par_s11_amb_mag,     fen)
		s11_amb_ang     = model_evaluate('fourier',    par_s11_amb_ang,     fen)
		s11_hot_mag     = model_evaluate('fourier',    par_s11_hot_mag,     fen)
		s11_hot_ang     = model_evaluate('fourier',    par_s11_hot_ang,     fen)

		s11_open_mag    = model_evaluate('fourier',    par_s11_open_mag,    fen)
		s11_open_ang    = model_evaluate('fourier',    par_s11_open_ang,    fen)
		s11_shorted_mag = model_evaluate('fourier',    par_s11_shorted_mag, fen)
		s11_shorted_ang = model_evaluate('fourier',    par_s11_shorted_ang, fen)

		s11_sr_mag      = model_evaluate('polynomial', par_s11_sr_mag,      fen)
		s11_sr_ang      = model_evaluate('polynomial', par_s11_sr_ang,      fen)
		s12s21_sr_mag   = model_evaluate('polynomial', par_s12s21_sr_mag,   fen)
		s12s21_sr_ang   = model_evaluate('polynomial', par_s12s21_sr_ang,   fen)	
		s22_sr_mag      = model_evaluate('polynomial', par_s22_sr_mag,      fen)
		s22_sr_ang      = model_evaluate('polynomial', par_s22_sr_ang,      fen)	

		s11_simu1_mag   = model_evaluate('fourier', par_s11_simu1_mag,   fen)
		s11_simu1_ang   = model_evaluate('fourier', par_s11_simu1_ang,   fen)
		s11_simu2_mag   = model_evaluate('fourier', par_s11_simu2_mag,   fen)
		s11_simu2_ang   = model_evaluate('fourier', par_s11_simu2_ang,   fen)





	
	if band == 'mid_band_2017':

		# Evaluating S11 models at raw frequency
		s11_LNA_mag_raw_model     = model_evaluate('fourier',    par_s11_LNA_mag,     fs11n)
		s11_LNA_ang_raw_model     = model_evaluate('fourier',    par_s11_LNA_ang,     fs11n)

		s11_amb_mag_raw_model     = model_evaluate('fourier',    par_s11_amb_mag,     fs11n)
		s11_amb_ang_raw_model     = model_evaluate('fourier',    par_s11_amb_ang,     fs11n)
		s11_hot_mag_raw_model     = model_evaluate('fourier',    par_s11_hot_mag,     fs11n)
		s11_hot_ang_raw_model     = model_evaluate('fourier',    par_s11_hot_ang,     fs11n)

		s11_open_mag_raw_model    = model_evaluate('fourier',    par_s11_open_mag,    fs11n)
		s11_open_ang_raw_model    = model_evaluate('fourier',    par_s11_open_ang,    fs11n)
		s11_shorted_mag_raw_model = model_evaluate('fourier',    par_s11_shorted_mag, fs11n)
		s11_shorted_ang_raw_model = model_evaluate('fourier',    par_s11_shorted_ang, fs11n)

		s11_sr_mag_raw_model      = model_evaluate('polynomial', par_s11_sr_mag,      fs11n)
		s11_sr_ang_raw_model      = model_evaluate('polynomial', par_s11_sr_ang,      fs11n)
		s12s21_sr_mag_raw_model   = model_evaluate('polynomial', par_s12s21_sr_mag,   fs11n)
		s12s21_sr_ang_raw_model   = model_evaluate('polynomial', par_s12s21_sr_ang,   fs11n)	
		s22_sr_mag_raw_model      = model_evaluate('polynomial', par_s22_sr_mag,      fs11n)
		s22_sr_ang_raw_model      = model_evaluate('polynomial', par_s22_sr_ang,      fs11n)		

		s11_simu1_mag_raw_model   = model_evaluate('fourier',    par_s11_simu1_mag,   fs11n)  # they are both sim2 
		s11_simu1_ang_raw_model   = model_evaluate('fourier',    par_s11_simu1_ang,   fs11n) 
		s11_simu2_mag_raw_model   = model_evaluate('fourier',    par_s11_simu2_mag,   fs11n)
		s11_simu2_ang_raw_model   = model_evaluate('fourier',    par_s11_simu2_ang,   fs11n)




		# Evaluating S11 models at EDGES frequency
		s11_LNA_mag     = model_evaluate('fourier',    par_s11_LNA_mag,     fen)
		s11_LNA_ang     = model_evaluate('fourier',    par_s11_LNA_ang,     fen)

		s11_amb_mag     = model_evaluate('fourier',    par_s11_amb_mag,     fen)
		s11_amb_ang     = model_evaluate('fourier',    par_s11_amb_ang,     fen)
		s11_hot_mag     = model_evaluate('fourier',    par_s11_hot_mag,     fen)
		s11_hot_ang     = model_evaluate('fourier',    par_s11_hot_ang,     fen)

		s11_open_mag    = model_evaluate('fourier',    par_s11_open_mag,    fen)
		s11_open_ang    = model_evaluate('fourier',    par_s11_open_ang,    fen)
		s11_shorted_mag = model_evaluate('fourier',    par_s11_shorted_mag, fen)
		s11_shorted_ang = model_evaluate('fourier',    par_s11_shorted_ang, fen)

		s11_sr_mag      = model_evaluate('polynomial', par_s11_sr_mag,      fen)
		s11_sr_ang      = model_evaluate('polynomial', par_s11_sr_ang,      fen)
		s12s21_sr_mag   = model_evaluate('polynomial', par_s12s21_sr_mag,   fen)
		s12s21_sr_ang   = model_evaluate('polynomial', par_s12s21_sr_ang,   fen)	
		s22_sr_mag      = model_evaluate('polynomial', par_s22_sr_mag,      fen)
		s22_sr_ang      = model_evaluate('polynomial', par_s22_sr_ang,      fen)	

		s11_simu1_mag   = model_evaluate('fourier',    par_s11_simu1_mag,   fen)   # they are both sim2 
		s11_simu1_ang   = model_evaluate('fourier',    par_s11_simu1_ang,   fen)
		s11_simu2_mag   = model_evaluate('fourier',    par_s11_simu2_mag,   fen)
		s11_simu2_ang   = model_evaluate('fourier',    par_s11_simu2_ang,   fen)










	# Adding noise
	if MC_s11_noise[0] > 0: 
		noise        = MC_s11_noise[0] * RMS_s11_LNA_mag * np.random.normal(np.zeros(len(fen)), np.ones(len(fen)))
		s11_LNA_mag  = s11_LNA_mag + noise

	if MC_s11_noise[1] > 0: 
		noise        = MC_s11_noise[1] * RMS_s11_LNA_ang * np.random.normal(np.zeros(len(fen)), np.ones(len(fen)))
		s11_LNA_ang  = s11_LNA_ang + noise

	if MC_s11_noise[2] > 0: 
		noise        = MC_s11_noise[2] * RMS_s11_amb_mag * np.random.normal(np.zeros(len(fen)), np.ones(len(fen)))
		s11_amb_mag  = s11_amb_mag + noise		

	if MC_s11_noise[3] > 0: 
		noise        = MC_s11_noise[3] * RMS_s11_amb_ang * np.random.normal(np.zeros(len(fen)), np.ones(len(fen)))
		s11_amb_ang  = s11_amb_ang + noise

	if MC_s11_noise[4] > 0: 
		noise        = MC_s11_noise[4] * RMS_s11_hot_mag * np.random.normal(np.zeros(len(fen)), np.ones(len(fen)))
		s11_hot_mag  = s11_hot_mag + noise		

	if MC_s11_noise[5] > 0: 
		noise        = MC_s11_noise[5] * RMS_s11_hot_ang * np.random.normal(np.zeros(len(fen)), np.ones(len(fen)))
		s11_hot_ang  = s11_hot_ang + noise

	if MC_s11_noise[6] > 0: 
		noise        = MC_s11_noise[6] * RMS_s11_open_mag * np.random.normal(np.zeros(len(fen)), np.ones(len(fen)))
		s11_open_mag  = s11_open_mag + noise		

	if MC_s11_noise[7] > 0: 
		noise        = MC_s11_noise[7] * RMS_s11_open_ang * np.random.normal(np.zeros(len(fen)), np.ones(len(fen)))
		s11_open_ang  = s11_open_ang + noise

	if MC_s11_noise[8] > 0: 
		noise        = MC_s11_noise[8] * RMS_s11_shorted_mag * np.random.normal(np.zeros(len(fen)), np.ones(len(fen)))
		s11_shorted_mag  = s11_shorted_mag + noise		

	if MC_s11_noise[9] > 0: 
		noise        = MC_s11_noise[9] * RMS_s11_shorted_ang * np.random.normal(np.zeros(len(fen)), np.ones(len(fen)))
		s11_shorted_ang  = s11_shorted_ang + noise

	if MC_s11_noise[10] > 0: 
		noise        = MC_s11_noise[10] * RMS_s11_sr_mag * np.random.normal(np.zeros(len(fen)), np.ones(len(fen)))
		s11_sr_mag   = s11_sr_mag + noise		

	if MC_s11_noise[11] > 0: 
		noise        = MC_s11_noise[11] * RMS_s11_sr_ang * np.random.normal(np.zeros(len(fen)), np.ones(len(fen)))
		s11_sr_ang   = s11_sr_ang + noise		

	if MC_s11_noise[12] > 0: 
		noise         = MC_s11_noise[12] * RMS_s12s21_sr_mag * np.random.normal(np.zeros(len(fen)), np.ones(len(fen)))
		s12s21_sr_mag = s12s21_sr_mag + noise		

	if MC_s11_noise[13] > 0: 
		noise         = MC_s11_noise[13] * RMS_s12s21_sr_ang * np.random.normal(np.zeros(len(fen)), np.ones(len(fen)))
		s12s21_sr_ang = s12s21_sr_ang + noise

	if MC_s11_noise[14] > 0: 
		noise        = MC_s11_noise[14] * RMS_s22_sr_mag * np.random.normal(np.zeros(len(fen)), np.ones(len(fen)))
		s22_sr_mag   = s22_sr_mag + noise		

	if MC_s11_noise[15] > 0: 
		noise        = MC_s11_noise[15] * RMS_s22_sr_ang * np.random.normal(np.zeros(len(fen)), np.ones(len(fen)))
		s22_sr_ang   = s22_sr_ang + noise

	if MC_s11_noise[16] > 0: 
		noise         = MC_s11_noise[16] * RMS_s11_simu1_mag * np.random.normal(np.zeros(len(fen)), np.ones(len(fen)))
		s11_simu1_mag = s11_simu1_mag + noise		

	if MC_s11_noise[17] > 0: 
		noise         = MC_s11_noise[17] * RMS_s11_simu1_ang * np.random.normal(np.zeros(len(fen)), np.ones(len(fen)))
		s11_simu1_ang = s11_simu1_ang + noise

	if MC_s11_noise[18] > 0: 
		noise         = MC_s11_noise[18] * RMS_s11_simu2_mag * np.random.normal(np.zeros(len(fen)), np.ones(len(fen)))
		s11_simu2_mag = s11_simu2_mag + noise		

	if MC_s11_noise[19] > 0: 
		noise         = MC_s11_noise[19] * RMS_s11_simu2_ang * np.random.normal(np.zeros(len(fen)), np.ones(len(fen)))
		s11_simu2_ang = s11_simu2_ang + noise








	# Systematic S11

	# Standard deviation of flat errors in frequency
	sigma_mag         = np.abs( 10**(-15.005/20) - 10**(-15/20) )
	sigma_mag_s21     = np.abs( 10**(-0/20) - 10**(-0.001/20) )
	sigma_phase_1mag  = 0.015 # deg at mag=1, which produces 6\sigma = 0.5deg at -15 dB


	if systematic_s11 == 'correlated':

		# flat errors in frequency
		error_mag      = np.random.normal(0, sigma_mag)
		norm_error_ang = np.random.normal(0, 1)



		if MC_s11_syst[0] > 0:
			s11_LNA_mag        = s11_LNA_mag       +   MC_s11_syst[0] * error_mag

		if MC_s11_syst[1] > 0:
			s11_LNA_ang        = s11_LNA_ang       +   MC_s11_syst[1] * norm_error_ang * (np.pi/180) * (sigma_phase_1mag/s11_LNA_mag)				

		if MC_s11_syst[2] > 0:
			s11_amb_mag        = s11_amb_mag       +   MC_s11_syst[2] * error_mag

		if MC_s11_syst[3] > 0:
			s11_amb_ang        = s11_amb_ang       +   MC_s11_syst[3] * norm_error_ang * (np.pi/180) * (sigma_phase_1mag/s11_amb_mag)				

		if MC_s11_syst[4] > 0:
			s11_hot_mag        = s11_hot_mag       +   MC_s11_syst[4] * error_mag

		if MC_s11_syst[5] > 0:
			s11_hot_ang        = s11_hot_ang       +   MC_s11_syst[5] * norm_error_ang * (np.pi/180) * (sigma_phase_1mag/s11_hot_mag)				

		if MC_s11_syst[6] > 0:
			s11_open_mag       = s11_open_mag      +   MC_s11_syst[6] * error_mag

		if MC_s11_syst[7] > 0:
			s11_open_ang       = s11_open_ang      +   MC_s11_syst[7] * norm_error_ang * (np.pi/180) * (sigma_phase_1mag/s11_open_mag)				

		if MC_s11_syst[8] > 0:
			s11_shorted_mag    = s11_shorted_mag   +   MC_s11_syst[8] * error_mag

		if MC_s11_syst[9] > 0:
			s11_shorted_ang    = s11_shorted_ang   +   MC_s11_syst[9] * norm_error_ang * (np.pi/180) * (sigma_phase_1mag/s11_shorted_mag)



		if MC_s11_syst[10] > 0:
			s11_sr_mag         = s11_sr_mag        +   MC_s11_syst[10] * error_mag			

		if MC_s11_syst[11] > 0:
			s11_sr_ang         = s11_sr_ang        +   MC_s11_syst[11] * norm_error_ang * (np.pi/180) * (sigma_phase_1mag/s11_sr_mag)				

		if MC_s11_syst[12] > 0:
			s12s21_sr_mag      = s12s21_sr_mag     +   MC_s11_syst[12] * np.random.normal(0, 2*sigma_mag_s21)       # not correlated. This uncertainty value is technically (2 * A * dA), where A is |S21|. But also |S21| ~ 1

		if MC_s11_syst[13] > 0:
			s12s21_sr_ang      = s12s21_sr_ang     +   MC_s11_syst[13] * (np.pi/180) * np.random.normal(0, 2*sigma_phase_1mag)   # not correlated, This uncertainty value is technically (2 * dP) where dP is the uncertainty in the phase of S21

		if MC_s11_syst[14] > 0:
			s22_sr_mag         = s22_sr_mag        +   MC_s11_syst[14] * error_mag			

		if MC_s11_syst[15] > 0:
			s22_sr_ang         = s22_sr_ang        +   MC_s11_syst[15] * norm_error_ang * (np.pi/180) * (sigma_phase_1mag/s22_sr_mag)



		if MC_s11_syst[16] > 0:
			s11_simu1_mag      = s11_simu1_mag     +   MC_s11_syst[16] * error_mag

		if MC_s11_syst[17] > 0:
			s11_simu1_ang      = s11_simu1_ang     +   MC_s11_syst[17] * norm_error_ang * (np.pi/180) * (sigma_phase_1mag/s11_simu1_mag)

		if MC_s11_syst[18] > 0:
			s11_simu2_mag      = s11_simu2_mag     +   MC_s11_syst[18] * error_mag

		if MC_s11_syst[19] > 0:
			s11_simu2_ang      = s11_simu2_ang     +   MC_s11_syst[19] * norm_error_ang * (np.pi/180) * (sigma_phase_1mag/s11_simu2_mag)			






	elif systematic_s11 == 'uncorrelated':


		if MC_s11_syst[0] > 0:
			s11_LNA_mag       = s11_LNA_mag       +   MC_s11_syst[0] * np.random.normal(0, 1) * sigma_mag

		if MC_s11_syst[1] > 0:
			s11_LNA_ang       = s11_LNA_ang       +   MC_s11_syst[1] * np.random.normal(0, 1) * (np.pi/180) * (sigma_phase_1mag/s11_LNA_mag)				

		if MC_s11_syst[2] > 0:
			s11_amb_mag       = s11_amb_mag       +   MC_s11_syst[2] * np.random.normal(0, 1) * sigma_mag

		if MC_s11_syst[3] > 0:
			s11_amb_ang       = s11_amb_ang       +   MC_s11_syst[3] * np.random.normal(0, 1) * (np.pi/180) * (sigma_phase_1mag/s11_amb_mag)				

		if MC_s11_syst[4] > 0:
			s11_hot_mag       = s11_hot_mag       +   MC_s11_syst[4] * np.random.normal(0, 1) * sigma_mag

		if MC_s11_syst[5] > 0:
			s11_hot_ang       = s11_hot_ang       +   MC_s11_syst[5] * np.random.normal(0, 1) * (np.pi/180) * (sigma_phase_1mag/s11_hot_mag)				

		if MC_s11_syst[6] > 0:
			s11_open_mag      = s11_open_mag      +   MC_s11_syst[6] * np.random.normal(0, 1) * sigma_mag

		if MC_s11_syst[7] > 0:
			s11_open_ang      = s11_open_ang      +   MC_s11_syst[7] * np.random.normal(0, 1) * (np.pi/180) * (sigma_phase_1mag/s11_open_mag)				

		if MC_s11_syst[8] > 0:
			s11_shorted_mag   = s11_shorted_mag   +   MC_s11_syst[8] * np.random.normal(0, 1) * sigma_mag

		if MC_s11_syst[9] > 0:
			s11_shorted_ang   = s11_shorted_ang   +   MC_s11_syst[9] * np.random.normal(0, 1) * (np.pi/180) * (sigma_phase_1mag/s11_shorted_mag)



		if MC_s11_syst[10] > 0:
			s11_sr_mag        = s11_sr_mag        +   MC_s11_syst[10] * np.random.normal(0, 1) * sigma_mag

		if MC_s11_syst[11] > 0:
			s11_sr_ang        = s11_sr_ang        +   MC_s11_syst[11] * np.random.normal(0, 1) * (np.pi/180) * (sigma_phase_1mag/s11_sr_mag)				

		if MC_s11_syst[12] > 0:
			s12s21_sr_mag     = s12s21_sr_mag     +   MC_s11_syst[12] * np.random.normal(0, 1) * 2*sigma_mag_s21        # not correlated. This uncertainty value is technically (2 * A * dA), where A is |S21|. But also |S21| ~ 1

		if MC_s11_syst[13] > 0:
			s12s21_sr_ang     = s12s21_sr_ang     +   MC_s11_syst[13] * np.random.normal(0, 1) * (np.pi/180) * 2 * sigma_phase_1mag    # not correlated, This uncertainty value is technically (2 * dP) where dP is the uncertainty in the phase of S21

		if MC_s11_syst[14] > 0:
			s22_sr_mag        = s22_sr_mag        +   MC_s11_syst[14] * np.random.normal(0, 1) * sigma_mag

		if MC_s11_syst[15] > 0:
			s22_sr_ang        = s22_sr_ang        +   MC_s11_syst[15] * np.random.normal(0, 1) * (np.pi/180) * (sigma_phase_1mag/s22_sr_mag)



		if MC_s11_syst[16] > 0:
			s11_simu1_mag     = s11_simu1_mag     +   MC_s11_syst[16] * np.random.normal(0, 1) * sigma_mag

		if MC_s11_syst[17] > 0:
			s11_simu1_ang     = s11_simu1_ang     +   MC_s11_syst[17] * np.random.normal(0, 1) * (np.pi/180) * (sigma_phase_1mag/s11_simu1_mag)

		if MC_s11_syst[18] > 0:
			s11_simu2_mag     = s11_simu2_mag     +   MC_s11_syst[18] * np.random.normal(0, 1) * sigma_mag

		if MC_s11_syst[19] > 0:
			s11_simu2_ang     = s11_simu2_ang     +   MC_s11_syst[19] * np.random.normal(0, 1) * (np.pi/180) * (sigma_phase_1mag/s11_simu2_mag)	







	# Producing complex S11
	rl        = s11_LNA_mag     * (np.cos(s11_LNA_ang)     + 1j*np.sin(s11_LNA_ang))
	ra        = s11_amb_mag     * (np.cos(s11_amb_ang)     + 1j*np.sin(s11_amb_ang))
	rh        = s11_hot_mag     * (np.cos(s11_hot_ang)     + 1j*np.sin(s11_hot_ang))
	ro        = s11_open_mag    * (np.cos(s11_open_ang)    + 1j*np.sin(s11_open_ang))
	rs        = s11_shorted_mag * (np.cos(s11_shorted_ang) + 1j*np.sin(s11_shorted_ang))

	s11_sr    = s11_sr_mag      * (np.cos(s11_sr_ang)      + 1j*np.sin(s11_sr_ang))
	s12s21_sr = s12s21_sr_mag   * (np.cos(s12s21_sr_ang)   + 1j*np.sin(s12s21_sr_ang))
	s22_sr    = s22_sr_mag      * (np.cos(s22_sr_ang)      + 1j*np.sin(s22_sr_ang))

	rs1       = s11_simu1_mag   * (np.cos(s11_simu1_ang)   + 1j*np.sin(s11_simu1_ang))
	rs2       = s11_simu2_mag   * (np.cos(s11_simu2_ang)   + 1j*np.sin(s11_simu2_ang))


	output = np.array([rl, ra, rh, ro, rs, s11_sr, s12s21_sr, s22_sr, rs1, rs2])






	if (plots == 'yes') and (band == 'high_band_2015'):


		# Plots
		plt.close()
		plt.close()
		plt.close()
		plt.close()
		plt.close()
		plt.close()
		plt.close()
		plt.close()




		# Magnitude

		size_x = 10
		size_y = 9
		x0 = 0.1
		y0 = 0.06
		dx = 0.4
		dy_main = 0.16
		dy_res  = 0.05


		f1  = plt.figure(num=1, figsize=(size_x, size_y))		



		ax = f1.add_axes([1*x0,                (1 + 3*0.5)*y0 + 4*dy_main + 3*dy_res, dx, dy_res])
		ax.plot(f_s11_lores, 20*np.log10(s11_amb_mag_raw) - 20*np.log10(s11_amb_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.002,0.002])
		ax.set_yticks([-0.001, 0.001])
		plt.ylabel('$\Delta$ [dB]')


		ax = f1.add_axes([1*x0,                (1 + 3*0.5)*y0 + 3*dy_main + 3*dy_res, dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_amb_mag),'k')
		plt.ylabel('magnitude [dB]')
		ax.set_xticklabels('')
		plt.ylim([-39.4,-38.0])
		ax.set_yticks(np.arange(-39.2,-38.0,0.2))
		ax.set_yticklabels(['-39.2','-39.0','-38.8','-38.6','-38.4','-38.2'])
		ax.text(85,-38.3,'AMBIENT')
		ax.text(85,-38.5,'NTERMS: ' + str(len(par_s11_amb_mag)))

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 3*0.5)*y0 + 4*dy_main + 3*dy_res, dx, dy_res])
		ax.plot(f_s11_lores, 20*np.log10(s11_hot_mag_raw) - 20*np.log10(s11_hot_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.0012,0.0012])
		ax.set_yticks([-0.0006, 0.0006])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 3*0.5)*y0 + 3*dy_main + 3*dy_res, dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_hot_mag),'k')		
		ax.set_xticklabels('')
		plt.ylim([-38.2,-36.8])
		ax.set_yticks(np.arange(-38.0,-36.8,0.2))
		ax.set_yticklabels(['-38.0','-37.8','-37.6','-37.4','-37.2','-37.0'])		
		ax.text(85,-37.1,'HOT')
		ax.text(85,-37.3,'NTERMS: ' + str(len(par_s11_hot_mag)))		









		ax = f1.add_axes([1*x0,                (1 + 2*0.5)*y0 + 3*dy_main + 2*dy_res, dx, dy_res])
		ax.plot(f_s11_hires, 20*np.log10(s11_open_mag_raw) - 20*np.log10(s11_open_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.001,0.001])
		ax.set_yticks([-0.0005, 0.0005])
		plt.ylabel('$\Delta$ [dB]')


		ax = f1.add_axes([1*x0,                (1 + 2*0.5)*y0 + 2*dy_main + 2*dy_res, dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_open_mag),'k')
		plt.ylabel('magnitude [dB]')
		ax.set_xticklabels('')
		plt.ylim([-0.95,-0.45])
		ax.set_yticks(np.arange(-0.90,-0.40,0.1))
		#ax.set_yticklabels(['-0.85','-0.80','-0.75','-0.70','-0.65','-0.60','-0.55'])		
		ax.text(85,-0.78,'OPEN CABLE')
		ax.text(85,-0.85,'NTERMS: ' + str(len(par_s11_open_mag)))		


		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 2*0.5)*y0 + 3*dy_main + 2*dy_res, dx, dy_res])
		ax.plot(f_s11_hires, 20*np.log10(s11_shorted_mag_raw) - 20*np.log10(s11_shorted_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.001,0.001])
		ax.set_yticks([-0.0005, 0.0005])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 2*0.5)*y0 + 2*dy_main + 2*dy_res, dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_shorted_mag),'k')		
		ax.set_xticklabels('')
		plt.ylim([-0.95,-0.45])
		ax.set_yticks(np.arange(-0.90,-0.40,0.1))		
		#ax.set_yticklabels(['-0.90','-0.85','-0.80','-0.75','-0.70','-0.65','-0.60','-0.55'])
		ax.text(85,-0.83,'SHORTED CABLE')
		ax.text(85,-0.89,'NTERMS: ' + str(len(par_s11_shorted_mag)))		








		ax = f1.add_axes([1*x0,                (1+0.5)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(f_sr_lores, 20*np.log10(s11_sr_mag_raw) - 20*np.log10(s11_sr_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.006,0.006])
		ax.set_yticks([-0.003, 0.003])
		plt.ylabel('$\Delta$ [dB]')


		ax = f1.add_axes([1*x0,                (1+0.5)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_sr_mag),'k')
		plt.ylabel('magnitude [dB]')
		ax.set_xticklabels('')
		plt.ylim([-50,-44])
		ax.set_yticks(np.arange(-49,-44,1))
		#ax.set_yticklabels(['-56','-49','-54','-53','-52'])
		ax.text(85,-45.2,'S11 SR')
		ax.text(85,-46,'NTERMS: ' + str(len(par_s11_sr_mag)))		

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+0.5)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(f_sr_lores, 20*np.log10(s12s21_sr_mag_raw) - 20*np.log10(s12s21_sr_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.00008,0.00008])
		ax.set_yticks([-0.00004, 0.00004])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+0.5)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(fe, 20*np.log10(s12s21_sr_mag),'k')		
		ax.set_xticklabels('')
		plt.ylim([-0.090,-0.040])
		ax.set_yticks(np.arange(-0.080,-0.040,0.01))
		ax.set_yticklabels(['-0.08','-0.07','-0.06','-0.05'])		
		ax.text(85,-0.075,'S12xS21 SR')
		ax.text(85,-0.082,'NTERMS: ' + str(len(par_s12s21_sr_mag)))		












		ax = f1.add_axes([1*x0,                1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(f_sr_lores, 20*np.log10(s22_sr_mag_raw) - 20*np.log10(s22_sr_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.02,0.02])
		ax.set_yticks([-0.01, 0.01])
		plt.ylabel('$\Delta$ [dB]')


		ax = f1.add_axes([1*x0,                1*y0,             dx, dy_main])
		ax.plot(fe, 20*np.log10(s22_sr_mag),'k')
		plt.ylabel('magnitude [dB]')
		plt.xlabel('frequency [MHz]')
		plt.ylim([-52,-46])
		ax.set_yticks(np.arange(-51,-46,1))
		#ax.set_yticklabels(['-49.0','-48.5','-48.0','-47.5','-47.0'])			
		ax.text(85,-47.2,'S22 SR')
		ax.text(85,-48,'NTERMS: ' + str(len(par_s22_sr_mag)))			

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(f_s11_lores, 20*np.log10(s11_LNA_mag_raw) - 20*np.log10(s11_LNA_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.006,0.006])
		ax.set_yticks([-0.003, 0.003])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0,             dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_LNA_mag),'k')		
		plt.xlabel('frequency [MHz]')
		plt.ylim([-22.5,-18.5])
		ax.set_yticks(np.arange(-22,-18,1))
		#ax.set_yticklabels(['-38','-37','-36','-35','-34','-33'])
		ax.text(85,-19.3,'LNA')
		ax.text(85,-19.8,'NTERMS: ' + str(len(par_s11_LNA_mag)))


		plt.savefig(path_plot_save + 's11_magnitude' + plot_flag + '.png', bbox_inches='tight')









		# Phase
		plt.close()


		size_x = 10
		size_y = 9
		x0 = 0.103
		y0 = 0.06
		dx = 0.4
		dy_main = 0.16
		dy_res  = 0.05


		f1  = plt.figure(num=1, figsize=(size_x, size_y))		



		ax = f1.add_axes([1*x0,                (1 + 3*0.5)*y0 + 4*dy_main + 3*dy_res, dx, dy_res])
		ax.plot(np.real(f_s11_lores), (180/np.pi)*s11_amb_ang_raw - (180/np.pi)*s11_amb_ang_raw_model,'k')
		ax.set_xticklabels('')
		plt.ylim([-0.008,0.008])
		ax.set_yticks([-0.004, 0.004])
		plt.ylabel('$\Delta$ [deg]')


		ax = f1.add_axes([1*x0,                (1 + 3*0.5)*y0 + 3*dy_main + 3*dy_res, dx, dy_main])
		ax.plot(fe, (180/np.pi)*(s11_amb_ang),'k')
		plt.ylabel('phase [deg]')
		ax.set_xticklabels('')
		plt.ylim([-40,-10])
		ax.set_yticks(np.arange(-35,-10,5))
		#ax.set_yticklabels(['-14','-12','-10','-8','-6'])
		ax.text(85,-31,'AMBIENT')
		ax.text(85,-35,'NTERMS: ' + str(len(par_s11_amb_ang)))

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 3*0.5)*y0 + 4*dy_main + 3*dy_res, dx, dy_res])
		ax.plot(np.real(f_s11_lores), (180/np.pi)*s11_hot_ang_raw - (180/np.pi)*s11_hot_ang_raw_model,'k')
		ax.set_xticklabels('')
		plt.ylim([-0.008,0.008])
		ax.set_yticks([-0.004, 0.004])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 3*0.5)*y0 + 3*dy_main + 3*dy_res, dx, dy_main])
		ax.plot(fe, (180/np.pi)*(s11_hot_ang),'k')		
		ax.set_xticklabels('')
		plt.ylim([-40,-10])
		ax.set_yticks(np.arange(-35,-10,5))
		#ax.set_yticklabels(['-14','-12','-10','-8','-6'])		
		ax.text(85,-31,'HOT')
		ax.text(85,-35,'NTERMS: ' + str(len(par_s11_hot_ang)))		









		ax = f1.add_axes([1*x0,                (1 + 2*0.5)*y0 + 3*dy_main + 2*dy_res, dx, dy_res])
		ax.plot(f_s11_hires, (180/np.pi)*np.unwrap(s11_open_ang_raw) - (180/np.pi)*np.unwrap(s11_open_ang_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.006,0.006])
		ax.set_yticks([-0.003, 0.003])
		plt.ylabel('$\Delta$ [deg]')


		ax = f1.add_axes([1*x0,                (1 + 2*0.5)*y0 + 2*dy_main + 2*dy_res, dx, dy_main])
		ax.plot(fe, (180/np.pi)*s11_open_ang,'k')
		plt.ylabel('phase [deg]')
		ax.set_xticklabels('')
		plt.ylim([-2500,300])
		ax.set_yticks(np.arange(-2000,200,500))
		#ax.set_yticklabels(['-1000','-800','-600','-400','-200'])		
		ax.text(85,-1600,'OPEN CABLE')
		ax.text(85,-2000,'NTERMS: ' + str(len(par_s11_open_ang)))		


		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 2*0.5)*y0 + 3*dy_main + 2*dy_res, dx, dy_res])
		ax.plot(f_s11_hires, (180/np.pi)*np.unwrap(s11_shorted_ang_raw) - (180/np.pi)*np.unwrap(s11_shorted_ang_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.006,0.006])
		ax.set_yticks([-0.003, 0.003])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 2*0.5)*y0 + 2*dy_main + 2*dy_res, dx, dy_main])
		ax.plot(fe, (180/np.pi)*s11_shorted_ang,'k')		
		ax.set_xticklabels('')
		plt.ylim([-2500,300])
		ax.set_yticks(np.arange(-2000,200,500))		
		#ax.set_yticklabels(['-800','-600','-400','-200','0'])
		ax.text(85,-1600,'SHORTED CABLE')
		ax.text(85,-2000,'NTERMS: ' + str(len(par_s11_shorted_ang)))		








		ax = f1.add_axes([1*x0,                (1+0.5)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(f_sr_lores, (180/np.pi)*np.unwrap(s11_sr_ang_raw) - (180/np.pi)*np.unwrap(s11_sr_ang_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.04,0.04])
		ax.set_yticks([-0.02, 0.02])
		plt.ylabel('$\Delta$ [deg]')


		ax = f1.add_axes([1*x0,                (1+0.5)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(fe, (180/np.pi)*np.unwrap(s11_sr_ang),'k')
		plt.ylabel('phase [deg]')
		ax.set_xticklabels('')
		plt.ylim([-5,25])
		ax.set_yticks(np.arange(0,25,5))
		#ax.set_yticklabels(['20','30','40','50'])
		ax.text(85,4,'S11 SR')
		ax.text(85,0,'NTERMS: ' + str(len(par_s11_sr_ang)))		

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+0.5)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(f_sr_lores, (180/np.pi)*np.unwrap(s12s21_sr_ang_raw) - (180/np.pi)*np.unwrap(s12s21_sr_ang_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.0008,0.0008])
		ax.set_yticks([-0.0004, 0.0004])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+0.5)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(fe, (180/np.pi)*np.unwrap(s12s21_sr_ang),'k')		
		ax.set_xticklabels('')
		plt.ylim([-60,-20])
		ax.set_yticks(np.arange(-55,-20,5))
		#ax.set_yticklabels(['-30','-25','-20','-15'])		
		ax.text(85,-48,'S12xS21 SR')
		ax.text(85,-54,'NTERMS: ' + str(len(par_s12s21_sr_ang)))		












		ax = f1.add_axes([1*x0,                1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(f_sr_lores, (180/np.pi)*np.unwrap(s22_sr_ang_raw) - (180/np.pi)*np.unwrap(s22_sr_ang_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.1,0.1])
		ax.set_yticks([-0.05, 0.05])
		plt.ylabel('$\Delta$ [deg]')


		ax = f1.add_axes([1*x0,                1*y0,             dx, dy_main])
		ax.plot(fe, (180/np.pi)*np.unwrap(s22_sr_ang),'k')
		plt.ylabel('phase [deg]')
		plt.xlabel('frequency [MHz]')
		plt.ylim([-50,0])
		ax.set_yticks(np.arange(-40,0,10))
		#ax.set_yticklabels(['0','5','10','15'])			
		ax.text(85,-33,'S22 SR')
		ax.text(85,-40,'NTERMS: ' + str(len(par_s22_sr_ang)))			

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(f_s11_lores, (180/np.pi)*np.unwrap(s11_LNA_ang_raw) - (180/np.pi)*np.unwrap(s11_LNA_ang_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.04,0.04])
		ax.set_yticks([-0.02, 0.02])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0,             dx, dy_main])
		ax.plot(fe, (180/np.pi)*np.unwrap(s11_LNA_ang),'k')		
		plt.xlabel('frequency [MHz]')
		plt.ylim([-260,-80])
		ax.set_yticks(np.arange(-230,-80,30))
		#ax.set_yticklabels(['85','90','95','100','105'])
		ax.text(85,-205,'LNA')
		ax.text(85,-230,'NTERMS: ' + str(len(par_s11_LNA_ang)))

		plt.savefig(path_plot_save + 's11_phase' + plot_flag + '.png', bbox_inches='tight')






		# Simulators
		plt.close()

		size_x = 10
		size_y = 4.5
		x0 = 0.1
		y0 = 0.12
		dx = 0.4
		dy_main = 0.3
		dy_res  = 0.1

		f1  = plt.figure(num=1, figsize=(size_x, size_y))			

		ax = f1.add_axes([1*x0,                (1+0.5)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(f_s11_hires, 20*np.log10(s11_simu1_mag_raw) - 20*np.log10(s11_simu1_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.00008,0.00008])
		ax.set_yticks([-0.00004, 0.00004])
		plt.ylabel('$\Delta$ [dB]')		

		ax = f1.add_axes([1*x0,                (1+0.5)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_simu1_mag),'k')
		plt.ylabel('magnitude [dB]')
		ax.set_xticklabels('')
		plt.ylim([-12.00,-11.60])
		ax.set_yticks(np.arange(-11.95,-11.60,0.1))
		#ax.set_yticklabels(['-11.80','-11.75','-11.70','-11.65','-11.60'])
		ax.text(85,-11.90,'SIMU1')
		ax.text(85,-11.96,'NTERMS: ' + str(len(par_s11_simu1_mag)))		

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+0.5)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(f_s11_hires, 20*np.log10(s11_simu2_mag_raw) - 20*np.log10(s11_simu2_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.00008,0.00008])
		ax.set_yticks([-0.00004, 0.00004])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+0.5)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_simu2_mag),'k')		
		ax.set_xticklabels('')
		plt.ylim([-12.30,-11.90])
		ax.set_yticks(np.arange(-12.25,-11.90,0.1))
		#ax.set_yticklabels(['-12.05','-12.00','-11.95','-11.90','-11.85'])		
		ax.text(85,-12.19,'SIMU2')
		ax.text(85,-12.25,'NTERMS: ' + str(len(par_s11_simu2_mag)))		







		ax = f1.add_axes([1*x0,                1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(f_s11_hires, (180/np.pi)*np.unwrap(s11_simu1_ang_raw) - (180/np.pi)*np.unwrap(s11_simu1_ang_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.0006,0.0006])
		ax.set_yticks([-0.0003, 0.0003])
		plt.ylabel('$\Delta$ [deg]')


		ax = f1.add_axes([1*x0,                1*y0,             dx, dy_main])
		ax.plot(fe, (180/np.pi)*np.unwrap(s11_simu1_ang),'k')
		plt.ylabel('phase [deg]')
		plt.xlabel('frequency [MHz]')
		plt.ylim([-500,-0])
		ax.set_yticks(np.arange(-400,0,100))
		#ax.set_yticklabels(['-50','0','50','100'])			
		ax.text(85,-350,'SIMU1')
		ax.text(85,-420,'NTERMS: ' + str(len(par_s11_simu1_ang)))			

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(f_s11_hires, (180/np.pi)*np.unwrap(s11_simu2_ang_raw) - (180/np.pi)*np.unwrap(s11_simu2_ang_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.0006,0.0006])
		ax.set_yticks([-0.0003, 0.0003])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0,             dx, dy_main])
		ax.plot(fe, (180/np.pi)*np.unwrap(s11_simu2_ang),'k')		
		plt.xlabel('frequency [MHz]')
		plt.ylim([-1000,0])
		ax.set_yticks(np.arange(-800,0,200))
		#ax.set_yticklabels(['-500','-400','-300','-200','-100'])
		ax.text(85,-700,'SIMU2')
		ax.text(85,-840,'NTERMS: ' + str(len(par_s11_simu2_ang)))


		plt.savefig(path_plot_save + 's11_simulators' + plot_flag + '.png', bbox_inches='tight')			
		plt.close()














	if (plots == 'yes') and (band == 'high_band_2017'):


		# Plots
		plt.close()
		plt.close()
		plt.close()
		plt.close()
		plt.close()
		plt.close()
		plt.close()
		plt.close()




		# Magnitude

		size_x = 10
		size_y = 9
		x0 = 0.1
		y0 = 0.06
		dx = 0.4
		dy_main = 0.16
		dy_res  = 0.05


		f1  = plt.figure(num=1, figsize=(size_x, size_y))		



		ax = f1.add_axes([1*x0,                (1 + 3*0.5)*y0 + 4*dy_main + 3*dy_res, dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_amb_mag_raw) - 20*np.log10(s11_amb_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.002,0.002])
		ax.set_yticks([-0.001, 0.001])
		plt.ylabel('$\Delta$ [dB]')


		ax = f1.add_axes([1*x0,                (1 + 3*0.5)*y0 + 3*dy_main + 3*dy_res, dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_amb_mag),'k')
		plt.ylabel('magnitude [dB]')
		ax.set_xticklabels('')
		plt.ylim([-39.4,-38.0])
		ax.set_yticks(np.arange(-39.2,-38.0,0.2))
		ax.set_yticklabels(['-39.2','-39.0','-38.8','-38.6','-38.4','-38.2'])
		ax.text(85,-38.3,'AMBIENT')
		ax.text(85,-38.5,'NTERMS: ' + str(len(par_s11_amb_mag)))

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 3*0.5)*y0 + 4*dy_main + 3*dy_res, dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_hot_mag_raw) - 20*np.log10(s11_hot_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.002,0.002])
		ax.set_yticks([-0.001, 0.001])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 3*0.5)*y0 + 3*dy_main + 3*dy_res, dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_hot_mag),'k')		
		ax.set_xticklabels('')
		plt.ylim([-38.2,-36.8])
		ax.set_yticks(np.arange(-38.0,-36.8,0.2))
		ax.set_yticklabels(['-38.0','-37.8','-37.6','-37.4','-37.2','-37.0'])		
		ax.text(85,-37.1,'HOT')
		ax.text(85,-37.3,'NTERMS: ' + str(len(par_s11_hot_mag)))		









		ax = f1.add_axes([1*x0,                (1 + 2*0.5)*y0 + 3*dy_main + 2*dy_res, dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_open_mag_raw) - 20*np.log10(s11_open_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.001,0.001])
		ax.set_yticks([-0.0005, 0.0005])
		plt.ylabel('$\Delta$ [dB]')


		ax = f1.add_axes([1*x0,                (1 + 2*0.5)*y0 + 2*dy_main + 2*dy_res, dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_open_mag),'k')
		plt.ylabel('magnitude [dB]')
		ax.set_xticklabels('')
		plt.ylim([-0.95,-0.45])
		ax.set_yticks(np.arange(-0.90,-0.40,0.1))
		#ax.set_yticklabels(['-0.85','-0.80','-0.75','-0.70','-0.65','-0.60','-0.55'])		
		ax.text(85,-0.78,'OPEN CABLE')
		ax.text(85,-0.85,'NTERMS: ' + str(len(par_s11_open_mag)))		


		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 2*0.5)*y0 + 3*dy_main + 2*dy_res, dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_shorted_mag_raw) - 20*np.log10(s11_shorted_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.001,0.001])
		ax.set_yticks([-0.0005, 0.0005])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 2*0.5)*y0 + 2*dy_main + 2*dy_res, dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_shorted_mag),'k')		
		ax.set_xticklabels('')
		plt.ylim([-0.95,-0.45])
		ax.set_yticks(np.arange(-0.90,-0.40,0.1))		
		#ax.set_yticklabels(['-0.90','-0.85','-0.80','-0.75','-0.70','-0.65','-0.60','-0.55'])
		ax.text(85,-0.83,'SHORTED CABLE')
		ax.text(85,-0.89,'NTERMS: ' + str(len(par_s11_shorted_mag)))		








		ax = f1.add_axes([1*x0,                (1+0.5)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_sr_mag_raw) - 20*np.log10(s11_sr_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.006,0.006])
		ax.set_yticks([-0.003, 0.003])
		plt.ylabel('$\Delta$ [dB]')


		ax = f1.add_axes([1*x0,                (1+0.5)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_sr_mag),'k')
		plt.ylabel('magnitude [dB]')
		ax.set_xticklabels('')
		plt.ylim([-50,-44])
		ax.set_yticks(np.arange(-49,-44,1))
		#ax.set_yticklabels(['-56','-49','-54','-53','-52'])
		ax.text(85,-45.2,'S11 SR')
		ax.text(85,-46,'NTERMS: ' + str(len(par_s11_sr_mag)))		

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+0.5)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(fs11, 20*np.log10(s12s21_sr_mag_raw) - 20*np.log10(s12s21_sr_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.00008,0.00008])
		ax.set_yticks([-0.00004, 0.00004])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+0.5)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(fe, 20*np.log10(s12s21_sr_mag),'k')		
		ax.set_xticklabels('')
		plt.ylim([-0.090,-0.040])
		ax.set_yticks(np.arange(-0.080,-0.040,0.01))
		ax.set_yticklabels(['-0.08','-0.07','-0.06','-0.05'])		
		ax.text(85,-0.075,'S12xS21 SR')
		ax.text(85,-0.082,'NTERMS: ' + str(len(par_s12s21_sr_mag)))		












		ax = f1.add_axes([1*x0,                1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(fs11, 20*np.log10(s22_sr_mag_raw) - 20*np.log10(s22_sr_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.02,0.02])
		ax.set_yticks([-0.01, 0.01])
		plt.ylabel('$\Delta$ [dB]')


		ax = f1.add_axes([1*x0,                1*y0,             dx, dy_main])
		ax.plot(fe, 20*np.log10(s22_sr_mag),'k')
		plt.ylabel('magnitude [dB]')
		plt.xlabel('frequency [MHz]')
		plt.ylim([-52,-46])
		ax.set_yticks(np.arange(-51,-46,1))
		#ax.set_yticklabels(['-49.0','-48.5','-48.0','-47.5','-47.0'])			
		ax.text(85,-47.2,'S22 SR')
		ax.text(85,-48,'NTERMS: ' + str(len(par_s22_sr_mag)))			

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_LNA_mag_raw) - 20*np.log10(s11_LNA_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.006,0.006])
		ax.set_yticks([-0.003, 0.003])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0,             dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_LNA_mag),'k')		
		plt.xlabel('frequency [MHz]')
		plt.ylim([-22.5,-18.5])
		ax.set_yticks(np.arange(-22,-18,1))
		#ax.set_yticklabels(['-38','-37','-36','-35','-34','-33'])
		ax.text(85,-19.3,'LNA')
		ax.text(85,-19.8,'NTERMS: ' + str(len(par_s11_LNA_mag)))


		plt.savefig(path_plot_save + 's11_magnitude' + plot_flag + '.png', bbox_inches='tight')









		# Phase
		plt.close()


		size_x = 10
		size_y = 9
		x0 = 0.103
		y0 = 0.06
		dx = 0.4
		dy_main = 0.16
		dy_res  = 0.05


		f1  = plt.figure(num=1, figsize=(size_x, size_y))		



		ax = f1.add_axes([1*x0,                (1 + 3*0.5)*y0 + 4*dy_main + 3*dy_res, dx, dy_res])
		ax.plot(np.real(fs11), (180/np.pi)*s11_amb_ang_raw - (180/np.pi)*s11_amb_ang_raw_model,'k')
		ax.set_xticklabels('')
		plt.ylim([-0.02,0.02])
		ax.set_yticks([-0.01, 0.01])
		plt.ylabel('$\Delta$ [deg]')


		ax = f1.add_axes([1*x0,                (1 + 3*0.5)*y0 + 3*dy_main + 3*dy_res, dx, dy_main])
		ax.plot(fe, (180/np.pi)*(s11_amb_ang),'k')
		plt.ylabel('phase [deg]')
		ax.set_xticklabels('')
		plt.ylim([-40,-10])
		ax.set_yticks(np.arange(-35,-10,5))
		#ax.set_yticklabels(['-14','-12','-10','-8','-6'])
		ax.text(85,-31,'AMBIENT')
		ax.text(85,-35,'NTERMS: ' + str(len(par_s11_amb_ang)))

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 3*0.5)*y0 + 4*dy_main + 3*dy_res, dx, dy_res])
		ax.plot(np.real(fs11), (180/np.pi)*s11_hot_ang_raw - (180/np.pi)*s11_hot_ang_raw_model,'k')
		ax.set_xticklabels('')
		plt.ylim([-0.02,0.02])
		ax.set_yticks([-0.01, 0.01])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 3*0.5)*y0 + 3*dy_main + 3*dy_res, dx, dy_main])
		ax.plot(fe, (180/np.pi)*(s11_hot_ang),'k')		
		ax.set_xticklabels('')
		plt.ylim([-40,-10])
		ax.set_yticks(np.arange(-35,-10,5))
		#ax.set_yticklabels(['-14','-12','-10','-8','-6'])		
		ax.text(85,-31,'HOT')
		ax.text(85,-35,'NTERMS: ' + str(len(par_s11_hot_ang)))		









		ax = f1.add_axes([1*x0,                (1 + 2*0.5)*y0 + 3*dy_main + 2*dy_res, dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s11_open_ang_raw) - (180/np.pi)*np.unwrap(s11_open_ang_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.006,0.006])
		ax.set_yticks([-0.003, 0.003])
		plt.ylabel('$\Delta$ [deg]')


		ax = f1.add_axes([1*x0,                (1 + 2*0.5)*y0 + 2*dy_main + 2*dy_res, dx, dy_main])
		ax.plot(fe, (180/np.pi)*s11_open_ang,'k')
		plt.ylabel('phase [deg]')
		ax.set_xticklabels('')
		plt.ylim([-2500,300])
		ax.set_yticks(np.arange(-2000,200,500))
		#ax.set_yticklabels(['-1000','-800','-600','-400','-200'])		
		ax.text(85,-1600,'OPEN CABLE')
		ax.text(85,-2000,'NTERMS: ' + str(len(par_s11_open_ang)))		


		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 2*0.5)*y0 + 3*dy_main + 2*dy_res, dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s11_shorted_ang_raw) - (180/np.pi)*np.unwrap(s11_shorted_ang_raw_model) + 720,'k')
		ax.set_xticklabels('')
		plt.ylim([-0.006,0.006])
		ax.set_yticks([-0.003, 0.003])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 2*0.5)*y0 + 2*dy_main + 2*dy_res, dx, dy_main])
		ax.plot(fe, (180/np.pi)*s11_shorted_ang,'k')		
		ax.set_xticklabels('')
		plt.ylim([-2500,300])
		ax.set_yticks(np.arange(-2000,200,500))		
		#ax.set_yticklabels(['-800','-600','-400','-200','0'])
		ax.text(85,-1600,'SHORTED CABLE')
		ax.text(85,-2000,'NTERMS: ' + str(len(par_s11_shorted_ang)))		








		ax = f1.add_axes([1*x0,                (1+0.5)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s11_sr_ang_raw) - (180/np.pi)*np.unwrap(s11_sr_ang_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.04,0.04])
		ax.set_yticks([-0.02, 0.02])
		plt.ylabel('$\Delta$ [deg]')


		ax = f1.add_axes([1*x0,                (1+0.5)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(fe, (180/np.pi)*np.unwrap(s11_sr_ang),'k')
		plt.ylabel('phase [deg]')
		ax.set_xticklabels('')
		plt.ylim([-5,25])
		ax.set_yticks(np.arange(0,25,5))
		#ax.set_yticklabels(['20','30','40','50'])
		ax.text(85,4,'S11 SR')
		ax.text(85,0,'NTERMS: ' + str(len(par_s11_sr_ang)))		

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+0.5)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s12s21_sr_ang_raw) - (180/np.pi)*np.unwrap(s12s21_sr_ang_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.0008,0.0008])
		ax.set_yticks([-0.0004, 0.0004])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+0.5)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(fe, (180/np.pi)*np.unwrap(s12s21_sr_ang),'k')		
		ax.set_xticklabels('')
		plt.ylim([-60,-20])
		ax.set_yticks(np.arange(-55,-20,5))
		#ax.set_yticklabels(['-30','-25','-20','-15'])		
		ax.text(85,-48,'S12xS21 SR')
		ax.text(85,-54,'NTERMS: ' + str(len(par_s12s21_sr_ang)))		












		ax = f1.add_axes([1*x0,                1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s22_sr_ang_raw) - (180/np.pi)*np.unwrap(s22_sr_ang_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.1,0.1])
		ax.set_yticks([-0.05, 0.05])
		plt.ylabel('$\Delta$ [deg]')


		ax = f1.add_axes([1*x0,                1*y0,             dx, dy_main])
		ax.plot(fe, (180/np.pi)*np.unwrap(s22_sr_ang),'k')
		plt.ylabel('phase [deg]')
		plt.xlabel('frequency [MHz]')
		plt.ylim([-50,0])
		ax.set_yticks(np.arange(-40,0,10))
		#ax.set_yticklabels(['0','5','10','15'])			
		ax.text(85,-33,'S22 SR')
		ax.text(85,-40,'NTERMS: ' + str(len(par_s22_sr_ang)))			

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s11_LNA_ang_raw) - (180/np.pi)*np.unwrap(s11_LNA_ang_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.04,0.04])
		ax.set_yticks([-0.02, 0.02])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0,             dx, dy_main])
		ax.plot(fe, (180/np.pi)*np.unwrap(s11_LNA_ang),'k')		
		plt.xlabel('frequency [MHz]')
		plt.ylim([-260,-80])
		ax.set_yticks(np.arange(-230,-80,30))
		#ax.set_yticklabels(['85','90','95','100','105'])
		ax.text(85,-205,'LNA')
		ax.text(85,-230,'NTERMS: ' + str(len(par_s11_LNA_ang)))

		plt.savefig(path_plot_save + 's11_phase' + plot_flag + '.png', bbox_inches='tight')






		# Simulators
		plt.close()

		size_x = 10
		size_y = 4.5
		x0 = 0.1
		y0 = 0.12
		dx = 0.4
		dy_main = 0.3
		dy_res  = 0.1

		f1  = plt.figure(num=1, figsize=(size_x, size_y))			

		ax = f1.add_axes([1*x0,                (1+0.5)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_simu1_mag_raw) - 20*np.log10(s11_simu1_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.0008,0.0008])
		ax.set_yticks([-0.0004, 0.0004])
		plt.ylabel('$\Delta$ [dB]')		

		ax = f1.add_axes([1*x0,                (1+0.5)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_simu1_mag),'k')
		plt.ylabel('magnitude [dB]')
		ax.set_xticklabels('')
		plt.ylim([-12.00,-11.60])
		ax.set_yticks(np.arange(-11.95,-11.60,0.1))
		#ax.set_yticklabels(['-11.80','-11.75','-11.70','-11.65','-11.60'])
		ax.text(85,-11.90,'SIMU1')
		ax.text(85,-11.96,'NTERMS: ' + str(len(par_s11_simu2_mag)))		

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+0.5)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_simu2_mag_raw) - 20*np.log10(s11_simu2_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.0008,0.0008])
		ax.set_yticks([-0.0004, 0.0004])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+0.5)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_simu2_mag),'k')		
		ax.set_xticklabels('')
		plt.ylim([-12.30,-11.90])
		ax.set_yticks(np.arange(-12.25,-11.90,0.1))
		#ax.set_yticklabels(['-12.05','-12.00','-11.95','-11.90','-11.85'])		
		ax.text(85,-12.19,'SIMU2')
		ax.text(85,-12.25,'NTERMS: ' + str(len(par_s11_simu2_mag)))		







		ax = f1.add_axes([1*x0,                1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s11_simu1_ang_raw) - (180/np.pi)*np.unwrap(s11_simu1_ang_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.006,0.006])
		ax.set_yticks([-0.003, 0.003])
		plt.ylabel('$\Delta$ [deg]')


		ax = f1.add_axes([1*x0,                1*y0,             dx, dy_main])
		ax.plot(fe, (180/np.pi)*np.unwrap(s11_simu1_ang),'k')
		plt.ylabel('phase [deg]')
		plt.xlabel('frequency [MHz]')
		plt.ylim([-500,-0])
		ax.set_yticks(np.arange(-400,0,100))
		#ax.set_yticklabels(['-50','0','50','100'])			
		ax.text(85,-350,'SIMU1')
		ax.text(85,-420,'NTERMS: ' + str(len(par_s11_simu2_ang)))			

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s11_simu2_ang_raw) - (180/np.pi)*np.unwrap(s11_simu2_ang_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.006,0.006])
		ax.set_yticks([-0.003, 0.003])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0,             dx, dy_main])
		ax.plot(fe, (180/np.pi)*np.unwrap(s11_simu2_ang),'k')		
		plt.xlabel('frequency [MHz]')
		plt.ylim([-1000,0])
		ax.set_yticks(np.arange(-800,0,200))
		#ax.set_yticklabels(['-500','-400','-300','-200','-100'])
		ax.text(85,-700,'SIMU2')
		ax.text(85,-840,'NTERMS: ' + str(len(par_s11_simu2_ang)))


		plt.savefig(path_plot_save + 's11_simulators' + plot_flag + '.png', bbox_inches='tight')			
		plt.close()























	if (plots == 'yes') and ((band == 'low_band_2015') or (band == 'low_band_2015_2017_05') or (band == 'low_band_2015_2017_09')):


		# Plots
		plt.close()
		plt.close()
		plt.close()
		plt.close()
		plt.close()
		plt.close()
		plt.close()
		plt.close()




		# Magnitude

		size_x = 10
		size_y = 9
		x0 = 0.1
		y0 = 0.06
		dx = 0.4
		dy_main = 0.16
		dy_res  = 0.05


		f1  = plt.figure(num=1, figsize=(size_x, size_y))		



		ax = f1.add_axes([1*x0,                (1 + 3*0.5)*y0 + 4*dy_main + 3*dy_res, dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_amb_mag_raw) - 20*np.log10(s11_amb_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		plt.ylim([-0.01,0.01])
		ax.set_yticks([-0.005, 0.005])
		plt.ylabel('$\Delta$ [dB]')


		ax = f1.add_axes([1*x0,                (1 + 3*0.5)*y0 + 3*dy_main + 3*dy_res, dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_amb_mag),'k')
		plt.ylabel('magnitude [dB]')
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		#plt.ylim([-39.6,-38.4])
		ax.set_yticks(np.arange(-39.6,-38.4,0.2))
		ax.set_yticklabels(['','-39.4','-39.2','-39.0','-38.8','-38.6'])
		ax.text(52,-38.6,'AMBIENT')
		ax.text(52,-38.8,'NTERMS: ' + str(len(par_s11_amb_mag)))

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 3*0.5)*y0 + 4*dy_main + 3*dy_res, dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_hot_mag_raw) - 20*np.log10(s11_hot_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		plt.ylim([-0.01,0.01])
		ax.set_yticks([-0.005, 0.005])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 3*0.5)*y0 + 3*dy_main + 3*dy_res, dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_hot_mag),'k')		
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		#plt.ylim([-38.6,-37.4])
		ax.set_yticks(np.arange(-38.6,-37.4,0.2))
		ax.set_yticklabels(['','-38.4','-38.2','-38.0','-37.8','-37.6'])		
		ax.text(52,-37.6,'HOT')
		ax.text(52,-37.8,'NTERMS: ' + str(len(par_s11_hot_mag)))		









		ax = f1.add_axes([1*x0,                (1 + 2*0.5)*y0 + 3*dy_main + 2*dy_res, dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_open_mag_raw) - 20*np.log10(s11_open_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		plt.ylim([-0.0002,0.0002])
		ax.set_yticks([-0.0001, 0.0001])
		plt.ylabel('$\Delta$ [dB]')


		ax = f1.add_axes([1*x0,                (1 + 2*0.5)*y0 + 2*dy_main + 2*dy_res, dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_open_mag),'k')
		plt.ylabel('magnitude [dB]')
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		#plt.ylim([-0.60,-0.35])
		ax.set_yticks(np.arange(-0.60,-0.35,0.05))
		ax.set_yticklabels(['','-0.55','-0.50','-0.45','-0.40',''])		
		ax.text(52,-0.52,'OPEN CABLE')
		ax.text(52,-0.56,'NTERMS: ' + str(len(par_s11_open_mag)))		


		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 2*0.5)*y0 + 3*dy_main + 2*dy_res, dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_shorted_mag_raw) - 20*np.log10(s11_shorted_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		plt.ylim([-0.0002,0.0002])
		ax.set_yticks([-0.0001, 0.0001])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 2*0.5)*y0 + 2*dy_main + 2*dy_res, dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_shorted_mag),'k')		
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		#plt.ylim([-0.65,-0.40])
		ax.set_yticks(np.arange(-0.65,-0.40,0.05))		
		ax.set_yticklabels(['','-0.60','-0.55','-0.50','-0.45',''])
		ax.text(52,-0.57,'SHORTED CABLE')
		ax.text(52,-0.61,'NTERMS: ' + str(len(par_s11_shorted_mag)))		








		ax = f1.add_axes([1*x0,                (1+0.5)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_sr_mag_raw) - 20*np.log10(s11_sr_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		plt.ylim([-0.12,0.12])
		ax.set_yticks([-0.06, 0.06])
		plt.ylabel('$\Delta$ [dB]')


		ax = f1.add_axes([1*x0,                (1+0.5)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_sr_mag),'k')
		plt.ylabel('magnitude [dB]')
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		#plt.ylim([-57,-51])
		ax.set_yticks(np.arange(-56,-51,1))
		ax.set_yticklabels(['-56','-55','-54','-53','-52'])
		ax.text(52,-52.1,'S11 SR')
		ax.text(52,-53,'NTERMS: ' + str(len(par_s11_sr_mag)))		

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+0.5)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(fs11, 20*np.log10(s12s21_sr_mag_raw) - 20*np.log10(s12s21_sr_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		plt.ylim([-0.0004,0.0004])
		ax.set_yticks([-0.0002, 0.0002])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+0.5)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(fe, 20*np.log10(s12s21_sr_mag),'k')		
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		#plt.ylim([-0.06,-0.03])
		ax.set_yticks(np.arange(-0.055,-0.03,0.005))
		ax.set_yticklabels(['-0.055','-0.050','-0.045','-0.040','-0.035'])		
		ax.text(52,-0.050,'S12xS21 SR')
		ax.text(52,-0.055,'NTERMS: ' + str(len(par_s12s21_sr_mag)))		












		ax = f1.add_axes([1*x0,                1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(fs11, 20*np.log10(s22_sr_mag_raw) - 20*np.log10(s22_sr_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		plt.ylim([-0.12,0.12])
		ax.set_yticks([-0.06, 0.06])
		plt.ylabel('$\Delta$ [dB]')


		ax = f1.add_axes([1*x0,                1*y0,             dx, dy_main])
		ax.plot(fe, 20*np.log10(s22_sr_mag),'k')
		plt.ylabel('magnitude [dB]')
		plt.xlabel('frequency [MHz]')
		plt.xlim([40, 120])
		#plt.ylim([-49.5,-46.5])
		ax.set_yticks(np.arange(-49,-46.5,0.5))
		ax.set_yticklabels(['-49.0','-48.5','-48.0','-47.5','-47.0'])			
		ax.text(52,-47,'S22 SR')
		ax.text(52,-47.5,'NTERMS: ' + str(len(par_s22_sr_mag)))			

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_LNA_mag_raw) - 20*np.log10(s11_LNA_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		plt.ylim([-0.06,0.06])
		ax.set_yticks([-0.03, 0.03])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0,             dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_LNA_mag),'k')		
		plt.xlabel('frequency [MHz]')
		plt.xlim([40, 120])
		#plt.ylim([-39,-32])
		ax.set_yticks(np.arange(-38,-32,1))
		ax.set_yticklabels(['-38','-37','-36','-35','-34','-33'])
		ax.text(52,-36.8,'LNA')
		ax.text(52,-37.8,'NTERMS: ' + str(len(par_s11_LNA_mag)))


		plt.savefig(path_plot_save + 's11_magnitude' + plot_flag + '.png', bbox_inches='tight')









		# Phase
		plt.close()


		size_x = 10
		size_y = 9
		x0 = 0.103
		y0 = 0.06
		dx = 0.4
		dy_main = 0.16
		dy_res  = 0.05


		f1  = plt.figure(num=1, figsize=(size_x, size_y))		



		ax = f1.add_axes([1*x0,                (1 + 3*0.5)*y0 + 4*dy_main + 3*dy_res, dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s11_amb_ang_raw) - (180/np.pi)*np.unwrap(s11_amb_ang_raw_model) - ((180/np.pi)*np.unwrap(s11_amb_ang_raw) - (180/np.pi)*np.unwrap(s11_amb_ang_raw_model))[-1],'k')
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		plt.ylim([-0.06,0.06])
		ax.set_yticks([-0.03, 0.03])
		plt.ylabel('$\Delta$ [deg]')


		ax = f1.add_axes([1*x0,                (1 + 3*0.5)*y0 + 3*dy_main + 3*dy_res, dx, dy_main])
		ax.plot(fe, (180/np.pi)*(s11_amb_ang),'k')
		plt.ylabel('phase [deg]')
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		#plt.ylim([-16,-4])
		ax.set_yticks(np.arange(-14,-4,2))
		ax.set_yticklabels(['-14','-12','-10','-8','-6'])
		ax.text(52,-12.2,'AMBIENT')
		ax.text(52,-14,'NTERMS: ' + str(len(par_s11_amb_ang)))

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 3*0.5)*y0 + 4*dy_main + 3*dy_res, dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s11_hot_ang_raw) - (180/np.pi)*np.unwrap(s11_hot_ang_raw_model) - ((180/np.pi)*np.unwrap(s11_hot_ang_raw) - (180/np.pi)*np.unwrap(s11_hot_ang_raw_model))[-1],'k')
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		plt.ylim([-0.06,0.06])
		ax.set_yticks([-0.03, 0.03])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 3*0.5)*y0 + 3*dy_main + 3*dy_res, dx, dy_main])
		ax.plot(fe, (180/np.pi)*(s11_hot_ang),'k')		
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		#plt.ylim([-16,-4])
		ax.set_yticks(np.arange(-14,-4,2))
		ax.set_yticklabels(['-14','-12','-10','-8','-6'])		
		ax.text(52,-12.2,'HOT')
		ax.text(52,-14,'NTERMS: ' + str(len(par_s11_hot_ang)))		









		ax = f1.add_axes([1*x0,                (1 + 2*0.5)*y0 + 3*dy_main + 2*dy_res, dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s11_open_ang_raw) - (180/np.pi)*np.unwrap(s11_open_ang_raw_model) - ((180/np.pi)*np.unwrap(s11_open_ang_raw) - (180/np.pi)*np.unwrap(s11_open_ang_raw_model))[-1],'k')
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		plt.ylim([-0.001,0.001])
		ax.set_yticks([-0.0005, 0.0005])
		plt.ylabel('$\Delta$ [deg]')


		ax = f1.add_axes([1*x0,                (1 + 2*0.5)*y0 + 2*dy_main + 2*dy_res, dx, dy_main])
		ax.plot(fe, (180/np.pi)*s11_open_ang,'k')
		plt.ylabel('phase [deg]')
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		#plt.ylim([-1200,0])
		ax.set_yticks(np.arange(-1000,0,200))
		ax.set_yticklabels(['-1000','-800','-600','-400','-200'])		
		ax.text(52,-810,'OPEN CABLE')
		ax.text(52,-1000,'NTERMS: ' + str(len(par_s11_open_ang)))		


		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 2*0.5)*y0 + 3*dy_main + 2*dy_res, dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s11_shorted_ang_raw) - (180/np.pi)*np.unwrap(s11_shorted_ang_raw_model) - ((180/np.pi)*np.unwrap(s11_shorted_ang_raw) - (180/np.pi)*np.unwrap(s11_shorted_ang_raw_model))[-1],'k')
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		plt.ylim([-0.002,0.002])
		ax.set_yticks([-0.001, 0.001])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 2*0.5)*y0 + 2*dy_main + 2*dy_res, dx, dy_main])
		ax.plot(fe, (180/np.pi)*s11_shorted_ang,'k')		
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		#plt.ylim([-1000,200])
		ax.set_yticks(np.arange(-800,200,200))		
		ax.set_yticklabels(['-800','-600','-400','-200','0'])
		ax.text(52,-610,'SHORTED CABLE')
		ax.text(52,-800,'NTERMS: ' + str(len(par_s11_shorted_ang)))		








		ax = f1.add_axes([1*x0,                (1+0.5)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s11_sr_ang_raw) - (180/np.pi)*np.unwrap(s11_sr_ang_raw_model) - ((180/np.pi)*np.unwrap(s11_sr_ang_raw) - (180/np.pi)*np.unwrap(s11_sr_ang_raw_model))[-1],'k')
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		plt.ylim([-1,1])
		ax.set_yticks([-0.5, 0.5])
		plt.ylabel('$\Delta$ [deg]')


		ax = f1.add_axes([1*x0,                (1+0.5)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(fe, (180/np.pi)*np.unwrap(s11_sr_ang),'k')
		plt.ylabel('phase [deg]')
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		#plt.ylim([10,60])
		ax.set_yticks(np.arange(20,60,10))
		ax.set_yticklabels(['20','30','40','50'])
		ax.text(52,26,'S11 SR')
		ax.text(52,18,'NTERMS: ' + str(len(par_s11_sr_ang)))		

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+0.5)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s12s21_sr_ang_raw) - (180/np.pi)*np.unwrap(s12s21_sr_ang_raw_model) - ((180/np.pi)*np.unwrap(s12s21_sr_ang_raw) - (180/np.pi)*np.unwrap(s12s21_sr_ang_raw_model))[-1],'k')
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		plt.ylim([-0.002,0.002])
		ax.set_yticks([-0.001, 0.001])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+0.5)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(fe, (180/np.pi)*np.unwrap(s12s21_sr_ang),'k')		
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		#plt.ylim([-35,-10])
		ax.set_yticks(np.arange(-30,-10,5))
		ax.set_yticklabels(['-30','-25','-20','-15'])		
		ax.text(52,-27,'S12xS21 SR')
		ax.text(52,-31.3,'NTERMS: ' + str(len(par_s12s21_sr_ang)))		












		ax = f1.add_axes([1*x0,                1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s22_sr_ang_raw) - (180/np.pi)*np.unwrap(s22_sr_ang_raw_model) - ((180/np.pi)*np.unwrap(s22_sr_ang_raw) - (180/np.pi)*np.unwrap(s22_sr_ang_raw_model))[-1],'k')
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		plt.ylim([-0.6,0.6])
		ax.set_yticks([-0.3, 0.3])
		plt.ylabel('$\Delta$ [deg]')


		ax = f1.add_axes([1*x0,                1*y0,             dx, dy_main])
		ax.plot(fe, (180/np.pi)*np.unwrap(s22_sr_ang),'k')
		plt.ylabel('phase [deg]')
		plt.xlabel('frequency [MHz]')
		plt.xlim([40, 120])
		#plt.ylim([-5,20])
		ax.set_yticks(np.arange(0,20,5))
		ax.set_yticklabels(['0','5','10','15'])			
		ax.text(52,3,'S22 SR')
		ax.text(52,-1,'NTERMS: ' + str(len(par_s22_sr_ang)))			

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s11_LNA_ang_raw) - (180/np.pi)*np.unwrap(s11_LNA_ang_raw_model) - ((180/np.pi)*np.unwrap(s22_sr_ang_raw) - (180/np.pi)*np.unwrap(s22_sr_ang_raw_model))[-1],'k')
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		plt.ylim([-0.4,0.4])
		ax.set_yticks([-0.2, 0.2])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0,             dx, dy_main])
		ax.plot(fe, (180/np.pi)*np.unwrap(s11_LNA_ang),'k')		
		plt.xlabel('frequency [MHz]')
		plt.xlim([40, 120])
		#plt.ylim([80,110])
		ax.set_yticks(np.arange(85,110,5))
		ax.set_yticklabels(['85','90','95','100','105'])
		ax.text(52,105,'LNA')
		ax.text(52,100,'NTERMS: ' + str(len(par_s11_LNA_ang)))

		plt.savefig(path_plot_save + 's11_phase' + plot_flag + '.png', bbox_inches='tight')




		plt.close()

		# Simulators

		size_x = 10
		size_y = 4.5
		x0 = 0.1
		y0 = 0.12
		dx = 0.4
		dy_main = 0.3
		dy_res  = 0.1


		f1  = plt.figure(num=1, figsize=(size_x, size_y))			



		ax = f1.add_axes([1*x0,                (1+0.5)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_simu1_mag_raw) - 20*np.log10(s11_simu1_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		plt.ylim([-0.0004,0.0004])
		ax.set_yticks([-0.0002, 0.0002])
		plt.ylabel('$\Delta$ [dB]')		

		ax = f1.add_axes([1*x0,                (1+0.5)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_simu1_mag),'k')
		plt.ylabel('magnitude [dB]')
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		#plt.ylim([-11.85,-11.55])
		ax.set_yticks(np.arange(-11.80,-11.55,0.05))
		ax.set_yticklabels(['-11.80','-11.75','-11.70','-11.65','-11.60'])
		ax.text(52,-11.75,'SIMU1')
		ax.text(52,-11.80,'NTERMS: ' + str(len(par_s11_simu1_mag)))		

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+0.5)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_simu2_mag_raw) - 20*np.log10(s11_simu2_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		plt.ylim([-0.0008,0.0008])
		ax.set_yticks([-0.0004, 0.0004])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+0.5)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_simu2_mag),'k')		
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		#plt.ylim([-12.10,-11.80])
		ax.set_yticks(np.arange(-12.05,-11.80,0.05))
		ax.set_yticklabels(['-12.05','-12.00','-11.95','-11.90','-11.85'])		
		ax.text(52,-12.00,'SIMU2')
		ax.text(52,-12.05,'NTERMS: ' + str(len(par_s11_simu2_mag)))		







		ax = f1.add_axes([1*x0,                1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s11_simu1_ang_raw) - (180/np.pi)*np.unwrap(s11_simu1_ang_raw_model),'k')
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		plt.ylim([-0.004,0.004])
		ax.set_yticks([-0.002, 0.002])
		plt.ylabel('$\Delta$ [deg]')


		ax = f1.add_axes([1*x0,                1*y0,             dx, dy_main])
		ax.plot(fe, (180/np.pi)*np.unwrap(s11_simu1_ang),'k')
		plt.ylabel('phase [deg]')
		plt.xlabel('frequency [MHz]')
		plt.xlim([40, 120])
		#plt.ylim([-100,150])
		ax.set_yticks(np.arange(-50,150,50))
		ax.set_yticklabels(['-50','0','50','100'])			
		ax.text(52,-10,'SIMU1')
		ax.text(52,-50,'NTERMS: ' + str(len(par_s11_simu1_ang)))			

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s11_simu2_ang_raw) - (180/np.pi)*np.unwrap(s11_simu2_ang_raw_model),'k')
		ax.set_xticklabels('')
		plt.xlim([40, 120])
		plt.ylim([-0.008,0.008])
		ax.set_yticks([-0.004, 0.004])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0,             dx, dy_main])
		ax.plot(fe, (180/np.pi)*np.unwrap(s11_simu2_ang),'k')		
		plt.xlabel('frequency [MHz]')
		plt.xlim([40, 120])
		#plt.ylim([-600,0])
		ax.set_yticks(np.arange(-500,0,100))
		ax.set_yticklabels(['-500','-400','-300','-200','-100'])
		ax.text(52,-400,'SIMU2')
		ax.text(52,-500,'NTERMS: ' + str(len(par_s11_simu2_ang)))


		plt.savefig(path_plot_save + 's11_simulators' + plot_flag + '.png', bbox_inches='tight')			
		plt.close()		
















	if (plots == 'yes') and (band == 'low_band2_2017'):


		# Plots
		plt.close()
		plt.close()
		plt.close()
		plt.close()
		plt.close()
		plt.close()
		plt.close()
		plt.close()




		# Magnitude

		size_x = 10
		size_y = 9
		x0 = 0.1
		y0 = 0.06
		dx = 0.4
		dy_main = 0.16
		dy_res  = 0.05


		f1  = plt.figure(num=1, figsize=(size_x, size_y))		



		ax = f1.add_axes([1*x0,                (1 + 3*0.5)*y0 + 4*dy_main + 3*dy_res, dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_amb_mag_raw) - 20*np.log10(s11_amb_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.01,0.01])
		ax.set_yticks([-0.005, 0.005])
		plt.ylabel('$\Delta$ [dB]')


		ax = f1.add_axes([1*x0,                (1 + 3*0.5)*y0 + 3*dy_main + 3*dy_res, dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_amb_mag),'k')
		plt.ylabel('magnitude [dB]')
		ax.set_xticklabels('')
		plt.ylim([-39.6,-38.4])
		ax.set_yticks(np.arange(-39.6,-38.4,0.2))
		ax.set_yticklabels(['','-39.4','-39.2','-39.0','-38.8','-38.6'])
		ax.text(52,-38.6,'AMBIENT')
		ax.text(52,-38.8,'NTERMS: ' + str(len(par_s11_amb_mag)))

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 3*0.5)*y0 + 4*dy_main + 3*dy_res, dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_hot_mag_raw) - 20*np.log10(s11_hot_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.01,0.01])
		ax.set_yticks([-0.005, 0.005])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 3*0.5)*y0 + 3*dy_main + 3*dy_res, dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_hot_mag),'k')		
		ax.set_xticklabels('')
		plt.ylim([-38.6,-37.4])
		ax.set_yticks(np.arange(-38.6,-37.4,0.2))
		ax.set_yticklabels(['','-38.4','-38.2','-38.0','-37.8','-37.6'])		
		ax.text(52,-37.6,'HOT')
		ax.text(52,-37.8,'NTERMS: ' + str(len(par_s11_hot_mag)))		









		ax = f1.add_axes([1*x0,                (1 + 2*0.5)*y0 + 3*dy_main + 2*dy_res, dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_open_mag_raw) - 20*np.log10(s11_open_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.0008,0.0008])
		ax.set_yticks([-0.0004, 0.0004])
		plt.ylabel('$\Delta$ [dB]')


		ax = f1.add_axes([1*x0,                (1 + 2*0.5)*y0 + 2*dy_main + 2*dy_res, dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_open_mag),'k')
		plt.ylabel('magnitude [dB]')
		ax.set_xticklabels('')
		plt.ylim([-0.60,-0.35])
		ax.set_yticks(np.arange(-0.60,-0.35,0.05))
		ax.set_yticklabels(['','-0.55','-0.50','-0.45','-0.40',''])		
		ax.text(52,-0.52,'OPEN CABLE')
		ax.text(52,-0.56,'NTERMS: ' + str(len(par_s11_open_mag)))		


		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 2*0.5)*y0 + 3*dy_main + 2*dy_res, dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_shorted_mag_raw) - 20*np.log10(s11_shorted_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.0008,0.0008])
		ax.set_yticks([-0.0004, 0.0004])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 2*0.5)*y0 + 2*dy_main + 2*dy_res, dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_shorted_mag),'k')		
		ax.set_xticklabels('')
		plt.ylim([-0.65,-0.40])
		ax.set_yticks(np.arange(-0.65,-0.40,0.05))		
		ax.set_yticklabels(['','-0.60','-0.55','-0.50','-0.45',''])
		ax.text(52,-0.57,'SHORTED CABLE')
		ax.text(52,-0.61,'NTERMS: ' + str(len(par_s11_shorted_mag)))		








		ax = f1.add_axes([1*x0,                (1+0.5)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_sr_mag_raw) - 20*np.log10(s11_sr_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.12,0.12])
		ax.set_yticks([-0.06, 0.06])
		plt.ylabel('$\Delta$ [dB]')


		ax = f1.add_axes([1*x0,                (1+0.5)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_sr_mag),'k')
		plt.ylabel('magnitude [dB]')
		ax.set_xticklabels('')
		plt.ylim([-57,-51])
		ax.set_yticks(np.arange(-56,-51,1))
		ax.set_yticklabels(['-56','-55','-54','-53','-52'])
		ax.text(52,-52.1,'S11 SR')
		ax.text(52,-53,'NTERMS: ' + str(len(par_s11_sr_mag)))		

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+0.5)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(fs11, 20*np.log10(s12s21_sr_mag_raw) - 20*np.log10(s12s21_sr_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.0004,0.0004])
		ax.set_yticks([-0.0002, 0.0002])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+0.5)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(fe, 20*np.log10(s12s21_sr_mag),'k')		
		ax.set_xticklabels('')
		plt.ylim([-0.06,-0.03])
		ax.set_yticks(np.arange(-0.055,-0.03,0.005))
		ax.set_yticklabels(['-0.055','-0.050','-0.045','-0.040','-0.035'])		
		ax.text(52,-0.050,'S12xS21 SR')
		ax.text(52,-0.055,'NTERMS: ' + str(len(par_s12s21_sr_mag)))		












		ax = f1.add_axes([1*x0,                1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(fs11, 20*np.log10(s22_sr_mag_raw) - 20*np.log10(s22_sr_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.12,0.12])
		ax.set_yticks([-0.06, 0.06])
		plt.ylabel('$\Delta$ [dB]')


		ax = f1.add_axes([1*x0,                1*y0,             dx, dy_main])
		ax.plot(fe, 20*np.log10(s22_sr_mag),'k')
		plt.ylabel('magnitude [dB]')
		plt.xlabel('frequency [MHz]')
		plt.ylim([-49.5,-46.5])
		ax.set_yticks(np.arange(-49,-46.5,0.5))
		ax.set_yticklabels(['-49.0','-48.5','-48.0','-47.5','-47.0'])			
		ax.text(52,-47,'S22 SR')
		ax.text(52,-47.5,'NTERMS: ' + str(len(par_s22_sr_mag)))			

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_LNA_mag_raw) - 20*np.log10(s11_LNA_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.06,0.06])
		ax.set_yticks([-0.03, 0.03])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0,             dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_LNA_mag),'k')		
		plt.xlabel('frequency [MHz]')
		plt.ylim([-39,-26])
		ax.set_yticks(np.arange(-38,-27,2))
		#ax.set_yticklabels(['-38','-37','-36','-35','-34','-33'])
		ax.text(52,-36.0,'LNA')
		ax.text(52,-37.8,'NTERMS: ' + str(len(par_s11_LNA_mag)))


		plt.savefig(path_plot_save + 's11_magnitude' + plot_flag + '.png', bbox_inches='tight')









		# Phase
		plt.close()


		size_x = 10
		size_y = 9
		x0 = 0.103
		y0 = 0.06
		dx = 0.4
		dy_main = 0.16
		dy_res  = 0.05


		f1  = plt.figure(num=1, figsize=(size_x, size_y))		



		ax = f1.add_axes([1*x0,                (1 + 3*0.5)*y0 + 4*dy_main + 3*dy_res, dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s11_amb_ang_raw) - (180/np.pi)*np.unwrap(s11_amb_ang_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.06,0.06])
		ax.set_yticks([-0.03, 0.03])
		plt.ylabel('$\Delta$ [deg]')


		ax = f1.add_axes([1*x0,                (1 + 3*0.5)*y0 + 3*dy_main + 3*dy_res, dx, dy_main])
		ax.plot(fe, (180/np.pi)*(s11_amb_ang),'k')
		plt.ylabel('phase [deg]')
		ax.set_xticklabels('')
		plt.ylim([-16,-4])
		ax.set_yticks(np.arange(-14,-4,2))
		ax.set_yticklabels(['-14','-12','-10','-8','-6'])
		ax.text(52,-12.2,'AMBIENT')
		ax.text(52,-14,'NTERMS: ' + str(len(par_s11_amb_ang)))

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 3*0.5)*y0 + 4*dy_main + 3*dy_res, dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s11_hot_ang_raw) - (180/np.pi)*np.unwrap(s11_hot_ang_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.06,0.06])
		ax.set_yticks([-0.03, 0.03])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 3*0.5)*y0 + 3*dy_main + 3*dy_res, dx, dy_main])
		ax.plot(fe, (180/np.pi)*(s11_hot_ang),'k')		
		ax.set_xticklabels('')
		plt.ylim([-16,-4])
		ax.set_yticks(np.arange(-14,-4,2))
		ax.set_yticklabels(['-14','-12','-10','-8','-6'])		
		ax.text(52,-12.2,'HOT')
		ax.text(52,-14,'NTERMS: ' + str(len(par_s11_hot_ang)))		









		ax = f1.add_axes([1*x0,                (1 + 2*0.5)*y0 + 3*dy_main + 2*dy_res, dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s11_open_ang_raw) - (180/np.pi)*np.unwrap(s11_open_ang_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.004,0.004])
		ax.set_yticks([-0.002, 0.002])
		plt.ylabel('$\Delta$ [deg]')


		ax = f1.add_axes([1*x0,                (1 + 2*0.5)*y0 + 2*dy_main + 2*dy_res, dx, dy_main])
		ax.plot(fe, (180/np.pi)*s11_open_ang,'k')
		plt.ylabel('phase [deg]')
		ax.set_xticklabels('')
		plt.ylim([-1200,0])
		ax.set_yticks(np.arange(-1000,0,200))
		ax.set_yticklabels(['-1000','-800','-600','-400','-200'])		
		ax.text(52,-810,'OPEN CABLE')
		ax.text(52,-1000,'NTERMS: ' + str(len(par_s11_open_ang)))		


		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 2*0.5)*y0 + 3*dy_main + 2*dy_res, dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s11_shorted_ang_raw) - (180/np.pi)*np.unwrap(s11_shorted_ang_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.004,0.004])
		ax.set_yticks([-0.002, 0.002])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 2*0.5)*y0 + 2*dy_main + 2*dy_res, dx, dy_main])
		ax.plot(fe, (180/np.pi)*s11_shorted_ang,'k')		
		ax.set_xticklabels('')
		plt.ylim([-1000,200])
		ax.set_yticks(np.arange(-800,200,200))		
		ax.set_yticklabels(['-800','-600','-400','-200','0'])
		ax.text(52,-610,'SHORTED CABLE')
		ax.text(52,-800,'NTERMS: ' + str(len(par_s11_shorted_ang)))		








		ax = f1.add_axes([1*x0,                (1+0.5)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s11_sr_ang_raw) - (180/np.pi)*np.unwrap(s11_sr_ang_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-1,1])
		ax.set_yticks([-0.5, 0.5])
		plt.ylabel('$\Delta$ [deg]')


		ax = f1.add_axes([1*x0,                (1+0.5)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(fe, (180/np.pi)*np.unwrap(s11_sr_ang),'k')
		plt.ylabel('phase [deg]')
		ax.set_xticklabels('')
		plt.ylim([10,60])
		ax.set_yticks(np.arange(20,60,10))
		ax.set_yticklabels(['20','30','40','50'])
		ax.text(52,26,'S11 SR')
		ax.text(52,18,'NTERMS: ' + str(len(par_s11_sr_ang)))		

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+0.5)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s12s21_sr_ang_raw) - (180/np.pi)*np.unwrap(s12s21_sr_ang_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.002,0.002])
		ax.set_yticks([-0.001, 0.001])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+0.5)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(fe, (180/np.pi)*np.unwrap(s12s21_sr_ang),'k')		
		ax.set_xticklabels('')
		plt.ylim([-35,-10])
		ax.set_yticks(np.arange(-30,-10,5))
		ax.set_yticklabels(['-30','-25','-20','-15'])		
		ax.text(52,-27,'S12xS21 SR')
		ax.text(52,-31.3,'NTERMS: ' + str(len(par_s12s21_sr_ang)))		












		ax = f1.add_axes([1*x0,                1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s22_sr_ang_raw) - (180/np.pi)*np.unwrap(s22_sr_ang_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.6,0.6])
		ax.set_yticks([-0.3, 0.3])
		plt.ylabel('$\Delta$ [deg]')


		ax = f1.add_axes([1*x0,                1*y0,             dx, dy_main])
		ax.plot(fe, (180/np.pi)*np.unwrap(s22_sr_ang),'k')
		plt.ylabel('phase [deg]')
		plt.xlabel('frequency [MHz]')
		plt.ylim([-5,20])
		ax.set_yticks(np.arange(0,20,5))
		ax.set_yticklabels(['0','5','10','15'])			
		ax.text(52,3,'S22 SR')
		ax.text(52,-1,'NTERMS: ' + str(len(par_s22_sr_ang)))			

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s11_LNA_ang_raw) - (180/np.pi)*np.unwrap(s11_LNA_ang_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.4,0.4])
		ax.set_yticks([-0.2, 0.2])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0,             dx, dy_main])
		ax.plot(fe, (180/np.pi)*np.unwrap(s11_LNA_ang),'k')		
		plt.xlabel('frequency [MHz]')
		plt.ylim([20,80])
		ax.set_yticks(np.arange(30,75,10))
		#ax.set_yticklabels(['85','90','95','100','105'])
		ax.text(52,40,'LNA')
		ax.text(52,30,'NTERMS: ' + str(len(par_s11_LNA_ang)))

		plt.savefig(path_plot_save + 's11_phase' + plot_flag + '.png', bbox_inches='tight')























		plt.close()

		# Simulators

		size_x = 10
		size_y = 4.5
		x0 = 0.1
		y0 = 0.12
		dx = 0.4
		dy_main = 0.3
		dy_res  = 0.1


		f1  = plt.figure(num=1, figsize=(size_x, size_y))			



		ax = f1.add_axes([1*x0,                (1+0.5)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_simu1_mag_raw) - 20*np.log10(s11_simu1_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.0008,0.0008])
		ax.set_yticks([-0.0004, 0.0004])
		plt.ylabel('$\Delta$ [dB]')		

		ax = f1.add_axes([1*x0,                (1+0.5)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_simu1_mag),'k')
		plt.ylabel('magnitude [dB]')
		ax.set_xticklabels('')
		plt.ylim([-11.85,-11.55])
		ax.set_yticks(np.arange(-11.80,-11.55,0.05))
		ax.set_yticklabels(['-11.80','-11.75','-11.70','-11.65','-11.60'])
		ax.text(52,-11.75,'SIMU1')
		ax.text(52,-11.80,'NTERMS: ' + str(len(par_s11_simu1_mag)))		

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+0.5)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_simu2_mag_raw) - 20*np.log10(s11_simu2_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.0008,0.0008])
		ax.set_yticks([-0.0004, 0.0004])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+0.5)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_simu2_mag),'k')		
		ax.set_xticklabels('')
		plt.ylim([-12.15,-11.85])
		ax.set_yticks(np.arange(-12.10,-11.86,0.05))
		#ax.set_yticklabels(['-12.05','-12.00','-11.95','-11.90','-11.85'])		
		ax.text(52,-12.05,'SIMU2')
		ax.text(52,-12.10,'NTERMS: ' + str(len(par_s11_simu2_mag)))		







		ax = f1.add_axes([1*x0,                1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s11_simu1_ang_raw) - (180/np.pi)*np.unwrap(s11_simu1_ang_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.004,0.004])
		ax.set_yticks([-0.002, 0.002])
		plt.ylabel('$\Delta$ [deg]')


		ax = f1.add_axes([1*x0,                1*y0,             dx, dy_main])
		ax.plot(fe, (180/np.pi)*np.unwrap(s11_simu1_ang),'k')
		plt.ylabel('phase [deg]')
		plt.xlabel('frequency [MHz]')
		plt.ylim([-100,150])
		ax.set_yticks(np.arange(-50,150,50))
		ax.set_yticklabels(['-50','0','50','100'])			
		ax.text(52,-10,'SIMU1')
		ax.text(52,-50,'NTERMS: ' + str(len(par_s11_simu1_ang)))			

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s11_simu2_ang_raw) - (180/np.pi)*np.unwrap(s11_simu2_ang_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.008,0.008])
		ax.set_yticks([-0.004, 0.004])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0,             dx, dy_main])
		ax.plot(fe, (180/np.pi)*np.unwrap(s11_simu2_ang),'k')		
		plt.xlabel('frequency [MHz]')
		plt.ylim([-600,0])
		ax.set_yticks(np.arange(-500,0,100))
		ax.set_yticklabels(['-500','-400','-300','-200','-100'])
		ax.text(52,-400,'SIMU2')
		ax.text(52,-500,'NTERMS: ' + str(len(par_s11_simu2_ang)))


		plt.savefig(path_plot_save + 's11_simulators' + plot_flag + '.png', bbox_inches='tight')			
		plt.close()		


















	if (plots == 'yes') and (band == 'mid_band_2017'):


		# Plots
		plt.close()
		plt.close()
		plt.close()
		plt.close()
		plt.close()
		plt.close()
		plt.close()
		plt.close()








	
		# Magnitude
	
		size_x = 10
		size_y = 9
		x0 = 0.1
		y0 = 0.06
		dx = 0.4
		dy_main = 0.16
		dy_res  = 0.05
		dyy   = 1
	
	
		f1  = plt.figure(num=1, figsize=(size_x, size_y))		
	
	
	
		ax = f1.add_axes([1*x0,                (1 + 3*dyy)*y0 + 4*dy_main + 3*dy_res, dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_amb_mag_raw) - 20*np.log10(s11_amb_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.01,0.01])
		plt.xlim([60, 120])
		ax.set_yticks([-0.005, 0.005])
		plt.ylabel('$\Delta$ [dB]')
		plt.title('AMBIENT, NTERMS: ' + str(len(par_s11_amb_mag)))		
	
	
		ax = f1.add_axes([1*x0,                (1 + 3*dyy)*y0 + 3*dy_main + 3*dy_res, dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_amb_mag),'k')
		plt.ylabel('magnitude [dB]')
		ax.set_xticklabels('')
		#plt.ylim([-39.6,-38.4])
		plt.xlim([60, 120])
		#ax.set_yticks(np.arange(-39.6,-38.4,0.2))
		#ax.set_yticklabels(['','-39.4','-39.2','-39.0','-38.8','-38.6'])
		#ax.text(52,-38.6,'AMBIENT')
		#ax.text(52,-38.8,'NTERMS: ' + str(len(par_s11_amb_mag)))
	
		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 3*dyy)*y0 + 4*dy_main + 3*dy_res, dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_hot_mag_raw) - 20*np.log10(s11_hot_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.01,0.01])
		plt.xlim([60, 120])
		ax.set_yticks([-0.005, 0.005])
		plt.title('HOT, NTERMS: ' + str(len(par_s11_hot_mag)))
	
		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 3*dyy)*y0 + 3*dy_main + 3*dy_res, dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_hot_mag),'k')		
		ax.set_xticklabels('')
		#plt.ylim([-38.6,-37.4])
		plt.xlim([60, 120])
		#ax.set_yticks(np.arange(-38.6,-37.4,0.2))
		#ax.set_yticklabels(['','-38.4','-38.2','-38.0','-37.8','-37.6'])		
		#ax.text(52,-37.6,'HOT')
		#ax.text(52,-37.8,'NTERMS: ' + str(len(par_s11_hot_mag)))		
	
	
	
	
	
	
	
	
	
		ax = f1.add_axes([1*x0,                (1 + 2*dyy)*y0 + 3*dy_main + 2*dy_res, dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_open_mag_raw) - 20*np.log10(s11_open_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.0008,0.0008])
		plt.xlim([60, 120])
		ax.set_yticks([-0.0004, 0.0004])
		plt.ylabel('$\Delta$ [dB]')
		plt.title('OPEN CABLE, NTERMS: ' + str(len(par_s11_open_mag)))		
	
	
		ax = f1.add_axes([1*x0,                (1 + 2*dyy)*y0 + 2*dy_main + 2*dy_res, dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_open_mag),'k')
		plt.ylabel('magnitude [dB]')
		ax.set_xticklabels('')
		#plt.ylim([-0.60,-0.35])
		plt.xlim([60, 120])
		#ax.set_yticks(np.arange(-0.60,-0.35,0.05))
		#ax.set_yticklabels(['','-0.55','-0.50','-0.45','-0.40',''])		
	
	
	
		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 2*dyy)*y0 + 3*dy_main + 2*dy_res, dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_shorted_mag_raw) - 20*np.log10(s11_shorted_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.0008,0.0008])
		plt.xlim([60, 120])
		ax.set_yticks([-0.0004, 0.0004])
		plt.title('SHORTED CABLE, NTERMS: ' + str(len(par_s11_shorted_mag)))
	
		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 2*dyy)*y0 + 2*dy_main + 2*dy_res, dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_shorted_mag),'k')		
		ax.set_xticklabels('')
		#plt.ylim([-0.65,-0.40])
		plt.xlim([60, 120])
		#ax.set_yticks(np.arange(-0.65,-0.40,0.05))		
		#ax.set_yticklabels(['','-0.60','-0.55','-0.50','-0.45',''])
	
	
	
	
	
	
	
	
	
		ax = f1.add_axes([1*x0,                (1+dyy)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_sr_mag_raw) - 20*np.log10(s11_sr_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.12,0.12])
		plt.xlim([60, 120])
		ax.set_yticks([-0.06, 0.06])
		plt.ylabel('$\Delta$ [dB]')
		plt.title('S11 SR, NTERMS: ' + str(len(par_s11_sr_mag)))			
	
	
		ax = f1.add_axes([1*x0,                (1+dyy)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_sr_mag),'k')
		plt.ylabel('magnitude [dB]')
		ax.set_xticklabels('')
		#plt.ylim([-57,-51])
		plt.xlim([60, 120])
		#ax.set_yticks(np.arange(-56,-51,1))
		#ax.set_yticklabels(['-56','-55','-54','-53','-52'])
	
	
		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+dyy)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(fs11, 20*np.log10(s12s21_sr_mag_raw) - 20*np.log10(s12s21_sr_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.0004,0.0004])
		plt.xlim([60, 120])
		ax.set_yticks([-0.0002, 0.0002])
		plt.title('S12xS21 SR, NTERMS: ' + str(len(par_s12s21_sr_mag)))		
	
		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+dyy)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(fe, 20*np.log10(s12s21_sr_mag),'k')		
		ax.set_xticklabels('')
		#plt.ylim([-0.06,-0.03])
		plt.xlim([60, 120])
		#ax.set_yticks(np.arange(-0.055,-0.03,0.005))
		#ax.set_yticklabels(['-0.055','-0.050','-0.045','-0.040','-0.035'])		
	
	
	
	
	
	
	
	
	
	
	
	
	
		ax = f1.add_axes([1*x0,                1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(fs11, 20*np.log10(s22_sr_mag_raw) - 20*np.log10(s22_sr_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.12,0.12])
		plt.xlim([60, 120])
		ax.set_yticks([-0.06, 0.06])
		plt.ylabel('$\Delta$ [dB]')
		plt.title('S22 SR, NTERMS: ' + str(len(par_s22_sr_mag)))			
	
	
		ax = f1.add_axes([1*x0,                1*y0,             dx, dy_main])
		ax.plot(fe, 20*np.log10(s22_sr_mag),'k')
		plt.ylabel('magnitude [dB]')
		plt.xlabel('frequency [MHz]')
		#plt.ylim([-49.5,-46.5])
		plt.xlim([60, 120])
		#ax.set_yticks(np.arange(-49,-46.5,0.5))
		#ax.set_yticklabels(['-49.0','-48.5','-48.0','-47.5','-47.0'])			
	
	
		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_LNA_mag_raw) - 20*np.log10(s11_LNA_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.06,0.06])
		plt.xlim([60, 120])
		ax.set_yticks([-0.03, 0.03])
		plt.title('LNA, NTERMS: ' + str(len(par_s11_LNA_mag)))		
	
		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0,             dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_LNA_mag),'k')		
		plt.xlabel('frequency [MHz]')
		#plt.ylim([-39,-26])
		plt.xlim([60, 120])
		#ax.set_yticks(np.arange(-38,-27,2))
		#ax.set_yticklabels(['-38','-37','-36','-35','-34','-33'])
	
	
	
		plt.savefig(path_plot_save + 's11_magnitude' + plot_flag + '.png', bbox_inches='tight')
















		# Phase
		plt.close()


		size_x = 10
		size_y = 9
		x0 = 0.103
		y0 = 0.06
		dx = 0.4
		dy_main = 0.16
		dy_res  = 0.05
		dyy = 1


		f1  = plt.figure(num=1, figsize=(size_x, size_y))		



		ax = f1.add_axes([1*x0,                (1 + 3*dyy)*y0 + 4*dy_main + 3*dy_res, dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s11_amb_ang_raw) - (180/np.pi)*np.unwrap(s11_amb_ang_raw_model) - ((180/np.pi)*np.unwrap(s11_amb_ang_raw) - (180/np.pi)*np.unwrap(s11_amb_ang_raw_model))[-1],'k')
		ax.set_xticklabels('')
		plt.ylim([-0.06,0.06])
		plt.xlim([60, 120])
		ax.set_yticks([-0.03, 0.03])
		plt.ylabel('$\Delta$ [deg]')
		plt.title('AMBIENT, NTERMS: ' + str(len(par_s11_amb_ang)))		

		ax = f1.add_axes([1*x0,                (1 + 3*dyy)*y0 + 3*dy_main + 3*dy_res, dx, dy_main])
		ax.plot(fe, (180/np.pi)*(s11_amb_ang),'k')
		plt.ylabel('phase [deg]')
		ax.set_xticklabels('')
		#plt.ylim([-16,-4])
		plt.xlim([60, 120])
		#ax.set_yticks(np.arange(-14,-4,2))
		#ax.set_yticklabels(['-14','-12','-10','-8','-6'])



		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 3*dyy)*y0 + 4*dy_main + 3*dy_res, dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s11_hot_ang_raw) - (180/np.pi)*np.unwrap(s11_hot_ang_raw_model) - ((180/np.pi)*np.unwrap(s11_hot_ang_raw) - (180/np.pi)*np.unwrap(s11_hot_ang_raw_model))[-1],'k')
		ax.set_xticklabels('')
		plt.ylim([-0.06,0.06])
		plt.xlim([60, 120])
		ax.set_yticks([-0.03, 0.03])
		plt.title('HOT, NTERMS: ' + str(len(par_s11_hot_ang)))		

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 3*dyy)*y0 + 3*dy_main + 3*dy_res, dx, dy_main])
		ax.plot(fe, (180/np.pi)*(s11_hot_ang),'k')		
		ax.set_xticklabels('')
		#plt.ylim([-16,-4])
		plt.xlim([60, 120])
		#ax.set_yticks(np.arange(-14,-4,2))
		#ax.set_yticklabels(['-14','-12','-10','-8','-6'])		
				









		ax = f1.add_axes([1*x0,                (1 + 2*dyy)*y0 + 3*dy_main + 2*dy_res, dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s11_open_ang_raw) - (180/np.pi)*np.unwrap(s11_open_ang_raw_model) - ((180/np.pi)*np.unwrap(s11_open_ang_raw) - (180/np.pi)*np.unwrap(s11_open_ang_raw_model))[-1],'k')
		ax.set_xticklabels('')
		plt.ylim([-0.004,0.004])
		plt.xlim([60, 120])
		ax.set_yticks([-0.002, 0.002])
		plt.ylabel('$\Delta$ [deg]')
		plt.title('OPEN CABLE, NTERMS: ' + str(len(par_s11_open_ang)))	

		ax = f1.add_axes([1*x0,                (1 + 2*dyy)*y0 + 2*dy_main + 2*dy_res, dx, dy_main])
		ax.plot(fe, (180/np.pi)*s11_open_ang,'k')
		plt.ylabel('phase [deg]')
		ax.set_xticklabels('')
		#plt.ylim([-1200,0])
		plt.xlim([60, 120])
		#ax.set_yticks(np.arange(-1000,0,200))
		#ax.set_yticklabels(['-1000','-800','-600','-400','-200'])		
		


		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 2*dyy)*y0 + 3*dy_main + 2*dy_res, dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s11_shorted_ang_raw) - (180/np.pi)*np.unwrap(s11_shorted_ang_raw_model) - ((180/np.pi)*np.unwrap(s11_shorted_ang_raw) - (180/np.pi)*np.unwrap(s11_shorted_ang_raw_model))[-1],'k')
		ax.set_xticklabels('')
		plt.ylim([-0.004,0.004])
		plt.xlim([60, 120])
		ax.set_yticks([-0.002, 0.002])
		plt.title('SHORTED CABLE, NTERMS: ' + str(len(par_s11_shorted_ang)))

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 2*dyy)*y0 + 2*dy_main + 2*dy_res, dx, dy_main])
		ax.plot(fe, (180/np.pi)*s11_shorted_ang,'k')		
		ax.set_xticklabels('')
		#plt.ylim([-1000,200])
		plt.xlim([60, 120])
		#ax.set_yticks(np.arange(-800,200,200))		
		#ax.set_yticklabels(['-800','-600','-400','-200','0'])
		








		ax = f1.add_axes([1*x0,                (1+dyy)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s11_sr_ang_raw) - (180/np.pi)*np.unwrap(s11_sr_ang_raw_model) - ((180/np.pi)*np.unwrap(s11_sr_ang_raw) - (180/np.pi)*np.unwrap(s11_sr_ang_raw_model))[-1],'k')
		ax.set_xticklabels('')
		plt.ylim([-1,1])
		plt.xlim([60, 120])
		ax.set_yticks([-0.5, 0.5])
		plt.ylabel('$\Delta$ [deg]')
		plt.title('S11 SR, NTERMS: ' + str(len(par_s11_sr_ang)))		


		ax = f1.add_axes([1*x0,                (1+dyy)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(fe, (180/np.pi)*np.unwrap(s11_sr_ang),'k')
		plt.ylabel('phase [deg]')
		ax.set_xticklabels('')
		#plt.ylim([10,60])
		plt.xlim([60, 120])
		#ax.set_yticks(np.arange(20,60,10))
		#ax.set_yticklabels(['20','30','40','50'])
		

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+dyy)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s12s21_sr_ang_raw) - (180/np.pi)*np.unwrap(s12s21_sr_ang_raw_model) - ((180/np.pi)*np.unwrap(s12s21_sr_ang_raw) - (180/np.pi)*np.unwrap(s12s21_sr_ang_raw_model))[-1],'k')
		ax.set_xticklabels('')
		plt.ylim([-0.002,0.002])
		plt.xlim([60, 120])
		ax.set_yticks([-0.001, 0.001])
		plt.title('S12xS21 SR, NTERMS: ' + str(len(par_s12s21_sr_ang)))			

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+dyy)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(fe, (180/np.pi)*np.unwrap(s12s21_sr_ang),'k')		
		ax.set_xticklabels('')
		#plt.ylim([-35,-10])
		plt.xlim([60, 120])
		#ax.set_yticks(np.arange(-30,-10,5))
		#ax.set_yticklabels(['-30','-25','-20','-15'])		
	












		ax = f1.add_axes([1*x0,                1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s22_sr_ang_raw) - (180/np.pi)*np.unwrap(s22_sr_ang_raw_model) - ((180/np.pi)*np.unwrap(s22_sr_ang_raw) - (180/np.pi)*np.unwrap(s22_sr_ang_raw_model))[-1],'k')
		ax.set_xticklabels('')
		plt.ylim([-0.6,0.6])
		plt.xlim([60, 120])
		ax.set_yticks([-0.3, 0.3])
		plt.ylabel('$\Delta$ [deg]')
		plt.title('S22 SR, NTERMS: ' + str(len(par_s22_sr_ang)))		

		ax = f1.add_axes([1*x0,                1*y0,             dx, dy_main])
		ax.plot(fe, (180/np.pi)*np.unwrap(s22_sr_ang),'k')
		plt.ylabel('phase [deg]')
		plt.xlabel('frequency [MHz]')
		#plt.ylim([-5,20])
		plt.xlim([60, 120])
		#ax.set_yticks(np.arange(0,20,5))
		#ax.set_yticklabels(['0','5','10','15'])			
			

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s11_LNA_ang_raw) - (180/np.pi)*np.unwrap(s11_LNA_ang_raw_model) - ((180/np.pi)*np.unwrap(s11_LNA_ang_raw) - (180/np.pi)*np.unwrap(s11_LNA_ang_raw_model))[-1],'k')
		ax.set_xticklabels('')
		plt.ylim([-0.4,0.4])
		plt.xlim([60, 120])
		ax.set_yticks([-0.2, 0.2])
		plt.title('LNA, NTERMS: ' + str(len(par_s11_LNA_ang)))	

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0,             dx, dy_main])
		ax.plot(fe, (180/np.pi)*np.unwrap(s11_LNA_ang),'k')		
		plt.xlabel('frequency [MHz]')
		#plt.ylim([20,80])
		plt.xlim([60, 120])
		#ax.set_yticks(np.arange(30,75,10))
		#ax.set_yticklabels(['85','90','95','100','105'])


		plt.savefig(path_plot_save + 's11_phase' + plot_flag + '.png', bbox_inches='tight')























		plt.close()

		# Simulators

		size_x = 10
		size_y = 4.5
		x0 = 0.1
		y0 = 0.12
		dx = 0.4
		dy_main = 0.3
		dy_res  = 0.1


		f1  = plt.figure(num=1, figsize=(size_x, size_y))			



		ax = f1.add_axes([1*x0,                (1+0.5)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_simu1_mag_raw) - 20*np.log10(s11_simu1_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.0008,0.0008])
		plt.xlim([60, 120])
		ax.set_yticks([-0.0004, 0.0004])
		plt.ylabel('$\Delta$ [dB]')
		plt.title('SIMU1, NTERMS: ' + str(len(par_s11_simu1_mag)))			

		ax = f1.add_axes([1*x0,                (1+0.5)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_simu1_mag),'k')
		plt.ylabel('magnitude [dB]')
		ax.set_xticklabels('')
		#plt.ylim([-11.85,-11.55])
		plt.xlim([60, 120])
		#ax.set_yticks(np.arange(-11.80,-11.55,0.05))
		#ax.set_yticklabels(['-11.80','-11.75','-11.70','-11.65','-11.60'])
	

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+0.5)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(fs11, 20*np.log10(s11_simu2_mag_raw) - 20*np.log10(s11_simu2_mag_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.0008,0.0008])
		plt.xlim([60, 120])
		ax.set_yticks([-0.0004, 0.0004])
		plt.title('SIMU2, NTERMS: ' + str(len(par_s11_simu2_mag)))		

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+0.5)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(fe, 20*np.log10(s11_simu2_mag),'k')		
		ax.set_xticklabels('')
		#plt.ylim([-12.15,-11.85])
		plt.xlim([60, 120])
		#ax.set_yticks(np.arange(-12.10,-11.86,0.05))
		#ax.set_yticklabels(['-12.05','-12.00','-11.95','-11.90','-11.85'])		
		







		ax = f1.add_axes([1*x0,                1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s11_simu1_ang_raw) - (180/np.pi)*np.unwrap(s11_simu1_ang_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.008, 0.008])
		plt.xlim([60, 120])
		ax.set_yticks([-0.004, 0.004])
		plt.ylabel('$\Delta$ [deg]')


		ax = f1.add_axes([1*x0,                1*y0,             dx, dy_main])
		ax.plot(fe, (180/np.pi)*np.unwrap(s11_simu1_ang),'k')
		plt.ylabel('phase [deg]')
		plt.xlabel('frequency [MHz]')
		plt.xlim([60, 120])
		#plt.ylim([-100,150])
		#ax.set_yticks(np.arange(-50,150,50))
		#ax.set_yticklabels(['-50','0','50','100'])			

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(fs11, (180/np.pi)*np.unwrap(s11_simu2_ang_raw) - (180/np.pi)*np.unwrap(s11_simu2_ang_raw_model),'k')
		ax.set_xticklabels('')
		plt.ylim([-0.008,0.008])
		plt.xlim([60, 120])
		ax.set_yticks([-0.004, 0.004])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0,             dx, dy_main])
		ax.plot(fe, (180/np.pi)*np.unwrap(s11_simu2_ang),'k')		
		plt.xlabel('frequency [MHz]')
		plt.xlim([60, 120])
		#plt.ylim([-600,0])
		#ax.set_yticks(np.arange(-500,0,100))
		#ax.set_yticklabels(['-500','-400','-300','-200','-100'])


		plt.savefig(path_plot_save + 's11_simulators' + plot_flag + '.png', bbox_inches='tight')			
		plt.close()		









	return output












def models_calibration_spectra(band, calibration_temperature, f, receiver_reflection='actual', MC_spectra_noise=np.zeros(6), plots='no'):



	if receiver_reflection == 'actual':

		if band == 'low_band_2015':
			# Path
			path_root      = home_folder + ''
			path_par_spec  = path_root + '/DATA/EDGES/calibration/receiver_calibration/calibration_august_2015/LNA/models/25degC/spectra/'
			path_data      = path_root + '/DATA/EDGES/calibration/receiver_calibration/calibration_august_2015/LNA/models/25degC/data/'
			path_plot_save = path_root + '/DATA/EDGES/calibration/receiver_calibration/calibration_august_2015/LNA/models/25degC/plots/'

			# Normalized frequency
			fn = (f - 75)/25


			# Loading parameters
			par_spec_amb        = np.genfromtxt(path_par_spec + 'par_spec_amb.txt')
			par_spec_hot        = np.genfromtxt(path_par_spec + 'par_spec_hot.txt')
			par_spec_open       = np.genfromtxt(path_par_spec + 'par_spec_open.txt')
			par_spec_shorted    = np.genfromtxt(path_par_spec + 'par_spec_shorted.txt')
			par_spec_simu1      = np.genfromtxt(path_par_spec + 'par_spec_simu1.txt')
			par_spec_simu2      = np.genfromtxt(path_par_spec + 'par_spec_simu2.txt')
			RMS_spec	    = np.genfromtxt(path_par_spec + 'RMS_spec.txt')


			# Evaluating models
			Tae  = model_evaluate('polynomial', par_spec_amb,     fn)
			The  = model_evaluate('polynomial', par_spec_hot,     fn)
			Toe  = model_evaluate('fourier',    par_spec_open,    fn)
			Tse  = model_evaluate('fourier',    par_spec_shorted, fn)
			Ts1e = model_evaluate('polynomial', par_spec_simu1,   fn)
			Ts2e = model_evaluate('polynomial', par_spec_simu2,   fn)




		if band == 'high_band_2015':
			# Path
			path_root      = home_folder + ''
			if calibration_temperature == 25:
				path_par_spec  = path_root + '/DATA/EDGES/calibration/receiver_calibration/calibration_march_2015/LNA/models/25degC/spectra/'
				path_data      = path_root + '/DATA/EDGES/calibration/receiver_calibration/calibration_march_2015/LNA/models/25degC/data/'
				path_plot_save = path_root + '/DATA/EDGES/calibration/receiver_calibration/calibration_march_2015/LNA/models/25degC/plots/'

			elif calibration_temperature == 35:
				path_par_spec  = path_root + '/DATA/EDGES/calibration/receiver_calibration/calibration_march_2015/LNA/models/35degC/spectra/'
				path_data      = path_root + '/DATA/EDGES/calibration/receiver_calibration/calibration_march_2015/LNA/models/35degC/data/'
				path_plot_save = path_root + '/DATA/EDGES/calibration/receiver_calibration/calibration_march_2015/LNA/models/35degC/plots/'


			# Normalized frequency
			fn = (f - 140)/60


			# Loading parameters
			par_spec_amb        = np.genfromtxt(path_par_spec + 'par_spec_amb.txt')
			par_spec_hot        = np.genfromtxt(path_par_spec + 'par_spec_hot.txt')
			par_spec_open       = np.genfromtxt(path_par_spec + 'par_spec_open.txt')
			par_spec_shorted    = np.genfromtxt(path_par_spec + 'par_spec_shorted.txt')
			par_spec_simu1      = np.genfromtxt(path_par_spec + 'par_spec_simu1.txt')
			par_spec_simu2      = np.genfromtxt(path_par_spec + 'par_spec_simu2.txt')
			RMS_spec	    = np.genfromtxt(path_par_spec + 'RMS_spec.txt')


			# Evaluating models
			Tae  = model_evaluate('polynomial', par_spec_amb,     fn)
			The  = model_evaluate('polynomial', par_spec_hot,     fn)
			Toe  = model_evaluate('fourier',    par_spec_open,    fn)
			Tse  = model_evaluate('fourier',    par_spec_shorted, fn)
			Ts1e = model_evaluate('fourier',    par_spec_simu1,   fn)
			Ts2e = model_evaluate('fourier',    par_spec_simu2,   fn)


		# RMS noise
		RMS_Tae  = RMS_spec[0]
		RMS_The  = RMS_spec[1]
		RMS_Toe  = RMS_spec[2]
		RMS_Tse  = RMS_spec[3]
		RMS_Ts1e = RMS_spec[4]
		RMS_Ts2e = RMS_spec[5]



		# Adding noise to models
		if MC_spectra_noise[0] > 0:
			Tae  = Tae  + MC_spectra_noise[0] * np.random.normal(0, np.ones(len(fn))) * RMS_Tae

		if MC_spectra_noise[1] > 0:
			The  = The  + MC_spectra_noise[1] * np.random.normal(0, np.ones(len(fn))) * RMS_The	

		if MC_spectra_noise[2] > 0:
			Toe  = Toe  + MC_spectra_noise[2] * np.random.normal(0, np.ones(len(fn))) * RMS_Toe

		if MC_spectra_noise[3] > 0:
			Tse  = Tse  + MC_spectra_noise[3] * np.random.normal(0, np.ones(len(fn))) * RMS_Tse	

		if MC_spectra_noise[4] > 0:
			Ts1e = Ts1e + MC_spectra_noise[4] * np.random.normal(0, np.ones(len(fn))) * RMS_Ts1e

		if MC_spectra_noise[5] > 0:
			Ts2e = Ts2e + MC_spectra_noise[5] * np.random.normal(0, np.ones(len(fn))) * RMS_Ts2e







	# This is considered for simulation purposes only

	if receiver_reflection == 'minus30dB':

		# Physical temperatures
		out = models_calibration_physical_temperature(band, f)
		Ta  = out[0]
		Thd = out[1]
		To  = out[2]
		Ts  = out[3]


		# Reflection coefficients
		out = models_calibration_s11(band, f, receiver_reflection=receiver_reflection)
		rl_minus30dB = out[0]
		ra           = out[1]
		rh           = out[2]
		ro           = out[3]
		rs           = out[4]


		# Calibration quantities
		out = models_LNA(band, f, spectra_data_model='model')
		sca = out[1]
		off = out[2]
		TU  = out[3]
		TC  = out[4]
		TS  = out[5]


		# Uncalibrated spectra
		Tae  = uncalibrated_antenna_temperature(Ta,  ra, rl_minus30dB, sca, off, TU, TC, TS)
		The  = uncalibrated_antenna_temperature(Thd, rh, rl_minus30dB, sca, off, TU, TC, TS)
		Toe  = uncalibrated_antenna_temperature(To,  ro, rl_minus30dB, sca, off, TU, TC, TS)
		Tse  = uncalibrated_antenna_temperature(Ts,  rs, rl_minus30dB, sca, off, TU, TC, TS)
		Ts1e = np.zeros(len(f))
		Ts2e = np.zeros(len(f))


	# Output
	output = np.array([Tae, The, Toe, Tse, Ts1e, Ts2e])












	# Plots
	if (plots == 'yes') and (band == 'low_band_2015'):

		data     = np.genfromtxt(path_data + 'average_spectra_300_350.txt')
		Tae_raw  = data[:,1]
		The_raw  = data[:,2]
		Toe_raw  = data[:,3]
		Tse_raw  = data[:,4]
		Ts1e_raw = data[:,5]
		Ts2e_raw = data[:,6]		


		# Magnitude

		size_x = 10
		size_y = 9
		x0 = 0.1
		y0 = 0.06
		dx = 0.4
		dy_main = 0.16
		dy_res  = 0.05


		f1  = plt.figure(num=1, figsize=(size_x, size_y))		




		ax = f1.add_axes([1*x0,                (1 + 2*0.5)*y0 + 3*dy_main + 2*dy_res, dx, dy_res])
		ax.plot(f, Tae_raw - Tae,'k')
		ax.set_xticklabels('')
		plt.ylim([-0.2,0.2])
		ax.set_yticks([-0.1, 0.1])
		plt.ylabel('$\Delta$T [K]')


		ax = f1.add_axes([1*x0,                (1 + 2*0.5)*y0 + 2*dy_main + 2*dy_res, dx, dy_main])
		ax.plot(f, Tae,'k')
		plt.ylabel('T [K]')
		ax.set_xticklabels('')
		plt.ylim([298,299])
		ax.set_yticks(np.arange(298.2,298.8,0.2))
		#ax.set_yticklabels(['-0.85','-0.80','-0.75','-0.70','-0.65','-0.60','-0.55'])		
		ax.text(52,298.25,'AMBIENT')
		ax.text(52,298.12,'NTERMS: ' + str(len(par_spec_amb)))		


		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 2*0.5)*y0 + 3*dy_main + 2*dy_res, dx, dy_res])
		ax.plot(f, The_raw - The,'k')
		ax.set_xticklabels('')
		plt.ylim([-0.2,0.2])
		ax.set_yticks([-0.1, 0.1])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 2*0.5)*y0 + 2*dy_main + 2*dy_res, dx, dy_main])
		ax.plot(f, The,'k')		
		ax.set_xticklabels('')
		plt.ylim([318,326])
		ax.set_yticks(np.arange(319,326,2))		
		#ax.set_yticklabels(['-0.90','-0.85','-0.80','-0.75','-0.70','-0.65','-0.60','-0.55'])
		ax.text(52,324,'HOT')
		ax.text(52,323,'NTERMS: ' + str(len(par_spec_hot)))		








		ax = f1.add_axes([1*x0,                (1+0.5)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(f, Toe_raw - Toe,'k')
		ax.set_xticklabels('')
		plt.ylim([-0.2,0.2])
		ax.set_yticks([-0.1, 0.1])
		plt.ylabel('$\Delta$T [K]')


		ax = f1.add_axes([1*x0,                (1+0.5)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(f, Toe,'k')
		plt.ylabel('T [K]')
		ax.set_xticklabels('')
		plt.ylim([264,284])
		ax.set_yticks(np.arange(268,284,4))
		#ax.set_yticklabels(['-56','-49','-54','-53','-52'])
		ax.text(52,269,'OPEN CABLE')
		ax.text(52,266.5,'NTERMS: ' + str(len(par_spec_open)))		

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+0.5)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(f, Tse_raw - Tse,'k')
		ax.set_xticklabels('')
		plt.ylim([-0.2,0.2])
		ax.set_yticks([-0.1, 0.1])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+0.5)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(f, Tse,'k')		
		ax.set_xticklabels('')
		plt.ylim([264,284])
		ax.set_yticks(np.arange(268,284,4))
		#ax.set_yticklabels(['-0.08','-0.07','-0.06','-0.05'])		
		ax.text(52,269,'SHORTED CABLE')
		ax.text(52,266.5,'NTERMS: ' + str(len(par_spec_shorted)))		












		ax = f1.add_axes([1*x0,                1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(f, Ts1e_raw - Ts1e,'k')
		ax.set_xticklabels('')
		plt.ylim([-0.2,0.2])
		ax.set_yticks([-0.1, 0.1])
		plt.ylabel('$\Delta$T [K]')


		ax = f1.add_axes([1*x0,                1*y0,             dx, dy_main])
		ax.plot(f, Ts1e,'k')
		plt.ylabel('T [K]')
		plt.xlabel('frequency [MHz]')
		plt.ylim([295,299])
		ax.set_yticks(np.arange(296,299,1))
		#ax.set_yticklabels(['-49.0','-48.5','-48.0','-47.5','-47.0'])			
		ax.text(52,296,'SIMU1')
		ax.text(52,295.5,'NTERMS: ' + str(len(par_spec_simu1)))			

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(f, Ts2e_raw - Ts2e,'k')
		ax.set_xticklabels('')
		plt.ylim([-0.2,0.2])
		ax.set_yticks([-0.1, 0.1])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0,             dx, dy_main])
		ax.plot(f, Ts2e,'k')		
		plt.xlabel('frequency [MHz]')
		plt.ylim([295,299])
		ax.set_yticks(np.arange(296,299,1))
		#ax.set_yticklabels(['-38','-37','-36','-35','-34','-33'])
		ax.text(52,296,'SIMU2')
		ax.text(52,295.5,'NTERMS: ' + str(len(par_spec_simu2)))


		plt.savefig(path_plot_save + 'spectra.png', bbox_inches='tight')
		plt.close()





	if (plots == 'yes') and (band == 'high_band_2015'):

		data     = np.genfromtxt(path_data + 'average_spectra_300_350.txt')
		Tae_raw  = data[:,1]
		The_raw  = data[:,2]
		Toe_raw  = data[:,3]
		Tse_raw  = data[:,4]
		Ts1e_raw = data[:,5]
		Ts2e_raw = data[:,6]		


		# Magnitude

		size_x = 10
		size_y = 9
		x0 = 0.1
		y0 = 0.06
		dx = 0.4
		dy_main = 0.16
		dy_res  = 0.05


		f1  = plt.figure(num=1, figsize=(size_x, size_y))		




		ax = f1.add_axes([1*x0,                (1 + 2*0.5)*y0 + 3*dy_main + 2*dy_res, dx, dy_res])
		ax.plot(f, Tae_raw - Tae,'k')
		ax.set_xticklabels('')
		plt.ylim([-0.4,0.4])
		ax.set_yticks([-0.2, 0.2])
		plt.ylabel('$\Delta$T [K]')


		ax = f1.add_axes([1*x0,                (1 + 2*0.5)*y0 + 2*dy_main + 2*dy_res, dx, dy_main])
		ax.plot(f, Tae,'k')
		plt.ylabel('T [K]')
		ax.set_xticklabels('')
		plt.ylim([286,290])
		ax.set_yticks(np.arange(287,290,1))
		#ax.set_yticklabels(['-0.85','-0.80','-0.75','-0.70','-0.65','-0.60','-0.55'])		
		ax.text(85,287,   'AMBIENT')
		ax.text(85,286.5, 'NTERMS: ' + str(len(par_spec_amb)))		


		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 2*0.5)*y0 + 3*dy_main + 2*dy_res, dx, dy_res])
		ax.plot(f, The_raw - The,'k')
		ax.set_xticklabels('')
		plt.ylim([-0.4,0.4])
		ax.set_yticks([-0.2, 0.2])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1 + 2*0.5)*y0 + 2*dy_main + 2*dy_res, dx, dy_main])
		ax.plot(f, The,'k')		
		ax.set_xticklabels('')
		plt.ylim([409,415])
		ax.set_yticks(np.arange(410,415,1))		
		#ax.set_yticklabels(['-0.90','-0.85','-0.80','-0.75','-0.70','-0.65','-0.60','-0.55'])
		ax.text(85,413.8, 'HOT')
		ax.text(85,413,   'NTERMS: ' + str(len(par_spec_hot)))		








		ax = f1.add_axes([1*x0,                (1+0.5)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(f, Toe_raw - Toe,'k')
		ax.set_xticklabels('')
		plt.ylim([-0.4,0.4])
		ax.set_yticks([-0.2, 0.2])
		plt.ylabel('$\Delta$T [K]')


		ax = f1.add_axes([1*x0,                (1+0.5)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(f, Toe,'k')
		plt.ylabel('T [K]')
		ax.set_xticklabels('')
		plt.ylim([0,140])
		ax.set_yticks(np.arange(20,140,20))
		#ax.set_yticklabels(['-56','-49','-54','-53','-52'])
		ax.text(85,22,'OPEN')
		ax.text(85,7, 'NTERMS: ' + str(len(par_spec_open)))		

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+0.5)*y0 + 2*dy_main + 1*dy_res,   dx, dy_res])
		ax.plot(f, Tse_raw - Tse,'k')
		ax.set_xticklabels('')
		plt.ylim([-0.4,0.4])
		ax.set_yticks([-0.2, 0.2])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, (1+0.5)*y0 + 1*dy_main + 1*dy_res,   dx, dy_main])
		ax.plot(f, Tse,'k')		
		ax.set_xticklabels('')
		plt.ylim([0,140])
		ax.set_yticks(np.arange(20,140,20))
		#ax.set_yticklabels(['-0.08','-0.07','-0.06','-0.05'])		
		ax.text(85,22,'SHORTED')
		ax.text(85,7, 'NTERMS: ' + str(len(par_spec_shorted)))		












		ax = f1.add_axes([1*x0,                1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(f, Ts1e_raw - Ts1e,'k')
		ax.set_xticklabels('')
		plt.ylim([-0.4,0.4])
		ax.set_yticks([-0.2, 0.2])
		plt.ylabel('$\Delta$T [K]')


		ax = f1.add_axes([1*x0,                1*y0,             dx, dy_main])
		ax.plot(f, Ts1e,'k')
		plt.ylabel('T [K]')
		plt.xlabel('frequency [MHz]')
		plt.ylim([240,300])
		ax.set_yticks(np.arange(250,300,10))
		#ax.set_yticklabels(['-49.0','-48.5','-48.0','-47.5','-47.0'])			
		ax.text(85,290,'SIMU1')
		ax.text(85,280,'NTERMS: ' + str(len(par_spec_simu1)))			

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0 + 1*dy_main, dx, dy_res])
		ax.plot(f, Ts2e_raw - Ts2e,'k')
		ax.set_xticklabels('')
		plt.ylim([-0.4,0.4])
		ax.set_yticks([-0.2, 0.2])

		ax = f1.add_axes([(1 + 0.8)*x0 + 1*dx, 1*y0,             dx, dy_main])
		ax.plot(f, Ts2e,'k')
		plt.xlabel('frequency [MHz]')
		plt.ylim([240,300])
		ax.set_yticks(np.arange(250,300,10))
		#ax.set_yticklabels(['-38','-37','-36','-35','-34','-33'])
		ax.text(85,252,'SIMU2')
		ax.text(85,242,'NTERMS: ' + str(len(par_spec_simu2)))


		plt.savefig(path_plot_save + 'spectra.png', bbox_inches='tight')
		plt.close()


	return output









def models_calibration_physical_temperature(band, folder, calibration_temperature, f, s_parameters=np.zeros(1), MC_temp=np.zeros(6)):
	"""
	Last Modification: May 28, 2017

	"""

	# Choosing the band
	common_path = home_folder + '/DATA/EDGES/calibration/receiver_calibration/'





	if band == 'high_band_2015':

		# Paths
		if calibration_temperature == 25:
			path_temp    = common_path + 'high_band1/2015_03_25C/results/' + folder + '/temp/'
			path_s11     = common_path + 'high_band1/2015_03_25C/results/' + folder + '/s11/'

		if calibration_temperature == 35:
			path_temp    = common_path + 'high_band1/2015_03_35C/results/' + folder + '/temp/'
			path_s11     = common_path + 'high_band1/2015_03_35C/results/' + folder + '/s11/'



		# Normalized frequency
		fn = (f - 140)/60			








	if band == 'high_band_2017':

		if calibration_temperature == 25:
			path_temp    = common_path + 'high_band1/2017_01_25C/results/' + folder + '/temp/'
			path_s11     = common_path + 'high_band1/2017_01_25C/results/' + folder + '/s11/'

		# Normalized frequency
		fn = (f - 140)/60	







	if band == 'low_band_2015':

		# Paths
		path_temp    = common_path + 'low_band1/2015_08_25C/results/' + folder + '/temp/'
		path_s11     = common_path + 'low_band1/2015_08_25C/results/' + folder + '/s11/'	

		# Normalized frequency
		fn = (f - 75)/25




	if band == 'low_band_2015_2017_05':

		# Paths
		path_temp    = common_path + 'low_band1/2017_05_25C/results/' + folder + '/temp/'
		path_s11     = common_path + 'low_band1/2017_05_25C/results/' + folder + '/s11/'

		# Normalized frequency
		fn = (f - 75)/25




	if band == 'low_band_2015_2017_09':

		# Paths
		path_temp    = common_path + 'low_band1/2017_09_25C/results/' + folder + '/temp/'
		path_s11     = common_path + 'low_band1/2017_09_25C/results/' + folder + '/s11/'

		# Normalized frequency
		fn = (f - 75)/25







	if band == 'low_band2_2017':

		if calibration_temperature == 25:

			# Paths
			path_temp    = common_path + 'low_band2/2016_09_25C/results/' + folder + '/temp/'
			path_s11     = common_path + 'low_band2/2016_09_25C/results/' + folder + '/s11/'	

		if calibration_temperature == 15:

			# Paths
			path_temp    = common_path + 'low_band2/2016_11_15C/results/' + folder + '/temp/'
			path_s11     = common_path + 'low_band2/2016_11_15C/results/' + folder + '/s11/'

		if calibration_temperature == 35:

			# Paths
			path_temp    = common_path + 'low_band2/2016_11_35C/results/' + folder + '/temp/'
			path_s11     = common_path + 'low_band2/2016_11_35C/results/' + folder + '/s11/'

		# Normalized frequency
		fn = (f - 75)/25






	# Physical temperatures
	phys_temp = np.genfromtxt(path_temp + 'physical_temperatures.txt')
	Ta  = phys_temp[0] * np.ones(len(fn))
	Th  = phys_temp[1] * np.ones(len(fn))
	To  = phys_temp[2] * np.ones(len(fn))
	Ts  = phys_temp[3] * np.ones(len(fn))
	Ts1 = phys_temp[4] * np.ones(len(fn))
	Ts2 = phys_temp[5] * np.ones(len(fn))



	# MC realizations of physical temperatures
	STD_temp = 0.1
	if MC_temp[0] > 0:
		Ta  = (Ta  + MC_temp[0] * STD_temp * np.random.normal(0,1)) 

	if MC_temp[1] > 0:	
		Th  = (Th  + MC_temp[1] * STD_temp * np.random.normal(0,1)) #* np.ones(len(fn))	

	if MC_temp[2] > 0:	
		To  = (To  + MC_temp[2] * STD_temp * np.random.normal(0,1)) #* np.ones(len(fn))

	if MC_temp[3] > 0:
		Ts  = (Ts  + MC_temp[3] * STD_temp * np.random.normal(0,1)) #* np.ones(len(fn))

	if MC_temp[4] > 0:
		Ts1 = (Ts1 + MC_temp[4] * STD_temp * np.random.normal(0,1)) #* np.ones(len(fn))

	if MC_temp[5] > 0:
		Ts2 = (Ts2 + MC_temp[5] * STD_temp * np.random.normal(0,1)) #* np.ones(len(fn))




	# S-parameters of hot load device
	if len(s_parameters) == 1:
		out = models_calibration_s11(band, folder, calibration_temperature, f)
		rh        = out[2]
		s11_sr    = out[5]
		s12s21_sr = out[6]
		s22_sr    = out[7]

	if len(s_parameters) == 4:
		rh        = s_parameters[0]
		s11_sr    = s_parameters[1]
		s12s21_sr = s_parameters[2]
		s22_sr    = s_parameters[3]



	# Temperature of hot device

	# reflection coefficient of termination
	rht = rc.gamma_de_embed(s11_sr, s12s21_sr, s22_sr, rh)

	# inverting the direction of the s-parameters,
	# since the port labels have to be inverted to match those of Pozar eqn 10.25
	s11_sr_rev = s22_sr
	s22_sr_rev = s11_sr

	# absolute value of S_21
	abs_s21 = np.sqrt(np.abs(s12s21_sr))

	# available power gain
	G = ( abs_s21**2 ) * ( 1-np.abs(rht)**2 ) / ( (np.abs(1-s11_sr_rev*rht))**2 * (1-(np.abs(rh))**2) )

	# temperature
	Thd  = G*Th + (1-G)*Ta



	# Output
	output = np.array([Ta, Thd, To, Ts, Ts1, Ts2, (1-G)*Ta])

	return output













def calibration_quantities(band, f, Tae, The, Toe, Tse, rl, ra, rh, ro, rs, Ta, Th, To, Ts, Tamb_internal, cterms, wterms):



	# S11 quantities 
	Fa = np.sqrt( 1 - np.abs(rl) ** 2 ) / ( 1 - ra*rl ) 
	Fh = np.sqrt( 1 - np.abs(rl) ** 2 ) / ( 1 - rh*rl )

	PHIa = np.angle( ra*Fa )
	PHIh = np.angle( rh*Fh )

	G = 1 - np.abs(rl) ** 2

	K1a = (1 - np.abs(ra) **2) * np.abs(Fa) ** 2 / G
	K1h = (1 - np.abs(rh) **2) * np.abs(Fh) ** 2 / G

	K2a = (np.abs(ra) ** 2) * (np.abs(Fa) ** 2) / G
	K2h = (np.abs(rh) ** 2) * (np.abs(Fh) ** 2) / G

	K3a = (np.abs(ra) * np.abs(Fa) / G) * np.cos(PHIa)
	K3h = (np.abs(rh) * np.abs(Fh) / G) * np.cos(PHIh)

	K4a = (np.abs(ra) * np.abs(Fa) / G) * np.sin(PHIa)
	K4h = (np.abs(rh) * np.abs(Fh) / G) * np.sin(PHIh)



	# Initializing arrays
	niter = 4
	Ta_iter = np.zeros((niter, len(f)))
	Th_iter = np.zeros((niter, len(f)))

	sca = np.zeros((niter, len(f)))
	off = np.zeros((niter, len(f)))

	Tae_iter = np.zeros((niter, len(f)))
	The_iter = np.zeros((niter, len(f)))
	Toe_iter = np.zeros((niter, len(f)))
	Tse_iter = np.zeros((niter, len(f)))

	TU = np.zeros((niter, len(f)))
	TC = np.zeros((niter, len(f)))
	TS = np.zeros((niter, len(f)))



	# Frequency normalization
	if (band == 'high_band_2015') or (band == 'high_band_2017'):
		fn = (f-140)/60
	if band == 'low_band_2015':
		fn = (f-75)/25		
	if band == 'low_band_2015_2017_05':
		fn = (f-75)/25
	if band == 'low_band_2015_2017_09':
		fn = (f-75)/25
	if band == 'low_band2_2017':
		fn = (f-75)/25
	else:
		fn = np.copy(f)



	# Calibration loop
	for i in range(niter):

		print(i)

		# Step 1: approximate physical temperature
		if i == 0:
			Ta_iter[i,:] = Tae / K1a
			Th_iter[i,:] = The / K1h

		if i > 0:		
			NWPa = TU[i-1,:]*K2a + TC[i-1,:]*K3a + TS[i-1,:]*K4a
			NWPh = TU[i-1,:]*K2h + TC[i-1,:]*K3h + TS[i-1,:]*K4h			

			Ta_iter[i,:] = (Tae_iter[i-1,:] - NWPa) / K1a
			Th_iter[i,:] = (The_iter[i-1,:] - NWPh) / K1h	


		# Step 2: scale and offset

		# Updating scale and offset
		sca_new  = (Th - Ta) / (Th_iter[i,:] - Ta_iter[i,:])
		off_new  = Ta_iter[i,:] - Ta

		if i == 0:
			sca_raw = sca_new
			off_raw = off_new
		if i > 0:
			sca_raw = sca[i-1,:] * sca_new
			off_raw = off[i-1,:] + off_new

		# Modeling scale
		p_sca    = np.polyfit(fn, sca_raw, cterms-1)
		m_sca    = np.polyval(p_sca, fn)
		sca[i,:] = m_sca

		# Modeling offset
		p_off    = np.polyfit(fn, off_raw, cterms-1)
		m_off    = np.polyval(p_off, fn)		
		off[i,:] = m_off




		# Step 3: corrected "uncalibrated spectrum" of cable
		#Tamb_internal = 300  # same as used for 3-pos switch computation. BUT RESULTS DON'T CHANGE IF ANOTHER VALUE IS USED

		Tae_iter[i,:] = (Tae - Tamb_internal) * sca[i,:] + Tamb_internal - off[i,:]
		The_iter[i,:] = (The - Tamb_internal) * sca[i,:] + Tamb_internal - off[i,:]
		Toe_iter[i,:] = (Toe - Tamb_internal) * sca[i,:] + Tamb_internal - off[i,:]
		Tse_iter[i,:] = (Tse - Tamb_internal) * sca[i,:] + Tamb_internal - off[i,:]



		# Step 4: computing NWP
		TU[i,:], TC[i,:], TS[i,:] = NWP_fit(band, f, rl, ro, rs, Toe_iter[i,:], Tse_iter[i,:], To, Ts, wterms)

	return sca[-1,:], off[-1,:], TU[-1,:], TC[-1,:], TS[-1,:]










def NWP_fit(band, f, rl, ro, rs, Toe, Tse, To, Ts, wterms):


	# Frequency normalization
	if band == 'high_band_2015':
		fn = (f-140)/60
	if band == 'high_band_2017':
		fn = (f-140)/60	
	if band == 'low_band_2015':
		fn = (f-75)/25
	if band == 'low_band_2015_2017_05':
		fn = (f-75)/25
	if band == 'low_band_2015_2017_09':
		fn = (f-75)/25
	if band == 'low_band2_2017':
		fn = (f-75)/25		
	else:
		fn = np.copy(f)


	# S11 quantities
	Fo = np.sqrt( 1 - np.abs(rl) ** 2 ) / ( 1 - ro*rl ) 
	Fs = np.sqrt( 1 - np.abs(rl) ** 2 ) / ( 1 - rs*rl )

	PHIo = np.angle( ro*Fo )
	PHIs = np.angle( rs*Fs )

	G = 1 - np.abs(rl) ** 2

	K1o = (1 - np.abs(ro) ** 2) * (np.abs(Fo) ** 2) / G
	K1s = (1 - np.abs(rs) ** 2) * (np.abs(Fs) ** 2) / G

	K2o = (np.abs(ro) ** 2) * (np.abs(Fo) ** 2) / G
	K2s = (np.abs(rs) ** 2) * (np.abs(Fs) ** 2) / G

	K3o = (np.abs(ro) * np.abs(Fo) / G) * np.cos(PHIo)
	K3s = (np.abs(rs) * np.abs(Fs) / G) * np.cos(PHIs)

	K4o = (np.abs(ro) * np.abs(Fo) / G) * np.sin(PHIo)
	K4s = (np.abs(rs) * np.abs(Fs) / G) * np.sin(PHIs)



	# Matrices A and b
	A = np.zeros((3 * wterms, 2*len(fn)))
	for i in range(wterms):
		A[i, :] = np.append(K2o * fn ** i, K2s * fn ** i) 
		A[i + 1 * wterms, :] = np.append(K3o * fn ** i, K3s * fn ** i)
		A[i + 2 * wterms, :] = np.append(K4o * fn ** i, K4s * fn ** i)
	b = np.append( (Toe - To*K1o), (Tse - Ts*K1s) )

	# Transposing matrices so 'frequency' dimension is along columns
	M = A.T
	ydata = np.reshape(b, (-1,1))



	# Solving system using 'short' QR decomposition (see R. Butt, Num. Anal. Using MATLAB)
	Q1, R1 = sp.linalg.qr(M, mode='economic')
	param  = sp.linalg.solve(R1, np.dot(Q1.T, ydata))	



	# Evaluating TU, TC, and TS
	TU = np.zeros(len(fn))
	TC = np.zeros(len(fn))
	TS = np.zeros(len(fn))

	for i in range(wterms):
		TU = TU + param[i, 0] * fn ** i
		TC = TC + param[i+1*wterms, 0] * fn ** i
		TS = TS + param[i+2*wterms, 0] * fn ** i



	# Parameters
	pU = param[0:int(len(param) / 3), 0].T
	pC = param[int((len(param)/3)):int((2 * len(param) / 3)), 0].T
	pS = param[int((2 * len(param)/3)):int(len(param)), 0].T



	return TU, TC, TS







def calibrated_antenna_temperature(Tde, rd, rl, sca, off, TU, TC, TS, Tamb_internal=300):

	# S11 quantities
	Fd = np.sqrt( 1 - np.abs(rl) ** 2 ) / ( 1 - rd*rl )	
	PHId = np.angle( rd*Fd )
	G = 1 - np.abs(rl) ** 2
	K1d = (1 - np.abs(rd) **2) * np.abs(Fd) ** 2 / G
	K2d = (np.abs(rd) ** 2) * (np.abs(Fd) ** 2) / G
	K3d = (np.abs(rd) * np.abs(Fd) / G) * np.cos(PHId)
	K4d = (np.abs(rd) * np.abs(Fd) / G) * np.sin(PHId)


	# Applying scale and offset to raw spectrum
	Tde_corrected = (Tde - Tamb_internal)*sca + Tamb_internal - off

	# Noise wave contribution
	NWPd = TU*K2d + TC*K3d + TS*K4d

	# Antenna temperature
	Td = (Tde_corrected - NWPd) / K1d

	return Td





def uncalibrated_antenna_temperature(Td, rd, rl, sca, off, TU, TC, TS, Tamb_internal=300):

	# S11 quantities
	Fd = np.sqrt( 1 - np.abs(rl) ** 2 ) / ( 1 - rd*rl )
	PHId = np.angle( rd*Fd )
	G = 1 - np.abs(rl) ** 2
	K1d = (1 - np.abs(rd) **2) * np.abs(Fd) ** 2 / G
	K2d = (np.abs(rd) ** 2) * (np.abs(Fd) ** 2) / G
	K3d = (np.abs(rd) * np.abs(Fd) / G) * np.cos(PHId)
	K4d = (np.abs(rd) * np.abs(Fd) / G) * np.sin(PHId)	


	# Noise wave contribution
	NWPd = TU*K2d + TC*K3d + TS*K4d	

	# Scaled and offset spectrum 
	Tde_corrected = Td*K1d + NWPd

	# Removing scale and offset
	Tde = Tamb_internal + (Tde_corrected - Tamb_internal + off) / sca

	return Tde









def models_LNA(band, folder, calibration_temperature, f, Tamb_internal=300, cterms=7, wterms=7, hb_flow=90, hb_fhigh=190, data=np.zeros(1), spectra_data_model='data', receiver_reflection='actual', MC_spectra_noise=np.zeros(6), MC_s11_noise=np.zeros(20), MC_s11_syst=np.zeros(20), systematic_s11='uncorrelated', MC_temp=np.zeros(6), cross_check='no', plot_flag='_flag', save='no', save_flag='_change_flag'):

	"""
	Using this function to produce a calibration file:

	f, il, ih = eg.frequency_edges(90, 190)
	fe = f[il:ih+1]
	rl, c1_35, c2_35, tu_35, tc_35, ts_35 = eg.models_LNA('high_band', 35, fe, save='yes', save_flag='_35degC_v1_20160319')

	"""



	# Path and normalized frequency

	common_path = home_folder + '/DATA/EDGES/calibration/receiver_calibration/'


	if band == 'high_band_2015':

		# Paths
		if calibration_temperature == 25:
			path_save      = common_path + 'high_band1/2015_03_25C/results/' + folder + '/calibration_files/'
			path_data      = common_path + 'high_band1/2015_03_25C/results/' + folder + '/data/'				
			path_plot_save = common_path + 'high_band1/2015_03_25C/results/' + folder + '/plots/'

		elif calibration_temperature == 35:
			path_save      = common_path + 'high_band1/2015_03_35C/results/' + folder + '/calibration_files/'
			path_data      = common_path + 'high_band1/2015_03_35C/results/' + folder + '/data/'				
			path_plot_save = common_path + 'high_band1/2015_03_35C/results/' + folder + '/plots/'

		# Normalized frequency
		fn = (f - 140)/60




	if band == 'high_band_2017':

		# Paths
		if calibration_temperature == 25:
			path_save      = common_path + 'high_band1/2017_01_25C/results/' + folder + '/calibration_files/'
			path_data      = common_path + 'high_band1/2017_01_25C/results/' + folder + '/data/'				
			path_plot_save = common_path + 'high_band1/2017_01_25C/results/' + folder + '/plots/'

		# Normalized frequency
		fn = (f - 140)/60		













	if band == 'low_band_2015':

		# Paths
		path_save      = common_path + 'low_band1/2015_08_25C/results/' + folder + '/calibration_files/'
		path_data      = common_path + 'low_band1/2015_08_25C/results/' + folder + '/data/'				
		path_plot_save = common_path + 'low_band1/2015_08_25C/results/' + folder + '/plots/'

		# Normalized frequency
		fn = (f - 75)/25




	if band == 'low_band_2015_2017_05':

		# Paths
		path_save      = common_path + 'low_band1/2017_05_25C/results/' + folder + '/calibration_files/'
		path_data      = common_path + 'low_band1/2017_05_25C/results/' + folder + '/data/'		
		path_plot_save = common_path + 'low_band1/2017_05_25C/results/' + folder + '/plots/'

		# Normalized frequency
		fn = (f - 75)/25



	if band == 'low_band_2015_2017_09':

		# Paths
		path_save      = common_path + 'low_band1/2017_09_25C/results/' + folder + '/calibration_files/'
		path_data      = common_path + 'low_band1/2017_09_25C/results/' + folder + '/data/'		
		path_plot_save = common_path + 'low_band1/2017_09_25C/results/' + folder + '/plots/'

		# Normalized frequency
		fn = (f - 75)/25






	if band == 'low_band2_2017':

		# Paths
		if calibration_temperature == 25:						
			path_save      = common_path + 'low_band2/2016_09_25C/results/' + folder + '/calibration_files/'
			path_data      = common_path + 'low_band2/2016_09_25C/results/' + folder + '/data/'				
			path_plot_save = common_path + 'low_band2/2016_09_25C/results/' + folder + '/plots/'

		if calibration_temperature == 15:
			path_save      = common_path + 'low_band2/2016_11_15C/results/' + folder + '/calibration_files/'
			path_data      = common_path + 'low_band2/2016_11_15C/results/' + folder + '/data/'				
			path_plot_save = common_path + 'low_band2/2016_11_15C/results/' + folder + '/plots/'

		if calibration_temperature == 35:
			path_save      = common_path + 'low_band2/2016_11_35C/results/' + folder + '/calibration_files/'
			path_data      = common_path + 'low_band2/2016_11_35C/results/' + folder + '/data/'				
			path_plot_save = common_path + 'low_band2/2016_11_35C/results/' + folder + '/plots/'


		# Normalized frequency
		fn = (f - 75)/25







	if band == 'mid_band_2017':

		# Paths
		if calibration_temperature == 25:						
			path_save      = common_path + 'mid_band/2017_11_25C/results/' + folder + '/calibration_files/'
			path_data      = common_path + 'mid_band/2017_11_25C/results/' + folder + '/data/'				
			path_plot_save = common_path + 'mid_band/2017_11_25C/results/' + folder + '/plots/'

		#if calibration_temperature == 15:
			#path_save      = common_path + 'low_band2/2016_11_15C/results/' + folder + '/calibration_files/'
			#path_data      = common_path + 'low_band2/2016_11_15C/results/' + folder + '/data/'				
			#path_plot_save = common_path + 'low_band2/2016_11_15C/results/' + folder + '/plots/'

		#if calibration_temperature == 35:
			#path_save      = common_path + 'low_band2/2016_11_35C/results/' + folder + '/calibration_files/'
			#path_data      = common_path + 'low_band2/2016_11_35C/results/' + folder + '/data/'				
			#path_plot_save = common_path + 'low_band2/2016_11_35C/results/' + folder + '/plots/'


		# Normalized frequency
		fn = (f - 75)/25



















	# Nominal data
	if len(data) == 1:


		# Spectra (pre-saved data or models)
		if spectra_data_model == 'data':    # Use this to compute the actual calibration quantities

			# Measured unscaled spectra
			out = np.genfromtxt(path_data + 'average_spectra_300_350.txt')

			Tae  = out[:,1]
			The  = out[:,2]
			Toe  = out[:,3]
			Tse  = out[:,4]
			Ts1e = out[:,5]
			Ts2e = out[:,6]



		if spectra_data_model == 'model':    # Use this for MC simulations

			out = models_calibration_spectra(band, calibration_temperature, f, receiver_reflection=receiver_reflection, MC_spectra_noise=MC_spectra_noise, plots='no')

			Tae  = out[0]
			The  = out[1]
			Toe  = out[2]
			Tse  = out[3]
			Ts1e = out[4]
			Ts2e = out[5]



		# S11 models 
		out = models_calibration_s11(band, folder, calibration_temperature, f, hb_flow=hb_flow, hb_fhigh=hb_fhigh, receiver_reflection=receiver_reflection, MC_s11_noise=MC_s11_noise, MC_s11_syst=MC_s11_syst, systematic_s11=systematic_s11, plots='yes', plot_flag=plot_flag)

		#phase_offset = (5/200)*f*(np.pi/180)
		#cable_offset = 0.01*(np.cos(phase_offset) + 1j*np.sin(phase_offset))

		rl        = out[0] #- 0.0008*(2.5-0.3j)
		ra        = out[1]
		rh        = out[2]
		ro        = out[3] #+ cable_offset #(1+1j)cable_offset
		rs        = out[4] #+ cable_offset #(1+1j)cable_offset
		s11_sr    = out[5]
		s12s21_sr = out[6]
		s22_sr    = out[7]
		rs1       = out[8]
		rs2       = out[9]




		# Physical temperatures, and temperature of Hot load
		out = models_calibration_physical_temperature(band, folder, calibration_temperature, f, s_parameters=np.array([rh, s11_sr, s12s21_sr, s22_sr]), MC_temp=MC_temp)

		Ta  = out[0]
		Thd = out[1]
		To  = out[2]
		Ts  = out[3]
		Ts1 = out[4]
		Ts2 = out[5]




	# External data
	if len(data) > 1:   # This is used for simulations of calibration using external simulated calibration measurements	

		Tae  = np.real(data[1])
		The  = np.real(data[2])
		Toe  = np.real(data[3])
		Tse  = np.real(data[4])
		Ts1e = np.real(data[5])
		Ts2e = np.real(data[6])

		rl   = data[7]
		ra   = data[8]
		rh   = data[9]
		ro   = data[10]
		rs   = data[11]
		rs1  = data[12]
		rs2  = data[13]

		Ta  = np.real(data[14])
		Thd = np.real(data[15])
		To  = np.real(data[16])
		Ts  = np.real(data[17])
		Ts1 = np.real(data[18])
		Ts2 = np.real(data[19])



	# Calibration quantities
	sca, off, TU, TC, TS = calibration_quantities(band, f, Tae, The, Toe, Tse, rl, ra, rh, ro, rs, Ta, Thd, To, Ts, Tamb_internal, cterms, wterms)



	# Cross-check
	if cross_check == 'yes':

		# Correcting calibration measurements
		Tac  = calibrated_antenna_temperature(Tae,  ra,  rl, sca, off, TU, TC, TS, Tamb_internal=Tamb_internal)
		Thc  = calibrated_antenna_temperature(The,  rh,  rl, sca, off, TU, TC, TS, Tamb_internal=Tamb_internal)
		Toc  = calibrated_antenna_temperature(Toe,  ro,  rl, sca, off, TU, TC, TS, Tamb_internal=Tamb_internal)
		Tsc  = calibrated_antenna_temperature(Tse,  rs,  rl, sca, off, TU, TC, TS, Tamb_internal=Tamb_internal)
		Ts1c = calibrated_antenna_temperature(Ts1e, rs1, rl, sca, off, TU, TC, TS, Tamb_internal=Tamb_internal)
		Ts2c = calibrated_antenna_temperature(Ts2e, rs2, rl, sca, off, TU, TC, TS, Tamb_internal=Tamb_internal)

		# Binning
		weight_array = np.ones(len(f))
		fb, Tacb,  xx = spectral_binning(f, Tac, weight_array,  64)
		fb, Thcb,  xx = spectral_binning(f, Thc, weight_array,  64)
		fb, Tocb,  xx = spectral_binning(f, Toc, weight_array,  64)
		fb, Tscb,  xx = spectral_binning(f, Tsc, weight_array,  64)
		fb, Ts1cb, xx = spectral_binning(f, Ts1c, weight_array, 64)
		fb, Ts2cb, xx = spectral_binning(f, Ts2c, weight_array, 64)

		fb, Tab,   xx = spectral_binning(f, Ta, weight_array,  64)
		fb, Thdb,  xx = spectral_binning(f, Thd, weight_array, 64)
		fb, Tob,   xx = spectral_binning(f, To, weight_array,  64)
		fb, Tsb,   xx = spectral_binning(f, Ts, weight_array,  64)
		fb, Ts1b,  xx = spectral_binning(f, Ts1, weight_array, 64)
		fb, Ts2b,  xx = spectral_binning(f, Ts2, weight_array, 64)


		if band == 'high_band_2015':

			# Plots
			plt.close()
			plt.close()


			size_x = 8
			size_y = 9

			f1  = plt.figure(num=1, figsize=(size_x, size_y))		

			ax = f1.add_subplot(6,1,1)
			ax.plot(fb, Tacb)
			ax.plot(fb, Tab, 'r')
			if calibration_temperature == 25:
				plt.ylim([295.5,295.75])
				ax.set_yticks(np.arange(295.55,295.75,0.05))
				ax.set_yticklabels(['295.55','295.60','295.65','295.70'])
			plt.ylabel('Ambient [K]')
			ax.text(83,295.68,'RMS: ' + str(int(1000*np.sqrt(np.sum((Tacb-Tab)**2)/len(fb)))) + ' mK')

			ax = f1.add_subplot(6,1,2)
			ax.plot(fb, Thcb)
			ax.plot(fb, Thdb, 'r')
			if calibration_temperature == 25:
				plt.ylim([406,406.7])
				ax.set_yticks(np.arange(406.1,406.7,0.1))
				ax.set_yticklabels(['406.1','406.2','406.3','406.4','406.5','406.6'])
			plt.ylabel('Hot [K]')
			ax.text(83,406.3,'RMS: ' + str(int(1000*np.sqrt(np.sum((Thcb-Thdb)**2)/len(fb)))) + ' mK')

			ax = f1.add_subplot(6,1,3)
			ax.plot(fb, Tocb)
			ax.plot(fb, Tob, 'r')
			if calibration_temperature == 25:
				plt.ylim([294,299])
				ax.set_yticks(np.arange(295,299,1))
			plt.ylabel('Open [K]')
			ax.text(83,297.6,'RMS: ' + str(int(1000*np.sqrt(np.sum((Tocb-Tob)**2)/len(fb)))) + ' mK')

			ax = f1.add_subplot(6,1,4)
			ax.plot(fb, Tscb)
			ax.plot(fb, Tsb, 'r')
			if calibration_temperature == 25:
				plt.ylim([293,298])
				ax.set_yticks(np.arange(294,298,1))
			plt.ylabel('Shorted [K]')
			ax.text(83,296.6,'RMS: ' + str(int(1000*np.sqrt(np.sum((Tscb-Tsb)**2)/len(fb)))) + ' mK')

			ax = f1.add_subplot(6,1,5)
			ax.plot(fb, Ts1cb)
			ax.plot(fb, Ts1b, 'r')
			if calibration_temperature == 25:
				plt.ylim([295.4,296])
				ax.set_yticks(np.arange(295.5,296,0.1))
			ax.set_yticklabels(['295.5','295.6','295.7','295.8','295.9'])
			plt.ylabel('Simu1 [K]')
			ax.text(83,295.85,'RMS: ' + str(int(1000*np.sqrt(np.sum((Ts1cb-Ts1b)**2)/len(fb)))) + ' mK')

			ax = f1.add_subplot(6,1,6)
			ax.plot(fb, Ts2cb)
			ax.plot(fb, Ts2b, 'r')
			if calibration_temperature == 25:
				plt.ylim([295.1,295.7])
				ax.set_yticks(np.arange(295.2,295.7,0.1))
				ax.set_yticklabels(['295.2','295.3','295.4','295.5','295.6'])
			plt.xlabel('frequency [MHz]')
			plt.ylabel('Simu2 [K]')
			ax.text(83,295.55,'RMS: ' + str(int(1000*np.sqrt(np.sum((Ts2cb-Ts2b)**2)/len(fb)))) + ' mK')

			plt.savefig(path_plot_save + 'calibration_crosscheck1' + plot_flag + '.png', bbox_inches='tight')
			plt.close()





			size_x = 8
			size_y = 5

			f1  = plt.figure(num=1, figsize=(size_x, size_y))		

			ax = f1.add_subplot(2,1,1)
			ax.plot(fb, 1000*(Ts1cb - np.mean(Ts1cb)))
			plt.ylim([-200,200])
			ax.set_yticks(np.array([-150,-100,-50,0,50,100,150]))
			#ax.set_yticklabels(['295.5','295.6','295.7','295.8','295.9'])
			plt.ylabel('Simu1 [mK]')
			ax.text(83,155,'RMS: ' + str(int(1000*np.std(Ts1cb))) + ' mK')
			plt.grid()


			ax = f1.add_subplot(2,1,2)
			ax.plot(fb, 1000*(Ts2cb - np.mean(Ts2cb)))
			plt.ylim([-200,200])
			ax.set_yticks(np.array([-150,-100,-50,0,50,100,150]))
			#ax.set_yticklabels(['295.2','295.3','295.4','295.5','295.6'])
			plt.xlabel('frequency [MHz]')
			plt.ylabel('Simu2 [mK]')
			ax.text(83,155,'RMS: ' + str(int(1000*np.std(Ts2cb))) + ' mK')
			plt.grid()


			plt.savefig(path_plot_save + 'calibration_crosscheck2' + plot_flag + '.png', bbox_inches='tight')
			plt.close()











		if band == 'high_band_2017':

			# Plots
			plt.close()
			plt.close()


			size_x = 8
			size_y = 9

			f1  = plt.figure(num=1, figsize=(size_x, size_y))		

			ax = f1.add_subplot(6,1,1)
			ax.plot(fb, Tacb)
			ax.plot(fb, Tab, 'r')
			#if calibration_temperature == 25:
				#plt.ylim([295.5,295.75])
				#ax.set_yticks(np.arange(295.55,295.75,0.05))
				#ax.set_yticklabels(['295.55','295.60','295.65','295.70'])
			plt.ylabel('Ambient [K]')
			ax.text(83,295.68,'RMS: ' + str(int(1000*np.sqrt(np.sum((Tacb-Tab)**2)/len(fb)))) + ' mK')

			ax = f1.add_subplot(6,1,2)
			ax.plot(fb, Thcb)
			ax.plot(fb, Thdb, 'r')
			#if calibration_temperature == 25:
				#plt.ylim([406,406.7])
				#ax.set_yticks(np.arange(406.1,406.7,0.1))
				#ax.set_yticklabels(['406.1','406.2','406.3','406.4','406.5','406.6'])
			plt.ylabel('Hot [K]')
			ax.text(83,406.3,'RMS: ' + str(int(1000*np.sqrt(np.sum((Thcb-Thdb)**2)/len(fb)))) + ' mK')

			ax = f1.add_subplot(6,1,3)
			ax.plot(fb, Tocb)
			ax.plot(fb, Tob, 'r')
			#if calibration_temperature == 25:
				#plt.ylim([294,299])
				#ax.set_yticks(np.arange(295,299,1))
			plt.ylabel('Open [K]')
			ax.text(83,297.6,'RMS: ' + str(int(1000*np.sqrt(np.sum((Tocb-Tob)**2)/len(fb)))) + ' mK')

			ax = f1.add_subplot(6,1,4)
			ax.plot(fb, Tscb)
			ax.plot(fb, Tsb, 'r')
			#if calibration_temperature == 25:
				#plt.ylim([293,298])
				#ax.set_yticks(np.arange(294,298,1))
			plt.ylabel('Shorted [K]')
			ax.text(83,296.6,'RMS: ' + str(int(1000*np.sqrt(np.sum((Tscb-Tsb)**2)/len(fb)))) + ' mK')

			ax = f1.add_subplot(6,1,5)
			ax.plot(fb, Ts1cb)
			ax.plot(fb, Ts1b, 'r')
			#if calibration_temperature == 25:
				#plt.ylim([295.4,296])
				#ax.set_yticks(np.arange(295.5,296,0.1))
			#ax.set_yticklabels(['295.5','295.6','295.7','295.8','295.9'])
			plt.ylabel('Simu1 [K]')
			ax.text(83,295.85,'RMS: ' + str(int(1000*np.sqrt(np.sum((Ts1cb-Ts1b)**2)/len(fb)))) + ' mK')

			ax = f1.add_subplot(6,1,6)
			ax.plot(fb, Ts2cb)
			ax.plot(fb, Ts2b, 'r')
			#if calibration_temperature == 25:
				#plt.ylim([295.1,295.7])
				#ax.set_yticks(np.arange(295.2,295.7,0.1))
				#ax.set_yticklabels(['295.2','295.3','295.4','295.5','295.6'])
			plt.xlabel('frequency [MHz]')
			plt.ylabel('Simu2 [K]')
			ax.text(83,295.55,'RMS: ' + str(int(1000*np.sqrt(np.sum((Ts2cb-Ts2b)**2)/len(fb)))) + ' mK')

			plt.savefig(path_plot_save + 'calibration_crosscheck1' + plot_flag + '.png', bbox_inches='tight')
			plt.close()





			size_x = 8
			size_y = 5

			f1  = plt.figure(num=1, figsize=(size_x, size_y))		

			ax = f1.add_subplot(2,1,1)
			ax.plot(fb, 1000*(Ts1cb - np.mean(Ts1cb)))
			plt.ylim([-200,200])
			#ax.set_yticks(np.array([-150,-100,-50,0,50,100,150]))
			#ax.set_yticklabels(['295.5','295.6','295.7','295.8','295.9'])
			plt.ylabel('Simu1 [mK]')
			ax.text(83,155,'RMS: ' + str(int(1000*np.std(Ts1cb))) + ' mK')
			plt.grid()


			ax = f1.add_subplot(2,1,2)
			ax.plot(fb, 1000*(Ts2cb - np.mean(Ts2cb)))
			plt.ylim([-200,200])
			#ax.set_yticks(np.array([-150,-100,-50,0,50,100,150]))
			#ax.set_yticklabels(['295.2','295.3','295.4','295.5','295.6'])
			plt.xlabel('frequency [MHz]')
			plt.ylabel('Simu2 [mK]')
			ax.text(83,155,'RMS: ' + str(int(1000*np.std(Ts2cb))) + ' mK')
			plt.grid()


			plt.savefig(path_plot_save + 'calibration_crosscheck2' + plot_flag + '.png', bbox_inches='tight')
			plt.close()
















		if (band == 'low_band_2015'):

			# Plots
			plt.close()
			plt.close()


			size_x = 8
			size_y = 9

			f1  = plt.figure(num=1, figsize=(size_x, size_y))		

			ax = f1.add_subplot(6,1,1)
			ax.plot(fb, Tacb)
			ax.plot(fb, Tab, 'r')
			plt.ylim([295.7,296.1])
			ax.set_yticks(np.arange(295.8,296.1,0.1))
			ax.set_yticklabels(['295.8','295.9','296.0'])
			plt.ylabel('Ambient [K]')
			ax.text(52,296.0,'RMS: ' + str(int(1000*np.sqrt(np.sum((Tacb-Tab)**2)/len(fb)))) + ' mK')

			ax = f1.add_subplot(6,1,2)
			ax.plot(fb, Thcb)
			ax.plot(fb, Thdb, 'r')
			plt.ylim([398.5,399])
			ax.set_yticks(np.arange(398.6,399,0.1))
			ax.set_yticklabels(['398.6','398.7','398.8','398.9'])
			plt.ylabel('Hot [K]')
			ax.text(52,398.6,'RMS: ' + str(int(1000*np.sqrt(np.sum((Thcb-Thdb)**2)/len(fb)))) + ' mK')

			ax = f1.add_subplot(6,1,3)
			ax.plot(fb, Tocb)
			ax.plot(fb, Tob, 'r')
			plt.ylim([293,298])
			ax.set_yticks(np.arange(294,298,1))
			plt.ylabel('Open [K]')
			ax.text(52,296.8,'RMS: ' + str(int(1000*np.sqrt(np.sum((Tocb-Tob)**2)/len(fb)))) + ' mK')

			ax = f1.add_subplot(6,1,4)
			ax.plot(fb, Tscb)
			ax.plot(fb, Tsb, 'r')
			plt.ylim([293,298])
			ax.set_yticks(np.arange(294,298,1))
			plt.ylabel('Shorted [K]')
			ax.text(52,296.8,'RMS: ' + str(int(1000*np.sqrt(np.sum((Tscb-Tsb)**2)/len(fb)))) + ' mK')

			ax = f1.add_subplot(6,1,5)
			ax.plot(fb, Ts1cb)
			ax.plot(fb, Ts1b, 'r')
			plt.ylim([295.8,296.3])
			ax.set_yticks(np.arange(295.9,296.3,0.1))
			ax.set_yticklabels(['295.9','296.0','296.1','296.2'])
			plt.ylabel('Simu1 [K]')
			ax.text(52,296.18,'RMS: ' + str(int(1000*np.sqrt(np.sum((Ts1cb-Ts1b)**2)/len(fb)))) + ' mK')

			ax = f1.add_subplot(6,1,6)
			ax.plot(fb, Ts2cb)
			ax.plot(fb, Ts2b, 'r')
			plt.ylim([295.7,296.2])
			ax.set_yticks(np.arange(295.8,296.2,0.1))
			ax.set_yticklabels(['295.8','295.9','296.0','296.1'])
			plt.xlabel('frequency [MHz]')
			plt.ylabel('Simu2 [K]')
			ax.text(52,296.08,'RMS: ' + str(int(1000*np.sqrt(np.sum((Ts2cb-Ts2b)**2)/len(fb)))) + ' mK')

			plt.savefig(path_plot_save + 'calibration_crosscheck1' + plot_flag + '.png', bbox_inches='tight')
			plt.close()





			size_x = 8
			size_y = 5

			f1  = plt.figure(num=1, figsize=(size_x, size_y))		

			ax = f1.add_subplot(2,1,1)
			ax.plot(fb, 1000*(Ts1cb - np.mean(Ts1cb)))
			plt.ylim([-200,200])
			ax.set_yticks(np.array([-150,-100,-50,0,50,100,150]))
			#ax.set_yticklabels(['295.5','295.6','295.7','295.8','295.9'])
			plt.ylabel('Simu1 [mK]')
			ax.text(54,155,'RMS: ' + str(int(1000*np.std(Ts1cb))) + ' mK')
			plt.grid()


			ax = f1.add_subplot(2,1,2)
			ax.plot(fb, 1000*(Ts2cb - np.mean(Ts2cb)))
			plt.ylim([-200,200])
			ax.set_yticks(np.array([-150,-100,-50,0,50,100,150]))
			#ax.set_yticklabels(['295.2','295.3','295.4','295.5','295.6'])
			plt.xlabel('frequency [MHz]')
			plt.ylabel('Simu2 [mK]')
			ax.text(54,155,'RMS: ' + str(int(1000*np.std(Ts2cb))) + ' mK')
			plt.grid()


			plt.savefig(path_plot_save + 'calibration_crosscheck2' + plot_flag + '.png', bbox_inches='tight')
			plt.close()









		if (band == 'low_band_2015_2017_05') or (band == 'low_band_2015_2017_09'):

			# Plots
			plt.close()
			plt.close()


			size_x = 8
			size_y = 8

			f1  = plt.figure(num=1, figsize=(size_x, size_y))		

			ax = f1.add_subplot(5,1,1)
			ax.plot(fb, Tacb)
			ax.plot(fb, Tab, 'r')
			#plt.ylim([295.91,296.24])
			ax.ticklabel_format(useOffset=False)
			#ax.set_yticks(np.arange(295.8,296.1,0.1))
			#ax.set_yticklabels(['295.8','295.9','296.0'])
			plt.ylabel('Ambient [K]')
			ax.text(85.,295.84,'RMS: ' + str(int(1000*np.sqrt(np.sum((Tacb-Tab)**2)/len(fb)))) + ' mK')

			ax = f1.add_subplot(5,1,2)
			ax.plot(fb, Thcb)
			ax.plot(fb, Thdb, 'r')
			#plt.ylim([398.91,399.39])
			ax.ticklabel_format(useOffset=False)
			#ax.set_yticks(np.arange(398.6,399,0.1))
			#ax.set_yticklabels(['398.6','398.7','398.8','398.9'])
			plt.ylabel('Hot [K]')
			ax.text(85.,394.,'RMS: ' + str(int(1000*np.sqrt(np.sum((Thcb-Thdb)**2)/len(fb)))) + ' mK')

			ax = f1.add_subplot(5,1,3)
			ax.plot(fb, Tocb)
			ax.plot(fb, Tob, 'r')
			#plt.ylim([293.1,297.9])
			ax.ticklabel_format(useOffset=False)
			#ax.set_yticks(np.arange(294,298,1))
			plt.ylabel('Open [K]')
			ax.text(85,296.5,'RMS: ' + str(int(1000*np.sqrt(np.sum((Tocb-Tob)**2)/len(fb)))) + ' mK')

			ax = f1.add_subplot(5,1,4)
			ax.plot(fb, Tscb)
			ax.plot(fb, Tsb, 'r')
			#plt.ylim([293.1,297.9])
			ax.ticklabel_format(useOffset=False)
			#ax.set_yticks(np.arange(294,298,1))
			plt.ylabel('Shorted [K]')
			ax.text(85,296.5,'RMS: ' + str(int(1000*np.sqrt(np.sum((Tscb-Tsb)**2)/len(fb)))) + ' mK')

			#ax = f1.add_subplot(6,1,5)
			#ax.plot(fb, Ts1cb)
			#ax.plot(fb, Ts1b, 'r')
			##plt.ylim([295.8,296.3])
			##ax.set_yticks(np.arange(295.9,296.3,0.1))
			##ax.set_yticklabels(['295.9','296.0','296.1','296.2'])
			#plt.ylabel('Simu1 [K]')
			#ax.text(52,296.18,'RMS: ' + str(int(1000*np.sqrt(np.sum((Ts1cb-Ts1b)**2)/len(fb)))) + ' mK')

			ax = f1.add_subplot(5,1,5)
			ax.plot(fb, Ts2cb)
			ax.plot(fb, Ts2b, 'r')
			#plt.ylim([295.51,295.79])
			ax.ticklabel_format(useOffset=False)
			#ax.set_yticks(np.arange(295.8,296.2,0.1))
			#ax.set_yticklabels(['295.8','295.9','296.0','296.1'])
			plt.xlabel('frequency [MHz]')
			plt.ylabel('Simu2 [K]')
			ax.text(85,295.6,'RMS: ' + str(int(1000*np.sqrt(np.sum((Ts2cb-Ts2b)**2)/len(fb)))) + ' mK')


			plt.savefig(path_plot_save + 'calibration_crosscheck1' + plot_flag + '.png', bbox_inches='tight')
			plt.close()





			size_x = 8
			size_y = 3.5

			f1  = plt.figure(num=1, figsize=(size_x, size_y))		

			ax = f1.add_subplot(1,1,1)
			ax.plot(fb, 1000*(Ts2cb - np.mean(Ts2cb)))
			plt.ylim([-200,200])
			##ax.set_yticks(np.array([-150,-100,-50,0,50,100,150]))
			##ax.set_yticklabels(['295.5','295.6','295.7','295.8','295.9'])
			plt.ylabel('Simu2 [mK]')
			ax.text(54,155,'RMS: ' + str(int(1000*np.std(Ts2cb))) + ' mK')
			plt.grid()
			plt.xlabel('frequency [MHz]')



			plt.savefig(path_plot_save + 'calibration_crosscheck2' + plot_flag + '.png', bbox_inches='tight')
			plt.close()



















		if (band == 'low_band2_2017'):

			# Plots
			plt.close()
			plt.close()


			size_x = 8
			size_y = 9

			f1  = plt.figure(num=1, figsize=(size_x, size_y))		

			ax = f1.add_subplot(6,1,1)
			ax.plot(fb, Tacb)
			ax.plot(fb, Tab, 'r')
			#plt.ylim([295.7,296.1])
			#plt.ylim([296.6,297])
			#ax.set_yticks(np.arange(296.65,296.99,0.1))
			#ax.set_yticklabels(['295.8','295.9','296.0'])			
			mmax  = np.max(np.array([np.max(Tacb), np.max(Tab)])) + 1.3*(np.max(Tacb) - np.min(Tacb))
			mmin  = np.min(np.array([np.min(Tacb), np.min(Tab)])) - 0.7*(np.max(Tacb) - np.min(Tacb))
			mtext = np.max(np.array([np.max(Tacb), np.max(Tab)])) + 0.5*(np.max(Tacb) - np.min(Tacb))
			plt.ylim([mmin, mmax])
			ax.ticklabel_format(useOffset=False)
			plt.ylabel('Ambient [K]')
			ax.text(52, mtext, 'RMS: ' + str(int(1000*np.sqrt(np.sum((Tacb-Tab)**2)/len(fb)))) + ' mK')
			ax.set_xticklabels('')


			ax = f1.add_subplot(6,1,2)
			ax.plot(fb, Thcb)
			ax.plot(fb, Thdb, 'r')
			#plt.ylim([398.5,399])
			#plt.ylim([400, 400.6])
			#ax.set_yticks(np.arange(400.1,400.6,0.1))
			#ax.set_yticklabels(['398.6','398.7','398.8','398.9'])
			mmax  = np.max(np.array([np.max(Thcb), np.max(Thdb)])) + 1.3*(np.max(Thcb) - np.min(Thcb))
			mmin  = np.min(np.array([np.min(Thcb), np.min(Thdb)])) - 0.7*(np.max(Thcb) - np.min(Thcb))
			mtext = np.max(np.array([np.max(Thcb), np.max(Thdb)])) + 0.5*(np.max(Thcb) - np.min(Thcb))
			plt.ylim([mmin, mmax])
			ax.ticklabel_format(useOffset=False)
			plt.ylabel('Hot [K]')
			ax.text(52, mtext, 'RMS: ' + str(int(1000*np.sqrt(np.sum((Thcb-Thdb)**2)/len(fb)))) + ' mK')
			ax.set_xticklabels('')


			ax = f1.add_subplot(6,1,3)
			ax.plot(fb, Tocb)
			ax.plot(fb, Tob, 'r')
			#plt.ylim([294,299])
			#ax.set_yticks(np.arange(295,299,1))
			mmax  = np.max(np.array([np.max(Tocb), np.max(Tob)])) + 1.3*(np.max(Tocb) - np.min(Tocb))
			mmin  = np.min(np.array([np.min(Tocb), np.min(Tob)])) - 0.7*(np.max(Tocb) - np.min(Tocb))
			mtext = np.max(np.array([np.max(Tocb), np.max(Tob)])) + 0.5*(np.max(Tocb) - np.min(Tocb))
			plt.ylim([mmin, mmax])
			plt.ylabel('Open [K]')
			ax.text(52, mtext, 'RMS: ' + str(int(1000*np.sqrt(np.sum((Tocb-Tob)**2)/len(fb)))) + ' mK')
			ax.set_xticklabels('')

			ax = f1.add_subplot(6,1,4)
			ax.plot(fb, Tscb)
			ax.plot(fb, Tsb, 'r')
			#plt.ylim([294,299])
			#ax.set_yticks(np.arange(295,299,1))
			mmax  = np.max(np.array([np.max(Tscb), np.max(Tsb)])) + 1.3*(np.max(Tscb) - np.min(Tscb))
			mmin  = np.min(np.array([np.min(Tscb), np.min(Tsb)])) - 0.7*(np.max(Tscb) - np.min(Tscb))
			mtext = np.max(np.array([np.max(Tscb), np.max(Tsb)])) + 0.5*(np.max(Tscb) - np.min(Tscb))
			plt.ylim([mmin, mmax])
			plt.ylabel('Shorted [K]')
			ax.text(52, mtext, 'RMS: ' + str(int(1000*np.sqrt(np.sum((Tscb-Tsb)**2)/len(fb)))) + ' mK')
			ax.set_xticklabels('')

			ax = f1.add_subplot(6,1,5)
			ax.plot(fb, Ts1cb)
			ax.plot(fb, Ts1b, 'r')
			#plt.ylim([296.3,296.6])
			#plt.ylim([296.6-0.7, 297.2-1.3])
			#ax.set_yticks(np.arange(296.7,297.2,0.1))
			mmax  = np.max(np.array([np.max(Ts1cb), np.max(Ts1b)])) + 1.3*(np.max(Ts1cb) - np.min(Ts1cb))
			mmin  = np.min(np.array([np.min(Ts1cb), np.min(Ts1b)])) - 0.7*(np.max(Ts1cb) - np.min(Ts1cb))
			mtext = np.max(np.array([np.max(Ts1cb), np.max(Ts1b)])) + 0.5*(np.max(Ts1cb) - np.min(Ts1cb))
			plt.ylim([mmin, mmax])
			ax.ticklabel_format(useOffset=False)
			plt.ylabel('Simu1 [K]')
			ax.text(52, mtext, 'RMS: ' + str(int(1000*np.sqrt(np.sum((Ts1cb-Ts1b)**2)/len(fb)))) + ' mK')
			ax.set_xticklabels('')

			ax = f1.add_subplot(6,1,6)
			ax.plot(fb, Ts2cb)
			ax.plot(fb, Ts2b, 'r')
			#plt.ylim([296.4,296.7])
			#plt.ylim([296.6-0.7, 297.2-1.3])
			#ax.set_yticks(np.arange(296.7,297.2,0.1))
			#ax.set_yticklabels(['295.8','295.9','296.0','296.1'])
			mmax  = np.max(np.array([np.max(Ts2cb), np.max(Ts2b)])) + 1.3*(np.max(Ts2cb) - np.min(Ts2cb))
			mmin  = np.min(np.array([np.min(Ts2cb), np.min(Ts2b)])) - 0.7*(np.max(Ts2cb) - np.min(Ts2cb))
			mtext = np.max(np.array([np.max(Ts2cb), np.max(Ts2b)])) + 0.5*(np.max(Ts2cb) - np.min(Ts2cb))
			plt.ylim([mmin, mmax])
			ax.ticklabel_format(useOffset=False)
			plt.xlabel('frequency [MHz]')
			plt.ylabel('Simu2 [K]')
			ax.text(52, mtext, 'RMS: ' + str(int(1000*np.sqrt(np.sum((Ts2cb-Ts2b)**2)/len(fb)))) + ' mK')


			plt.savefig(path_plot_save + 'calibration_crosscheck1' + plot_flag + '.png', bbox_inches='tight')
			plt.close()





			size_x = 8
			size_y = 5

			f1  = plt.figure(num=1, figsize=(size_x, size_y))		

			ax = f1.add_subplot(2,1,1)
			ax.plot(fb, 1000*(Ts1cb - np.mean(Ts1cb)))
			plt.ylim([-200,200])
			ax.set_yticks(np.array([-150,-100,-50,0,50,100,150]))
			#ax.set_yticklabels(['295.5','295.6','295.7','295.8','295.9'])
			plt.ylabel('Simu1 [mK]')
			ax.text(54,155,'RMS: ' + str(int(1000*np.std(Ts1cb))) + ' mK')
			plt.grid()


			ax = f1.add_subplot(2,1,2)
			ax.plot(fb, 1000*(Ts2cb - np.mean(Ts2cb)))
			plt.ylim([-200,200])
			ax.set_yticks(np.array([-150,-100,-50,0,50,100,150]))
			#ax.set_yticklabels(['295.2','295.3','295.4','295.5','295.6'])
			plt.xlabel('frequency [MHz]')
			plt.ylabel('Simu2 [mK]')
			ax.text(54,155,'RMS: ' + str(int(1000*np.std(Ts2cb))) + ' mK')
			plt.grid()


			plt.savefig(path_plot_save + 'calibration_crosscheck2' + plot_flag + '.png', bbox_inches='tight')
			plt.close()






	if save == 'yes':

		# Array
		save_array = np.zeros((len(f), 8))
		save_array[:,0] = f
		save_array[:,1] = np.real(rl)
		save_array[:,2] = np.imag(rl)
		save_array[:,3] = sca
		save_array[:,4] = off
		save_array[:,5] = TU
		save_array[:,6] = TC
		save_array[:,7] = TS

		# Save
		np.savetxt(path_save + 'calibration_file_' + band + save_flag + '.txt', save_array, fmt='%1.8f')


	return rl, sca, off, TU, TC, TS


























def level2read(band, version, date):

	"""
	band:     'high_band', 'low_band'
	version:  'v1', 'v3', etc.
	date:     '2015_218_00' 
	"""

	path = home_folder + '/DATA/EDGES/spectra/level2/' + band + '/' + version + '/'

	data   = np.genfromtxt(path + date + '_LST_data_'   + version +'.txt')
	meta   = np.genfromtxt(path + date + '_LST_meta_'   + version +'.txt')
	std    = np.genfromtxt(path + date + '_LST_std_'    + version +'.txt')
	weight = np.genfromtxt(path + date + '_LST_weight_' + version +'.txt')


	return data, meta, std, weight
























def raw_spectral_difference(s1, s2):

	delta = []
	for i in range(len(s1)):

		if (s1[i] != 0) and (s2[i] != 0):

			delta.append(s2[i] - s1[i])
	return np.sum(delta)











def level2_to_level3(band, version, antenna='blade', flag=''):

	# Selecting band

	if (band == 'high_band') and (antenna=='fourpoint'):

		path_data_high_band = home_folder + '/DATA/EDGES/spectra/level2/high_band/' + version + '/'

		dates   = ['2015_109_11', 
		           '2015_110_00', '2015_111_00', '2015_112_00', '2015_113_00', '2015_113_09', '2015_114_00', '2015_115_00', '2015_116_00', '2015_117_00', '2015_118_00', '2015_119_00', '2015_119_13', 
		           '2015_120_00', '2015_120_14', '2015_121_00', '2015_122_00', '2015_122_05', '2015_122_08', '2015_123_00', '2015_123_08', '2015_123_15', '2015_124_00', '2015_124_13', '2015_125_00', '2015_125_05', '2015_125_08', '2015_126_00', '2015_127_00', '2015_128_00', '2015_129_00', 
		           '2015_130_00', '2015_131_00', '2015_132_00', '2015_132_04', '2015_133_00', '2015_134_00', '2015_135_00', '2015_136_00', '2015_137_00', '2015_138_00', '2015_139_00', 
		           '2015_140_00', '2015_141_00', '2015_142_00', '2015_143_00', '2015_144_00', '2015_145_00', '2015_146_00', '2015_147_00', '2015_148_00', '2015_149_00', 
		           '2015_150_00', '2015_151_00', '2015_152_00', '2015_153_00', '2015_154_00', '2015_155_00', '2015_156_00', '2015_157_00', 
		           '2015_161_18', '2015_162_00', '2015_163_00', '2015_164_00', '2015_165_00', '2015_166_00', '2015_167_00', '2015_168_00', '2015_169_00', 
		           '2015_170_00', '2015_171_00', '2015_172_00', '2015_173_00', '2015_174_00', '2015_175_00', '2015_176_00', '2015_177_00', '2015_178_00', '2015_179_00', 
		           '2015_180_00', '2015_181_00', '2015_182_00', '2015_183_00', '2015_184_00', '2015_185_00', '2015_186_00', '2015_187_00', '2015_188_00', '2015_189_00', 
		           '2015_190_00', '2015_191_00', '2015_192_00', '2015_192_18', '2015_193_00', '2015_194_00', '2015_195_00', '2015_198_00']		






	if (band == 'high_band') and (antenna=='blade'):

		path_data_high_band = home_folder + '/DATA/EDGES/spectra/level2/high_band/' + version + '/'

		dates   = ['2015_206_00', '2015_207_00', '2015_208_00', '2015_209_00', 
		           '2015_210_00', '2015_210_03', '2015_211_00', '2015_211_18', '2015_212_00', '2015_215_08', '2015_216_00', '2015_217_00', '2015_218_00', '2015_219_00',
		           '2015_220_00', '2015_221_00', '2015_222_00', '2015_223_00', '2015_224_00', '2015_225_00', '2015_226_00', '2015_227_00', '2015_228_00', '2015_229_00',
		           '2015_230_00', '2015_231_00', '2015_232_00', '2015_233_00', '2015_234_00', '2015_235_00', '2015_236_00', '2015_237_00', '2015_238_00', '2015_239_00',
		           '2015_240_00', '2015_241_00', '2015_242_00', '2015_243_00', '2015_245_00',
		           '2015_250_15', '2015_251_00', '2015_251_21', '2015_252_00', '2015_253_00', '2015_254_00', '2015_255_00', '2015_256_00', '2015_257_00', '2015_258_00', '2015_259_00', 
		           '2015_260_00', '2015_261_00', '2015_262_00', '2015_265_19', '2015_266_00', '2015_267_00', '2015_268_00', '2015_269_00', 
		           '2015_270_00', '2015_271_00', '2015_272_00', '2015_273_00', '2015_274_00', '2015_275_00', '2015_276_00', '2015_277_00', '2015_278_00', '2015_279_00',
		           '2015_280_00', '2015_281_17', '2015_282_00', '2015_283_00', '2015_284_00', '2015_285_00', '2015_286_00', '2015_287_00', '2015_288_00', '2015_289_00',
		           '2015_290_00', '2015_291_00', '2015_292_00', '2015_293_00', '2015_294_00', '2015_295_00', '2015_296_00', '2015_297_00', '2015_298_00', '2015_299_00',
		           '2015_300_00', '2015_301_00', '2015_302_00', '2015_303_00', 
		           '2015_310_18', '2015_311_00', '2015_312_00', '2015_313_00', '2015_314_00', '2015_315_00', '2015_316_00', '2015_317_00', '2015_318_00', '2015_319_00',
		           '2015_320_00', '2015_321_00', '2015_322_00', '2015_323_00', '2015_324_00', '2015_325_00', '2015_326_00', '2015_327_00', '2015_328_00', '2015_329_00',
		           '2015_330_00', '2015_331_00', '2015_332_00', '2015_333_00', '2015_334_00', '2015_335_00', '2015_336_00', '2015_337_00', '2015_338_00', '2015_339_00',
		           '2015_340_00', '2015_341_00', '2015_342_00', '2015_343_00', '2015_344_00', '2015_345_00', '2015_346_00', '2015_347_00', '2015_348_00', '2015_349_00',
		           '2015_350_00', '2015_351_00', '2015_352_00', '2015_353_00', '2015_354_00', '2015_355_00', '2015_356_00', '2015_357_00', '2015_358_00', '2015_359_00',
		           '2015_360_00', '2015_361_00', '2015_362_00', '2015_363_00', '2015_364_00', '2015_365_00',
		           '2016_001_00', '2016_002_00', '2016_003_00', '2016_004_00', '2016_005_00', '2016_006_00', '2016_007_00', '2016_008_00', '2016_009_00',
		           '2016_010_00', '2016_011_00', '2016_012_00', '2016_013_00', '2016_014_00', '2016_015_00', '2016_016_00', '2016_017_00', '2016_018_00', '2016_019_00',
		           '2016_020_00', '2016_027_20', '2016_028_00', '2016_029_00',
		           '2016_030_00', '2016_031_00', '2016_032_00', '2016_033_00', '2016_034_00', '2016_035_00', '2016_036_00', '2016_037_00', '2016_038_00', '2016_039_00',
		           '2016_040_00', '2016_041_00', '2016_042_00', '2016_043_00', '2016_044_00', '2016_045_00', '2016_046_00', '2016_047_00', '2016_048_00', '2016_049_00',
		           '2016_050_00', '2016_051_00', '2016_052_00', '2016_053_00', '2016_055_07', '2016_056_00', '2016_057_00', '2016_058_00', '2016_059_00',
		           '2016_060_00', '2016_061_00', '2016_062_00', '2016_063_00', '2016_064_00', '2016_065_00', '2016_066_00', '2016_067_00', '2016_068_00', '2016_069_00',
		           '2016_070_00', '2016_071_00', '2016_072_00', '2016_073_00', '2016_074_00', '2016_075_00', '2016_076_00', '2016_077_00', '2016_078_00', '2016_079_00',
		           '2016_080_00', '2016_081_00', '2016_082_00']




	if (band == 'low_band') and (antenna=='blade'):

		path_data_high_band = home_folder + '/DATA/EDGES/spectra/level2/low_band/' + version + '/'

		dates   = ['2015_286_02', '2015_287_00', '2015_288_00', '2015_289_00',
		           '2015_291_00', '2015_292_00', '2015_293_00', '2015_294_00', '2015_295_00', '2015_296_00', '2015_297_00', '2015_298_00', '2015_299_00',
		           '2015_300_00', '2015_301_00', '2015_302_00', '2015_303_00',
		           '2015_310_18', '2015_311_00', '2015_312_00', '2015_313_00', '2015_314_00', '2015_315_00', '2015_316_00', '2015_317_00', '2015_318_00', '2015_319_00',
		           '2015_320_00', '2015_321_00', '2015_322_00', '2015_323_00', '2015_324_00', '2015_325_00', '2015_326_00', '2015_327_00', '2015_328_00', '2015_329_00',
		           '2015_330_00', '2015_331_00', '2015_332_00', '2015_333_00', '2015_334_00', '2015_335_00', '2015_336_00', '2015_337_00', '2015_338_00', '2015_339_00',
		           '2015_340_00', '2015_341_00', '2015_342_00', '2015_343_14', '2015_344_00', '2015_344_21', '2015_345_00', '2015_346_00', '2015_347_00', '2015_348_00', '2015_349_00',
		           '2015_350_00', '2015_351_00', '2015_352_00', '2015_353_00', '2015_354_00',
		           '2015_362_00', '2015_363_00', '2015_364_00', '2015_365_00',
		           '2016_001_00', '2016_002_00', '2016_003_00', '2016_004_00', '2016_005_00', '2016_006_00', '2016_007_00', '2016_008_00', '2016_009_00',
		           '2016_010_00', '2016_011_00', '2016_012_00', '2016_013_00', '2016_014_00', '2016_015_00', '2016_016_00', '2016_017_00', '2016_018_00', '2016_019_00',
		           '2016_020_00', '2016_028_00', '2016_029_00',
		           '2016_030_00', '2016_031_00', '2016_032_00', '2016_033_00', '2016_034_00', '2016_035_00', '2016_036_00', '2016_037_00', '2016_038_00', '2016_039_00',
		           '2016_040_00', '2016_041_00', '2016_042_00', '2016_043_00', '2016_044_00', '2016_045_00', '2016_046_00', '2016_047_00', '2016_048_00', '2016_049_00',
		           '2016_050_00', '2016_051_00', '2016_052_00', '2016_053_00', '2016_055_21', '2016_056_00', '2016_057_00', '2016_058_00', '2016_059_00',
		           '2016_060_00', '2016_061_00', '2016_062_00', '2016_063_00', '2016_064_00', '2016_065_00', '2016_066_00', '2016_067_00', '2016_068_00', '2016_069_00',
		           '2016_070_00', '2016_071_00', '2016_072_00', '2016_073_00', '2016_074_00', '2016_075_00', '2016_076_00', '2016_077_00', '2016_078_00', '2016_079_00',
		           '2016_080_00', '2016_081_00', '2016_082_00']





	# Loading all days
	data    = []
	meta    = []
	std     = []
	weights = []	

	for i in range(len(dates)):

		print('Loading data files: ' + str(i+1) + ' of ' + str(len(dates)))

		d, m, s, w = level2read(band, version, dates[i])
		data.append(d)
		meta.append(m)
		std.append(s)
		weights.append(w)



	# Organizing them in 72 LST arrays, each with data from all days

	# Data cubes
	l_data    = np.zeros((72, len(dates), len(data[0][:,0])))
	l_meta    = np.zeros((72, len(dates), len(meta[0][0,:])))
	l_std     = np.zeros((72, len(dates), len(std[0][:,0])))
	l_weights = np.zeros((72, len(dates), len(weights[0][:,0])))
	#print(l_data.shape)



	# Storing data

	# For all LSTs
	for j in range(72):

		print('Full LST Arrays: ' + str(j+1) + ' of 72')

		# Data per LST
		LST_data    = np.zeros((len(dates), len(data[0][:,0])))
		LST_meta    = np.zeros((len(dates), len(meta[0][0,:])))
		LST_std     = np.zeros((len(dates), len(std[0][:,0])))
		LST_weights = np.zeros((len(dates), len(weights[0][:,0])))


		# For all dates
		for i in range(len(dates)):
			LST_data[i,:]    = data[i][:,j+1].reshape(1,-1)
			LST_meta[i,:]    = meta[i][j,:]
			LST_std[i,:]     = std[i][:,j+1].reshape(1,-1)
			LST_weights[i,:] = weights[i][:,j+1].reshape(1,-1)


		# All LSTs and dates
		l_data[j,:,:]    = LST_data
		l_meta[j,:,:]    = LST_meta
		l_std[j,:,:]     = LST_std
		l_weights[j,:,:] = LST_weights



	# Frequency vector
	freq = data[0][:,0]





	# Binning data
	# -------------------------------------------
	if band == 'high_band':
		flow  = 90
		fhigh = 190
		fstep = 0.4
		n_bin = 6    # for RFI cleaning stage

	elif band == 'low_band':
		flow  = 50
		fhigh = 100
		fstep = 0.4
		n_bin = 4    # for RFI cleaning stage

	fb, tb_all, wb_all = data_analysis_binning(freq, l_data, l_weights, flow, fhigh, fstep)




	# Removing RFI
	# -------------------------------------------
	tb_no_rfi_all = np.zeros( (len(tb_all[:,0,0]), len(tb_all[0,:,0]), len(tb_all[0,0,:])) )
	wb_no_rfi_all = np.zeros( (len(tb_all[:,0,0]), len(tb_all[0,:,0]), len(tb_all[0,0,:])) )

	for j in range(len(tb_all[:,0,0])):
		for i in range(len(tb_all[0,:,0])):
			print(str(j) + ' ' + str(i))
			tb_no_rfi_one_spectrum, wb_no_rfi_one_spectrum = data_analysis_RFI_removal(fb, tb_all[j,i,:], wb_all[j,i,:], n_bin = n_bin, n_sigma = 3.0, N_iter = 5)
			tb_no_rfi_all[j,i,:] = tb_no_rfi_one_spectrum
			wb_no_rfi_all[j,i,:] = wb_no_rfi_one_spectrum



	# Save
	path      = home_folder + '/DATA/EDGES/spectra/level3/' + band + '/'
	save_file = path  + band + '_' + version + '_' + antenna + flag + '.hdf5'



	with h5py.File(save_file, 'w') as hf:
		hf.create_dataset('frequency',           data = fb)
		hf.create_dataset('antenna_temperature', data = tb_no_rfi_all)
		hf.create_dataset('metadata',            data = l_meta)
		hf.create_dataset('weights',             data = wb_no_rfi_all)	


	return fb, tb_no_rfi_all, wb_no_rfi_all  #tb_all, wb_all
















def level3_read(path_file):

	"""
	This is NOT the only version.

	For low-band, I am using a different hdf5 format because I do not average raw spectra. Use the function below.

	"""

	with h5py.File(path_file,'r') as hf:
		#print([key for key in hf.keys()])

		hf_f = hf.get('frequency')
		f    = np.array(hf_f)

		hf_t = hf.get('antenna_temperature')
		t    = np.array(hf_t)

		hf_w = hf.get('weights')
		w    = np.array(hf_w)

		hf_d = hf.get('dates')
		d    = np.array(hf_d)

		hf_at  = hf.get('amb_temp')
		at = np.array(hf_at)

		hf_ah  = hf.get('amb_hum')
		ah = np.array(hf_ah)

		hf_rct = hf.get('recv_ctrl_temp')
		rct = np.array(hf_rct)

		hf_rmt = hf.get('recv_meas_temp')
		rmt = np.array(hf_rmt)


	return f, t, w, d, at, ah, rct, rmt







def level3_read_raw_spectra(path_file):

	"""

	"""

	with h5py.File(path_file,'r') as hf:
		#print([key for key in hf.keys()])

		hf_f = hf.get('frequency')
		f    = np.array(hf_f)

		hf_t = hf.get('antenna_temperature')
		t    = np.array(hf_t)

		hf_w = hf.get('weights')
		w    = np.array(hf_w)

		hf_m = hf.get('meta_data')
		m    = np.array(hf_m)


	return f, t, w, m








def level4read_v2(path_file):

	# path_file = /media/raul/DATA/EDGES/spectra/level4/high_band/high_band_v1.hdf5

	# Show keys (array names inside HDF5 file)
	with h5py.File(path_file,'r') as hf:
		print([key for key in hf.keys()])

		hf_freq    = hf.get('frequency')
		freq       = np.array(hf_freq)

		hf_Tsky    = hf.get('sky_temperature')
		Tsky       = np.array(hf_Tsky)

		hf_weights = hf.get('weights')
		weights    = np.array(hf_weights)		

		hf_wea     = hf.get('weather_receiver')
		wea        = np.array(hf_wea)

		hf_LST     = hf.get('LST')
		LST        = np.array(hf_LST)

		hf_bt      = hf.get('best_temp_all')
		bt         = np.array(hf_bt)[:,0]

	return freq, Tsky, weights, wea, LST, bt












def level5read(path_file):

	# path_file = /media/raul/DATA/EDGES/spectra/level5/high_band/high_band_v1.hdf5

	# Show keys (array names inside HDF5 file)
	with h5py.File(path_file,'r') as hf:
		print([key for key in hf.keys()])

		hf_freq    = hf.get('frequency')
		freq       = np.array(hf_freq)

		hf_Ta      = hf.get('antenna_temperature')
		Ta         = np.array(hf_Ta)

		hf_weights = hf.get('weights')
		weights    = np.array(hf_weights)



	return freq, Ta, weights










def level2read_v2(path_file, print_key='no'):

	# path_file = /media/raul/DATA/EDGES/spectra/level2/high_band/v2/file.hdf5

	# Show keys (array names inside HDF5 file)
	with h5py.File(path_file,'r') as hf:

		if print_key == 'yes':
			print([key for key in hf.keys()])

		hf_freq    = hf.get('frequency')
		freq       = np.array(hf_freq)

		hf_Ta      = hf.get('antenna_temperature')
		Ta         = np.array(hf_Ta)

		hf_meta    = hf.get('metadata')
		meta       = np.array(hf_meta)

		hf_weights = hf.get('weights')
		weights    = np.array(hf_weights)



	return freq, Ta, meta, weights	


















def level2read_v2_RFI_review(path_file, LST_1, LST_2, sun_el_max=-10, amb_hum_max=150):

	# path_file = /media/raul/DATA/EDGES/spectra/level2/high_band/v2/file.hdf5

	# Show keys (array names inside HDF5 file)
	with h5py.File(path_file,'r') as hf:


		hf_freq    = hf.get('frequency')
		freq       = np.array(hf_freq)

		hf_Ta      = hf.get('antenna_temperature')
		Ta         = np.array(hf_Ta)

		hf_meta    = hf.get('metadata')
		meta       = np.array(hf_meta)

		hf_weights = hf.get('weights')
		weights    = np.array(hf_weights)



	# Selecting LST range
	index       = np.arange(len(meta[:,0]))
	index_LST_1 = index[meta[:,3]  >= LST_1]
	index_LST_2 = index[meta[:,3]  <  LST_2]
	index_SUN   = index[meta[:,6]  <= sun_el_max]
	index_HUM   = index[meta[:,10] <= amb_hum_max]

	index1      = np.intersect1d(index_LST_1, index_LST_2)
	index2      = np.intersect1d(index_SUN, index_HUM)
	index_all   = np.intersect1d(index1, index2)

	t_sel = Ta[index_all, :]
	m_sel = meta[index_all, :]
	w_sel = weights[index_all, :]

	print(index_all)







	# Computing residuals
	res_all = np.zeros((len(t_sel[:,0]), len(freq)))
	for i in range(len(t_sel[:,0])):

		if np.sum(w_sel[i,:]) > 0:
			print(i)
			pp    = fit_polynomial_fourier('EDGES_polynomial', freq, t_sel[i,:], 5, Weights=w_sel[i,:])
			model = model_evaluate('EDGES_polynomial', pp[0], freq)
			res   = t_sel[i,:] - model

			res_all[i,:] = res



	## Plotting
	#K = 1
	#f1 = plt.figure(1)
	#for i in range(len(res_all[:,0])):
		#plt.plot(freq, res_all[i,:] + K*i)

	#plt.xlim([100, 190])
	#plt.ylim([-3, K*(len(res_all[:,0])+3)])
	#plt.grid()


	return freq, res_all, meta	



























def weighted_mean(data_array, weights_array):

	# Number of frequency channels
	lf = len(data_array[0,:])

	# Number of spectra
	ls = len(data_array[:,0])

	# Initializing arrays
	av = np.zeros(lf)
	w  = np.zeros(lf)

	# Cycle over frequency channels
	for k in range(lf):
		num = 0
		den = 0
		wei = 0

		# Cycle over number of spectra
		for j in range(ls):
			if (weights_array[j,k] > 0): # (data_array[j,k] > 0) and 
				num = num + data_array[j,k] * weights_array[j,k]
				den = den + weights_array[j,k]


		# Computing averages
		if (num != 0) and (den != 0): 
			av[k] = num/den
			w[k]  = den


	return av, w









def weighted_standard_deviation(av, data_array, std_array):

	ls = len(data_array[0,:])
	la = len(data_array[:,0])

	std_sq = np.zeros(ls)

	for k in range(ls):
		num = 0
		den = 0		
		for j in range(la):
			num = num + ((data_array[j,k]-av[k])/std_array[j,k])**2
			den = den + 1/(std_array[j,k]**2)

		if (num != 0) and (den != 0): 
			std_sq[k] = num/den


	std = np.sqrt(std_sq)	

	return std









def spectral_averaging(data_array, weights_array):

	"""
	array: 2D format ls x lf
	ls: number of spectra (number of 1D arrays)
	lf: number of frequency points per spectra
	"""

	av, w  = weighted_mean(data_array, weights_array)	

	return av, w






def spectral_zero_removal_old(f, d, w, flow, fhigh, weight = 0):

	no_zeros = 0
	wn = w/np.max(w)
	freq    = 0
	data    = 0
	weights = 0
	for i in range(len(f)):

		if (wn[i] > weight) and (no_zeros==0) and (f[i] >= flow) and (f[i] <= fhigh):

			freq    = f[i]
			data    = d[i]
			weights = w[i]
			no_zeros = 1

		elif (wn[i] > weight) and (no_zeros==1) and (f[i] >= flow) and (f[i] <= fhigh):

			freq    = np.append(freq,    f[i])
			data    = np.append(data,    d[i])
			weights = np.append(weights, w[i])


	return freq, data, weights







def spectral_zero_removal(f, d, w, flow, fhigh, weight = 0):

	ww = w/np.max(w)

	f_new = f[(ww > weight) & (f >= flow) & (f <= fhigh)]
	d_new = d[(ww > weight) & (f >= flow) & (f <= fhigh)]
	w_new = w[(ww > weight) & (f >= flow) & (f <= fhigh)]

	return f_new, d_new, w_new














def ground_loss(band, f, model_type='value', ground_loss_percent=0.5, MC='no'):

	"""
	February 26, 2017

	"""

	if band == 'high_band_2015':

		# Tom
		#if model_type == 'Tom':		
		ground_loss_file = home_folder + '/DATA/EDGES/calibration/loss/high_band/ground_loss/Blade_Percentage_Loss_in_field_size.txt'			
		data             = np.genfromtxt(ground_loss_file)
		raw_fre          = data[:,0]
		raw_pbh          = data[:,1]/100   # fraction of power below horizon
		raw_pah          = 1 - raw_pbh     # fraction of power above horizon
		nterms           = 35              # it seems that 35 fourier terms are necessary
		par              = fit_polynomial_fourier('fourier', (raw_fre-140)/60, raw_pah, nterms)
		pah_tom          = model_evaluate('fourier', par[0], (f-140)/60)        # power above horizon


		# Alan
		#if model_type == 'Alan':			
		par = [1.874884e+01, -1.000643e+02, 1.824230e+02, -1.335697e+02, 3.470102e+01]
		pbh = np.polyval(par, f/150) / 300			
		pah_alan = 1 - pbh


		# Value
		#if model_type == 'value':			
		pah_value = np.ones(len(f)) - (ground_loss_percent/100)   # ground_loss_percent is an actual loss (not gain) in percent. Acceptable values are 0, 0.5 (%), or 1 (%)


		# Nominal loss
		if model_type == 'Tom':
			pah = pah_tom
		elif model_type == 'Alan':
			pah = pah_alan
		elif model_type == 'value':
			pah = pah_value

		# MC
		# The MC perturbations consist of a random flat offset, plus a scaled version of the difference between the Tom's (Alan's) profile and the nominal profile
		if MC == 'yes':
			flag = 0
			while flag == 0:
				sigma_offset     = 0.0005 # 1-sigma of flat offset (0.05%)
				sigma_proportion = 0.3    # 1-sigma of scales (30%)
				perturbation     = np.random.normal(0, sigma_offset) + np.random.normal(0, sigma_proportion)*(pah_tom-pah) + np.random.normal(0, sigma_proportion)*(pah_alan-pah)
				pah              = pah + perturbation
				if np.max(pah) <= 1:
					flag = 1




	if (band == 'low_band_2015') or (band == 'low_band2_2017'):

		# Value			
		pah_value = np.ones(len(f)) - (ground_loss_percent/100)   # ground_loss_percent is an actual loss (not gain) in percent. Acceptable values are 0, 0.5 (%), 1 (%), etc.


		if model_type == 'value':
			pah = pah_value		


		# MC
		# The MC perturbations consist of a random flat offset
		if MC == 'yes':
			flag = 0
			while flag == 0:
				sigma_offset     = 0.0005 # 1-sigma of flat offset, 10% of nominal (0.05%)
				perturbation     = np.random.normal(0, sigma_offset)
				pah              = pah + perturbation
				if np.max(pah) <= 1:
					flag = 1


	return pah

























def antenna_loss(band, f, MC='no'):

	# These numbers come from a FEKO simulation run by Alan.
	# Two emails sent on 01/19/2016.


	if band == 'high_band_2015':

		raw_eff = np.array([99.8965, 99.9185, 99.9364, 99.9485, 99.9576, 99.9644, 99.9694, 99.9729, 99.9751, 99.9764, 99.9769, 99.9766, 99.9758, 99.9745, 99.9727, 99.9706, 99.9681, 99.9654, 99.9625, 99.9594, 99.9561, 99.9528, 99.9493])
		raw_eff = raw_eff / 100
		raw_fre = np.arange(90, 201, 5)

		nterms = 15      # 15 fourier terms
		p = fit_polynomial_fourier('fourier', (raw_fre-140)/60, raw_eff, nterms) 
		antenna_loss     = model_evaluate('fourier', p[0], (f-140)/60)


		# Monte Carlo
		if MC=='yes':
			sigma = 0.1*(1-antenna_loss)        # 10% of the difference between applying the "loss" and not applying 
			antenna_loss = antenna_loss + sigma*np.random.normal() 




	if (band == 'low_band_2015') or (band == 'low_band2_2017'):
		antenna_loss = 1


	return antenna_loss














def balun_and_connector_loss(band, f, Rant, MC=[0,0,0,0,0,0,0,0]):

	"""

	band: 'high_band' or 'low_band'
	f:    frequency in MHz
	Rant: reflection coefficient of antenna at the reference plane, the LNA input

	MC[0] = tube_inner_radius
	MC[1] = tube_outer_radius
	MC[2] = tube_length
	MC[3] = connector_inner_radius
	MC[4] = connector_outer_radius
	MC[5] = connector_length
	MC[6] = metal_conductivity   
	MC[7] = teflon_permittivity

	"""








	# Angular frequency
	w = 2 * np.pi * f * 1e6   

	# Inch-to-meters conversion
	inch2m = 1/39.370

	# Conductivity of copper
	sigma_copper0 = 5.813 * 10**7     # Pozar 3rd edition. Alan uses a different number. What is his source??




	if band == 'high_band_2015':


		# Balun dimensions 
		ric_b  = ((5/32)*inch2m)/2  # radius of outer wall of inner conductor
		if MC[0] == 1:
			ric_b = ric_b + 0.03*ric_b*np.random.normal()	# 1-sigma of 3%, about 0.04 mm

		roc_b  = ((0.37)*inch2m)/2  # radius of inner wall of outer conductor
		if MC[1] == 1:
			roc_b = roc_b + 0.03*roc_b*np.random.normal()	# 1-sigma of 3%, about 0.08 mm 

		l_b    = 21.9*inch2m    # length in meters
		if MC[2] == 1:
			l_b = l_b + 0.001*np.random.normal()	# 1-sigma of 1 mm


		# Connector+bend dimensions
		ric_c  = (0.05*inch2m)/2  # radius of outer wall of inner conductor
		if MC[3] == 1:
			ric_c = ric_c + 0.03*ric_c*np.random.normal()	# 1-sigma of 3%, about < 0.04 mm

		roc_c  = (0.16*inch2m)/2  # radius of inner wall of outer conductor
		if MC[4] == 1:
			roc_c = roc_c + 0.03*roc_c*np.random.normal()	# 1-sigma of 3%, about 0.04 mm	

		l_c    = 1.18*inch2m  # length
		if MC[5] == 1:
			l_c = l_c + 0.0001*np.random.normal()	# 1-sigma of 0.1 mm


		# Metal conductivity
		sigma_copper   = 1     * sigma_copper0        
		sigma_brass    = 0.29  * sigma_copper0

		sigma_xx_inner = 0.2   * sigma_copper0
		sigma_xx_outer = 0.024 * sigma_copper0

		if MC[6] == 1:
			sigma_copper   = sigma_copper   + 0.01*sigma_copper   * np.random.normal()   # 1-sigma of 1% of value
			sigma_brass    = sigma_brass    + 0.01*sigma_brass    * np.random.normal()   # 1-sigma of 1% of value
			sigma_xx_inner = sigma_xx_inner + 0.01*sigma_xx_inner * np.random.normal()   # 1-sigma of 1% of value
			sigma_xx_outer = sigma_xx_outer + 0.01*sigma_xx_outer * np.random.normal()   # 1-sigma of 1% of value



		# Permeability
		u0        = 4*np.pi*10**(-7)  # permeability of free space (same for copper, brass, etc., all nonmagnetic materials)

		ur_air    = 1 # relative permeability of air
		u_air     = u0 * ur_air

		ur_teflon = 1 # relative permeability of teflon
		u_teflon  = u0 * ur_teflon



		# Permittivity
		c          = 299792458       # speed of light
		e0         = 1/(u0 * c**2)   # permittivity of free space

		er_air           = 1.07 # why Alan???? shouldn't it be closer to 1 ?
		ep_air           = e0 * er_air
		tan_delta_air    = 0 
		epp_air          = ep_air    * tan_delta_air

		er_teflon        = 2.05 # why Alan????   	
		ep_teflon        = e0 * er_teflon
		tan_delta_teflon = 0.0002 # http://www.kayelaby.npl.co.uk/general_physics/2_6/2_6_5.html
		epp_teflon       = ep_teflon * tan_delta_teflon

		if MC[7] == 1:
			epp_teflon = epp_teflon + 0.01*epp_teflon * np.random.normal()	# 1-sigma of 1%









	if band == 'low_band_2015':

		# These are valid for the low-band antenna
		balun_length     = 43.6 # inches
		connector_length = 0.8 # inch
		
		

		# Information from memos 166 and 181
		# -------------------------------------------------------------------


		# Balun dimensions 
		ric_b  = ((5/16)*inch2m)/2  # radius of outer wall of inner conductor
		if MC[0] == 1:
			ric_b = ric_b + 0.03*ric_b*np.random.normal()	# 1-sigma of 3%, about 0.04 mm

		roc_b  = ((3/4)*inch2m)/2  # radius of inner wall of outer conductor
		if MC[1] == 1:
			roc_b = roc_b + 0.03*roc_b*np.random.normal()	# 1-sigma of 3%, about 0.08 mm 

		l_b    = balun_length*inch2m    # length in meters
		if MC[2] == 1:
			l_b = l_b + 0.001*np.random.normal()	# 1-sigma of 1 mm


		# Connector dimensions
		ric_c  = (0.05*inch2m)/2  # radius of outer wall of inner conductor
		if MC[3] == 1:
			ric_c = ric_c + 0.03*ric_c*np.random.normal()	# 1-sigma of 3%, about < 0.04 mm

		roc_c  = (0.16*inch2m)/2  # radius of inner wall of outer conductor
		if MC[4] == 1:
			roc_c = roc_c + 0.03*roc_c*np.random.normal()	# 1-sigma of 3%, about 0.04 mm	

		l_c    = connector_length*inch2m  # length
		if MC[5] == 1:
			l_c = l_c + 0.0001*np.random.normal()	# 1-sigma of 0.1 mm


		# Metal conductivity
		sigma_copper   = 0.8   * sigma_copper0
		sigma_brass    = 0.24  * sigma_copper0

		sigma_xx_inner = 0.24  * sigma_copper0
		sigma_xx_outer = 0.024 * sigma_copper0

		if MC[6] == 1:
			sigma_copper   = sigma_copper   + 0.01*sigma_copper   * np.random.normal()   # 1-sigma of 1% of value
			sigma_brass    = sigma_brass    + 0.01*sigma_brass    * np.random.normal()   # 1-sigma of 1% of value
			sigma_xx_inner = sigma_xx_inner + 0.01*sigma_xx_inner * np.random.normal()   # 1-sigma of 1% of value
			sigma_xx_outer = sigma_xx_outer + 0.01*sigma_xx_outer * np.random.normal()   # 1-sigma of 1% of value



		# Permeability
		u0        = 4*np.pi*10**(-7)  # permeability of free space (same for copper, brass, etc., all nonmagnetic materials)

		ur_air    = 1 # relative permeability of air
		u_air     = u0 * ur_air

		ur_teflon = 1 # relative permeability of teflon
		u_teflon  = u0 * ur_teflon



		# Permittivity
		c          = 299792458       # speed of light
		e0         = 1/(u0 * c**2)   # permittivity of free space

		er_air           = 1.07 # why Alan???? shouldn't it be closer to 1 ?
		ep_air           = e0 * er_air
		tan_delta_air    = 0 
		epp_air          = ep_air    * tan_delta_air

		er_teflon        = 2.05 # why Alan????   	
		ep_teflon        = e0 * er_teflon
		tan_delta_teflon = 0.0002 # http://www.kayelaby.npl.co.uk/general_physics/2_6/2_6_5.html
		epp_teflon       = ep_teflon * tan_delta_teflon

		if MC[7] == 1:
			epp_teflon = epp_teflon + 0.01*epp_teflon * np.random.normal()	# 1-sigma of 1%








	if band == 'low_band2_2017':	

		# These are valid for the low-band antenna
		balun_length     = 43.6 # inches
		connector_length = 0.8 # inch
		


		# Information from memos 166, 181, 210, 216
		# -----------------------------------------------------------------


		# Balun dimensions 
		ric_b  = ((5/16)*inch2m)/2  # radius of outer wall of inner conductor
		if MC[0] == 1:
			ric_b = ric_b + 0.03*ric_b*np.random.normal()	# 1-sigma of 3%, about 0.04 mm

		roc_b  = ((3/4)*inch2m)/2  # radius of inner wall of outer conductor
		if MC[1] == 1:
			roc_b = roc_b + 0.03*roc_b*np.random.normal()	# 1-sigma of 3%, about 0.08 mm 

		l_b    = balun_length*inch2m    # length in meters   BEFORE 44.1
		if MC[2] == 1:
			l_b = l_b + 0.001*np.random.normal()	# 1-sigma of 1 mm


		# Connector dimensions
		ric_c  = (0.05*inch2m)/2  # radius of outer wall of inner conductor
		if MC[3] == 1:
			ric_c = ric_c + 0.03*ric_c*np.random.normal()	# 1-sigma of 3%, about < 0.04 mm

		roc_c  = (0.16*inch2m)/2  # radius of inner wall of outer conductor
		if MC[4] == 1:
			roc_c = roc_c + 0.03*roc_c*np.random.normal()	# 1-sigma of 3%, about 0.04 mm	

		l_c    = connector_length*inch2m  # length    CHANGE FROM 0.5 TO 1 INCH
		if MC[5] == 1:
			l_c = l_c + 0.0001*np.random.normal()	# 1-sigma of 0.1 mm


		# Metal conductivity
		sigma_copper   = 0.8   * sigma_copper0 
		sigma_brass    = 0.24  * sigma_copper0

		sigma_xx_inner = 0.24  * sigma_copper0
		sigma_xx_outer = 0.024 * sigma_copper0

		if MC[6] == 1:
			sigma_copper   = sigma_copper   + 0.01*sigma_copper   * np.random.normal()   # 1-sigma of 1% of value
			sigma_brass    = sigma_brass    + 0.01*sigma_brass    * np.random.normal()   # 1-sigma of 1% of value
			sigma_xx_inner = sigma_xx_inner + 0.01*sigma_xx_inner * np.random.normal()   # 1-sigma of 1% of value
			sigma_xx_outer = sigma_xx_outer + 0.01*sigma_xx_outer * np.random.normal()   # 1-sigma of 1% of value



		# Permeability
		u0        = 4*np.pi*10**(-7)  # permeability of free space (same for copper, brass, etc., all nonmagnetic materials)

		ur_air    = 1 # relative permeability of air
		u_air     = u0 * ur_air

		ur_teflon = 1 # relative permeability of teflon
		u_teflon  = u0 * ur_teflon



		# Permittivity
		c          = 299792458       # speed of light
		e0         = 1/(u0 * c**2)   # permittivity of free space

		er_air           = 1.07 # why Alan???? shouldn't it be closer to 1 ?
		ep_air           = e0 * er_air
		tan_delta_air    = 0 
		epp_air          = ep_air    * tan_delta_air

		er_teflon        = 2.05 # why Alan????   	
		ep_teflon        = e0 * er_teflon
		tan_delta_teflon = 0.0002 # http://www.kayelaby.npl.co.uk/general_physics/2_6/2_6_5.html
		epp_teflon       = ep_teflon * tan_delta_teflon

		if MC[7] == 1:
			epp_teflon = epp_teflon + 0.01*epp_teflon * np.random.normal()	# 1-sigma of 1%









	if band == 'mid_band_2018':	

		# Information from memo 273 and email from Alan Oct 18, 2018
		# -----------------------------------------------------------------

		# These are valid for the mid-band antenna
		balun_length     = 35 # inches
		connector_length = 0.03/inch2m # (3 cm <-> 1.18 inch) # Fairview SC3792



		# Balun dimensions 
		ric_b  = ((16/32)*inch2m)/2  # radius of outer wall of inner conductor
		if MC[0] == 1:
			ric_b = ric_b + 0.03*ric_b*np.random.normal()	# 1-sigma of 3%, about 0.04 mm

		roc_b  = ((1.25)*inch2m)/2  # radius of inner wall of outer conductor
		if MC[1] == 1:
			roc_b = roc_b + 0.03*roc_b*np.random.normal()	# 1-sigma of 3%, about 0.08 mm 

		l_b    = balun_length*inch2m    # length in meters 
		if MC[2] == 1:
			l_b = l_b + 0.001*np.random.normal()	# 1-sigma of 1 mm


		# Connector dimensions (Fairview SC3792)
		ric_c  = (0.05*inch2m)/2  # radius of outer wall of inner conductor
		if MC[3] == 1:
			ric_c = ric_c + 0.03*ric_c*np.random.normal()	# 1-sigma of 3%, about < 0.04 mm

		roc_c  = (0.161*inch2m)/2  # radius of inner wall of outer conductor
		if MC[4] == 1:
			roc_c = roc_c + 0.03*roc_c*np.random.normal()	# 1-sigma of 3%, about 0.04 mm	

		l_c    = connector_length*inch2m  # length    in meters
		if MC[5] == 1:
			l_c = l_c + 0.0001*np.random.normal()	# 1-sigma of 0.1 mm


		# Metal conductivity
		sigma_copper   = 0.8   * sigma_copper0   # Difference with Alan. Alan doesn't multiply by 0.8. Also, his sigma_copper0 is 5.96e7, compared to mine, which is 5.813e7 from Pozar
		sigma_brass    = 0.24  * sigma_copper0

		sigma_xx_inner = 0.24  * sigma_copper0
		sigma_xx_outer = 0.024 * sigma_copper0

		if MC[6] == 1:
			sigma_copper   = sigma_copper   + 0.01*sigma_copper   * np.random.normal()   # 1-sigma of 1% of value
			sigma_brass    = sigma_brass    + 0.01*sigma_brass    * np.random.normal()   # 1-sigma of 1% of value
			sigma_xx_inner = sigma_xx_inner + 0.01*sigma_xx_inner * np.random.normal()   # 1-sigma of 1% of value
			sigma_xx_outer = sigma_xx_outer + 0.01*sigma_xx_outer * np.random.normal()   # 1-sigma of 1% of value



		# Permeability
		u0        = 4*np.pi*10**(-7)  # permeability of free space (same for copper, brass, etc., all nonmagnetic materials)

		ur_air    = 1 # relative permeability of air
		u_air     = u0 * ur_air

		ur_teflon = 1 # relative permeability of teflon
		u_teflon  = u0 * ur_teflon



		# Permittivity
		c          = 299792458       # speed of light
		e0         = 1/(u0 * c**2)   # permittivity of free space

		er_air           = 1.2 # Question for Alan. Why this value ???? shouldn't it be closer to 1 ?
		ep_air           = e0 * er_air
		tan_delta_air    = 0 
		epp_air          = ep_air    * tan_delta_air

		er_teflon        = 2.05 # why Alan????   	
		ep_teflon        = e0 * er_teflon
		tan_delta_teflon = 0.0002 # http://www.kayelaby.npl.co.uk/general_physics/2_6/2_6_5.html
		epp_teflon       = ep_teflon * tan_delta_teflon

		if MC[7] == 1:
			epp_teflon = epp_teflon + 0.01*epp_teflon * np.random.normal()	# 1-sigma of 1%

















	# Skin Depth 
	skin_depth_copper = np.sqrt(2 / (w * u0 * sigma_copper))
	skin_depth_brass  = np.sqrt(2 / (w * u0 * sigma_brass))

	skin_depth_xx_inner = np.sqrt(2 / (w * u0 * sigma_xx_inner))
	skin_depth_xx_outer = np.sqrt(2 / (w * u0 * sigma_xx_outer))




	# Surface resistance
	Rs_copper = 1 / (sigma_copper * skin_depth_copper)
	Rs_brass  = 1 / (sigma_brass  * skin_depth_brass)

	Rs_xx_inner = 1 / (sigma_xx_inner * skin_depth_xx_inner)
	Rs_xx_outer = 1 / (sigma_xx_outer * skin_depth_xx_outer)




	# Transmission Line Parameters
	# ----------------------------

	# Balun
	# -----

	# Inductance per unit length
	Lb_inner  = u0 * skin_depth_copper / (4 * np.pi * ric_b)
	Lb_dielec = (u_air / (2 * np.pi)) * np.log(roc_b/ric_b) 
	Lb_outer  = u0 * skin_depth_brass / (4 * np.pi * roc_b)
	Lb        = Lb_inner + Lb_dielec + Lb_outer

	# Capacitance per unit length	
	Cb = 2 * np.pi * ep_air / np.log(roc_b/ric_b)

	# Resistance per unit length
	Rb = (Rs_copper / (2 * np.pi * ric_b))   +   (Rs_brass / (2 * np.pi * roc_b))

	# Conductance per unit length
	Gb = 2 * np.pi * w * epp_air / np.log(roc_b/ric_b)





	# Connector
	# ---------

	# Inductance per unit length
	Lc_inner  = u0 * skin_depth_xx_inner / (4 * np.pi * ric_c)
	Lc_dielec = (u_teflon / (2 * np.pi)) * np.log(roc_c/ric_c)
	Lc_outer  = u0 * skin_depth_xx_outer / (4 * np.pi * roc_c)
	Lc = Lc_inner + Lc_dielec + Lc_outer

	# Capacitance per unit length	
	Cc = 2 * np.pi * ep_teflon / np.log(roc_c/ric_c)

	# Resistance per unit length
	Rc = (Rs_xx_inner / (2 * np.pi * ric_c))   +   (Rs_xx_outer / (2 * np.pi * roc_c))

	# Conductance per unit length
	Gc = 2 * np.pi * w * epp_teflon / np.log(roc_c/ric_c)





	# Propagation constant
	gamma_b = np.sqrt( (Rb + 1j*w*Lb) * (Gb + 1j*w*Cb) )
	gamma_c = np.sqrt( (Rc + 1j*w*Lc) * (Gc + 1j*w*Cc) )


	# Complex Cable Impedance
	Zchar_b = np.sqrt( (Rb + 1j*w*Lb) / (Gb + 1j*w*Cb) )
	Zchar_c = np.sqrt( (Rc + 1j*w*Lc) / (Gc + 1j*w*Cc) )




	# ----------------------------------------------------------------------------------
	# The following loss calculations employ the expressions in Memo 126, and end of 125 
	# ----------------------------------------------------------------------------------

	# Impedance of Agilent terminations
	Zref = 50
	Ropen, Rshort, Rmatch = rc.agilent_85033E(f*1e6, Zref, 1)
	Zopen  = rc.gamma2impedance(Ropen,  Zref)
	Zshort = rc.gamma2impedance(Rshort, Zref)
	Zmatch = rc.gamma2impedance(Rmatch, Zref)



	# Impedance of terminated transmission lines
	Zin_b_open  = rc.input_impedance_transmission_line(Zchar_b, gamma_b, l_b, Zopen)
	Zin_b_short = rc.input_impedance_transmission_line(Zchar_b, gamma_b, l_b, Zshort)
	Zin_b_match = rc.input_impedance_transmission_line(Zchar_b, gamma_b, l_b, Zmatch)

	Zin_c_open  = rc.input_impedance_transmission_line(Zchar_c, gamma_c, l_c, Zopen)
	Zin_c_short = rc.input_impedance_transmission_line(Zchar_c, gamma_c, l_c, Zshort)
	Zin_c_match = rc.input_impedance_transmission_line(Zchar_c, gamma_c, l_c, Zmatch)



	# Reflection of terminated transmission lines
	Rin_b_open  = rc.impedance2gamma(Zin_b_open,  Zref)
	Rin_b_short = rc.impedance2gamma(Zin_b_short, Zref)
	Rin_b_match = rc.impedance2gamma(Zin_b_match, Zref)

	Rin_c_open  = rc.impedance2gamma(Zin_c_open,  Zref)
	Rin_c_short = rc.impedance2gamma(Zin_c_short, Zref)
	Rin_c_match = rc.impedance2gamma(Zin_c_match, Zref)





	# S-parameters (it has to be done in this order, first the Connector+Bend, then the Balun)
	Rant_c, S11c, S12S21c, S22c = rc.de_embed(Ropen, Rshort, Rmatch, Rin_c_open, Rin_c_short, Rin_c_match, Rant) # Reflection of antenna + balun, at the input of bend+connector	
	Rant_b, S11b, S12S21b, S22b = rc.de_embed(Ropen, Rshort, Rmatch, Rin_b_open, Rin_b_short, Rin_b_match, Rant_c) # Reflection of antenna only, at the input of balun


	# Inverting S11 and S22
	S11b_rev = S22b
	S22b_rev = S11b

	S11c_rev = S22c
	S22c_rev = S11c



	# Absolute value of S_21
	abs_S21b = np.sqrt(np.abs(S12S21b))
	abs_S21c = np.sqrt(np.abs(S12S21c))



	# Available Power Gain (Gain Factor, also known as Loss Factor)
	Gb = ( abs_S21b**2 ) * ( 1-np.abs(Rant_b)**2 ) / ( (np.abs(1-S11b_rev*Rant_b))**2 * (1-(np.abs(Rant_c))**2) )
	Gc = ( abs_S21c**2 ) * ( 1-np.abs(Rant_c)**2 ) / ( (np.abs(1-S11c_rev*Rant_c))**2 * (1-(np.abs(Rant))**2) )




	## ---------------------------------------------------------------
	## Alternative way, Memo 126. Gives the Same results as above !!!!
	## ---------------------------------------------------------------

	## Impedance of Antenna at Reference Plane
	#Zant = rc.gamma2impedance(Rant, 50)

	## Impedance of Antenna at the input of Connector + Bend
	#Zant_before_c = rc.gamma2impedance(Rant_c, 50)



	## Factor R (Gamma)
	#Rb = ((Zant_before_c - Zchar_b)/(Zant_before_c + Zchar_b)) * np.exp(2 * gamma_b * l_b)
	#Rc = ((Zant - Zchar_c)/(Zant + Zchar_c)) * np.exp(2 * gamma_c * l_c)


	## Voltage and Currents
	#Vin_b  =   np.exp(gamma_b * l_b) + Rb * np.exp(-gamma_b * l_b)
	#Iin_b  = ( np.exp(gamma_b * l_b) - Rb * np.exp(-gamma_b * l_b) ) / Zchar_b
	#Vout_b =  1 + Rb
	#Iout_b = (1 - Rb) / Zchar_b

	#Vin_c  =   np.exp(gamma_c * l_c) + Rc * np.exp(-gamma_c * l_c)
	#Iin_c  = ( np.exp(gamma_c * l_c) - Rc * np.exp(-gamma_c * l_c) ) / Zchar_c
	#Vout_c =  1 + Rc
	#Iout_c = (1 - Rc) / Zchar_c


	## Loss parameter
	#Gb = np.real(Vout_b * np.conj(Iout_b) ) / np.real(Vin_b * np.conj(Iin_b))
	#Gc = np.real(Vout_c * np.conj(Iout_c) ) / np.real(Vin_c * np.conj(Iin_c))



	return Gb, Gc








def RFI_manual_cuts(f, t, w):

	flag = 0
	for i in range(len(f)):		
		if (f[i] < 129.65) or ((f[i] > 130.40) and (f[i] < 134)) or ((f[i] > 140) and (f[i] < 145.4)) or ((f[i] > 146.2) and (f[i] < 149.6)) or (f[i] > 150.7):
			if flag == 0:
				f_new = f[i]
				t_new = t[i]
				w_new = w[i]
				flag = 1

			elif flag == 1:
				f_new = np.append(f_new, f[i])
				t_new = np.append(t_new, t[i])
				w_new = np.append(w_new, w[i])


	return f_new, t_new, w_new









def RFI_DTV_removal(f, t2D, w2D):


	# Selecting data in the range where DTV are to be found
	fstart=160	
	fQ = f[f>=fstart]
	tQ = t2D[:,f>=fstart]
	wQ = w2D[:,f>=fstart]


	# Compute residuals and RMS for the selected frequency range
	res_all = np.zeros((len(tQ[:,0]), len(fQ)))
	RMS_all = np.zeros(len(tQ[:,0]))
	for i in range(len(tQ[:,0])):		
		if np.sum(wQ[i,:]) >  100:
			pp    = fit_polynomial_fourier('EDGES_polynomial', fQ/150, tQ[i,:], 3, Weights=wQ[i,:])
			model = model_evaluate('EDGES_polynomial', pp[0], fQ/150)
			res   = tQ[i,:]-model
			RMS   = np.std(res[wQ[i,:]>0])
			res_all[i,:] = res
			RMS_all[i]   = RMS


	# Computing typical RMS
	minT       = 0
	maxT       = 1
	index      = np.arange(0,len(tQ[:,0]))
	index_sel  = index[(np.sum(wQ, axis=1) > 0) & (RMS_all > minT) & (RMS_all < maxT)]
	RMS_median_sel = np.median(RMS_all[index_sel])


	# Cleaning range where DTV is identified
	res_all_2 = res_all[RMS_all < 2*RMS_median_sel]
	t2D_clean = np.copy(t2D)
	w2D_clean = np.copy(w2D)
	for i in range(len(index)):
		if RMS_all[i] > 2*RMS_median_sel:
			t2D_clean[i, f>=fstart] = 0
			w2D_clean[i, f>=fstart] = 0


	return t2D_clean, w2D_clean










def data_analysis_high_band_level3_ALL_LST_averages():

	# Bring the META selections to this level



	# Calibrating and cleaning data
	for i in range(72):
		f, ta, m, w                   = data_analysis_high_band_level3(i)
		avt, avw                      = spectral_averaging(ta, w)
		avt_clean, useless, avw_clean = data_analysis_high_band_level3_extra_RFI_flagging(f, avt.reshape(1,-1), np.ones((1,len(f))), avw.reshape(1,-1), fit_poly_order=25, N_sigma=3)

		if i == 0:
			avt_clean_all = avt_clean
			avw_clean_all = avw_clean

		elif i > 0:
			avt_clean_all = np.append(avt_clean_all, avt_clean, axis=0)
			avw_clean_all = np.append(avw_clean_all, avw_clean, axis=0)



	# Save
	save_file = '/media/raul/DATA/EDGES/spectra/level5/high_band/high_band_v1.hdf5'	

	with h5py.File(save_file, 'w') as hf:
		hf.create_dataset('frequency',           data = f)
		hf.create_dataset('antenna_temperature', data = avt_clean_all)
		hf.create_dataset('weights',             data = avw_clean_all)



	return 1



















def data_analysis(LST_index_array, n_sigma = 3, N_rms_sigma = 3, N_res_sigma = 3):
	"""
	LST_index_array = np.array([5,6,7,8,9,10])
	"""

	# Load data
	level4file = '/media/raul/DATA/EDGES/spectra/level4/high_band/high_band_v1_blade_s11day_262_recv_temp_full_correction_tambient_300.hdf5'
	f, ta_all, m_all, w_all = level3read(level4file)


	# Selection of data based on time, sun elevation, and then time-averaging
	# -----------------------------------------------------------------------
	l_days = len(ta_all[0,:,0])
	l_freq = len(ta_all[0,0,:])	
	t = np.zeros((l_days, l_freq))
	w = np.zeros((l_days, l_freq))
	max_sun_el = -10 # Elevation selection
	n_bin = 4        # Parameter used for RFI cleaning


	# Loop over days
	flag0 = 0
	for k in range(l_days):


		# Average all the 20-minute-LST spectra
		flag1 = 0
		t_temp = np.array([0])
		w_temp = np.array([0])		

		for j in range(len(LST_index_array)):

			if (m_all[LST_index_array[j],k,6] < max_sun_el) and (np.sum(w_all[LST_index_array[j],k,:]) > 0):

				print(str(k) + ': ' + str(m_all[LST_index_array[j],k,6]))

				if flag1 == 0:
					t_temp = ta_all[LST_index_array[j],k,:].reshape(1,-1)
					w_temp = w_all[LST_index_array[j],k,:].reshape(1,-1)
					flag1  = 1

				elif flag1 > 0:
					t_temp = np.append(t_temp, ta_all[LST_index_array[j],k,:].reshape(1,-1), axis=0)
					w_temp = np.append(w_temp, w_all[LST_index_array[j],k,:].reshape(1,-1),  axis=0)
					flag1  = flag1 + 1


		# There is only one 20-minute LST bin available for this day (no need for RFI cleaning since this has already been performed to Level4 files)
		if flag1 == 1:
			t[k,:] = t_temp
			w[k,:] = w_temp


		# Averaging and RFI-cleaning of all 20-minute LST bins available for each day
		elif flag1 > 1:

			# Averaging
			avt, avw = spectral_averaging(t_temp, w_temp)

			# RFI cleaning after averaging over LST
			avt_no_rfi, avw_no_rfi = data_analysis_RFI_removal(f, avt, avw, n_bin = n_bin, n_sigma = n_sigma, N_iter = 5)
			t[k,:] = avt#avt_no_rfi
			w[k,:] = avw#avw_no_rfi



	# Filtering based on RMS of data
	# ------------------------------
	index_RMS = data_analysis_RMS_selection(f, t, w, fit_poly_order = 5, small_sample_size = 5, N_rms_sigma = N_rms_sigma)
	t_RMS = t[index_RMS,:]
	w_RMS = w[index_RMS,:]









	# Filtering based on residuals
	#index_residuals = data_analysis_residuals_selection(f, t_RMS, w_RMS, fit_poly_order = 5, small_sample_size = 5, N_res_sigma = N_res_sigma)








	# Plots
	# -----------------------------------
	plt.close()
	plt.close()
	plt.close()
	plt.close()



	f1 = plt.figure(1)
	# -----------------------------------------
	plt.subplot(1,2,1)

	res = np.zeros((len(t_RMS[:,0]), len(t_RMS[0,:])))
	for i in range(len(t_RMS[:,0])):
		pp       = fit_polynomial_fourier('EDGES_polynomial', f, t_RMS[i,:], 16, Weights=w_RMS[i,:])
		model    = model_evaluate('EDGES_polynomial', pp[0], f)
		res[i,:] = -(t_RMS[i,:] - model) + i

	res_nan = np.nan*np.zeros((len(t_RMS[:,0]), len(t_RMS[0,:])))
	res_nan[np.nonzero(t_RMS)] = res[np.nonzero(t_RMS)]
	plt.plot(f, res_nan.T)   # I have to invert vertically the data because I am inverting the vertical axis
	plt.xlim([90, 190])
	plt.ylim([0-0.5, len(t_RMS[:,0])-0.5])
	plt.xlabel('frequency [MHz]')
	plt.ylabel('spectrum number')	
	plt.gca().invert_yaxis()





	plt.subplot(1,2,2)

	avt, avw = spectral_averaging(t_RMS, w_RMS)
	avt_no_rfi, avw_no_rfi = data_analysis_RFI_removal(f, avt, avw, n_bin = 4, n_sigma = 2.9, N_iter = 5)
	pp       = fit_polynomial_fourier('EDGES_polynomial', f, avt_no_rfi, 5, Weights=avw_no_rfi)
	av_model = model_evaluate('EDGES_polynomial', pp[0], f)

	t_RMS_nan = np.nan*np.zeros((len(t_RMS[:,0]), len(t_RMS[0,:])))
	t_RMS_nan[np.nonzero(t_RMS)] = t_RMS[np.nonzero(t_RMS)]

	im = plt.imshow(t_RMS_nan - av_model, interpolation='none', aspect='auto', extent=[90, 190, len(t_RMS[:,0]), 0]);im.set_clim([-3, 3])
	plt.xlabel('frequency [MHz]')
	plt.ylabel('spectrum number')







	f2 = plt.figure(2)
	# -----------------------------------------	
	plt.plot(f, avt_no_rfi - av_model)
	plt.grid()
	plt.xlim([80, 200])
	plt.ylim([-1,1])
	plt.xlabel('frequency [MHz]')
	plt.ylabel(r'$\Delta$ temperature [K]')







	#f3 = plt.figure(3)
	## ----------------------------------------
	#n_av = 6
	#l_av = int(len(t_RMS[:,0])/n_av)
	#res_av = np.zeros((n_av, len(f)))
	#avt_no_rfi_all = np.zeros((n_av, len(f)))
	#avw_no_rfi_all = np.zeros((n_av, len(f)))

	#for i in range(n_av):
		#i1 = i*l_av
		#i2 = (i+1)*l_av
		#if i < (n_av - 1):
			#avt, avw = spectral_averaging(t_RMS[i1:i2,:], w_RMS[i1:i2,:])
			#avt_no_rfi, avw_no_rfi = data_analysis_RFI_removal(f, avt, avw, n_bin = 4, n_sigma = 3, N_iter = 5)
			#pp       = fit_polynomial_fourier('EDGES_polynomial', f, avt_no_rfi, 9, Weights=avw_no_rfi)
			#av_model = model_evaluate('EDGES_polynomial', pp[0], f)
			#res      = avt_no_rfi - av_model

		#elif i == (n_av - 1):
			#avt, avw = spectral_averaging(t_RMS[i1::,:], w_RMS[i1::,:])
			#avt_no_rfi, avw_no_rfi = data_analysis_RFI_removal(f, avt, avw, n_bin = 4, n_sigma = 3, N_iter = 5)
			#pp       = fit_polynomial_fourier('EDGES_polynomial', f, avt_no_rfi, 9, Weights=avw_no_rfi)
			#av_model = model_evaluate('EDGES_polynomial', pp[0], f)
			#res      = avt_no_rfi - av_model


		#res_av[i,:] = res
		#avt_no_rfi_all[i,:] = avt_no_rfi
		#avw_no_rfi_all[i,:] = avw_no_rfi


	#for i in range(n_av):
		#plt.plot(f, res_av[i,:]+i+1)
	#plt.grid()
	#plt.xlabel('frequency')
	#plt.ylabel(r'$\Delta$ temperature [K]')
	#plt.xlim([80, 200])
	#plt.ylim([0, n_av+1])





	#f4 = plt.figure(4)
	##--------------------------------------
	#avtt, avww = spectral_averaging(avt_no_rfi_all, avw_no_rfi_all)
	#pp         = fit_polynomial_fourier('EDGES_polynomial', f, avtt, 5, Weights = avww)
	#avtt_model = model_evaluate('EDGES_polynomial', pp[0], f)
	#plt.plot(f, avtt - avtt_model)
	#plt.ylim([-1,1])



	return f, t_RMS, w_RMS























def data_analysis_level3(LST_index_array):
	"""
	LST_index_array = np.array([5,6,7,8,9,10])
	"""


	# Loading data
	level3file = '/media/raul/DATA/EDGES/spectra/level3/high_band/high_band_v1_blade.hdf5'
	f, ta_all, m_all, s_all, w_all = level3read(level3file)







	l_days = len(ta_all[0,:,0])
	l_freq = len(ta_all[0,0,:])




	# Selection of data based on time, sun elevation, and then time-averaging

	t = np.zeros((l_days, l_freq))
	w = np.zeros((l_days, l_freq))

	max_sun_el = -10


	# Loop over days
	flag0 = 0
	for k in range(l_days):

		flag1 = 0
		t_temp = np.array([0])
		w_temp = np.array([0])

		print('hola')

		# Loop over 20-minute time bins
		for j in range(len(LST_index_array)):
			print(str(k) + ': ' + str(m_all[LST_index_array[j],k,6]))

			if (m_all[LST_index_array[j],k,6] < max_sun_el) and (np.sum(w_all[LST_index_array[j],k,:]) > 0):



				if flag1 == 0:
					t_temp = ta_all[LST_index_array[j],k,:].reshape(1,-1)
					w_temp = w_all[LST_index_array[j],k,:].reshape(1,-1)
					flag1 = 1

				elif flag1 > 0:
					t_temp = np.append(t_temp, ta_all[LST_index_array[j],k,:].reshape(1,-1), axis=0)
					w_temp = np.append(w_temp, w_all[LST_index_array[j],k,:].reshape(1,-1),  axis=0)
					flag1 = flag1 + 1


		if flag1 == 1:
			t[k,:] = t_temp
			w[k,:] = w_temp

		elif flag1 > 1:
			print(t_temp.shape)
			t[k,:], w[k,:] = spectral_averaging(t_temp, w_temp)







	# Receiver Calibration
	print('----------------------------------------')
	# Combined gain
	combined_gain_2015_212 = combined_gain('high_band', antenna_s11_day = 212, flag_ground_loss = 1, flag_antenna_loss = 1, flag_balun_connector_loss = 1)		
	combined_gain_2015_262 = combined_gain('high_band', antenna_s11_day = 262, flag_ground_loss = 1, flag_antenna_loss = 1, flag_balun_connector_loss = 1)

	# Calibration
	# Looping over days
	tcal = np.zeros((l_days, l_freq))
	for k in range(l_days):

		print('Receiver calibration: Spectrum number: ' + str(k+1) + ' of ' + str(l_days))

		if (m_all[LST_index_array[0], k, 0] == 2015) and (m_all[LST_index_array[0], k, 1] > 205) and (m_all[LST_index_array[0], k, 1] < 262):
			tcal[k,:] = data_calibration('high_band', 25, t[k,:], 'blade', antenna_s11_day = 212, combined_gain = combined_gain_2015_212)

		elif ((m_all[LST_index_array[0], k, 0] == 2015) and (m_all[LST_index_array[0], k, 1] >= 262)) or ((m_all[LST_index_array[0], k, 0] == 2016) and (m_all[LST_index_array[0], k, 1] > 0)):
			tcal[k,:] = data_calibration('high_band', 25, t[k,:], 'blade', antenna_s11_day = 262, combined_gain = combined_gain_2015_262)


	# Flattening zeros
	Z = np.zeros((l_days, l_freq))
	Z[np.nonzero(w)] = 1
	tcal_leveled = tcal*Z					







	# Binning
	fstart = 108.2
	fstop  = 189.8
	fstep  = 0.4

	fb = np.arange(fstart, fstop+(fstep/2), fstep)
	tb = np.zeros((l_days, len(fb)))
	wb = np.zeros((l_days, len(fb)))

	for k in range(l_days):
		print('Binning: ' + str(k) + ' of ' + str(l_days))
		if np.sum(w[k,:]) > 1000:
			fb, tb[k,:], wb[k,:] = spectral_binning_fixed_frequency(fstart, fstop, fstep, f, tcal_leveled[k,:], w[k,:])






	# Filtering based on RMS of data
	index_RMS = data_analysis_level3_RMS_selection(fb, tb, wb, fit_poly_order = 5, small_sample_size = 5, N_rms_sigma = 3)
	t_RMS = tcal_leveled[index_RMS,:]
	w_RMS = w[index_RMS,:]








	# Computing 10 sub-averages
	len10 = int(len(index_RMS)/10)
	tt = np.zeros((10,l_freq))
	ww = np.zeros((10,l_freq))
	rr = np.zeros((10,l_freq))

	for k in range(10):
		if k < 9:
			tt[k,:], ww[k,:] = spectral_averaging(t_RMS[(k*len10):((k+1)*len10),:], w_RMS[(k*len10):((k+1)*len10),:])

		elif k == 9:
			tt[k,:], ww[k,:] = spectral_averaging(t_RMS[(k*len10)::,:], w_RMS[(k*len10)::,:])

		p       = fit_polynomial_fourier('EDGES_polynomial', f/200, tt[k,:], 9, Weights=ww[k,:])
		model   = model_evaluate('EDGES_polynomial', p[0], f/200)
		rr[k,:] = tt[k,:] - model

		mr = np.median(np.abs(rr[k,:]))

		tt[k, np.abs(rr[k,:]) > 5*mr] = 0
		ww[k, np.abs(rr[k,:]) > 5*mr] = 0

		p       = fit_polynomial_fourier('EDGES_polynomial', f/200, tt[k,:], 9, Weights=ww[k,:])
		model   = model_evaluate('EDGES_polynomial', p[0], f/200)
		rr[k,:] = tt[k,:] - model



	# Total average at raw resolution, starting at 108 MHz	
	avt, avw = spectral_averaging(tt, ww)
	avtt = avt[2949::]
	avww = avw[2949::]
	ff   = f[2949::]

	for i in range(4):  # 4 iterations to remove RFI
		p        = fit_polynomial_fourier('EDGES_polynomial', ff/200, avtt, 9, Weights=avww)
		model    = model_evaluate('EDGES_polynomial', p[0], ff/200)
		res      = avtt - model
		mr       = np.median(np.abs(res[avww > 0]))
		print(mr)
		avtt[np.abs(res) > 5*mr] = 0
		avww[np.abs(res) > 5*mr] = 0

	print('--------------')







	# Binning at 400 kHz

	pp1 = fit_polynomial_fourier('EDGES_polynomial', ff/200, avtt, 5, Weights=avww)
	pp2 = fit_polynomial_fourier('EDGES_polynomial', ff[1148::]/200, avtt[1148::], 5, Weights=avww[1148::])

	m1 = model_evaluate('EDGES_polynomial', pp1[0], ff/200)
	m2 = model_evaluate('EDGES_polynomial', pp2[0], ff/200)

	fb1, tb1, wb1 = spectral_binning_fixed_frequency(108.2, 189.8, 0.4, ff, avtt-m1+1, avww)
	fb2, tb2, wb2 = spectral_binning_fixed_frequency(115.2, 189.8, 0.4, ff, avtt-m2+1, avww)



	plt.plot(fb1, 1000*(tb1-1), 'b')
	plt.plot(fb2, 1000*(tb2-1), 'r')
	plt.xlim([100, 200])
	plt.ylim([-100, 100])
	plt.xlabel('frequency [MHz]')
	plt.ylabel('dT [mK]')
	plt.grid()



	## Binning at 60 kHz
	#fb2, tb2, wb2 = spectral_binning_fixed_frequency(108.03, 189.97, 0.06, ff, avtt, avww)
	#for i in range(7):
		#p        = fit_polynomial_fourier('EDGES_polynomial', fb2/200, tb2, 23, Weights=wb2)
		#model    = model_evaluate('EDGES_polynomial', p[0], fb2/200)
		#res      = tb2 - model
		#mr       = np.median(np.abs(res[wb2 > 0]))
		#print(mr)
		#tb2[np.abs(res) > 5*mr] = 0
		#wb2[np.abs(res) > 5*mr] = 0




	## Binning at 60 kHz
	#fstart = 108.03
	#fstop  = 189.97
	#fstep  = 0.06

	#fb2 = np.arange(fstart, fstop+(fstep/2), fstep)
	#tb2 = np.zeros((len(index_RMS), len(fb2)))
	#wb2 = np.zeros((len(index_RMS), len(fb2)))

	#for k in range(10):
		#if k < 9:
			#fb2, tb2[k,:], wb2[k,:] = spectral_binning_fixed_frequency(fstart, fstop, fstep, f, t_RMS[(k*len10):((k+1)*len10),:], w_RMS[(k*len10):((k+1)*len10),:])
		#elif k == 9:
			#fb2, tb2[k,:], wb2[k,:] = spectral_binning_fixed_frequency(fstart, fstop, fstep, f, t_RMS[(k*len10)::,:], w_RMS[(k*len10)::,:])



	return ff, avtt, avww, res













def data_analysis_high_band_level3(LST_index_array):
	"""
	LST_index_array = np.array([5,6,7,8,9,10])
	"""


	# Loading data
	level3file = '/media/raul/DATA/EDGES/spectra/level3/high_band/high_band_v1_blade.hdf5'
	f, ta_all, m_all, s_all, w_all = level3read(level3file)




	for k in range(len(LST_index_array)):





		LST_index = LST_index_array[k]

		# Data from LST_index (it can go between 0 and 71)
		ta_LST_all = ta_all[LST_index,:,:]
		m_LST_all  = m_all[LST_index,:,:]
		s_LST_all  = s_all[LST_index,:,:]
		w_LST_all  = w_all[LST_index,:,:]




		# Selection based on Meta Data
		ta_LST, m_LST, w_LST = data_analysis_high_band_level3_meta_selection(ta_LST_all, m_LST_all, w_LST_all, sun_elevation = 'yes', max_sun_elevation = -10, moon_elevation = 'no', max_moon_elevation = -10, amb_temp = np.array([-10,110]), amb_hum = np.array([-10,50]), rec_temp = np.array([-10,110]))




		# Receiver Calibration
		print('----------------------------------------')
		# Combined gain
		combined_gain_2015_212 = combined_gain('high_band', antenna_s11_day = 212, flag_ground_loss = 1, flag_antenna_loss = 1, flag_balun_connector_loss = 1)		
		combined_gain_2015_262 = combined_gain('high_band', antenna_s11_day = 262, flag_ground_loss = 1, flag_antenna_loss = 1, flag_balun_connector_loss = 1)

		# Calibration
		# Looping over days
		for i in range(len(ta_LST[:,0])):

			print('Receiver calibration: Spectrum number: ' + str(i+1) + ' of ' + str(len(ta_LST[:,0])))

			if (m_LST[i,0] == 2015) and (m_LST[i,1] > 205) and (m_LST[i,1] < 262):
				ta_cal_temp = data_calibration('high_band', 25, ta_LST[i,:], 'blade', antenna_s11_day = 212, combined_gain = combined_gain_2015_212)

			elif ((m_LST[i,0] == 2015) and (m_LST[i,1] >= 262)) or ((m_LST[i,0] == 2016) and (m_LST[i,1] > 0)):
				ta_cal_temp = data_calibration('high_band', 25, ta_LST[i,:], 'blade', antenna_s11_day = 262, combined_gain = combined_gain_2015_262)

			if i == 0:
				ta_cal = ta_cal_temp.reshape(1,-1)

			elif i > 0:
				ta_cal = np.append(ta_cal, ta_cal_temp.reshape(1,-1), axis = 0)










		# Flattening zeros
		Z = np.zeros((len(ta_cal[:,0]), len(ta_cal[0,:])))
		Z[np.nonzero(w_LST[0:len(ta_cal[:,0]),:])] = 1
		ta_cal_leveled = ta_cal*Z



		# Binning
		fstart = 108.2
		fstop  = 189.8
		fstep  = 0.4

		fb = np.arange(fstart, fstop+(fstep/2), fstep)
		tb = np.zeros((len(ta_cal_leveled[:,0]),len(fb)))
		wb = np.zeros((len(ta_cal_leveled[:,0]),len(fb)))

		for i in range(len(ta_LST[:,0])):
			print('Binning: ' + str(i) + ' of ' + str(len(ta_LST[:,0])))
			fb, tb[i,:], wb[i,:] = spectral_binning_fixed_frequency(fstart, fstop, fstep, f, ta_cal[i,:], w_LST[i,:])


		#tb[:,49:55] = 0
		#wb[:,49:55] = 0		

		#tb[:,66:70] = 0
		#wb[:,66:70] = 0

		#tb[:,89:91] = 0
		#wb[:,89:91] = 0

		#tb[:,99] = 0
		#wb[:,99] = 0




		# Filtering based on RMS of data
		index_RMS = data_analysis_level3_RMS_selection(fb, tb, wb, fit_poly_order = 5, small_sample_size = 5, N_rms_sigma = 3)
		tt_RMS = ta_cal_leveled[index_RMS,:]
		mm_RMS = m_LST[index_RMS,:]
		ww_RMS = w_LST[index_RMS,:]



		# RFI flagging 1
		# Here, the data set is binned before flagging RFI
		fb2, tb2, wb2, residuals = data_analysis_level3_RFI_flagging('high_band', f, tt_RMS, ww_RMS, fstep  = 0.06, N_res_sigma = 4)



		# Filtering based on total power
		index_good_total_power, tp = data_analysis_level3_temperature_scatter_selection(fb2, tb2, wb2, N_choice=1000, small_sample_size=5, N_sigma=2)
		tb3 = tb2[index_good_total_power, :]
		wb3 = wb2[index_good_total_power, :]		



		# RFI flagging
		fb4, avtb4, avwb4, avtx1, avtx2, avtx3, avtx4, avwx1, avwx2, avwx3, avwx4 = data_analysis_level3_RFI_flagging2(fb2, tb3, wb3, N_sigma = 3)



		par1, model, RMS, cov = fit_polynomial_fourier('EDGES_polynomial', fb4/150, avtx1, 5, Weights=np.diag(avwx1))
		par2, model, RMS, cov = fit_polynomial_fourier('EDGES_polynomial', fb4/150, avtx2, 5, Weights=np.diag(avwx2))
		par3, model, RMS, cov = fit_polynomial_fourier('EDGES_polynomial', fb4/150, avtx3, 5, Weights=np.diag(avwx3))
		par4, model, RMS, cov = fit_polynomial_fourier('EDGES_polynomial', fb4/150, avtx4, 5, Weights=np.diag(avwx4))


		m1 = model_evaluate('EDGES_polynomial', par1, fb4/150)
		m2 = model_evaluate('EDGES_polynomial', par2, fb4/150)
		m3 = model_evaluate('EDGES_polynomial', par3, fb4/150)
		m4 = model_evaluate('EDGES_polynomial', par4, fb4/150)










		## Binning to 400 kHz
		#fb5, tb5, wb5 = spectral_binning_fixed_frequency(110.2, 189.8, 0.4, fb4, avtb4, avwb4)



		## Fitting and removing model
		#par   = np.polyfit(fb5[wb5>1e3], tb5[wb5>1e3], 5)
		#model = np.polyval(par, fb5)
		#delta = tb5 - model


		#par   = np.polyfit(fb4[wb5>1e3], tb5[wb5>1e3], 5)
		#model = np.polyval(par, fb5)
		#delta = tb5 - model		










		## Accumulating data products for all LSTs considered
		#if k == 0:

			#tt_all = tb2
			#mm_all = mm_RMS
			#ww_all = wb2
			#rr_all = residuals

		#elif k > 0:
			#tt_all = np.append(tt_all, tb2,       axis=0)
			#mm_all = np.append(mm_all, mm_RMS,    axis=0)
			#ww_all = np.append(ww_all, wb2,       axis=0)
			#rr_all = np.append(rr_all, residuals, axis=0)







		## Removing regions with potential Digital TV
		#print('----------------------------------------')
		#ta_DTV1, m_DTV1, w_DTV1 = data_analysis_high_band_level3_DTV_removal(f, ta_RMS, m_RMS, w_RMS,    1, small_sample_size=5, N_ratio_sigma=2.5)
		#print('----------------------------------------')
		#ta_DTV2, m_DTV2, w_DTV2 = data_analysis_high_band_level3_DTV_removal(f, ta_DTV1, m_DTV1, w_DTV1, 2, small_sample_size=5, N_ratio_sigma=2.5)
		#print('----------------------------------------')
		#ta_DTV3, m_DTV3, w_DTV3 = data_analysis_high_band_level3_DTV_removal(f, ta_DTV2, m_DTV2, w_DTV2, 3, small_sample_size=5, N_ratio_sigma=2.5)



		## Removing extra RFI
		#print('----------------------------------------')
		#ta_clean, m_clean, w_clean = data_analysis_high_band_level3_extra_RFI_flagging(f, ta_DTV3, m_DTV3, w_DTV3, fit_poly_order=7, N_sigma=3)










	return fb4, avtx1-m1, avtx2-m2, avtx3-m3, avtx4-m4      #tt_RMS, ww_RMS  #fb2, tt_all, mm_all, ww_all, rr_all

























def data_analysis_high_band_level3_meta_selection(ta_LST, m_LST, w_LST, sun_elevation = 'no', max_sun_elevation = -10, moon_elevation = 'no', max_moon_elevation = -10, amb_temp = np.array([-10,110]), amb_hum = np.array([-10,110]), rec_temp = np.array([-10,110])):




	N_spectra = len(ta_LST[:,0])
	index_generic = np.arange(N_spectra)



	# Sun elevation
	if (sun_elevation == 'yes'):
		flag = 0
		for i in range(N_spectra):
			if (m_LST[i,6] <= max_sun_elevation) and (np.sum(w_LST[i,:]) > 0):
				if flag == 0:
					index_sun_elevation = i
					flag = 1
				elif flag == 1:
					index_sun_elevation = np.append(index_sun_elevation, i)
	else:
		index_sun_elevation = index_generic




	# Moon elevation				
	if (moon_elevation == 'yes'):
		flag = 0
		for i in range(N_spectra):
			if (m_LST[i,8] <= max_moon_elevation) and (np.sum(w_LST[i,:]) > 0):
				if flag == 0:
					index_moon_elevation = i
					flag = 1
				elif flag == 1:
					index_moon_elevation = np.append(index_moon_elevation, i)
	else:
		index_moon_elevation = index_generic	




	# Ambient temperature
	flag = 0
	for i in range(N_spectra):
		if (m_LST[i,9] >= amb_temp[0]) and (m_LST[i,9] <= amb_temp[1]) and (np.sum(w_LST[i,:]) > 0):
			if flag == 0:
				index_amb_temp = i
				flag = 1
			elif flag == 1:
				index_amb_temp = np.append(index_amb_temp, i)




	# Ambient humidity
	flag = 0
	for i in range(N_spectra):
		if (m_LST[i,10] >= amb_hum[0]) and (m_LST[i,10] <= amb_hum[1]) and (np.sum(w_LST[i,:]) > 0):
			if flag == 0:
				index_amb_hum = i
				flag = 1
			elif flag == 1:
				index_amb_hum = np.append(index_amb_hum, i)




	# Receiver temperature
	flag = 0
	for i in range(N_spectra):
		if (m_LST[i,12] >= rec_temp[0]) and (m_LST[i,12] <= rec_temp[1]) and (np.sum(w_LST[i,:]) > 0):
			if flag == 0:
				index_rec_temp = i
				flag = 1
			elif flag == 1:
				index_rec_temp = np.append(index_rec_temp, i)




	# Intersection of all meta selections
	index_meta1 = np.intersect1d(index_sun_elevation, index_moon_elevation)
	index_meta2 = np.intersect1d(index_amb_temp, index_amb_hum)
	index_meta3 = np.intersect1d(index_meta1, index_meta2)
	index_meta  = np.intersect1d(index_meta3, index_rec_temp)



	# Selecting data from metadata index 
	ta_sel = ta_LST[index_meta, :]
	m_sel  = m_LST[index_meta, :]
	w_sel  = w_LST[index_meta, :]


	return ta_sel, m_sel, w_sel
























def data_analysis_RMS_selection(f, ta, w, fit_poly_order = 5, small_sample_size = 5, N_rms_sigma = 3):

	# f: raw resolution from 90 to 190 MHz
	# ta, w: 2D arrays, frequency domain along the horizontal axis


	# Computing RMS from selected data
	N_spectra = len(ta[:,0])
	flag = 0
	for i in range(N_spectra):		
		if np.sum(w[i,:]) >= 1000:
			W = np.diag(w[i,:])
			par, model, rms_not_believable, cov = fit_polynomial_fourier('EDGES_polynomial', f/200, ta[i,:], fit_poly_order, Weights=W)
			rms = np.sqrt( np.sum(w[i,:]*(ta[i,:]-model)**2) / np.sum(w[i,:]) )

			if flag == 0:
				#model_sel = model.reshape(1,-1)
				rms_sel   = rms
				flag      = 1

			elif flag == 1:
				#model_sel = np.append(model_sel, model.reshape(1,-1), axis=0)
				rms_sel   = np.append(rms_sel, rms)

			print('RMS residuals: Spectrum Number: ' + str(i+1) + ' of ' + str(N_spectra) + ': ' + str(round(rms,3)))

		if np.sum(w[i,:]) < 1000:
			if flag == 0:
				#model_sel = model.reshape(1,-1)
				rms_sel   = 0
				flag      = 1

			elif flag == 1:
				rms_sel   = np.append(rms_sel, 0)

	# print('--------------------------------------------------------')
	# print('--------------------------------------------------------')
	# print('--------------------------------------------------------')	


	# Identifying typical RMS mean and std
	N_choice  = 2000
	flag = 0
	for i in range(N_choice):
		rms_choice = np.random.choice(rms_sel[rms_sel>0], small_sample_size)
		if flag == 0:
			rms_choice_mean = np.mean(rms_choice)
			rms_choice_std  = np.std(rms_choice)
			flag = 1

		elif flag == 1:
			rms_choice_mean = np.append(rms_choice_mean, np.mean(rms_choice))
			rms_choice_std  = np.append(rms_choice_std, np.std(rms_choice))

	rms_mean = np.median(rms_choice_mean)
	rms_std  = np.median(rms_choice_std)


	# Selection based on RMS
	print('----------------------------------------')
	flag = 0
	for i in range(N_spectra):
		if np.sum(w[i,:]) > 1000:
			if (rms_sel[i] >= (rms_mean - N_rms_sigma*rms_std)) and (rms_sel[i] <= (rms_mean + N_rms_sigma*rms_std)):
				if flag == 0:
					index_rms = i
					flag      = 1

				elif flag == 1:
					index_rms = np.append(index_rms, i)


				print('RMS check of raw spectrum: Spectrum Number: ' + str(i+1) + ' of ' + str(N_spectra) + ': ' + str(round(rms_sel[i],3)) + ': Passed')

			else:
				print('RMS check of raw spectrum: Spectrum Number: ' + str(i+1) + ' of ' + str(N_spectra) + ': ' + str(round(rms_sel[i],3)) + ': FAILED')


	return index_rms 











def data_analysis_residuals_selection(f, t, w, fit_poly_order = 5, small_sample_size = 5, N_res_sigma = 3):

	"""
	f: 1D array
	t: 2D array, frequency along horizontal axis
	w: 2D array, frequency along horizontal axis

	"""


	# Computing residuals
	res = np.zeros((len(t[:,0]), len(t[0,:])))
	for i in range(len(t[:,0])):
		pp       = fit_polynomial_fourier('EDGES_polynomial', f, t[i,:], 5, Weights=w[i,:])
		model    = model_evaluate('EDGES_polynomial', pp[0], f)
		res[i,:] = t[i,:] - model


	# Computing typical STD
	N_choice  = 10000
	res_mean = np.zeros(len(f))
	res_std  = np.zeros(len(f))

	for j in range(len(f)):
		flag = 0
		for i in range(N_choice):
			res_choice = np.random.choice(res[w[:,j]>0, j], small_sample_size)
			if flag == 0:
				res_choice_mean = np.mean(res_choice)
				res_choice_std  = np.std(res_choice)
				flag = 1

			elif flag == 1:
				res_choice_mean = np.append(res_choice_mean, np.mean(res_choice))
				res_choice_std  = np.append(res_choice_std,  np.std(res_choice))

		res_mean[j] = np.median(res_choice_mean)
		res_std[j]  = np.median(res_choice_std)


	return res_mean, res_std










def data_analysis_high_band_level3_DTV_removal(f, ta, m, w, range_freq, small_sample_size=5, N_ratio_sigma=3):

	# f: raw resolution from 90 to 190 MHz
	# ta, w: 2D arrays, frequency domain along the horizontal axis


	# Index of frequencies used
	index_150 = 9831   # 150 MHz
	index_165 = 12289  # 165 MHz

	index_170 = 13108  # 170 MHz
	index_175 = 13928  # 175 MHz
	index_180 = 14747  # 180 MHz

	index_188 = 16200  # 188 MHz


	# Arrays of indices
	if range_freq == 1:
		index_good  = np.append(np.arange(index_150, index_165), np.arange(index_188, len(f)))
		index_model = index_165

	elif range_freq == 2:
		index_good  = np.append(np.arange(index_175, index_180), np.arange(index_188, len(f)))
		index_model = index_180

	elif range_freq == 3:
		index_good  = np.append(np.arange(index_170, index_180), np.arange(index_188, len(f)))
		index_model = index_180


	# Frequency vectors
	f_base  = f[index_150:index_165]
	f_good  = f[index_good]
	f_model = f[index_model::]		


	# Computing RMS ratios
	N_spectra = len(ta[:,0])
	for i in range(N_spectra):

		if np.sum(w[i, 14000::]) > 0:

			ta_base  = ta[i, index_150:index_165]
			w_base   = w[i, index_150:index_165]

			ta_good  = ta[i, index_good]
			w_good   = w[i, index_good]

			ta_model = ta[i, index_model::]
			w_model  = w[i, index_model::]


			W = np.diag(w_base)	
			par_base, model_base, rms, cov = fit_polynomial_fourier('polynomial', f_base/200, ta_base, 5, Weights=W)
			rms_base                       = np.sqrt( np.sum(w_base*(ta_base-model_base)**2) / np.sum(w_base) )

			W = np.diag(w_good)
			par_good, model_good, rms, cov = fit_polynomial_fourier('polynomial', f_good/200, ta_good, 5, Weights=W)
			model                             = model_evaluate('polynomial', par_good, f_model/200)


			rms_good = np.sqrt( np.sum(w_good*(ta_good-model_good)**2) / np.sum(w_good) )
			rms_dtv  = np.sqrt( np.sum(w_model*(ta_model-model)**2) / np.sum(w_model) )	



		elif np.sum(w[i, 14000::]) == 0:

			rms_base = 1
			rms_dtv  = 0


		if i == 0:
			rms_ratio_all  = rms_dtv/rms_base

		elif i > 0:
			rms_ratio_all  = np.append(rms_ratio_all, rms_dtv/rms_base)

		print('DTV removal: Spectrum Number: ' + str(i+1) + ' of ' + str(N_spectra) + ': Computing Ratio')


	print('----------------------------------------')	


	# Typical "good" values for the RMS ratio	
	N_choice  = 2000
	flag = 0
	index_nonzero     = np.nonzero(rms_ratio_all)
	rms_ratio_nonzero = rms_ratio_all[index_nonzero]

	for i in range(N_choice):
		ratio_choice  = np.random.choice(rms_ratio_nonzero, small_sample_size)

		if flag == 0:
			ratio_choice_mean = np.mean(ratio_choice)
			ratio_choice_std  = np.std(ratio_choice)			

			flag = 1

		elif flag == 1:
			ratio_choice_mean = np.append(ratio_choice_mean, np.mean(ratio_choice))
			ratio_choice_std  = np.append(ratio_choice_std,  np.std(ratio_choice))


	ratio_mean = np.median(ratio_choice_mean)
	ratio_std  = np.median(ratio_choice_std)	


	# Selection based on the RMS ratio	
	flag = 0
	ta_out = np.copy(ta)
	m_out  = np.copy(m) 
	w_out  = np.copy(w)
	for i in range(N_spectra):
		if (rms_ratio_all[i] > (ratio_mean + N_ratio_sigma*ratio_std)): # and (rms_ratio_all2[i] > (ratio_mean2 + N_ratio_sigma*ratio_std2)):
			ta_out[i, index_165::] = 0
			w_out[i, index_165::]  = 0

			print('DTV removal: Spectrum Number: ' + str(i+1) + ' of ' + str(N_spectra) + ': ' + str(round(rms_ratio_all[i],3)) + ': SECTION FLAGGED')

		else:	
			print('DTV removal: Spectrum Number: ' + str(i+1) + ' of ' + str(N_spectra) + ': ' + str(round(rms_ratio_all[i],3)) + ': No Problem')


	return ta_out, m_out, w_out











def data_analysis_high_band_level3_extra_RFI_flagging(f, ta, m, w, fit_model='EDGES_polynomial', fit_poly_order=7, section_width=10, N_points_section_threshold=10, small_sample_size = 10, N_sigma=3):


	# Removing a model from each spectrum
	N_spectra = len(ta[:,0])
	flag = 0






	# Cutting out range 130-150 MHz not to bias the models due to the strong RFI

	f130 = 134
	f150 = 154	
	for i in range(len(f)-1):
		if (f[i] < f130) and (f[i+1] >= f130):
			index_130 = i

	for i in range(len(f)-1):
		if (f[i] < f150) and (f[i+1] >= f150):
			index_150 = i+1

	index_data = np.append(np.arange(0,index_130), np.arange(index_150,len(f)-1))
	f_selection = f[index_data]

	for i in range(N_spectra):		
		if np.sum(w[i,:]) > 0:

			ta_selection = ta[i,index_data]
			w_selection  = w[i,index_data]

			W = np.diag(w_selection)
			par_selection, model_selection, rms_not_believable, cov = fit_polynomial_fourier(fit_model, f_selection/200, ta_selection, fit_poly_order, Weights=W)
			model = model_evaluate(fit_model, par_selection, f/200)

			if i == 0:
				models_all = model.reshape(1,-1)


			elif i > 0:
				models_all = np.append(models_all, model.reshape(1,-1), axis=0)

		print('Extra RFI removal: Spectrum Number: ' + str(i+1) + ' of ' + str(N_spectra) + ': Fitting model')		


	print('----------------------------------------')


	# Removing RFI based on typical RMS within selections
	f_sections_all = np.arange(f[0], f[-1]+(section_width/2)+1, section_width)	# typically 10-MHz sections
	ta_out = np.copy(ta)
	m_out  = np.copy(m)
	w_out  = np.copy(w)

	print(ta.shape)

	for k in range(N_spectra):			# for all spectra

		print('Extra RFI removal: Spectrum Number: ' + str(k+1) + ' of ' + str(N_spectra) + ': Removing RFI')

		for j in range(len(f_sections_all)-1):	# for all sections

			flag = 0
			for i in range(len(f)):		# for all raw frequencies		

				if ( (f[i] - f_sections_all[j]) >= 0 )and ( (f[i] - f_sections_all[j]) < section_width ) and (w[k,i] > 0):

					if flag == 0:
						f_section = f[i]
						t_section = ta[k,i] - models_all[k,i]
						w_section = w[k,i]
						flag = 1

					elif flag == 1:
						f_section = np.append(f_section, f[i])
						t_section = np.append(t_section, ta[k,i] - models_all[k,i])
						w_section = np.append(w_section, w[k,i])





			if len(f_section) > N_points_section_threshold:

				N_choice          = 3000
				flag2             = 0

				for i in range(N_choice):
					data_choice  = np.random.choice(t_section, small_sample_size)

					if flag2 == 0:
						choice_mean = np.mean(data_choice)
						choice_std  = np.std(data_choice)			

						flag2 = 1

					elif flag2 == 1:
						choice_mean = np.append(choice_mean, np.mean(data_choice))
						choice_std  = np.append(choice_std,  np.std(data_choice))


				data_mean = np.median(choice_mean)
				data_std  = np.median(choice_std)					



			for i in range(len(f)):		# for all raw frequencies		
				if ( (f[i] - f_sections_all[j]) >= 0 ) and ( (f[i] - f_sections_all[j]) < section_width ) and (w[k,i] > 0):

					if ((ta[k,i] - models_all[k,i]) < (data_mean - N_sigma*data_std)) or ((ta[k,i] - models_all[k,i]) > (data_mean + N_sigma*data_std)):

						ta_out[k,i] = 0
						w_out[k,i]  = 0



	return ta_out, m_out, w_out #, models_all







def FEKO_high_band_fourpoint_beam(frequency_interpolation='no', frequency=np.array([0]), AZ_antenna_axis=0):

	"""

	Original frequency: 80-200 MHz in steps of 5 MHz
	AZ_antenna_axis = -6    #  Angle of orientation (in integer degrees) of excited antenna panels relative to due North. Best value is around -6.

	"""

	filename = home_folder + '/DATA/EDGES/calibration/beam/alans_antenna_simulations/fourpoint_high-band/alan_latest_fourpoint_beam_model_azelq_2m_6.8_2.0_1.4a80.txt'
	data = np.genfromtxt(filename)

	# Loading data
	beam_maps = np.zeros((25,91,360))
	for i in range(25):
		beam_maps[i,:,:] = (10**(data[(i*360):((i+1)*360),2::]/10)).T

	# Frequency interpolation
	if frequency_interpolation == 'yes':
		f_original = np.arange(80,201,5)
		interp_beam = np.zeros((len(frequency), len(beam_maps[0,:,0]), len(beam_maps[0,0,:])))
		for j in range(len(beam_maps[0,:,0])):
			for i in range(len(beam_maps[0,0,:])):
				#print('Elevation: ' + str(j) + ', Azimuth: ' + str(i))
				par   = np.polyfit(f_original/200, beam_maps[:,j,i], 13)
				model = np.polyval(par, frequency/200)
				interp_beam[:,j,i] = model

		beam_maps = np.copy(interp_beam)



	# Shifting beam relative to true AZ (referenced at due North)
	# Due to angle of orientation of excited antenna panels relative to due North
	if AZ_antenna_axis < 0:
		AZ_index          = -AZ_antenna_axis
		bm1               = beam_maps[:,:,AZ_index::]
		bm2               = beam_maps[:,:,0:AZ_index]
		beam_maps_shifted = np.append(bm1, bm2, axis=2)

	elif AZ_antenna_axis > 0:
		AZ_index          = AZ_antenna_axis
		bm1               = beam_maps[:,:,0:(-AZ_index)]
		bm2               = beam_maps[:,:,(360-AZ_index)::]
		beam_maps_shifted = np.append(bm2, bm1, axis=2)

	elif AZ_antenna_axis == 0:
		beam_maps_shifted = np.copy(beam_maps)



	return beam_maps_shifted # in linear units !!!!!









def CST_high_band_blade_beam(frequency_interpolation='no', frequency=np.array([0]), AZ_antenna_axis=0):

	"""

	Original beam frequency: 90-200 MHz in steps of 1 MHz
	AZ_antenna_axis = -6    #  Angle of orientation (in integer degrees) of excited antenna panels relative to due North. Best value is around -6. 

	"""

	#filename = home_folder + '/DATA/EDGES/beam_models/beam_blade_highband_dB_NotNormed_matrix_56.mat'
	#d        = sio.loadmat(filename)
	#data_dB  = d['beam_directivity_dB']

	#beam_maps_flipped = 10**(data_dB[99::,0:91,0:-1]/10)
	#beam_maps = np.fliplr(beam_maps_flipped)	


	filename = home_folder + '/DATA/EDGES/beam_models/beam_data_NotNormed_linear_Highband_Blade_90MHz-200MHz.mat'
	d                 = sio.loadmat(filename)
	data              = d['beam_directivity_linear']
	beam_maps_flipped = data[89::, 0:91, 0:-1]
	beam_maps         = np.fliplr(beam_maps_flipped)



	# Frequency interpolation
	if frequency_interpolation == 'yes':
		f_original = np.arange(90,201,1)
		interp_beam = np.zeros((len(frequency), len(beam_maps[0,:,0]), len(beam_maps[0,0,:])))
		for j in range(len(beam_maps[0,:,0])):
			for i in range(len(beam_maps[0,0,:])):
				#print('Elevation: ' + str(j) + ', Azimuth: ' + str(i))
				par   = np.polyfit(f_original/200, beam_maps[:,j,i], 13)
				model = np.polyval(par, frequency/200)
				interp_beam[:,j,i] = model

		beam_maps = np.copy(interp_beam)



	# Shifting beam relative to true AZ (referenced at due North)
	# Due to angle of orientation of excited antenna panels relative to due North
	if AZ_antenna_axis < 0:
		AZ_index          = -AZ_antenna_axis
		bm1               = beam_maps[:,:,AZ_index::]
		bm2               = beam_maps[:,:,0:AZ_index]
		beam_maps_shifted = np.append(bm1, bm2, axis=2)

	elif AZ_antenna_axis > 0:
		AZ_index          = AZ_antenna_axis
		bm1               = beam_maps[:,:,0:(-AZ_index)]
		bm2               = beam_maps[:,:,(360-AZ_index)::]
		beam_maps_shifted = np.append(bm2, bm1, axis=2)

	elif AZ_antenna_axis == 0:
		beam_maps_shifted = np.copy(beam_maps)



	return beam_maps_shifted # in linear units !!!!!

















def FEKO_low_band_blade_beam(beam_file=1, frequency_interpolation='no', frequency=np.array([0]), AZ_antenna_axis=0):

	"""

	beam_file = 1  # nominal beam file
	Original frequency: 50-100 MHz in steps of 5 MHz
	AZ_antenna_axis = 0    #  Angle of orientation (in integer degrees) of excited antenna panels relative to due North. Best value is around X ???

	"""

	data_folder_alan = edges_folder + 'calibration/beam/alan/blade_low_band/'
	data_folder_nivedita = edges_folder + 'calibration/beam/nivedita/blade_low_band/'


	# Loading beam

	# Extended ground plane
	# --------------------------------------------------------
	if beam_file == 0:
		# Extended ground plane, FROM NIVEDITA, 40-100 MHz
		ff         = data_folder_nivedita + 'newniv.txt'
		f_original = np.arange(40,101,2)   #between 40 and 100 MHz in steps of 2 MHz
		print('BEAM EXTENDED GROUND PLANE, FROM NIVEDITA')

	if beam_file == 1:		
		# Extended ground plane, 40-100 MHz
		ff         = data_folder_alan + 'alan_blade_beam_model_azelq_blade9perf7low_g4.txt'
		f_original = np.arange(40,101,2)   #between 40 and 100 MHz in steps of 2 MHz

	if beam_file == 2:
		# Extended ground plane, 40-120 MHz
		ff         = data_folder_alan + 'azelq_blade9perf7low_g4w_40_120_MHz.txt'
		f_original = np.arange(40,121,2)   #between 40 and 120 MHz in steps of 2 MHz


	# Original ground plane
	# ---------------------------------------------------------
	if beam_file == 3:
		# Original ground plane, between 80 and 200 MHz in steps of 5 MHz
		ff         = data_folder_alan + 'azelq_blade11_3.5_2e-2_original_small_ground_plane_low_band1.txt'
		f_original = np.arange(40,101,2.5)   # It can directly be scaled to 40-100 MHz

	if beam_file == 4:
		# Original ground plane, between 40 and 100 MHz in steps of 2 MHz, by NIVEDITA
		ff         = data_folder_nivedita + 'oldniv_original_10x10m_ground_plane_low_band1_from_nivedita.txt'
		f_original = np.arange(40,101,2)
		print('BEAM ORIGINAL GROUND PLANE, FROM NIVEDITA')

	if beam_file == 5:
		# Original ground plane, between 50 and 120 MHz in steps of 2 MHz, from Alan
		ff         = data_folder_alan + 'azelq_blade_10x10.txt'
		f_original = np.arange(50,121,2)
		print('BEAM ORIGINAL GROUND PLANE, 50-120 MHz, FROM ALAN')		





	data = np.genfromtxt(ff)




	# Loading data and convert to linear representation
	beam_maps = np.zeros((len(f_original),91,360))
	for i in range(len(f_original)):
		beam_maps[i,:,:] = (10**(data[(i*360):((i+1)*360),2::]/10)).T



	# Frequency interpolation
	if frequency_interpolation == 'yes':

		interp_beam = np.zeros((len(frequency), len(beam_maps[0,:,0]), len(beam_maps[0,0,:])))
		for j in range(len(beam_maps[0,:,0])):
			for i in range(len(beam_maps[0,0,:])):
				#print('Elevation: ' + str(j) + ', Azimuth: ' + str(i))
				par   = np.polyfit(f_original/200, beam_maps[:,j,i], 13)
				model = np.polyval(par, frequency/200)
				interp_beam[:,j,i] = model

		beam_maps = np.copy(interp_beam)




	# Shifting beam relative to true AZ (referenced at due North)
	# Due to angle of orientation of excited antenna panels relative to due North
	if AZ_antenna_axis < 0:
		AZ_index          = -AZ_antenna_axis
		bm1               = beam_maps[:,:,AZ_index::]
		bm2               = beam_maps[:,:,0:AZ_index]
		beam_maps_shifted = np.append(bm1, bm2, axis=2)

	elif AZ_antenna_axis > 0:
		AZ_index          = AZ_antenna_axis
		bm1               = beam_maps[:,:,0:(-AZ_index)]
		bm2               = beam_maps[:,:,(360-AZ_index)::]
		beam_maps_shifted = np.append(bm2, bm1, axis=2)

	elif AZ_antenna_axis == 0:
		beam_maps_shifted = np.copy(beam_maps)



	return beam_maps_shifted



















def FEKO_high_band_blade_beam_plus_shaped_finite_ground_plane(beam_file=1, frequency_interpolation='no', frequency=np.array([0]), AZ_antenna_axis=0):

	"""

	beam_file = 1  # nominal beam file
	Original frequency: 80-200 MHz in steps of 5 MHz
	AZ_antenna_axis = -6    #  Angle of orientation (in integer degrees) of excited antenna panels relative to due North. Best value is around -6.

	"""

	data_folder = home_folder + '/DATA/EDGES/calibration/beam/alans_antenna_simulations/blade_high_band/'

	# Loading beam
	# ------------------------------------------------------
	#
	# All these beams cover 80-200 MHz
	if beam_file == 0:
		ff = data_folder + 'alan_blade_plus_shaped_finite_ground_plane_beam_model_azelq_blade9_hgt52_gfhigh.txt'

	elif beam_file == 1:
		ff = data_folder + 'gfbeam/azelq_blade9.35w_9.35l_hgt52_gf2.5hplus3.5_2e-2.txt'

	elif beam_file == 2:	
		ff = data_folder + 'gfbeam/azelq_blade9.35w_9.35l_hgt52_2.3_gf2.5hplus3.5_2e-2.txt'

	elif beam_file == 3:
		ff = data_folder + 'gfbeam/azelq_blade9.35w_9.35l_hgt52_485_gf2.5hplus3.5_2e-2.txt'

	elif beam_file == 4:
		ff = data_folder + 'gfbeam/azelq_blade9.35w_9.35l_hgt52_629_gf2.5hplus3.5_2e-2.txt'

	elif beam_file == 5:
		ff = data_folder + 'gfbeam/azelq_blade9.35w_9.35l_hgt52_gf2.5hplus3.5_1e-1.txt'

	elif beam_file == 6:
		ff = data_folder + 'gfbeam/azelq_blade9.35w_9.35l_hgt52_gf2.5hplus3.5_1e-3.txt'

	elif beam_file == 7:
		ff = data_folder + 'gfbeam/azelq_blade9.35w_9.35l_hgt52_gf2.5hplus10_2e-2.txt'

	elif beam_file == 8:
		ff = data_folder + 'gfbeam/azelq_blade9.35w_9.35l_hgt52_gf2.5hplus20_2e-2.txt'

	elif beam_file == 9:
		ff = data_folder + 'gfbeam/azelq_blade9.35w_9.35l_hgt523_gf2.5hplus3.5_2e-2.txt'

	elif beam_file == 10:
		ff = data_folder + 'gfbeam/azelq_blade9.35w_9.45l_hgt52_gf2.5hplus3.5_2e-2.txt'

	elif beam_file == 11:
		ff = data_folder + 'gfbeam/azelq_blade9.45w_9.35l_hgt52_gf2.5hplus3.5_2e-2.txt'

	
	
	
	
	# These files cover 65-200 MHz
	if beam_file == 20:
		#ff = data_folder + 'gfbeam_65_200_MHz/azelq_blade9.35w_9.35l_hgt52_2.3_gf2.5hplus3.5_2e-2_65_200a.txt'
		ff = data_folder + 'gfbeam_65_200_MHz/azelq_blade9.35w_9.35l_hgt52_2.3_gf2.5hplus3.5_2e-2_65_200j.txt'
		print(' ')
		print('------------- Beam Model: Blade over Plus-Shaped Ground Plane over 65-200 MHz -------------')
		print(' ')

	if beam_file == 21:
		ff = data_folder + 'gfbeam_65_200_MHz/blade_nogroundplane_65_200.txt'   # From Alan, March 31, 2018:  "blade over a uniform e=3.5 2e-2 S/m ground"
		print(' ')
		print('------------- Beam Model: Blade over No Ground Plane (just soil) over 65-200 MHz -------------')
		print(' ')





	

	

	# Actually load data
	
	# Beams from Alan
	if beam_file < 30:
		if beam_file < 20:
			f_original = np.arange(80, 201, 5)  # 80-200 MHz in steps of 5 MHz
			
		elif (beam_file >= 20) and (beam_file <30):
			f_original = np.arange(65, 201, 1)  # 65-200 MHz in steps of 1 MHz
		
		data = np.genfromtxt(ff)
		
		frequency_length = len(f_original)
		beam_maps = np.zeros((frequency_length, 91, 360))
		for i in range(frequency_length):
			beam_maps[i,:,:] = (10**(data[(i*360):((i+1)*360),2::]/10)).T    # In linear units
	
	
	
	
	
	# Beam from Nivedita
	# ----------------------------------------------
	# 65-98 in steps of 1 MHz
	# 98-200 in steps of 2 MHz 
	#
	if beam_file == 30:
		print(' ')
		print('------------- Beam Model from NIVEDITA: Blade over Plus-Shaped Ground Plane over 65-200 MHz -------------')
		print(' ')		
		f_original, beam_maps = FEKO_high_band_blade_nivedita()     # In linear units
		
		
		





	# Frequency interpolation
	if frequency_interpolation == 'yes':		
		interp_beam = np.zeros((len(frequency), len(beam_maps[0,:,0]), len(beam_maps[0,0,:])))
		for j in range(len(beam_maps[0,:,0])):
			for i in range(len(beam_maps[0,0,:])):
				#print('Elevation: ' + str(j) + ', Azimuth: ' + str(i))
				par   = np.polyfit(f_original/200, beam_maps[:,j,i], 13)   # 13th order polynomial is the highest possible, without running into numerical issues. The interpolation is accurate to higher than 30dB
				model = np.polyval(par, frequency/200)
				interp_beam[:,j,i] = model

		beam_maps = np.copy(interp_beam)



	# Shifting beam relative to true AZ (referenced at due North)
	# Due to angle of orientation of excited antenna panels relative to due North
	if AZ_antenna_axis < 0:
		AZ_index          = -AZ_antenna_axis
		bm1               = beam_maps[:,:,AZ_index::]
		bm2               = beam_maps[:,:,0:AZ_index]
		beam_maps_shifted = np.append(bm1, bm2, axis=2)

	elif AZ_antenna_axis > 0:
		AZ_index          = AZ_antenna_axis
		bm1               = beam_maps[:,:,0:(-AZ_index)]
		bm2               = beam_maps[:,:,(360-AZ_index)::]
		beam_maps_shifted = np.append(bm2, bm1, axis=2)

	elif AZ_antenna_axis == 0:
		beam_maps_shifted = np.copy(beam_maps)



	return beam_maps_shifted # in linear units !!!!!






def FEKO_high_band_blade_nivedita():
	
	path_file = '/DATA/EDGES/calibration/beam/nivedita/high_band/FEKO_highband_realgnd_Simple-blade.txt'
	counter = -1
	bm   = np.zeros((85, 91, 360))
	freq = np.zeros(85)
	counter_freq = -1
	with open(home_folder + path_file) as file_object:
		for one_line in file_object:
			
			#counter = counter + 1
			#print(counter)
			
			if one_line[1:8] == 'Freq = ':
				counter_freq = counter_freq + 1
				if (one_line[8] == '1') or (one_line[8] == '2'):
					freq[counter_freq] = float(one_line[8:11])
					#print(one_line[8:14])
					
					
				else:
					freq[counter_freq] = float(one_line[8:10])
					#print(one_line[8:13])
				
				
				counter_az_start = 'yes'
				counter_az = -3
			
			counter_az = counter_az + 1
			if (counter_az_start == 'yes') and (counter_az >=0) and (counter_az < 360):
				K    = one_line[5:-2]
				KK   = re.split(r'\t+', K)
				KKK  = [float(i) for i in KK]
				KKKK = np.asarray(KKK)
				
				
				bm[counter_freq, :, counter_az] = np.flip(KKKK[1:92], axis=0)
				
			
					
	return freq, bm


































def antenna_beam_factor(band, antenna, name_save, file_high_band_blade_FEKO=1, file_low_band_blade_FEKO=1, reference_frequency=140, rotation_from_north=-5, sky_model='guzman_haslam', band_deg=10, index_inband=2.5, index_outband=2.57):



	# Data paths
	path_data = home_folder + '/DATA/EDGES/calibration/sky/'
	path_save = home_folder + '/DATA/EDGES/calibration/beam_factors/' + band + '/'
	#path_save = home_folder + '/DATA/EDGES/calibration/beam_factors/' + band + '/' #test/'


	# Loading beam	
	AZ_beam  = np.arange(0, 360)
	EL_beam  = np.arange(0, 91)


	if band == 'high_band':
		if antenna == 'fourpoint':

			# FEKO fourpoint beam 
			beam_all = FEKO_high_band_fourpoint_beam(AZ_antenna_axis=rotation_from_north)

			# Frequecy array
			freq_array = np.arange(80, 201, 5, dtype='uint32')



		elif antenna == 'blade_CST':

			# CST blade beam 
			beam_all = CST_high_band_blade_beam(AZ_antenna_axis=rotation_from_north)

			# Frequecy array
			freq_array = np.arange(90, 201, 1, dtype='uint32')



		elif antenna == 'blade_FEKO':

			# FEKO blade beam
			beam_all = FEKO_high_band_blade_beam_plus_shaped_finite_ground_plane(beam_file=file_high_band_blade_FEKO, AZ_antenna_axis=rotation_from_north)

			# Frequency array
			freq_array = np.arange(80, 201, 5, dtype='uint32')
			
			
			
		elif antenna == 'blade_FEKO_65_200_MHz':

			# FEKO blade beam
			beam_all = FEKO_high_band_blade_beam_plus_shaped_finite_ground_plane(beam_file=file_high_band_blade_FEKO, AZ_antenna_axis=rotation_from_north)
			
			# Current options for beam_file:
			# 20: blade over plus-shaped ground plane, from ALAN
			# 21: blade over no ground plane, just soil, from ALAN
			# 30: blade over plus-shaped ground plane, from NIVEDITA
			
			# Frequency array
			if (file_high_band_blade_FEKO >= 20) and (file_high_band_blade_FEKO < 30):
				freq_array = np.arange(65, 201, 1, dtype='uint32')
				
			if (file_high_band_blade_FEKO == 30):
				freq_array1 = np.arange(65, 98.5, 1)
				freq_array2 = np.arange(100, 201, 2)
				freq_array  = np.append(freq_array1, freq_array2, axis=0)







	if (band == 'low_band1') or (band == 'low_band2'):
		if antenna == 'blade_FEKO':

			# FEKO blade beam
			beam_all = FEKO_low_band_blade_beam(beam_file=file_low_band_blade_FEKO, AZ_antenna_axis=rotation_from_north)

			# Frequency array
			if file_low_band_blade_FEKO == 0:
				freq_array = np.arange(40, 101, 2, dtype='uint32')   # Extended ground plane, FROM NIVEDITA, 40-100 MHz'

			elif file_low_band_blade_FEKO == 1:
				freq_array = np.arange(40, 101, 2, dtype='uint32')   # Extended ground plane, 40-100 MHz'

			elif file_low_band_blade_FEKO == 2:
				freq_array = np.arange(40, 121, 2, dtype='uint32')   # Extended ground plane, 40-120 MHz' 

			elif file_low_band_blade_FEKO == 4:
				freq_array = np.arange(40, 101, 2, dtype='uint32')   # Original, 10mx10m Low-Band 1 ground plane, 40-100 MHz'

			elif file_low_band_blade_FEKO == 5:
				freq_array = np.arange(50, 121, 2, dtype='uint32')   # Original, 10mx10m Low-Band 1 ground plane, 50-120 MHz'


	# Index of reference frequency
	index_freq_array = np.arange(len(freq_array))
	irf = index_freq_array[freq_array == reference_frequency]
	print(irf)







	# Loading sky model
	if sky_model == 'guzman_haslam':

		# Loading galactic coordinates (the Haslam map is in NESTED Galactic Coordinates)
		coord              = fits.open(path_data + 'coordinate_maps/pixel_coords_map_nested_galactic_res9.fits')
		coord_array        = coord[1].data
		lon                = coord_array['LONGITUDE']
		lat                = coord_array['LATITUDE']
		GALAC_COORD_object = apc.SkyCoord(lon, lat, frame='galactic', unit='deg')  # defaults to ICRS frame


		# Loading Haslam map
		haslam_map = fits.open(path_data + 'haslam_map/lambda_haslam408_dsds.fits')
		haslam408  = (haslam_map[1].data)['temperature']


		# Spectral index in HEALPix RING Galactic Coordinates, nside=512
		beta_file = path_data + 'spectral_index/sky_spectral_index_original_45_408_MHz_maps_galactic_coordinates_nside_512_ring_3Ksubtracted.hdf5'
		with h5py.File(beta_file, 'r') as hf:			
			hf_beta   = hf.get('spectral_index')
			beta_ring = np.array(hf_beta)


		# Convert beta to NESTED format
		beta = hp.reorder(beta_ring, r2n=True)


		# Loading celestial coordinates to fill in the spectral index hole around the north pole
		coord              = fits.open(path_data + 'coordinate_maps/pixel_coords_map_nested_celestial_res9.fits')
		coord_array        = coord[1].data
		RA                 = coord_array['LONGITUDE']
		DEC                = coord_array['LATITUDE']


		# Filling the hole
		beta[DEC>68] = np.mean(beta[(DEC>60) & (DEC<68)])


		# Remove offsets
		Tcmb = 2.725
		Tzlc = -3.46		
		T408 = haslam408 - 3    # - Tcmb - Tzlc   # Corrections necessary


		# Produce map at the same frequencies as the beam
		#Teor, xHI, z = model_eor(freq_array.astype(float), T21 = -1, model_type='gaussian_frequency', fr=140)

		guzman_haslam = np.zeros((len(T408), len(freq_array)))
		for i in range(len(freq_array)):

			guzman_haslam[:,i] = T408 * (freq_array[i]/408)**(-beta) + 3     # +   Teor[i]





	if sky_model == 'haslam':

		# Loading galactic coordinates (the Haslam map is in NESTED Galactic Coordinates)
		coord              = fits.open(path_data + 'coordinate_maps/pixel_coords_map_nested_galactic_res9.fits')
		coord_array        = coord[1].data
		lon                = coord_array['LONGITUDE']
		lat                = coord_array['LATITUDE']
		GALAC_COORD_object = apc.SkyCoord(lon, lat, frame='galactic', unit='deg')  # defaults to ICRS frame

		# Loading Haslam map
		haslam_map = fits.open(path_data + 'haslam_map/lambda_haslam408_dsds.fits')
		haslam408  = (haslam_map[1].data)['temperature']

		# Scaling Haslam map (the map contains the CMB, which has to be removed at 408 MHz, and then added back)
		Tcmb   = 2.725
		T408   = haslam408 - Tcmb
		b0     = band_deg          # default 10 degrees, galactic elevation threshold for different spectral index


		#for i in range(len(lat)):
			#if (lat[i] >= -b0) and (lat[i] <= b0):
				#haslam150[i] = Tcmb + ((haslam[i]-Tcmb)*(XXXXXXXX/408)**(-index_inband))
			#elif (lat[i] < -b0) or (lat[i] > b0):
				#haslam150[i] = Tcmb + ((haslam[i]-Tcmb)*(XXXXXXXX/408)**(-index_outband))


		haslam = np.zeros((len(T408), len(freq_array)))
		for i in range(len(freq_array)):

			# Band of the Galactic center, using spectral index
			haslam[(lat >= -b0) & (lat <= b0), i] = T408[(lat >= -b0) & (lat <= b0)] * (freq_array[i]/408)**(-index_inband) + Tcmb

			# Range outside the Galactic center, using second spectral index
			haslam[(lat < -b0) | (lat > b0), i]   = T408[(lat < -b0) | (lat > b0)] * (freq_array[i]/408)**(-index_outband) + Tcmb


			#haslam[:, i] = T408 * (freq_array[i]/408)**(-2.5) + Tcmb



	if sky_model == 'gsm2008':

		# Loading GSM and RING Galactic Coordinates
		lon_ring, lat_ring, RA, DEC, freq_gsm, gsm_original = GSM_HDF5_read(home_folder + '/DATA/EDGES/beam_convolution/gsm/data_hdf5/GSM_dataset_40_200_MHz.hdf5')

		# Coordinates from RING to NESTED
		lon = hp.reorder(lon_ring, r2n=True)
		lat = hp.reorder(lat_ring, r2n=True)

		# Coordinate object
		GALAC_COORD_object = apc.SkyCoord(lon, lat, frame='galactic', unit='deg')  # defaults to ICRS frame

		# Select same frequencies for the sky as the beam
		gsm2008 = np.zeros( (len(lon), len(freq_array)) )
		for i in range(len(freq_array)):

			# Sky from RING to NESTED
			kk = hp.reorder(gsm_original[:, freq_gsm == freq_array[i]].flatten(), r2n=True)
			gsm2008[:,i] = kk





	if sky_model == 'gsm2016':

		# Loading GSM2016 and NESTED Galactic Coordinates
		lon, lat, RA, DEC, freq_gsm, gsm_original = GSM_HDF5_read(home_folder + '/DATA/EDGES/beam_convolution/gsm2016-master/data_hdf5/GSM2016_dataset_40_200_MHz.hdf5')

		# Coordinate object
		GALAC_COORD_object = apc.SkyCoord(lon, lat, frame='galactic', unit='deg')  # defaults to ICRS frame

		# Select same frequencies for the sky as the beam
		gsm2016 = np.zeros( (len(lon), len(freq_array)) )
		for i in range(len(freq_array)):
			gsm2016[:,i] = gsm_original[:, freq_gsm == freq_array[i]].flatten()		








	# EDGES location	
	EDGES_lat_deg  = -26.714778
	EDGES_lon_deg  = 116.605528 
	EDGES_location = apc.EarthLocation(lat=EDGES_lat_deg*apu.deg, lon=EDGES_lon_deg*apu.deg)


	# Reference UTC observation time. At this time, the LST is 0.1666 (00:10 Hrs LST) at the EDGES location (it was wrong before, now it is correct)
	Time_iter    = np.array([2014, 1, 1, 9, 39, 42])     
	Time_iter_dt = dt.datetime(Time_iter[0], Time_iter[1], Time_iter[2], Time_iter[3], Time_iter[4], Time_iter[5]) 


	# Looping over LST
	LST             = np.zeros(72)
	convolution_ref = np.zeros((len(LST), len(beam_all[:,0,0])))
	convolution     = np.zeros((len(LST), len(beam_all[:,0,0])))	
	numerator       = np.zeros((len(LST), len(beam_all[:,0,0])))
	denominator     = np.zeros((len(LST), len(beam_all[:,0,0])))


	#for i in range(len(LST)):
	for i in range(1):


		print(name_save + ', LST: ' + str(i) + ' out of 72')


		# Advancing time ( 19:57 minutes UTC correspond to 20 minutes LST )
		minutes_offset = 19
		seconds_offset = 57
		if i > 0:
			Time_iter_dt = Time_iter_dt + dt.timedelta(minutes = minutes_offset, seconds = seconds_offset)
			Time_iter    = np.array([Time_iter_dt.year, Time_iter_dt.month, Time_iter_dt.day, Time_iter_dt.hour, Time_iter_dt.minute, Time_iter_dt.second]) 



		# LST 
		LST[i] = utc2lst(Time_iter, EDGES_lon_deg)



		# Transforming Galactic coordinates of Sky to Local coordinates		
		altaz          = GALAC_COORD_object.transform_to(apc.AltAz(location=EDGES_location, obstime=apt.Time(Time_iter_dt, format='datetime')))
		AZ             = np.asarray(altaz.az)
		EL             = np.asarray(altaz.alt)



		# Selecting coordinates and sky data above the horizon
		AZ_above_horizon         = AZ[EL>=0]
		EL_above_horizon         = EL[EL>=0]

		if sky_model == 'guzman_haslam':
			guzman_haslam_above_horizon = guzman_haslam[EL>=0,:]

		if sky_model == 'haslam':
			haslam_above_horizon     = haslam[EL>=0,:]
			haslam_ref_above_horizon = haslam_above_horizon[:, irf].flatten()

		if sky_model == 'gsm2008':
			gsm2008_above_horizon = gsm2008[EL>0,:]

		if sky_model == 'gsm2016':
			gsm2016_above_horizon = gsm2016[EL>0,:]



		# Looping over beam frequencies
		az_array   = np.tile(AZ_beam,91)
		el_array   = np.repeat(EL_beam,360)
		az_el_original      = np.array([az_array, el_array]).T
		az_el_above_horizon = np.array([AZ_above_horizon, EL_above_horizon]).T





		# Precomputation of beam at frequency reference for normalization in sky_models, haslam, gsm2008, gsm2016
		beam_array_v0         = beam_all[irf,:,:].reshape(1,-1)[0]
		beam_above_horizon_v0 = spi.griddata(az_el_original, beam_array_v0, az_el_above_horizon, method='cubic')  # interpolated beam




		# Loop over frequency
		for j in range(len(freq_array)):

			print(name_save + ', Freq: ' + str(j) + ' out of ' + str(len(beam_all[:,0,0])))

			beam_array         = beam_all[j,:,:].reshape(1,-1)[0]
			beam_above_horizon = spi.griddata(az_el_original, beam_array, az_el_above_horizon, method='cubic')  # interpolated beam


			no_nan_array = np.ones(len(AZ_above_horizon)) - np.isnan(beam_above_horizon)
			index_no_nan = np.nonzero(no_nan_array)[0]

			if sky_model == 'guzman_haslam':
				guzman_haslam_above_horizon_ff = guzman_haslam_above_horizon[:, j].flatten() #print(ff)
				numerator[i, j]                = np.sum(beam_above_horizon[index_no_nan]*guzman_haslam_above_horizon_ff[index_no_nan])
				denominator[i, j]              = np.sum(beam_above_horizon_v0[index_no_nan]*guzman_haslam_above_horizon_ff[index_no_nan])

				# Antenna temperature
				convolution[i, j]              = np.sum(beam_above_horizon[index_no_nan]*guzman_haslam_above_horizon_ff[index_no_nan])/np.sum(beam_above_horizon[index_no_nan])


			if sky_model == 'haslam':				
				convolution_ref[i, j]   = np.sum(beam_above_horizon[index_no_nan]*haslam_ref_above_horizon[index_no_nan])/np.sum(beam_above_horizon[index_no_nan])

				# Antenna temperature
				haslam_above_horizon_ff = haslam_above_horizon[:, j].flatten()
				convolution[i, j]       = np.sum(beam_above_horizon[index_no_nan]*haslam_above_horizon_ff[index_no_nan])/np.sum(beam_above_horizon[index_no_nan])


			if sky_model == 'gsm2008':
				gsm2008_above_horizon_ff = gsm2008_above_horizon[:, j].flatten() #print(ff)
				numerator[i, j]          = np.sum(beam_above_horizon[index_no_nan]*gsm2008_above_horizon_ff[index_no_nan])
				denominator[i, j]        = np.sum(beam_above_horizon_v0[index_no_nan]*gsm2008_above_horizon_ff[index_no_nan])

				# Antenna temperature
				convolution[i, j]              = np.sum(beam_above_horizon[index_no_nan]*gsm2008_above_horizon_ff[index_no_nan])/np.sum(beam_above_horizon[index_no_nan])	


			if sky_model == 'gsm2016':
				gsm2016_above_horizon_ff = gsm2016_above_horizon[:, j].flatten() #print(ff)
				numerator[i, j]          = np.sum(beam_above_horizon[index_no_nan]*gsm2016_above_horizon_ff[index_no_nan])
				denominator[i, j]        = np.sum(beam_above_horizon_v0[index_no_nan]*gsm2016_above_horizon_ff[index_no_nan])

				# Antenna temperature
				convolution[i, j]              = np.sum(beam_above_horizon[index_no_nan]*gsm2016_above_horizon_ff[index_no_nan])/np.sum(beam_above_horizon[index_no_nan])				




	if (sky_model == 'guzman_haslam') or (sky_model == 'gsm2008') or (sky_model == 'gsm2016'):
		beam_factor_T = numerator.T/denominator.T


	if sky_model == 'haslam':

		# if (band == 'high_band') and (antenna == 'fourpoint'):
		beam_factor_T = convolution_ref.T/convolution_ref[:,irf].T

		#elif (band == 'high_band') and (antenna == 'blade_CST'):
			#beam_factor = convolution.T/convolution[:,irf].T

		#elif (band == 'high_band') and (antenna == 'blade_FEKO'):
			#beam_factor = convolution.T/convolution[:,irf].T


	beam_factor = beam_factor_T.T







	# Saving beam factor
	np.savetxt(path_save + name_save + '_tant.txt', convolution)
	np.savetxt(path_save + name_save + '_data.txt', beam_factor)
	np.savetxt(path_save + name_save + '_LST.txt',  LST)
	np.savetxt(path_save + name_save + '_freq.txt', freq_array)




	return freq_array, LST, convolution, beam_factor

















def receiver_calibration(band, fe, receiver_temperature=25, low_band_cal_file=1, high_band_cal_file=1):


	"""
	Last modification: April 24, 2016
	This function returns the five calibration quantities.
	For the high-band receiver this function interpolates / extrapolates the calibration quantities based on the receiver temperature.
	The two anchor temperatures are 25degC and 35degC.
	"""	


	if band == 'low_band_2015':


		# Original 2015 Calibration (Cfit=6, Wfit=5)
		if low_band_cal_file == 0:
			path_calibration_low_band  = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band1/2015_08_25C/results/nominal/calibration_files/'

			calibration_file = path_calibration_low_band + 'calibration_file_low_band_2015_cfit6_wfit5.txt'
			N_cfit = 6
			N_wfit = 5

			# Number of terms for frequency interpolation for LNA
			N_s11_LNA = 13  # 50-100 MHz	




		# Original 2015 Calibration (Cfit=7, Wfit=7)
		if low_band_cal_file == 1:
			path_calibration_low_band  = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band1/2015_08_25C/results/nominal/calibration_files/'

			calibration_file = path_calibration_low_band + 'calibration_file_low_band_2015_nominal.txt'
			N_cfit = 7
			N_wfit = 7

			# Number of terms for frequency interpolation for LNA
			N_s11_LNA = 13  # 50-100 MHz			


		# 2017-05 Calibration (Cfit=7, Wfit=7)
		if low_band_cal_file == 2:
			path_calibration_low_band  = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band1/2017_05_25C/results/50_100_MHz/calibration_files/'

			calibration_file = path_calibration_low_band + 'calibration_file_low_band_2015_2017_05_50_100_MHz.txt'
			N_cfit = 4  # 7
			N_wfit = 4  # 7 

			# Number of terms for frequency interpolation for LNA
			N_s11_LNA = 13  # 50-100 MHz


		# 2017-05 Calibration 50-120 MHz (Cfit=8, Wfit=7)
		if low_band_cal_file == 3:
			path_calibration_low_band  = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band1/2017_05_25C/results/50_120_MHz/calibration_files/'

			calibration_file = path_calibration_low_band + 'calibration_file_low_band_2015_2017_05_50_120_MHz.txt'
			N_cfit = 8
			N_wfit = 7

			# Number of terms for frequency interpolation for LNA
			N_s11_LNA = 19  # 50-120 MHz





		# ---------------------------------------------------------------------

		# 2017-09 Calibration 50-100 MHz 
		if low_band_cal_file == 4:
			# Place holder
			print('place holder')



		# 2017-09 Calibration 50-120 MHz 
		if low_band_cal_file == 5:
			path_calibration_low_band  = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band1/2017_09_25C/results/50_120_MHz/calibration_files/'

			calibration_file = path_calibration_low_band + 'calibration_file_low_band_2015_2017_09_50_120_MHz_cterms7_wterms8.txt'
			N_cfit = 7
			N_wfit = 8

			# Number of terms for frequency interpolation for LNA
			N_s11_LNA = 25  # 50-120 MHz

		# ---------------------------------------------------------------------



		LNA_cal = np.genfromtxt(calibration_file)
		f_orig       = LNA_cal[:,0]
		f_orig_norm  = (f_orig - 75)/25
		s11_LNA_orig = LNA_cal[:,1] + 1j*LNA_cal[:,2]
		sca_orig     = LNA_cal[:,3]
		off_orig     = LNA_cal[:,4]
		TU_orig      = LNA_cal[:,5]
		TC_orig      = LNA_cal[:,6]
		TS_orig      = LNA_cal[:,7]

		fe_norm      = (fe - 75)/25








	if band == 'low_band2_2017':
		path_calibration_low_band_25  = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band2/2016_09_25C/results/nominal/calibration_files/'
		path_calibration_low_band_15  = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band2/2016_11_15C/results/nominal/calibration_files/'
		path_calibration_low_band_35  = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band2/2016_11_35C/results/nominal/calibration_files/'



		# Cfit=6, Wfit=5
		if low_band_cal_file == 0:
			calibration_file_25 = path_calibration_low_band_25 + 'calibration_file_low_band2_2017_cfit6_wfit5.txt'
			calibration_file_15 = path_calibration_low_band_15 + 'calibration_file_low_band2_2017_cfit6_wfit5.txt'
			calibration_file_35 = path_calibration_low_band_35 + 'calibration_file_low_band2_2017_cfit6_wfit5.txt'

			N_cfit = 6
			N_wfit = 5			



		# Cfit=7, Wfit=7
		if low_band_cal_file == 1:
			calibration_file_25 = path_calibration_low_band_25 + 'calibration_file_low_band2_2017_nominal.txt'
			calibration_file_15 = path_calibration_low_band_15 + 'calibration_file_low_band2_2017_nominal.txt'
			calibration_file_35 = path_calibration_low_band_35 + 'calibration_file_low_band2_2017_nominal.txt'

			N_cfit = 7
			N_wfit = 7			




		LNA_cal_25      = np.genfromtxt(calibration_file_25)
		LNA_cal_15      = np.genfromtxt(calibration_file_15)
		LNA_cal_35      = np.genfromtxt(calibration_file_35)

		f_orig_25  = LNA_cal_25[:,0]		
		s11_LNA_25 = LNA_cal_25[:,1] + 1j*LNA_cal_25[:,2]
		sca_25     = LNA_cal_25[:,3]
		off_25     = LNA_cal_25[:,4]
		TU_25      = LNA_cal_25[:,5]
		TC_25      = LNA_cal_25[:,6]
		TS_25      = LNA_cal_25[:,7]

		f_orig_15  = LNA_cal_15[:,0]		
		s11_LNA_15 = LNA_cal_15[:,1] + 1j*LNA_cal_15[:,2]
		sca_15     = LNA_cal_15[:,3]
		off_15     = LNA_cal_15[:,4]
		TU_15      = LNA_cal_15[:,5]
		TC_15      = LNA_cal_15[:,6]
		TS_15      = LNA_cal_15[:,7]

		f_orig_35  = LNA_cal_35[:,0]		
		s11_LNA_35 = LNA_cal_35[:,1] + 1j*LNA_cal_35[:,2]
		sca_35     = LNA_cal_35[:,3]
		off_35     = LNA_cal_35[:,4]
		TU_35      = LNA_cal_35[:,5]
		TC_35      = LNA_cal_35[:,6]
		TS_35      = LNA_cal_35[:,7]


		if (receiver_temperature == 25) or (receiver_temperature == 0):  # in case there is no measurement of the receiver temperature, a value of zero is assigned, and use default calibration
			s11_LNA_orig = s11_LNA_25
			sca_orig     = sca_25
			off_orig     = off_25
			TU_orig      = TU_25
			TC_orig      = TC_25
			TS_orig      = TS_25


		elif receiver_temperature == 15:
			s11_LNA_orig = s11_LNA_15
			sca_orig     = sca_15
			off_orig     = off_15
			TU_orig      = TU_15
			TC_orig      = TC_15
			TS_orig      = TS_15	


		elif receiver_temperature == 35:
			s11_LNA_orig = s11_LNA_35
			sca_orig     = sca_35
			off_orig     = off_35
			TU_orig      = TU_35
			TC_orig      = TC_35
			TS_orig      = TS_35



		elif (receiver_temperature > 15) and (receiver_temperature < 25):

			# Interpolation to measured temperature
			# Simultaneous fit for all frequency channels
			par = np.polyfit(np.array([15, 25]), np.array([np.real(s11_LNA_15), np.real(s11_LNA_25)]), 1)
			re_s11_LNA   = np.polyval(par, receiver_temperature)

			par = np.polyfit(np.array([15, 25]), np.array([np.imag(s11_LNA_15), np.imag(s11_LNA_25)]), 1)
			im_s11_LNA   = np.polyval(par, receiver_temperature)

			s11_LNA_orig = re_s11_LNA + 1j*im_s11_LNA


			par       = np.polyfit(np.array([15, 25]), np.array([sca_15, sca_25]), 1)
			sca_orig  = np.polyval(par, receiver_temperature)

			par       = np.polyfit(np.array([15, 25]), np.array([off_15, off_25]), 1)
			off_orig  = np.polyval(par, receiver_temperature)

			par       = np.polyfit(np.array([15, 25]), np.array([TU_15,  TU_25]), 1)
			TU_orig   = np.polyval(par, receiver_temperature)

			par       = np.polyfit(np.array([15, 25]), np.array([TC_15,  TC_25]), 1)
			TC_orig   = np.polyval(par, receiver_temperature)

			par       = np.polyfit(np.array([15, 25]), np.array([TS_15,  TS_25]), 1)
			TS_orig   = np.polyval(par, receiver_temperature)



		elif (receiver_temperature > 25) and (receiver_temperature < 35):

			# Interpolation to measured temperature
			# Simultaneous fit for all frequency channels
			par = np.polyfit(np.array([25, 35]), np.array([np.real(s11_LNA_25), np.real(s11_LNA_35)]), 1)
			re_s11_LNA   = np.polyval(par, receiver_temperature)

			par = np.polyfit(np.array([25, 35]), np.array([np.imag(s11_LNA_25), np.imag(s11_LNA_35)]), 1)
			im_s11_LNA   = np.polyval(par, receiver_temperature)

			s11_LNA_orig = re_s11_LNA + 1j*im_s11_LNA


			par       = np.polyfit(np.array([25, 35]), np.array([sca_25, sca_35]), 1)
			sca_orig  = np.polyval(par, receiver_temperature)

			par       = np.polyfit(np.array([25, 35]), np.array([off_25, off_35]), 1)
			off_orig  = np.polyval(par, receiver_temperature)

			par       = np.polyfit(np.array([25, 35]), np.array([TU_25,  TU_35]), 1)
			TU_orig   = np.polyval(par, receiver_temperature)

			par       = np.polyfit(np.array([25, 35]), np.array([TC_25,  TC_35]), 1)
			TC_orig   = np.polyval(par, receiver_temperature)

			par       = np.polyfit(np.array([25, 35]), np.array([TS_25,  TS_35]), 1)
			TS_orig   = np.polyval(par, receiver_temperature)


		f_orig_norm = (f_orig_25 - 75)/25
		fe_norm     = (fe - 75)/25

		# Number of terms for frequency interpolation for LNA
		N_s11_LNA = 13 # yes, 13










	if band == 'high_band_2015':
		path_calibration_high_band = home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_march_2015/LNA/calibration_files/'

		#if high_band_cal_file == 1:
			#calibration_file_25 = path_calibration_high_band + 'calibration_file_high_band_v1_cterms7_wterms7.txt'
			#calibration_file_35 = path_calibration_high_band + 'calibration_file_high_band_35degC_v1_cterms7_wterms7.txt'
			#N_cfit = 7
			#N_wfit = 7

		#if high_band_cal_file == 2:
			#calibration_file_25 = path_calibration_high_band + 'calibration_file_high_band_v1_cterms7_wterms6.txt'
			#calibration_file_35 = path_calibration_high_band + 'calibration_file_high_band_35degC_v1_cterms7_wterms6.txt'
			#N_cfit = 7
			#N_wfit = 6

		#if high_band_cal_file == 3:
			#calibration_file_25 = path_calibration_high_band + 'calibration_file_high_band_v1_cterms6_wterms7.txt'
			#calibration_file_35 = path_calibration_high_band + 'calibration_file_high_band_35degC_v1_cterms6_wterms7.txt'
			#N_cfit = 6
			#N_wfit = 7

		#if high_band_cal_file == 4:
			#calibration_file_25 = path_calibration_high_band + 'calibration_file_high_band_v1_cterms6_wterms6.txt'
			#calibration_file_35 = path_calibration_high_band + 'calibration_file_high_band_35degC_v1_cterms6_wterms6.txt'
			#N_cfit = 6
			#N_wfit = 6

		#if high_band_cal_file == 5:
			#calibration_file_25 = path_calibration_high_band + 'calibration_file_high_band_v1_cterms6_wterms5.txt'
			#calibration_file_35 = path_calibration_high_band + 'calibration_file_high_band_35degC_v1_cterms6_wterms5.txt'
			#N_cfit = 6
			#N_wfit = 5

		#if high_band_cal_file == 6:
			#calibration_file_25 = path_calibration_high_band + 'calibration_file_high_band_v1_cterms5_wterms6.txt'
			#calibration_file_35 = path_calibration_high_band + 'calibration_file_high_band_35degC_v1_cterms5_wterms6.txt'
			#N_cfit = 5
			#N_wfit = 6

		#if high_band_cal_file == 7:
			#calibration_file_25 = path_calibration_high_band + 'calibration_file_high_band_v1_cterms5_wterms5.txt'
			#calibration_file_35 = path_calibration_high_band + 'calibration_file_high_band_35degC_v1_cterms5_wterms5.txt'
			#N_cfit = 5
			#N_wfit = 5


		calibration_file_25 = path_calibration_high_band + 'calibration_file_high_band_v1_cterms7_wterms7.txt'




		LNA_cal_25 = np.genfromtxt(calibration_file_25)
		f_orig_25     = LNA_cal_25[:,0]
		s11_LNA_25    = LNA_cal_25[:,1] + 1j*LNA_cal_25[:,2]
		sca_25        = LNA_cal_25[:,3]
		off_25        = LNA_cal_25[:,4]
		TU_25         = LNA_cal_25[:,5]
		TC_25         = LNA_cal_25[:,6]
		TS_25         = LNA_cal_25[:,7]

		LNA_cal_35 = np.genfromtxt(calibration_file_35)
		f_orig_35     = LNA_cal_35[:,0]
		s11_LNA_35    = LNA_cal_35[:,1] + 1j*LNA_cal_35[:,2]
		sca_35        = LNA_cal_35[:,3]
		off_35        = LNA_cal_35[:,4]
		TU_35         = LNA_cal_35[:,5]
		TC_35         = LNA_cal_35[:,6]
		TS_35         = LNA_cal_35[:,7]

		if (receiver_temperature == 25) or (receiver_temperature == 0):  # in case there is no measurement of the receiver temperature, a value of zero is assigned, and use default calibration
			s11_LNA_orig = s11_LNA_25
			sca_orig     = sca_25
			off_orig     = off_25
			TU_orig      = TU_25
			TC_orig      = TC_25
			TS_orig      = TS_25

		elif receiver_temperature == 35:
			s11_LNA_orig = s11_LNA_35
			sca_orig     = sca_35
			off_orig     = off_35
			TU_orig      = TU_35
			TC_orig      = TC_35
			TS_orig      = TS_35		
			f_orig       = f_orig_25



		else:			

			# Interpolation to measured temperature

			# Simultaneous fit for all frequency channels
			par = np.polyfit(np.array([25, 35]), np.array([np.real(s11_LNA_25), np.real(s11_LNA_35)]), 1)
			re_s11_LNA   = np.polyval(par, receiver_temperature)

			par = np.polyfit(np.array([25, 35]), np.array([np.imag(s11_LNA_25), np.imag(s11_LNA_35)]), 1)
			im_s11_LNA   = np.polyval(par, receiver_temperature)

			s11_LNA_orig = re_s11_LNA + 1j*im_s11_LNA


			par       = np.polyfit(np.array([25, 35]), np.array([sca_25, sca_35]), 1)
			sca_orig  = np.polyval(par, receiver_temperature)

			par       = np.polyfit(np.array([25, 35]), np.array([off_25, off_35]), 1)
			off_orig  = np.polyval(par, receiver_temperature)

			par       = np.polyfit(np.array([25, 35]), np.array([TU_25,  TU_35]), 1)
			TU_orig   = np.polyval(par, receiver_temperature)

			par       = np.polyfit(np.array([25, 35]), np.array([TC_25,  TC_35]), 1)
			TC_orig   = np.polyval(par, receiver_temperature)

			par       = np.polyfit(np.array([25, 35]), np.array([TS_25,  TS_35]), 1)
			TS_orig   = np.polyval(par, receiver_temperature)


		# Frequency vectors for the high-band
		f_orig       = f_orig_25
		f_orig_norm  = (f_orig - 140)/60
		fe_norm      = (fe - 140)/60


		# Number of terms for frequency interpolation
		N_s11_LNA = 31  # yes, 31, not 13




	# Interpolation to input frequency

	# LNA S11
	# -------------------------------
	pp           = np.polyfit(f_orig_norm, np.real(s11_LNA_orig), N_s11_LNA)
	real_s11_LNA = np.polyval(pp, fe_norm)

	pp           = np.polyfit(f_orig_norm, np.imag(s11_LNA_orig), N_s11_LNA)
	imag_s11_LNA = np.polyval(pp, fe_norm)

	s11_LNA      = real_s11_LNA + 1j*imag_s11_LNA





	# Scale
	# -------------------------------
	pp  = np.polyfit(f_orig_norm, sca_orig, N_cfit)
	sca = np.polyval(pp, fe_norm)


	# Offset
	# -------------------------------
	pp  = np.polyfit(f_orig_norm, off_orig, N_cfit)
	off = np.polyval(pp, fe_norm)


	# TU
	# -------------------------------
	pp = np.polyfit(f_orig_norm, TU_orig,   N_wfit)
	TU = np.polyval(pp, fe_norm)


	# TC
	# -------------------------------
	pp = np.polyfit(f_orig_norm, TC_orig,   N_wfit)
	TC = np.polyval(pp, fe_norm)


	# TS
	# -------------------------------
	pp = np.polyfit(f_orig_norm, TS_orig,   N_wfit)
	TS = np.polyval(pp, fe_norm)		






	return s11_LNA, sca, off, TU, TC, TS
























def spectral_index_simulated_data(band, case_data, case_beam_factor, beam_correction='on', npar=3, flow=110, fhigh=190):

	# Loading data
	path_data        = home_folder + '/DATA/EDGES/beam_convolution/sky_convolved_beam/' + band + '/'
	path_beam_factor = home_folder + '/DATA/EDGES/beam_convolution/beam_factors/'





	# Night time real data for comparison
	if case_data == 'a00':
		LST, f, dd, md, wd = spectral_index_LST_night_time_data('blade')




	# Simulated data

	# Fourpoint
	if case_data == 'a01':
		f             = np.arange(100,201,1)
		filename_data = 'high_band_gsm_fourpoint_infinite_flow_100_fhigh_200_fstep_1.txt'




	# Blade
	if case_data == 'b01':
		f             = np.arange(100,201,1)
		filename_data = 'high_band_gsm_blade_infinite_flow_100_fhigh_200_fstep_1.txt'

	if case_data == 'b02':
		f             = np.arange(100,201,1)
		filename_data = 'high_band_gsm_blade_plus_shaped_finite_flow_100_fhigh_200_fstep_1.txt'	

	if case_data == 'b03': # Achromatic
		f             = np.arange(100,201,1)
		filename_data = 'high_band_gsm_blade_infinite_flow_100_fhigh_200_fstep_1_fixed_beam_150_MHz.txt'




	# Cosine square 
	if case_data == 'c01': # Achromatic
		f             = np.arange(100,201,1)
		filename_data = 'high_band_gsm_cosine_square_flow_100_fhigh_200_fstep_1.txt'		





	# Scaled Haslam and Blade	
	if case_data == 'd01': # Achromatic, spectral indices 2.5, 2.57
		f             = np.arange(100,201,1)
		filename_data = 'high_band_scaled_haslam_2.5_2.57_blade_infinite_flow_100_fhigh_200_fstep_1_fixed_beam_150_MHz.txt'		

	if case_data == 'd02': # Achromatic, spectral indices 2.4, 2.6
		f             = np.arange(100,201,1)
		filename_data = 'high_band_scaled_haslam_2.4_2.6_blade_infinite_flow_100_fhigh_200_fstep_1_fixed_beam_150_MHz.txt'		





	# Using custom GSM from maps at 45 and 408 MHz	
	if case_data == 'e01':
		f             = np.arange(90,191,1)
		filename_data = 'high_band_45_408_MHz_original_blade_plus_shaped_finite_flow_90_fhigh_190_fstep_1_fixed_beam_150_MHz.txt'		

	if case_data == 'e02':
		f             = np.arange(90,191,1)
		filename_data = 'high_band_45_408_MHz_original_blade_plus_shaped_finite_flow_90_fhigh_190_fstep_1_fixed_beam_150_MHz_3Ksubtracted.txt'	

	if case_data == 'e03':
		f             = np.arange(90,191,1)
		filename_data = 'high_band_45_408_MHz_original_blade_plus_shaped_finite_flow_90_fhigh_190_fstep_1_fixed_beam_150_MHz_3Ksubtracted_-6deg_AZ.txt'	

	if case_data == 'e04':
		f             = np.arange(90,191,1)
		filename_data = 'high_band_45_408_MHz_gsm_blade_plus_shaped_finite_flow_90_fhigh_190_fstep_1_fixed_beam_150_MHz.txt'














	# Beam factor	
	if case_beam_factor == 'x01':
		f_bf = np.arange(80,201,5)
		filename_beam_factor = 'beam_factor_high_band_fourpoint_band10deg_indices_2.5_2.5_data.txt'

	if case_beam_factor == 'x02':
		f_bf = np.arange(80,201,5)
		filename_beam_factor = 'beam_factor_high_band_fourpoint_band10deg_indices_2.5_2.57_data.txt'




	if case_beam_factor == 'y01':
		f_bf = np.arange(100,201,1)
		filename_beam_factor = 'beam_factor_high_band_blade_band10deg_indices_2.5_2.5_data.txt'

	if case_beam_factor == 'y02':
		f_bf = np.arange(100,201,1)
		filename_beam_factor = 'beam_factor_high_band_blade_band10deg_indices_2.5_2.57_data.txt'








	# Actually loading data
	if case_data == 'a00':
		t  = dd
		ww = wd

	else:
		tt = np.genfromtxt(path_data        + filename_data)
		t  = tt[:,1::]
		ww = np.ones((72, len(f))) # len(t[:,0])

	bf = np.genfromtxt(path_beam_factor + filename_beam_factor)




	# Initialization of arrays
	bf_raw           = np.zeros((72,len(f)))
	t_beam_corrected = np.zeros((72,len(f)))

	T0        = np.zeros(72)
	beta      = np.zeros(72)
	gamma     = np.zeros(72)
	RMS       = np.zeros(72)	
	residuals = np.zeros((72,len(f)))

	Tcmb = 2.725


	# Looping over LST
	for j in range(72):


		# Applying beam correction
		if beam_correction == 'on':

			# Interpolating beam factor to spectra frequency
			par_bf      = np.polyfit(f_bf/150, bf[j,:], 10)   # fitting a 10 degree polynomial in frequency to each LST of the beam factor
			bf_raw[j,:] = np.polyval(par_bf, f/150)			
			t_beam_corrected[j,:] = t[j,:] / bf_raw[j,:]


		elif beam_correction == 'off':
			t_beam_corrected[j,:] = t[j,:] / 1


		# Choosing frequency range
		xx = np.ones(len(f)) # weights[j,:]
		frequency, temperature, weights = spectral_zero_removal(f, t_beam_corrected[j,:], ww[j,:], flow, fhigh, weight = 0)  # 


		# Remove CMB from beam-corrected data if processing measurements. If processing GSM simulations this step is not necessary.
		if (case_data == 'a00') or (case_data[0] == 'd'):
			print('Tcmb removed before spectral fitting.')
			tempe = temperature - Tcmb
		else:
			tempe  = np.copy(temperature)


		# Parameter fitting
		par_fit    = np.polyfit(np.log(frequency/150), np.log(tempe), npar-1)

		print('LST: ' + str(j) + ' of 72')

		if npar == 2:
			beta[j] = -par_fit[0]
			T0[j]   =  np.exp(par_fit[1])						

		elif npar == 3:
			gamma[j] = -par_fit[0]
			beta[j]  = -par_fit[1]
			T0[j]    =  np.exp(par_fit[2])


		# Computing residuals and RMS in range of the simulated data
		log_model      = np.polyval(par_fit, np.log(f/150))
		model          = np.exp(log_model)
		residuals[j,:] = t_beam_corrected[j,:] -  model
		RMS[j]         = np.sqrt(np.sum(residuals[j,:]**2)/len(f))



	# Reference LSTs
	LST = np.arange(1/6,24,1/3)


	# Complete arrays
	T0_LST    = np.array([LST, T0]).T
	beta_LST  = np.array([LST, beta]).T
	gamma_LST = np.array([LST, gamma]).T
	RMS_LST   = np.array([LST, RMS]).T



	## Saving data
	#path_save = '/media/raul/DATA/EDGES/spectral_index/' + band + '/'
	#name_save = 'spectral_index_' + band + '_' + case_data + '_' + case_beam_factor + '_npar_' + str(npar) + '_flim_' + str(flow) + '_' + str(fhigh) + '_sun_el_max_' + str(sun_el_max) + '_RMS_median_' + str(RMS_median_threshold) + save_flag
	#save_file = path_save + 'data/' + name_save



	#with h5py.File(save_file + '.hdf5', 'w') as hf:
		#hf.create_dataset('meta',      data = m)
		#hf.create_dataset('LST',       data = LST)
		#hf.create_dataset('T0',        data = T0)
		#hf.create_dataset('beta',      data = beta)
		#hf.create_dataset('gamma',     data = gamma)
		#hf.create_dataset('RMS',       data = RMS)
		#hf.create_dataset('T0_LST',    data = T0_LST)
		#hf.create_dataset('beta_LST',  data = beta_LST)
		#hf.create_dataset('gamma_LST', data = gamma_LST)
		#hf.create_dataset('RMS_LST',   data = RMS_LST)
		#hf.create_dataset('residuals', data = residuals)
		#hf.create_dataset('freq_binned', data = f)


	return T0_LST, beta_LST, gamma_LST, RMS_LST, residuals











def spectral_index(band, case_data, case_beam_factor, save_flag='', beam_correction='on', npar=3,  flow=110, fhigh=190, sun_el_max=-10, RMS_median_threshold=1.1, save_data='yes'):

	# Loading data
	path_data =        home_folder + '/DATA/EDGES/spectra/level4/' + band + '/'
	path_beam_factor = home_folder + '/DATA/EDGES/beam_convolution/beam_factors/'	








	# Calibrated data
	if case_data == 'a01':
		filename_data = 'high_band_v1_fourpoint_s11day_157_recv_temp_not_corrected_tambient_300.hdf5'

	#if case_data == 'a02':
	#	filename_data = 'high_band_v1_fourpoint_s11day_157_recv_temp_corrected_half_temperature_difference.hdf5'

	if case_data == 'a03':
		filename_data = 'high_band_v1_fourpoint_s11day_157_recv_temp_full_correction_tambient_300.hdf5'	




	if case_data == 'b01':
		filename_data = 'high_band_v1_blade_s11day_262_recv_temp_not_corrected_tambient_300.hdf5'

	#if case_data == 'b02':
	#	filename_data = 'high_band_v1_blade_s11day_262_recv_temp_corrected_half_temperature_difference.hdf5'		

	if case_data == 'b03':
		filename_data = 'high_band_v1_blade_s11day_262_recv_temp_full_correction_tambient_300.hdf5'

	if case_data == 'b04':
		filename_data = 'high_band_v1_blade_s11day_262_recv_temp_full_correction_tambient_300_ground_loss_percent_0.5.hdf5'

	if case_data == 'b05':
		filename_data = 'high_band_v1_blade_s11day_212_recv_temp_full_correction_tambient_300_ground_loss_percent_0.5.hdf5'







	# Beam factor	
	if case_beam_factor == 'x01':
		f_bf = np.arange(80,201,5)
		filename_beam_factor = 'beam_factor_high_band_fourpoint_band10deg_indices_2.5_2.5_data.txt'

	if case_beam_factor == 'x02':
		f_bf = np.arange(80,201,5)
		filename_beam_factor = 'beam_factor_high_band_fourpoint_band10deg_indices_2.5_2.57_data.txt'




	if case_beam_factor == 'y01':
		f_bf = np.arange(100,201,1)
		filename_beam_factor = 'beam_factor_high_band_blade_band10deg_indices_2.5_2.5_data.txt'

	if case_beam_factor == 'y02':
		f_bf = np.arange(100,201,1)
		filename_beam_factor = 'beam_factor_high_band_blade_band10deg_indices_2.5_2.57_data.txt'

	if case_beam_factor == 'y03':
		f_bf = np.arange(80,201,5)
		filename_beam_factor = 'beam_factor_high_band_blade_FEKO_AZrotation-5_band10deg_indices_2.5_2.57_data.txt'






	# Loading calibrated data and beam factor
	if case_data == 'a00':
		f, t, m, w = eg.spectral_index_LST_night_time_data('blade')	
	else:
		f, t, m, w = level4read(path_data + filename_data)

	bf = np.genfromtxt(path_beam_factor + filename_beam_factor)



	# Initialization of arrays 
	bf_raw           = np.zeros((72,len(f)))
	t_beam_corrected = np.zeros((len(t[:,0,0]),len(t[0,:,0]),len(t[0,0,:])))

	T0         = np.zeros((len(t[:,0,0]), len(t[0,:,0])))
	beta       = np.zeros((len(t[:,0,0]), len(t[0,:,0])))
	gamma      = np.zeros((len(t[:,0,0]), len(t[0,:,0])))

	RMS        = np.zeros((len(t[:,0,0]),len(t[0,:,0])))
	RMS_median = np.zeros(72)

	gamma_mean = np.zeros(72)
	beta_mean  = np.zeros(72)
	T0_mean    = np.zeros(72)
	RMS_mean   = np.zeros(72)

	gamma_std  = np.zeros(72)
	beta_std   = np.zeros(72)
	T0_std     = np.zeros(72)
	RMS_std    = np.zeros(72)

	residuals  = np.zeros((len(t[:,0,0]), len(t[0,:,0]), len(f)))








	# Looping over LST
	for j in range(len(bf[:,0])):




		# Interpolating beam factor to spectra frequency
		par_bf      = np.polyfit(f_bf/150, bf[j,:], 10)   # fitting a 10 degree polynomial in frequency to each LST of the beam factor
		bf_raw[j,:] = np.polyval(par_bf, f/150)


		# Applying beam correction
		if beam_correction == 'on':
			t_beam_corrected[j,:,:] = t[j,:,:] / bf_raw[j,:]

		elif beam_correction == 'off':
			t_beam_corrected[j,:,:] = t[j,:,:] / 1



		# Looping over days
		for i in range(len(t_beam_corrected[0,:,0])):

			# Only process data with Sun below "sun_el_max"
			if (m[j,i,6] <= sun_el_max):

				# Checking that the spectrum has enough data points
				if np.sum(w[j,i,:]) > 1000:

					# Removing channels with no data (zero values) and choosing frequency range
					frequency, temperature_with_cmb, weights = spectral_zero_removal(f, t_beam_corrected[j,i,:], w[j,i,:], flow, fhigh, weight = 0)

					# Removing CMB temperature and Extragalactic spectrum (Guzman et al. 2010)
					Tcmb = 2.725
					Tex  = (10**(7.66))  *  ( frequency**(-2.79) )    # extragalactic model
					temperature = temperature_with_cmb # - Tcmb - Tex




					# Parameter fitting
					if len(frequency) > 5:	

						# Actual fitting
						par_fit    = np.polyfit(np.log(frequency/150), np.log(temperature), npar-1)
						print('LST: ' + str(j) + ' of 72: Day ' + str(i) + ' of ' + str(len(t[0,:,0])))

						if npar == 2:
							beta[j,i]  = -par_fit[0]
							T0[j,i]    =  np.exp(par_fit[1])						

						elif npar == 3:
							gamma[j,i] = -par_fit[0]
							beta[j,i]  = -par_fit[1]
							T0[j,i]    =  np.exp(par_fit[2])


						# Computing RMS
						log_model = np.polyval(par_fit, np.log(frequency/150))
						model     = np.exp(log_model)
						RMS[j,i]  = np.sqrt(np.sum((temperature-model)**2)/len(model)) 



						# Storing spectral residuals
						log_model_wz     = np.polyval(par_fit, np.log(f/150))
						model_wz         = np.exp(log_model_wz)                # model with data where the actual data array has zeros
						Tex_all_freq     = (10**(7.66))  *  ( f**(-2.79) )     # extragalactic model 
						residuals[j,i,:] = t_beam_corrected[j,i,:] - model_wz  # (t_beam_corrected[j,i,:] - Tcmb - Tex_all_freq) - model_wz
						residuals[j,i,t_beam_corrected[j,i,:] == 0] = 0





	# Filter based on RMS metric
	for i in range(len(RMS[:,0])):
		rms_array     = RMS[i,RMS[i,:]>0]
		if len(rms_array) > 2:
			RMS_median[i] = np.median(rms_array)

	for j in range(len(RMS[:,0])):
		for i in range(len(RMS[0,:])):
			if RMS[j,i] > RMS_median_threshold * RMS_median[j]:
				gamma[j,i] = 0
				beta[j,i]  = 0
				T0[j,i]    = 0
				RMS[j,i]   = 0






	# Reference LSTs
	LST = np.arange(1/6,24,1/3)


	# Time-averages and scatters	
	T0_LST_wz         = np.zeros((len(LST),3))
	T0_LST_wz[:,0]    = LST

	beta_LST_wz       = np.zeros((len(LST),3))
	beta_LST_wz[:,0]  = LST

	gamma_LST_wz      = np.zeros((len(LST),3))
	gamma_LST_wz[:,0] = LST

	RMS_LST_wz        = np.zeros((len(LST),3))
	RMS_LST_wz[:,0]   = LST


	# Looping over LST
	for i in range(len(LST)):
		T0_LST_array    = T0[i,RMS[i,:]>0]		
		beta_LST_array  = beta[i,RMS[i,:]>0]		
		gamma_LST_array = gamma[i,RMS[i,:]>0]
		RMS_LST_array   = RMS[i,RMS[i,:]>0]

		# Computing mean and standard deviation at each LST if there is more than 1 point
		if len(T0_LST_array) > 1:

			T0_LST_wz[i,1]    = np.mean(T0_LST_array)
			T0_LST_wz[i,2]    = np.std(T0_LST_array)

			beta_LST_wz[i,1]  = np.mean(beta_LST_array)
			beta_LST_wz[i,2]  = np.std(beta_LST_array)

			gamma_LST_wz[i,1] = np.mean(gamma_LST_array)
			gamma_LST_wz[i,2] = np.std(gamma_LST_array)			

			RMS_LST_wz[i,1]   = np.mean(RMS_LST_array)
			RMS_LST_wz[i,2]   = np.std(RMS_LST_array)

	# Removing zeros
	T0_LST    = T0_LST_wz[np.abs(T0_LST_wz[:,1]) > 0, :]
	beta_LST  = beta_LST_wz[np.abs(beta_LST_wz[:,1]) > 0, :]
	gamma_LST = gamma_LST_wz[np.abs(gamma_LST_wz[:,1]) > 0, :]
	RMS_LST   = RMS_LST_wz[np.abs(RMS_LST_wz[:,1]) > 0, :]







	# Saving data
	if save_data=='yes':

		path_save = home_folder + '/DATA/EDGES/spectral_index/' + band + '/'
		name_save = 'spectral_index_' + band + '_' + case_data + '_' + case_beam_factor + '_npar_' + str(npar) + '_flim_' + str(flow) + '_' + str(fhigh) + '_sun_el_max_' + str(sun_el_max) + '_RMS_median_' + str(RMS_median_threshold) + save_flag
		save_file = path_save + 'data/' + name_save

		with h5py.File(save_file + '.hdf5', 'w') as hf:
			hf.create_dataset('meta',        data = m)
			hf.create_dataset('LST',         data = LST)
			hf.create_dataset('T0',          data = T0)
			hf.create_dataset('beta',        data = beta)
			hf.create_dataset('gamma',       data = gamma)
			hf.create_dataset('RMS',         data = RMS)
			hf.create_dataset('T0_LST',      data = T0_LST)
			hf.create_dataset('beta_LST',    data = beta_LST)
			hf.create_dataset('gamma_LST',   data = gamma_LST)
			hf.create_dataset('RMS_LST',     data = RMS_LST)
			hf.create_dataset('residuals',   data = residuals)
			hf.create_dataset('freq_binned', data = f)




	# Summary plot

	plt.close()
	plt.close()

	size_x = 29
	size_y = 20

	if beam_correction == 'on':
		T0_low = 200; T0_high = 900
		b_low = 2.48; b_high = 2.66
		g_low = -0.2; g_high = 0.2
		r_low = 0;    r_high = 1

	if beam_correction == 'off':
		T0_low = 200; T0_high = 900
		b_low = 2.35; b_high = 2.75
		g_low = -0.6; g_high = 0.6
		r_low = 0;    r_high = 3.5 	


	f1 = plt.figure(num=1, figsize=(size_x, size_y))

	plt.subplot2grid((3,4), (0,0))
	im = plt.imshow(T0.T, interpolation='none', aspect='auto', extent=[0,24,len(T0[0,:]),0])
	im.set_clim([T0_low, T0_high])
	#cbar = plt.colorbar() #(ticks=np.arange(-10,11,5))
	#ax = cbar.ax
	#ax.text(-0.1,1.05,'[K]',size=12)	
	#plt.xlabel('LST [Hr]')
	plt.ylabel('day number', fontsize=16)
	plt.title(r'$T_{150}$', fontsize=16)
	plt.xticks(np.arange(0,25,4))

	plt.subplot2grid((3,4), (0,1))
	im = plt.imshow(beta.T, interpolation='none', aspect='auto', extent=[0,24,len(T0[0,:]),0])
	im.set_clim([b_low, b_high])
	#cbar = plt.colorbar() #(ticks=np.arange(-10,11,5))
	#ax = cbar.ax
	#ax.text(-0.1,1.05,'[K]',size=12)	
	#plt.xlabel('LST [Hr]')
	#plt.ylabel('day number')
	plt.title(r'$\beta$', fontsize=22)	
	plt.xticks(np.arange(0,25,4))

	plt.subplot2grid((3,4), (0,2))
	im = plt.imshow(gamma.T, interpolation='none', aspect='auto', extent=[0,24,len(T0[0,:]),0])
	im.set_clim([g_low, g_high])
	#cbar = plt.colorbar() #(ticks=np.arange(-10,11,5))
	#ax = cbar.ax
	#ax.text(-0.1,1.05,'[K]',size=12)	
	#plt.xlabel('LST [Hr]')
	#plt.ylabel('day number')
	plt.title(r'$\gamma$', fontsize=22)
	plt.xticks(np.arange(0,25,4))

	plt.subplot2grid((3,4), (0,3))
	im = plt.imshow(RMS.T, interpolation='none', aspect='auto', extent=[0,24,len(T0[0,:]),0])
	im.set_clim([r_low, r_high])
	#cbar = plt.colorbar() #(ticks=np.arange(-10,11,5))
	#ax = cbar.ax
	#ax.text(-0.1,1.05,'[K]',size=12)	
	#plt.xlabel('LST [Hr]')
	#plt.ylabel('day number')
	plt.title('RMS', fontsize=16)
	plt.xticks(np.arange(0,25,4))








	LST = np.arange(1/6,24,1/3)

	plt.subplot2grid((3,4), (1,0))
	plt.errorbar(T0_LST[:,0], T0_LST[:,1], T0_LST[:,2], fmt='.')
	plt.xlim([0,24])
	plt.ylim([T0_low, T0_high])
	plt.grid()
	plt.xlabel('LST [Hr]', fontsize=16)
	plt.ylabel(r'$T_{150}$ [K]', fontsize=16)
	plt.xticks(np.arange(0,25,4))

	plt.subplot2grid((3,4), (1,1))
	plt.errorbar(beta_LST[:,0], beta_LST[:,1], beta_LST[:,2], fmt='.')
	plt.xlim([0,24])
	plt.ylim([b_low, b_high])
	plt.grid()
	plt.xlabel('LST [Hr]', fontsize=16)
	plt.ylabel(r'$\beta$', fontsize=22)
	plt.xticks(np.arange(0,25,4))

	plt.subplot2grid((3,4), (1,2))
	plt.errorbar(gamma_LST[:,0], gamma_LST[:,1], gamma_LST[:,2], fmt='.')
	plt.xlim([0,24])
	plt.ylim([g_low, g_high])
	plt.grid()
	plt.xlabel('LST [Hr]', fontsize=16)
	plt.ylabel(r'$\gamma$', fontsize=22)
	plt.xticks(np.arange(0,25,4))

	plt.subplot2grid((3,4), (1,3))
	plt.errorbar(RMS_LST[:,0], RMS_LST[:,1], RMS_LST[:,2], fmt='.')
	plt.xlim([0,24])
	plt.ylim([r_low, r_high])
	plt.grid()
	plt.xlabel('LST [Hr]', fontsize=16)
	plt.ylabel('RMS [K]', fontsize=16)
	plt.xticks(np.arange(0,25,4))






	path_plot_save = path_save + 'plots/'
	plt.savefig(path_plot_save + name_save + '.png', bbox_inches='tight')
	plt.close()
	plt.close()


	return 1





















def spectral_index_test(band, case_data, case_beam_factor, save_flag='', beam_correction='on', npar=3,  flow=110, fhigh=190, sun_el_max=-10, RMS_median_threshold=1.1):

	# Loading data
	path_data           = home_folder + '/DATA/EDGES/spectra/level4/' + band + '/'
	path_simulated_data = home_folder + '/DATA/EDGES/beam_convolution/sky_convolved_beam/' + band + '/' 
	path_beam_factor    = home_folder + '/DATA/EDGES/beam_convolution/beam_factors/'	








	# Calibrated data
	if case_data == 'a01':
		filename_data = 'high_band_v1_fourpoint_s11day_157_recv_temp_not_corrected.hdf5'

	#if case_data == 'a02':
	#	filename_data = 'high_band_v1_fourpoint_s11day_157_recv_temp_corrected_half_temperature_difference.hdf5'

	if case_data == 'a03':
		filename_data = 'high_band_v1_fourpoint_s11day_157_recv_temp_full_correction.hdf5'	





	if case_data == 'b01':
		filename_data = 'high_band_v1_blade_s11day_262_recv_temp_not_corrected.hdf5'

	#if case_data == 'b02':
	#	filename_data = 'high_band_v1_blade_s11day_262_recv_temp_corrected_half_temperature_difference.hdf5'		

	if case_data == 'b03':
		filename_data = 'high_band_v1_blade_s11day_262_recv_temp_full_correction.hdf5'








	# Data simulated using GSM
	if case_data == 'r01':
		f             = np.arange(100,201,1)
		filename_data = 'high_band_gsm_fourpoint_infinite_flow_100_fhigh_200_fstep_1.txt'



	if case_data == 's01':
		f             = np.arange(100,201,1)
		filename_data = 'high_band_gsm_blade_infinite_flow_100_fhigh_200_fstep_1.txt'

	if case_data == 's02':
		f             = np.arange(100,201,1)
		filename_data = 'high_band_gsm_blade_plus_shaped_finite_flow_100_fhigh_200_fstep_1.txt'	








	# Beam factor	
	if case_beam_factor == 'x01':
		f_bf = np.arange(80,201,5)
		filename_beam_factor = 'beam_factor_high_band_fourpoint_band10deg_indices_2.5_2.5_data.txt'

	if case_beam_factor == 'x02':
		f_bf = np.arange(80,201,5)
		filename_beam_factor = 'beam_factor_high_band_fourpoint_band10deg_indices_2.5_2.57_data.txt'




	if case_beam_factor == 'y01':
		f_bf = np.arange(100,201,1)
		filename_beam_factor = 'beam_factor_high_band_blade_band10deg_indices_2.5_2.5_data.txt'

	if case_beam_factor == 'y02':
		f_bf = np.arange(100,201,1)
		filename_beam_factor = 'beam_factor_high_band_blade_band10deg_indices_2.5_2.57_data.txt'










	# Loading calibrated data and beam factor
	Tcmb = 2.725

	# 24 hours of night time data
	if case_data == 'a00':
		f, t, m, w = spectral_index_LST_night_time_data('blade')

	# Simulated data, GSM convolved with beam models
	elif (case_data == 'r01') or (case_data == 's01') or (case_data == 's02'):
		tt = np.genfromtxt(path_simulated_data + filename_data)
		t  = np.reshape(tt[:,1::] + Tcmb, (72,1,-1))
		m  = -90*np.ones((72, 1, len(f)))
		w  = 1e3*np.ones((72, 1, len(f)))

	# Regular data
	else:
		f, t, m, w = level4read(path_data + filename_data)

	# Beam factor
	bf = np.genfromtxt(path_beam_factor + filename_beam_factor)









	# Initialization of arrays 
	bf_raw           = np.zeros((72,len(f)))
	t_beam_corrected = np.zeros((len(t[:,0,0]),len(t[0,:,0]),len(t[0,0,:])))

	T0         = np.zeros((len(t[:,0,0]), len(t[0,:,0])))
	beta       = np.zeros((len(t[:,0,0]), len(t[0,:,0])))
	gamma      = np.zeros((len(t[:,0,0]), len(t[0,:,0])))

	RMS        = np.zeros((len(t[:,0,0]),len(t[0,:,0])))
	RMS_median = np.zeros(72)

	gamma_mean = np.zeros(72)
	beta_mean  = np.zeros(72)
	T0_mean    = np.zeros(72)
	RMS_mean   = np.zeros(72)

	gamma_std  = np.zeros(72)
	beta_std   = np.zeros(72)
	T0_std     = np.zeros(72)
	RMS_std    = np.zeros(72)

	residuals  = np.zeros((len(t[:,0,0]), len(t[0,:,0]), len(f)))







	# Looping over LST
	for j in range(len(bf[:,0])):




		# Interpolating beam factor to spectra frequency
		par_bf      = np.polyfit(f_bf/150, bf[j,:], 10)   # fitting a 10 degree polynomial in frequency to each LST of the beam factor
		bf_raw[j,:] = np.polyval(par_bf, f/150)


		# Applying beam correction
		if beam_correction == 'on':
			t_beam_corrected[j,:,:] = t[j,:,:] / bf_raw[j,:]

		elif beam_correction == 'off':
			t_beam_corrected[j,:,:] = t[j,:,:] / 1



		# Looping over days
		for i in range(len(t_beam_corrected[0,:,0])):

			if (m[j,i,6] <= sun_el_max):

				# Checking that the spectrum has enough data points
				if np.sum(w[j,i,:]) > 1000:

					# Removing channels with no data (zero values) and choosing frequency range
					frequency, temperature_with_cmb, weights = spectral_zero_removal(f, t_beam_corrected[j,i,:], w[j,i,:], flow, fhigh, weight = 0)

					# Removing CMB temperature
					temperature = temperature_with_cmb - Tcmb


					# Parameter fitting
					if len(frequency) > 5:	
						par_fit    = np.polyfit(np.log(frequency/150), np.log(temperature), npar-1)

						print('LST: ' + str(j) + ' of 72: Day ' + str(i) + ' of ' + str(len(t[0,:,0])))

						if npar == 2:
							beta[j,i]  = -par_fit[0]
							T0[j,i]    =  np.exp(par_fit[1])						

						elif npar == 3:
							gamma[j,i] = -par_fit[0]
							beta[j,i]  = -par_fit[1]
							T0[j,i]    =  np.exp(par_fit[2])


						# Computing RMS
						log_model  = np.polyval(par_fit, np.log(frequency/150))
						model      = np.exp(log_model)
						RMS[j,i]   = np.sqrt(np.sum((temperature-model)**2)/len(model)) 


						# Storing spectral residuals
						log_model_wz     = np.polyval(par_fit, np.log(f/150))
						model_wz         = np.exp(log_model_wz)
						residuals[j,i,:] = (t_beam_corrected[j,i,:]-Tcmb) - model_wz
						residuals[j,i, t_beam_corrected[j,i,:] == 0] = 0



	## Reference LSTs
	#LST = np.arange(1/6,24,1/3)


	## Complete arrays
	#T0_LST    = np.array([LST, T0]).T
	#beta_LST  = np.array([LST, beta]).T
	#gamma_LST = np.array([LST, gamma]).T
	#RMS_LST   = np.array([LST, RMS]).T




	return T0, beta, gamma, RMS, residuals #, t, f, t_beam_corrected





















def spectral_index_read(path_file):

	# path_file = /home/raul/DATA/EDGES/spectral_index/high_band/spectral_index_high_band_a01_x01_......hdf5

	# Show keys (array names inside HDF5 file)
	with h5py.File(path_file,'r') as hf:
		print([key for key in hf.keys()])	

		hf_LST     = hf.get('LST')
		LST        = np.array(hf_LST)

		hf_meta    = hf.get('meta')
		meta       = np.array(hf_meta)			

		hf_T0      = hf.get('T0')
		T0         = np.array(hf_T0)

		hf_beta    = hf.get('beta')
		beta       = np.array(hf_beta)

		hf_gamma   = hf.get('gamma')
		gamma      = np.array(hf_gamma)

		hf_RMS     = hf.get('RMS')
		RMS        = np.array(hf_RMS)	


		hf_T0      = hf.get('T0_LST')
		T0_LST     = np.array(hf_T0)

		hf_beta    = hf.get('beta_LST')
		beta_LST   = np.array(hf_beta)

		hf_gamma   = hf.get('gamma_LST')
		gamma_LST  = np.array(hf_gamma)

		hf_RMS     = hf.get('RMS_LST')
		RMS_LST    = np.array(hf_RMS)

		hf_resid   = hf.get('residuals')
		residuals  = np.array(hf_resid)

		hf_fb      = hf.get('freq_binned')
		fb         = np.array(hf_fb)



	return LST, meta, T0, beta, gamma, RMS, T0_LST, beta_LST, gamma_LST, RMS_LST, residuals, fb









def emcee_prior(a, b):
	"""
	Multivariate prior on two fit parameters, a and b
	"""

	a0 = 0
	b0 = 0
	sigma_a0 = 1
	sigma_b0 = 1

	P = np.exp( -(1/2)* ( ((a-a0)/sigma_a0)**2 + ((b-b0)/sigma_b0)**2 ) )

	return P









def calibration_dataset(band, filename):

	# Loading data
	path_par_ant_s11 = home_folder + '/WORK/EDGES/receiver_calibration/calibration_march_2015/antenna/models/parameters/'
	path_par_LNA_s11 = home_folder + '/WORK/EDGES/receiver_calibration/calibration_march_2015/LNA/models/25degC/s11/'


	f = np.arange(90, 191, 1)



	# Fiducial parameters
	par = np.genfromtxt(path_par_ant_s11 + 'par_antenna_s11_high_band_2015_157_12terms_polynomial.txt')
	par_s11_ant_re  = par[:,0]
	par_s11_ant_im  = par[:,1]	

	par_s11_LNA_mag = np.genfromtxt(path_par_LNA_s11 + 'par_s11_LNA_mag.txt')
	par_s11_LNA_ang = np.genfromtxt(path_par_LNA_s11 + 'par_s11_LNA_ang.txt')



	path_calibration_high_band = home_folder + '/WORK/EDGES/receiver_calibration/calibration_march_2015/LNA/calibration_files/'
	calibration_file_25        = path_calibration_high_band + 'calibration_file_high_band_v1_20151006.txt'
	cal                        = np.genfromtxt(calibration_file_25)	
	fr = cal[:,0]
	C1 = cal[:,3]
	C2 = cal[:,4]
	TU = cal[:,5]
	TC = cal[:,6]
	TS = cal[:,7]


	pC1 = fit_polynomial_fourier('polynomial', (fr-140)/60, C1, 7)
	pC2 = fit_polynomial_fourier('polynomial', (fr-140)/60, C2, 7)
	pTU = fit_polynomial_fourier('polynomial', (fr-140)/60, TU, 7)
	pTC = fit_polynomial_fourier('polynomial', (fr-140)/60, TC, 7)
	pTS = fit_polynomial_fourier('polynomial', (fr-140)/60, TS, 7)


	par_C1 = pC1[0]
	par_C2 = pC2[0]
	par_TU = pTU[0]
	par_TC = pTC[0]
	par_TS = pTS[0]








	# Covariance matrices
	# --------------------------------------------------


	# Evaluating fiducial quantities	
	s11_ant_re  = model_evaluate('polynomial',    par_s11_ant_re,     (f-140)/60)
	s11_ant_im  = model_evaluate('polynomial',    par_s11_ant_im,     (f-140)/60)	

	s11_LNA_mag = model_evaluate('fourier',       par_s11_LNA_mag,    (f-140)/60)
	s11_LNA_ang = model_evaluate('fourier',       par_s11_LNA_ang,    (f-140)/60)




	# Computation settings
	n_MC = 5000
	s11_mag_std     = np.abs(10**(-15/20) - 10**(-15.01/20))
	s11_ang_std     = 0.015 * (np.pi/180) # radians
	scatter_s11_mag = np.random.normal(0, s11_mag_std, size=n_MC)
	scatter_s11_ang = np.random.normal(0, s11_ang_std, size=n_MC)



	# Initializing arrays
	par_s11_ant_re_MC  = np.zeros((n_MC, len(par_s11_ant_re)))
	par_s11_ant_im_MC  = np.zeros((n_MC, len(par_s11_ant_im)))

	par_s11_LNA_mag_MC = np.zeros((n_MC, len(par_s11_LNA_mag)))
	par_s11_LNA_ang_MC = np.zeros((n_MC, len(par_s11_LNA_ang)))	



	res_s11_ant_re_MC  = np.zeros((n_MC, len(f)))
	res_s11_ant_im_MC  = np.zeros((n_MC, len(f)))

	res_s11_LNA_mag_MC = np.zeros((n_MC, len(f)))
	res_s11_LNA_ang_MC = np.zeros((n_MC, len(f)))








	# Fitting parameters for many realizations due to measurement errors

	s11_ant_mag = np.sqrt((s11_ant_re**2) + (s11_ant_im**2))
	s11_ant_ang = np.arctan2(s11_ant_im, s11_ant_re)	

	for i in range(n_MC):

		print(i)


		# S11 of antenna

		temp_mag = s11_ant_mag + (scatter_s11_mag[i])
		temp_ang = s11_ant_ang + (scatter_s11_ang[i]/s11_ant_mag)

		temp_re  = temp_mag*np.cos(temp_ang)
		temp_im  = temp_mag*np.sin(temp_ang)

		par_re   = fit_polynomial_fourier('polynomial', (f-140)/60, temp_re, len(par_s11_ant_re))
		par_im   = fit_polynomial_fourier('polynomial', (f-140)/60, temp_im, len(par_s11_ant_im))

		model_re = model_evaluate('polynomial', par_re[0], (f-140)/60)		
		model_im = model_evaluate('polynomial', par_im[0], (f-140)/60)

		par_s11_ant_re_MC[i,:] = par_re[0]
		par_s11_ant_im_MC[i,:] = par_im[0]

		res_s11_ant_re_MC[i,:] = temp_re - model_re		
		res_s11_ant_im_MC[i,:] = temp_im - model_im




		# S11 of LNA 
		temp_mag = s11_LNA_mag + (scatter_s11_mag[i])
		temp_ang = s11_LNA_ang + (scatter_s11_ang[i]/s11_LNA_mag)

		par_mag  = fit_polynomial_fourier('fourier', (f-140)/60, temp_mag, len(par_s11_LNA_mag))
		par_ang  = fit_polynomial_fourier('fourier', (f-140)/60, temp_ang, len(par_s11_LNA_ang))

		model_mag = model_evaluate('fourier', par_mag[0], (f-140)/60)
		model_ang = model_evaluate('fourier', par_ang[0], (f-140)/60)

		par_s11_LNA_mag_MC[i,:] = par_mag[0]
		par_s11_LNA_ang_MC[i,:] = par_ang[0]

		res_s11_LNA_mag_MC[i,:] = temp_mag - model_mag
		res_s11_LNA_ang_MC[i,:] = temp_ang - model_ang



	# Covariance matrices
	covmat_s11_ant_re  = np.cov(par_s11_ant_re_MC.T)
	covmat_s11_ant_im  = np.cov(par_s11_ant_im_MC.T)

	covmat_s11_LNA_mag = np.cov(par_s11_LNA_mag_MC.T)
	covmat_s11_LNA_ang = np.cov(par_s11_LNA_ang_MC.T)	






	# Check of scatter in reflection coefficients due to parameter covariance matrix
	par_ant_re_MC = np.random.multivariate_normal(par_s11_ant_re, covmat_s11_ant_re, n_MC)
	par_ant_im_MC = np.random.multivariate_normal(par_s11_ant_im, covmat_s11_ant_im, n_MC)

	par_LNA_mag_MC = np.random.multivariate_normal(par_s11_LNA_mag, covmat_s11_LNA_mag, n_MC)
	par_LNA_ang_MC = np.random.multivariate_normal(par_s11_LNA_ang, covmat_s11_LNA_ang, n_MC)	

	model_s11_ant_re_MC = np.zeros((n_MC, len(f)))
	model_s11_ant_im_MC = np.zeros((n_MC, len(f)))	

	model_s11_LNA_mag_MC = np.zeros((n_MC, len(f)))
	model_s11_LNA_ang_MC = np.zeros((n_MC, len(f)))

	for i in range(n_MC):
		model_s11_ant_re_MC[i,:] = model_evaluate('polynomial', par_s11_ant_re_MC[i,:], (f-140)/60)
		model_s11_ant_im_MC[i,:] = model_evaluate('polynomial', par_s11_ant_im_MC[i,:], (f-140)/60)		

		model_s11_LNA_mag_MC[i,:] = model_evaluate('fourier', par_s11_LNA_mag_MC[i,:], (f-140)/60)
		model_s11_LNA_ang_MC[i,:] = model_evaluate('fourier', par_s11_LNA_ang_MC[i,:], (f-140)/60)





	## Covariance matrices
	#covmat_s11_ant_re  = np.eye(len(par_s11_ant_re))
	#covmat_s11_ant_im  = np.eye(len(par_s11_ant_im))
	#covmat_s11_LNA_mag = np.eye(len(par_s11_LNA_mag))
	#covmat_s11_LNA_ang = np.eye(len(par_s11_LNA_ang))
	covmat_C1          = np.eye(len(par_C1))
	covmat_C2          = np.eye(len(par_C2))
	covmat_TU          = np.eye(len(par_TU))
	covmat_TC          = np.eye(len(par_TC))
	covmat_TS          = np.eye(len(par_TS))





	# Saving
	path_save = home_folder + '/DATA/EDGES/calibration_datasets/' + band + '/' + filename + '.hdf5'


	with h5py.File(path_save, 'w') as hf:
		hf.create_dataset('fiducial_gamma_antenna_real',        data = par_s11_ant_re)
		hf.create_dataset('fiducial_gamma_antenna_imag',        data = par_s11_ant_im)
		hf.create_dataset('fiducial_gamma_receiver_magnitude',  data = par_s11_LNA_mag)
		hf.create_dataset('fiducial_gamma_receiver_phase',      data = par_s11_LNA_ang)
		hf.create_dataset('fiducial_C1',                        data = par_C1)
		hf.create_dataset('fiducial_C2',                        data = par_C2)
		hf.create_dataset('fiducial_TU',                        data = par_TU)
		hf.create_dataset('fiducial_TC',                        data = par_TC)
		hf.create_dataset('fiducial_TS',                        data = par_TS)


		hf.create_dataset('covmat_gamma_antenna_real',        data = covmat_s11_ant_re)
		hf.create_dataset('covmat_gamma_antenna_imag',        data = covmat_s11_ant_im)
		hf.create_dataset('covmat_gamma_receiver_magnitude',  data = covmat_s11_LNA_mag)
		hf.create_dataset('covmat_gamma_receiver_phase',      data = covmat_s11_LNA_ang)
		hf.create_dataset('covmat_C1',                        data = covmat_C1)
		hf.create_dataset('covmat_C2',                        data = covmat_C2)
		hf.create_dataset('covmat_TU',                        data = covmat_TU)
		hf.create_dataset('covmat_TC',                        data = covmat_TC)
		hf.create_dataset('covmat_TS',                        data = covmat_TS)


	return covmat_s11_ant_re, covmat_s11_ant_im, covmat_s11_LNA_mag, covmat_s11_LNA_ang










def calibration_dataset_read(path_file):

	"""
	Example of path file:
	'/home/user/Desktop/calibration_file.hdf5'
	"""


	# Show keys (array names inside HDF5 file)
	with h5py.File(path_file,'r') as hf:
		print([key for key in hf.keys()])

		hf_fid_gamma_antenna_real = hf.get('fiducial_gamma_antenna_real')
		hf_fid_gamma_antenna_imag = hf.get('fiducial_gamma_antenna_imag')
		hf_fid_gamma_receiver_mag = hf.get('fiducial_gamma_receiver_magnitude')
		hf_fid_gamma_receiver_ang = hf.get('fiducial_gamma_receiver_phase')
		hf_fid_C1                 = hf.get('fiducial_C1')
		hf_fid_C2                 = hf.get('fiducial_C2')
		hf_fid_TU                 = hf.get('fiducial_TU')
		hf_fid_TC                 = hf.get('fiducial_TC')
		hf_fid_TS                 = hf.get('fiducial_TS')

		hf_cov_gamma_antenna_real = hf.get('covmat_gamma_antenna_real')
		hf_cov_gamma_antenna_imag = hf.get('covmat_gamma_antenna_imag')
		hf_cov_gamma_receiver_mag = hf.get('covmat_gamma_receiver_magnitude')
		hf_cov_gamma_receiver_ang = hf.get('covmat_gamma_receiver_phase')
		hf_cov_C1                 = hf.get('covmat_C1')
		hf_cov_C2                 = hf.get('covmat_C2')
		hf_cov_TU                 = hf.get('covmat_TU')
		hf_cov_TC                 = hf.get('covmat_TC')
		hf_cov_TS                 = hf.get('covmat_TS')		



		fid_gamma_antenna_real    = np.array(hf_fid_gamma_antenna_real)
		fid_gamma_antenna_imag    = np.array(hf_fid_gamma_antenna_imag)
		fid_gamma_receiver_mag    = np.array(hf_fid_gamma_receiver_mag)
		fid_gamma_receiver_ang    = np.array(hf_fid_gamma_receiver_ang)
		fid_C1                    = np.array(hf_fid_C1)
		fid_C2                    = np.array(hf_fid_C2)
		fid_TU                    = np.array(hf_fid_TU)
		fid_TC                    = np.array(hf_fid_TC)
		fid_TS                    = np.array(hf_fid_TS)

		cov_gamma_antenna_real    = np.array(hf_cov_gamma_antenna_real)
		cov_gamma_antenna_imag    = np.array(hf_cov_gamma_antenna_imag)
		cov_gamma_receiver_mag    = np.array(hf_cov_gamma_receiver_mag)
		cov_gamma_receiver_ang    = np.array(hf_cov_gamma_receiver_ang)
		cov_C1                    = np.array(hf_cov_C1)
		cov_C2                    = np.array(hf_cov_C2)
		cov_TU                    = np.array(hf_cov_TU)
		cov_TC                    = np.array(hf_cov_TC)
		cov_TS                    = np.array(hf_cov_TS)	


	fiducial            = [fid_gamma_antenna_real, fid_gamma_antenna_imag, fid_gamma_receiver_mag, fid_gamma_receiver_ang, fid_C1, fid_C2, fid_TU, fid_TC, fid_TS]
	covariance_matrices = [cov_gamma_antenna_real, cov_gamma_antenna_imag, cov_gamma_receiver_mag, cov_gamma_receiver_ang, cov_C1, cov_C2, cov_TU, cov_TC, cov_TS]


	return fiducial, covariance_matrices	
















def noise_averaging():


	# Loading data
	level3file = '/media/raul/DATA/EDGES/spectra/level3/low_band/low_band_v1.hdf5'
	f, ta_all, m_all, s_all, w_all = level3read(level3file)

	for i in np.arange(6,8,1):
		if i == 6:
			ta_LST = ta_all[i, m_all[i,:,6]<-10, :]
			w_LST  = w_all[i, m_all[i,:,6]<-10, :]

		elif i > 6:
			ta_LST = np.append(ta_LST, ta_all[i,m_all[i,:,6]<-10,:], axis=0)
			w_LST  = np.append(w_LST, w_all[i,m_all[i,:,6]<-10,:], axis=0)



	ff, tt, ww = spectral_binning_fixed_frequency(50, 100, 0.117, f, ta_LST[0,:], w_LST[0,:])
	tb = np.zeros((len(ta_LST[:,0]), len(ff)))
	wb = np.zeros((len(w_LST[:,0]),  len(ff)))

	for j in range(len(ta_LST[:,0])):
		fb, tb[j,:], wb[j,:] = spectral_binning_fixed_frequency(50, 100, 0.117, f, ta_LST[j,:], w_LST[j,:])	

	index = 257
	data_array = tb[np.abs(tb[:,index]-np.median(tb[:,index]))< 1, index]

	Nrep   = 200
	results1 = np.zeros((len(data_array)-3, Nrep))
	for j in range(len(data_array)-3):

		for i in range(Nrep):
			data_choice = np.random.choice(data_array, j+2)
			results1[j,i] = np.mean(data_choice)







	ff, tt, ww = spectral_binning_fixed_frequency(50, 100, 1, f, ta_LST[0,:], w_LST[0,:])
	tb = np.zeros((len(ta_LST[:,0]), len(ff)))
	wb = np.zeros((len(w_LST[:,0]),  len(ff)))

	for j in range(len(ta_LST[:,0])):
		fb, tb[j,:], wb[j,:] = spectral_binning_fixed_frequency(50, 100, 1, f, ta_LST[j,:], w_LST[j,:])	

	index = 30#257
	data_array = tb[np.abs(tb[:,index]-np.median(tb[:,index]))< 10, index]

	Nrep   = 200
	results2 = np.zeros((len(data_array)-3, Nrep))
	for j in range(len(data_array)-3):

		for i in range(Nrep):
			data_choice = np.random.choice(data_array, j+2)
			results2[j,i] = np.mean(data_choice)





	ss1 = np.std(results1, axis=1)
	ss2 = np.std(results2, axis=1)

	print(len(ss1))
	print(len(ss2))

	N  = np.arange(1/3,(1/3*100) + 1/3, 1/3)
	print(len(N))

	f1, ax = plt.subplots()
	h1, = plt.loglog(N,ss1[0:100], label='117 kHz BW')
	#h2,  = plt.loglog(N,ss2[0:100], label='500 kHz BW')

	plt.loglog(N,((ss1[N==10]/ss1[0])*np.sqrt(3*10))*ss1[0]/np.sqrt(3*N),'k')
	#plt.loglog(N,ss2[N==10]/np.sqrt(3*N),'k')
	ax.set_yticks([0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1, 2])

	plt.xlim([0,100/3])
	plt.ylim([0.01, 2])
	plt.grid()
	plt.ylabel(r'$\sigma_T$ [K]', fontsize=16)
	plt.xlabel('integration time [Hrs]')
	#plt.legend(handles=[h1, h2])
	plt.title('80 MHz, 117 kHz RBW')	

	#tb_av, wb_av = spectral_averaging(tb, wb)

	#par = np.polyfit(fb[tb_av>0], tb_av[tb_av>0], 13)
	#model = np.polyval(par, fb)

	return fb, tb, wb, data_array, results1, ss1













def data_analysis_level3_RFI_flagging(band, f, t, w, fstep  = 0.06, N_res_sigma = 1.5):

	# Processing parameters
	polyterms            = 11
	residuals_hard_limit = 4
	small_sample_size    = 10
	N_choice             = 2000





	# Binning the input data
	if band == 'high_band':
		fstart = 108 + (fstep/2)
		fstop  = 190 - (fstep/2)


	elif band == 'low_band':
		fstart = 50  + (fstep/2)
		fstop  = 100 - (fstep/2) 


	fb = np.arange(fstart, fstop+(fstep/2), fstep)
	tb = np.zeros((len(t[:,0]),len(fb)))
	wb = np.zeros((len(t[:,0]),len(fb)))

	for i in range(len(t[:,0])):	
		fb, tb[i,:], wb[i,:] = spectral_binning_fixed_frequency(fstart, fstop, fstep, f, t[i,:], w[i,:])




	# Computing models and residuals from the binned data
	residuals = np.zeros((len(tb[:,0]), len(tb[0,:])))
	for i in range(len(tb[:,0])):
		par   = np.polyfit(fb[tb[i,:]>0], tb[i, tb[i,:]>0], polyterms)
		model = np.polyval(par, fb)
		residuals[i,:] = tb[i,:] - model

	print('residuals computed')	


	# Flagging (setting to zero) large residuals

	# Loop over frequencies
	for j in range(len(tb[0,:])):
		res_array = residuals[np.abs(residuals[:,j]) < residuals_hard_limit, j]
		print('frequency: ' + str(j) + ' of ' + str(len(tb[0,:])))
		if len(res_array) > 0:

			# Computation of medians			
			flag = 0			
			for i in range(N_choice):
				res_choice = np.random.choice(res_array, small_sample_size)
				if flag == 0:
					res_choice_mean = np.mean(res_choice)
					res_choice_std  = np.std(res_choice)
					flag = 1

				elif flag == 1:
					res_choice_mean = np.append(res_choice_mean, np.mean(res_choice))
					res_choice_std  = np.append(res_choice_std, np.std(res_choice))

			res_mean = np.median(res_choice_mean)
			res_std  = np.median(res_choice_std)



			# Selection based on median
			print('----------------------------------------')
			print( str(j) + ' of ' + str(len(tb[0,:])) )
			flag = 0
			for i in range(len(tb[:,0])):
				if (np.abs(residuals[i,j]) >= (res_mean + N_res_sigma*res_std)):
					tb[i,j] = 0
					wb[i,j] = 0
					residuals[i,j] = 0


	# Loop over time 
	for j in range(len(residuals[:,0])):
		res_array = residuals[j, np.abs(residuals[j,:]) < residuals_hard_limit]
		print('time: ' + str(j) + ' of ' + str(len(residuals[:,0])))
		if len(res_array) > 0:

			# Computation of medians			
			flag = 0			
			for i in range(N_choice):
				res_choice = np.random.choice(res_array, small_sample_size)
				if flag == 0:
					res_choice_mean = np.mean(res_choice)
					res_choice_std  = np.std(res_choice)
					flag = 1

				elif flag == 1:
					res_choice_mean = np.append(res_choice_mean, np.mean(res_choice))
					res_choice_std  = np.append(res_choice_std, np.std(res_choice))

			res_mean = np.median(res_choice_mean)
			res_std  = np.median(res_choice_std)



			# Selection based on median
			print('----------------------------------------')
			print( str(j) + ' of ' + str(len(residuals[:,0])) )
			flag = 0
			for i in range(len(residuals[0,:])):
				if (np.abs(residuals[j,i]) >= (res_mean + N_res_sigma*res_std)):
					tb[j,i] = 0
					wb[j,i] = 0
					residuals[j,i] = 0



	return fb, tb, wb, residuals














def data_analysis_level3_RFI_flagging2(fb, tb, wb, N_sigma = 3):

	# 
	polyterms = 11

	lr  = len(tb[:,0])
	lrx = int(lr/4)


	# Averaging data into four averages
	avtb1, avwb1 = spectral_averaging(tb[(0*lrx):(1*lrx),:], wb[(0*lrx):(1*lrx), :])
	avtb2, avwb2 = spectral_averaging(tb[(1*lrx):(2*lrx),:], wb[(1*lrx):(2*lrx), :])
	avtb3, avwb3 = spectral_averaging(tb[(2*lrx):(3*lrx),:], wb[(2*lrx):(3*lrx), :])
	avtb4, avwb4 = spectral_averaging(tb[(3*lrx):lr,:],      wb[(3*lrx):lr,  :])

	# Modeling averages
	par1 = np.polyfit(fb[avtb1>0], avtb1[avtb1>0], polyterms)
	par2 = np.polyfit(fb[avtb2>0], avtb2[avtb2>0], polyterms)
	par3 = np.polyfit(fb[avtb3>0], avtb3[avtb3>0], polyterms)
	par4 = np.polyfit(fb[avtb4>0], avtb4[avtb4>0], polyterms)

	model1 = np.polyval(par1, fb)
	model2 = np.polyval(par2, fb)
	model3 = np.polyval(par3, fb)
	model4 = np.polyval(par4, fb)

	# Residuals from averages
	res1 = avtb1 - model1
	res2 = avtb2 - model2
	res3 = avtb3 - model3
	res4 = avtb4 - model4



	# Removing RFI from averages
	avtb1[np.abs(res1) > N_sigma*np.median(np.abs(res1))] = 0
	avtb2[np.abs(res2) > N_sigma*np.median(np.abs(res2))] = 0
	avtb3[np.abs(res3) > N_sigma*np.median(np.abs(res3))] = 0
	avtb4[np.abs(res4) > N_sigma*np.median(np.abs(res4))] = 0

	avwb1[np.abs(res1) > N_sigma*np.median(np.abs(res1))] = 0
	avwb2[np.abs(res2) > N_sigma*np.median(np.abs(res2))] = 0
	avwb3[np.abs(res3) > N_sigma*np.median(np.abs(res3))] = 0	
	avwb4[np.abs(res4) > N_sigma*np.median(np.abs(res4))] = 0

	# Computing residuals from cleaned averages
	par1x = np.polyfit(fb[avtb1>0], avtb1[avtb1>0], polyterms)
	par2x = np.polyfit(fb[avtb2>0], avtb2[avtb2>0], polyterms)
	par3x = np.polyfit(fb[avtb3>0], avtb3[avtb3>0], polyterms)
	par4x = np.polyfit(fb[avtb4>0], avtb4[avtb4>0], polyterms)

	model1x = np.polyval(par1x, fb)
	model2x = np.polyval(par2x, fb)
	model3x = np.polyval(par3x, fb)
	model4x = np.polyval(par4x, fb)

	res1x = avtb1 - model1x
	res2x = avtb2 - model2x
	res3x = avtb3 - model3x
	res4x = avtb4 - model4x


	# Computing average from four subsets
	avtb, avwb = spectral_averaging(np.array([avtb1, avtb2, avtb3, avtb4]), np.array([avwb1, avwb2, avwb3, avwb4]))

	# Modeling total average
	par   = np.polyfit(fb[avtb>0], avtb[avtb>0], polyterms)
	model = np.polyval(par, fb)

	# Residuals from average
	res   = avtb - model

	##avr[np.abs(avr) > N_res_sigma_average*np.median(np.abs(avr))] = 0
	#avtb[np.abs(resx) > N_res_sigma_average*np.median(np.abs(resx))] = 0
	#avwb[np.abs(resx) > N_res_sigma_average*np.median(np.abs(resx))] = 0


	return fb, avtb, avwb, avtb1, avtb2, avtb3, avtb4, avwb1, avwb2, avwb3, avwb4


















def data_analysis_level3_temperature_scatter_selection(fb, tb, wb, N_choice=1000, small_sample_size=5, N_sigma=3):



	# Computing the temperature scatter
	tp = np.zeros(len(tb[:,0]))
	for i in range(len(tp)):

		par   = np.polyfit(fb[tb[i,:]>0], tb[i,tb[i,:]>0], 3)
		model = np.polyval(par, fb)

		tp[i] = model[0]  #np.sum(tb[i,tb[i,:]>0]*wb[i,tb[i,:]>0])





	# Computation of medians			
	flag = 0			
	for i in range(N_choice):
		choice = np.random.choice(tp, small_sample_size)
		if flag == 0:
			choice_mean = np.mean(choice)
			choice_std  = np.std(choice)
			flag = 1

		elif flag == 1:
			choice_mean = np.append(choice_mean, np.mean(choice))
			choice_std  = np.append(choice_std,  np.std(choice))

	best_mean = np.median(choice_mean)
	best_std  = np.median(choice_std)

	print(best_mean)
	print(best_std)



	# Selection based on medians
	index_in  = np.arange(len(tp))
	index_out = index_in[np.abs(tp - best_mean) <= (N_sigma*best_std)]


	return index_out, tp











def GSM_properties(freq_array):

	# Loading data	
	gsm_file = home_folder + '/DATA/EDGES/beam_convolution/gsm/data_hdf5/gsm_dataset.hdf5'		
	lon, lat, RA, DEC, freq_gsm, gsm = GSM_HDF5_read(gsm_file, print_keys='no')


	# Selecting data in frequency range
	index = np.arange(len(freq_gsm))
	sky_all = gsm[:,index[freq_gsm==np.min(freq_array)]:(index[freq_gsm==np.max(freq_array)]+1)]


	# Initializing arrays
	par_all = np.zeros((len(lon), 3))
	res_all = np.zeros((len(lon), len(freq_array)))


	# Looping over pixels
	for j in range(len(lon)):

		print(' Percentage of progress: ' + str(round(100*j/len(lon),2)) + '%')

		par       = np.polyfit(np.log(freq_array/150), np.log(sky_all[j,:]), 2)
		log_model = np.polyval(par, np.log(freq_array/150))
		model     = np.exp(log_model) 
		par_all[j,:] = par
		res_all[j,:] = sky_all[j,:] - model


	# Saving results
	path_save = home_folder + '/DATA/EDGES/beam_convolution/gsm/model_results/'
	save_file = path_save + 'model_results.hdf5'

	with h5py.File(save_file, 'w') as hf:
		hf.create_dataset('parameters',    data = par_all)
		hf.create_dataset('residuals',     data = res_all)
		hf.create_dataset('galactic_lon',  data = lon)
		hf.create_dataset('galactic_lat',  data = lat)
		hf.create_dataset('celestial_RA',  data = RA)
		hf.create_dataset('celestial_DEC', data = DEC)
		hf.create_dataset('frequency',     data = freq_array)	

	return 1










def GSM_properties_read(path_file, print_keys='no'):

	with h5py.File(path_file,'r') as hf:

		if print_keys == 'yes':
			print([key for key in hf.keys()])

		hf_freq    = hf.get('frequency')
		freq       = np.array(hf_freq)

		hf_lon      = hf.get('galactic_lon')
		lon         = np.array(hf_lon)

		hf_lat      = hf.get('galactic_lat')
		lat         = np.array(hf_lat)

		hf_RA       = hf.get('celestial_RA')
		RA          = np.array(hf_RA)

		hf_DEC      = hf.get('celestial_DEC')
		DEC         = np.array(hf_DEC)		

		hf_par      = hf.get('parameters')
		par         = np.array(hf_par)	

		hf_res      = hf.get('residuals')
		res         = np.array(hf_res)		


	return lon, lat, RA, DEC, freq, par, res
















def GSM_to_HDF5():

	path_data = home_folder + '/DATA/EDGES/beam_convolution/'

	# Galactic coordinates (the GSM is in Galactic Coordinates, RING FORMAT !!!)
	coord              = fits.open(path_data + 'coordinate_maps/pixel_coords_map_ring_galactic_res9.fits')
	coord_array        = coord[1].data
	lon                = coord_array['LONGITUDE']
	lat                = coord_array['LATITUDE']

	# Celestial coordinates (RING FORMAT !!!)
	coord              = fits.open(path_data + 'coordinate_maps/pixel_coords_map_ring_celestial_res9.fits')
	coord_array        = coord[1].data
	RA                 = coord_array['LONGITUDE']
	DEC                = coord_array['LATITUDE']	



	freq_array = np.arange(40, 201, 1)
	data_all = np.zeros(( len(lon), len(freq_array) ))


	# Looping over frequency
	for j in range(len(freq_array)):


		# Loading sky data from Global Sky Model
		freq_iter = freq_array[j]
		FREQ = str(freq_iter)
		print(FREQ)

		if len(FREQ) == 2:
			FREQ = '0' + FREQ
		sky = np.genfromtxt(path_data + 'gsm/data/sky_' + FREQ + '.dat')

		data_all[:,j] = sky

	# Save
	path_save = home_folder + '/DATA/EDGES/beam_convolution/gsm/data_hdf5/'
	save_file = path_save + 'GSM_dataset.hdf5'

	with h5py.File(save_file, 'w') as hf:
		hf.create_dataset('GSM_dataset',   data = data_all)
		hf.create_dataset('galactic_lon',  data = lon)
		hf.create_dataset('galactic_lat',  data = lat)
		hf.create_dataset('celestial_RA',  data = RA)
		hf.create_dataset('celestial_DEC', data = DEC)
		hf.create_dataset('frequency',     data = freq_array)

	return 1		









def GSM_HDF5_read(path_file, print_keys='no'):
	"""
	This function also work with GSM2016 hdf5 files

	"""

	with h5py.File(path_file,'r') as hf:

		if print_keys == 'yes':
			print([key for key in hf.keys()])

		hf_freq    = hf.get('frequency')
		freq       = np.array(hf_freq)

		hf_lon      = hf.get('galactic_lon')
		lon         = np.array(hf_lon)

		hf_lat      = hf.get('galactic_lat')
		lat         = np.array(hf_lat)

		hf_RA       = hf.get('celestial_RA')
		RA          = np.array(hf_RA)

		hf_DEC      = hf.get('celestial_DEC')
		DEC         = np.array(hf_DEC)		

		hf_gsm      = hf.get('GSM_dataset')
		gsm         = np.array(hf_gsm)		


	return lon, lat, RA, DEC, freq, gsm












def GSM2016_produce_maps():

	freq = np.arange(40, 201, 1)

	for i in range(len(freq)):
		freq_str    = str(freq[i])
		freq_str_zp = freq_str.zfill(3)
		freq_GHz    = str(freq[i]/1000)
		print(freq_str_zp)
		system("python " + home_folder + "/DATA/EDGES/beam_convolution/gsm2016-master/create_map_python3.py -f " + freq_GHz + " -r 0 -u TRJ -o '" + home_folder + "/DATA/EDGES/beam_convolution/gsm2016-master/output/gsm2016_" + freq_str_zp + "_MHz.npz'")

	return 0







def GSM2016_to_HDF5():

	path_data = home_folder + '/DATA/EDGES/beam_convolution/'

	# Galactic coordinates (the GSM2016 was produced in Galactic Coordinates, NEST FORMAT !!!)
	coord              = fits.open(path_data + 'coordinate_maps/pixel_coords_map_nested_galactic_res6.fits')
	coord_array        = coord[1].data
	lon                = coord_array['LONGITUDE']
	lat                = coord_array['LATITUDE']

	# Celestial coordinates (NEST FORMAT !!!)
	coord              = fits.open(path_data + 'coordinate_maps/pixel_coords_map_nested_celestial_res6.fits')
	coord_array        = coord[1].data
	RA                 = coord_array['LONGITUDE']
	DEC                = coord_array['LATITUDE']	



	freq_array = np.arange(40, 201, 1)
	data_all = np.zeros(( len(lon), len(freq_array) ))


	# Looping over frequency
	for j in range(len(freq_array)):


		# Loading sky data from Global Sky Model
		freq_iter = freq_array[j]
		FREQ = str(freq_iter)
		print(FREQ)

		if len(FREQ) == 2:
			FREQ = '0' + FREQ
		sky = np.load(path_data + 'gsm2016-master/output/gsm2016_' + FREQ + '_MHz.npz')

		data_all[:,j] = sky['arr_0']

	# Save
	path_save = home_folder + '/DATA/EDGES/beam_convolution/gsm2016-master/data_hdf5/'
	save_file = path_save + 'GSM2016_dataset_40_200_MHz.hdf5'

	with h5py.File(save_file, 'w') as hf:
		hf.create_dataset('GSM_dataset',   data = data_all)
		hf.create_dataset('galactic_lon',  data = lon)
		hf.create_dataset('galactic_lat',  data = lat)
		hf.create_dataset('celestial_RA',  data = RA)
		hf.create_dataset('celestial_DEC', data = DEC)
		hf.create_dataset('frequency',     data = freq_array)

	return 1

































def model_rejection(f, data, weights, test_model='yes', model_type='tanh', T21_tanh=0.027, T21_gauss=-0.1, zr=8, dz=1, anastasia_model_number=0, jordan_model_number=0, fit_type='EDGES_polynomial', flow = 90, fhigh = 190, nterm_fg=5, binning='yes', rfi_removal='yes'):

	# Assume model in the data or not
	if test_model == 'yes':

		# Choosing model type		
		if model_type == 'tanh':
			tanh_EoR, xHI, z = model_eor(f, T21=T21_tanh, zr=zr, dz=dz) # in Kelvin 
			delta_data       = (data - tanh_EoR)
			model_EoR        = tanh_EoR

		if model_type == 'gaussian':
			gauss_EoR, xHI, z = model_eor(f, T21=T21_gauss, model_type='gaussian', zr=zr, dz=dz) # in Kelvin 
			delta_data        = (data - gauss_EoR)
			model_EoR         = gauss_EoR

		elif model_type == 'anastasia':
			anas_EoR   = model_eor_anastasia(anastasia_model_number, f, interpolation_kind='linear')  # in Kelvin  # 'linear'
			delta_data = (data - anas_EoR)
			model_EoR  = anas_EoR

		elif model_type == 'jordan':
			jord_EoR   = model_eor_jordan(jordan_model_number, f, interpolation_kind='linear')  # in Kelvin
			delta_data = (data - jord_EoR)
			model_EoR  = jord_EoR


	elif test_model == 'no':
		delta_data = data
		model_EoR  = np.zeros(len(f))


	# Selecting data in the chosen range	
	fx   = f[(f>=flow) & (f<=fhigh)]
	dx   = delta_data[(f>=flow) & (f<=fhigh)]	
	wx   = weights[(f>=flow) & (f<=fhigh)]
	ex   = model_EoR[(f>=flow) & (f<=fhigh)]


	# Fit model to data
	pp   = fit_polynomial_fourier(fit_type, fx/150, dx, nterm_fg, Weights=wx)
	mx   = model_evaluate(fit_type, pp[0], fx/150)
	rx   = dx - mx


	# Binning residuals
	if binning == 'yes':
		fb, rx, wx = spectral_binning_number_of_samples(fx, rx, wx, nsamples=64)
		fx, ex, kk = spectral_binning_number_of_samples(fx, ex, np.ones(len(fx)), nsamples=64)


	# Removing RFI or 'strange' peaks
	if rfi_removal == 'yes':
		rx, wx = RFI_cleaning_std(fx, rx, wx, n_sigma = 2.5, df_MHz = 20, npar = 4)


	# Computing WEIGHTED residuals RMS
	RMS = np.sqrt(  np.sum(wx*rx**2) / np.sum(wx)  )


	return fx, rx, wx, ex, RMS













def antenna_beam_factor_new_way(band, beam_case, flow, fhigh, fstep, filename):
	"""
	Last modification: March 27, 2015.

	flow:  100  (number, not string)
	fhigh: 200  (number, not string)
	fstep:   1  (number, not string)
	band: 'high_band', 'low_band'
	beam_case: 'cosine square', 'fourpoint_infinite', 'blade_infinite'
	freq_array: np.arange(110,191,1)
	"""	


	# Data paths
	path_root = home_folder + '/DATA/EDGES/'	
	path_data = path_root + 'beam_convolution/'
	path_save = path_data + 'beam_factors/'





	# Frequency vector
	freq_array = np.arange(flow, fhigh+fstep, fstep)





	# Beam selection
	if beam_case == 'fourpoint_infinite':
		beam = FEKO_high_band_fourpoint_beam(frequency_interpolation='yes', frequency=freq_array)

	elif beam_case == 'blade_infinite':
		beam = CST_high_band_blade_beam(frequency_interpolation='yes', frequency=freq_array)

	elif beam_case == 'blade_plus_shaped_finite':
		beam = FEKO_high_band_blade_beam_plus_shaped_finite_ground_plane(frequency_interpolation='yes', frequency=freq_array)





	# Beam coordinates
	AZ_beam             = np.arange(0,360)
	EL_beam             = np.arange(0, 91)
	AZ_beam_array       = np.tile(AZ_beam,91)
	EL_beam_array       = np.repeat(EL_beam,360)
	AZ_EL_beam_original = np.array([AZ_beam_array, EL_beam_array]).T





	# Loading galactic coordinates (the Haslam map is in Galactic Coordinates, NESTED FORMAT !!!)
	coord              = fits.open(path_data + 'coordinate_maps/pixel_coords_map_nested_galactic_res9.fits')
	coord_array        = coord[1].data
	lon                = coord_array['LONGITUDE']
	lat                = coord_array['LATITUDE']
	GALAC_COORD_object = apc.SkyCoord(lon, lat, frame='galactic', unit='deg')  # defaults to ICRS frame





	# Loading Haslam map
	haslam_map = fits.open(path_data + 'haslam_map/lambda_haslam408_dsds.fits')
	haslam     = (haslam_map[1].data)['temperature']

	# Temperature of the CMB
	Tcmb       = 2.725

	# Removing CMB from Haslam map
	haslam_no_CMB = haslam - Tcmb




	# EDGES location	
	EDGES_lat_deg  = -26.714778
	EDGES_lon_deg  = 116.605528 
	EDGES_location = apc.EarthLocation(lat=EDGES_lat_deg*apu.deg, lon=EDGES_lon_deg*apu.deg)




	# Initializing quantities
	lat_low  = np.arange(-90, 81, 10)
	lat_high = np.arange(-80, 91, 10)

	raul_beam_factor = np.zeros((len(lat_low), 72, len(freq_array)))
	LST              = np.zeros(72)




	# Reference observation time. At this time, the LST is 0.1666 (00:10 Hrs LST) at the EDGES location
	Time_iter    = np.array([2014, 1, 1, 9, 39, 42])     
	Time_iter_dt = dt.datetime(Time_iter[0], Time_iter[1], Time_iter[2], Time_iter[3], Time_iter[4], Time_iter[5]) 		






	# Looping over LST 
	for i in range(72):




		# Advancing time ( 19:57 minutes UTC correspond to 20 minutes LST )
		minutes_offset = 19
		seconds_offset = 57
		if i > 0:
			Time_iter_dt = Time_iter_dt + dt.timedelta(minutes = minutes_offset, seconds = seconds_offset)
			Time_iter    = np.array([Time_iter_dt.year, Time_iter_dt.month, Time_iter_dt.day, Time_iter_dt.hour, Time_iter_dt.minute, Time_iter_dt.second]) 



		# LST 
		LST[i] = utc2lst(Time_iter, EDGES_lon_deg)				




		# Local coordinates corresponding to galactic coordinates
		altaz = GALAC_COORD_object.transform_to(apc.AltAz(location=EDGES_location, obstime=apt.Time(Time_iter_dt, format='datetime')))
		AZ    = np.asarray(altaz.az)
		EL    = np.asarray(altaz.alt)




		# Selecting coordinates and sky data above the horizon
		AZ_above_horizon    = AZ[EL>=0]
		EL_above_horizon    = EL[EL>=0]
		AZ_EL_above_horizon = np.array([AZ_above_horizon, EL_above_horizon]).T





		# Looping over frequency
		for j in range(len(freq_array)):


			# Evaluating beam at local coordinates above horizon
			if (beam_case == 'fourpoint_infinite') or (beam_case == 'blade_infinite') or (beam_case == 'blade_plus_shaped_finite'):
				beam_original      = beam[j,:,:].reshape(1,-1)[0]
				beam_above_horizon = spi.griddata(AZ_EL_beam_original, beam_original, AZ_EL_above_horizon, method='cubic')  # interpolated beam

			elif beam_case == 'cosine_square':
				beam_above_horizon = np.cos((np.pi/180)*(90-EL_above_horizon))**2




			# Looping over sky region
			for k in range(len(lat_low)):


				print('')
				print('------------------------------------------------------------------------------------------')
				print('LST: ' + str(i+1) + ' of 72. Region: ' + str(k+1) + ' of 18. Frequency: ' + str(freq_array[j]) + ' MHz. ')
				print('------------------------------------------------------------------------------------------')				



				AZ_region    = AZ[ (EL >= 0) & (lat >= lat_low[k]) & (lat < lat_high[k]) ]
				EL_region    = EL[ (EL >= 0) & (lat >= lat_low[k]) & (lat < lat_high[k]) ]
				sky_region   = haslam_no_CMB[ (EL >= 0) & (lat >= lat_low[k]) & (lat < lat_high[k]) ]
				AZ_EL_region = np.array([AZ_region, EL_region]).T





				# Evaluating beam at local coordinates above horizon
				if (beam_case == 'fourpoint_infinite') or (beam_case == 'blade_infinite') or (beam_case == 'blade_plus_shaped_finite'):
					beam_original      = beam[j,:,:].reshape(1,-1)[0]
					beam_region        = spi.griddata(AZ_EL_beam_original, beam_original, AZ_EL_region,        method='cubic')  # interpolated beam

				elif beam_case == 'cosine_square':			
					beam_region        = np.cos((np.pi/180)*(90-EL_region))**2



				# Index without nans
				no_nan_array_above_horizon = np.ones(len(AZ_above_horizon)) - np.isnan(beam_above_horizon)
				index_no_nan_above_horizon = np.nonzero(no_nan_array_above_horizon)[0]

				no_nan_array_region = np.ones(len(AZ_region)) - np.isnan(beam_region)
				index_no_nan_region = np.nonzero(no_nan_array_region)[0]		



				# Convolution between beam and Haslam map at 408 MHz
				if (len(index_no_nan_region) > 0) and (len(index_no_nan_above_horizon) > 0):

					Numerator   = np.sum(sky_region[index_no_nan_region]*beam_region[index_no_nan_region])
					Denominator = np.sum(beam_above_horizon[index_no_nan_above_horizon])

				else:
					Numerator   = 0
					Denominator = 0


				# Raul beam factor
				if (np.abs(Numerator) > 0) and (np.abs(Denominator) > 0): 
					raul_beam_factor[k, i, j] = Numerator/Denominator
				else:
					raul_beam_factor[k, i, j] = 0



	# Save
	save_file = path_save + filename + '.hdf5'


	with h5py.File(save_file, 'w') as hf:
		hf.create_dataset('LST',         data = LST)
		hf.create_dataset('frequency',   data = freq_array)
		hf.create_dataset('beam_factor', data = raul_beam_factor)


	return LST, freq_array, raul_beam_factor












def raul_beam_factor_read(path_file, print_keys = 'no'):

	with h5py.File(path_file,'r') as hf:

		if print_keys == 'yes':
			print([key for key in hf.keys()])

		hf_LST           = hf.get('LST')
		LST              = np.array(hf_LST)	

		hf_freq          = hf.get('frequency')
		freq             = np.array(hf_freq)

		hf_bf            = hf.get('beam_factor')
		raul_beam_factor = np.array(hf_bf)


	return LST, freq, raul_beam_factor













def raul_beam_factor_combine():

	path_data = home_folder + '/DATA/EDGES/beam_convolution/beam_factors/'

	# Fourpoint
	LST, fp_f1, fp_bf1 = raul_beam_factor_read(path_data + 'raul_beam_factor_fourpoint_infinite_18_regions_100-133_MHz.hdf5')
	LST, fp_f2, fp_bf2 = raul_beam_factor_read(path_data + 'raul_beam_factor_fourpoint_infinite_18_regions_134-166_MHz.hdf5')
	LST, fp_f3, fp_bf3 = raul_beam_factor_read(path_data + 'raul_beam_factor_fourpoint_infinite_18_regions_167-200_MHz.hdf5')


	# Blade
	LST, bl_f1, bl_bf1 = raul_beam_factor_read(path_data + 'raul_beam_factor_blade_infinite_18_regions_100-133_MHz.hdf5')
	LST, bl_f2, bl_bf2 = raul_beam_factor_read(path_data + 'raul_beam_factor_blade_infinite_18_regions_134-166_MHz.hdf5')
	LST, bl_f3, bl_bf3 = raul_beam_factor_read(path_data + 'raul_beam_factor_blade_infinite_18_regions_167-200_MHz.hdf5')	


	# Combining data
	fp_f12  = np.append(fp_f1,   fp_f2)
	fp_f    = np.append(fp_f12,  fp_f3)
	fp_bf12 = np.append(fp_bf1,  fp_bf2, axis=2)
	fp_bf   = np.append(fp_bf12, fp_bf3, axis=2)

	bl_f12  = np.append(bl_f1,   bl_f2)
	bl_f    = np.append(bl_f12,  bl_f3)
	bl_bf12 = np.append(bl_bf1,  bl_bf2, axis=2)
	bl_bf   = np.append(bl_bf12, bl_bf3, axis=2)


	# Saving data
	path_file1 = path_data + 'raul_beam_factor_fourpoint_infinite_18_regions.hdf5'
	path_file2 = path_data + 'raul_beam_factor_blade_infinite_18_regions.hdf5'


	with h5py.File(path_file1, 'w') as hf:
		hf.create_dataset('LST',         data=LST)
		hf.create_dataset('frequency',   data=fp_f)
		hf.create_dataset('beam_factor', data=fp_bf)


	with h5py.File(path_file2, 'w') as hf:
		hf.create_dataset('LST',         data=LST)
		hf.create_dataset('frequency',   data=fp_f)
		hf.create_dataset('beam_factor', data=bl_bf)	


	return 1






def spectral_index_lnlike(theta, v, region_constants, data, sigma_noise):

	# Evaluating model
	model = spectral_index_model(theta, v, region_constants)

	# Log-likelihood
	log_likelihood = -(1/2)  *  np.sum(  ((data-model)/sigma_noise)**2  )


	return log_likelihood






def spectral_index_model(theta, v, region_constants):

	## Evaluating model
	#model = 0
	#n_par_sets = int(len(theta)/2)
	#for i in range(n_par_sets):

		## Parameters
		#beta  = theta[i*n_par_sets + 0]
		#gamma = theta[i*n_par_sets + 1]

		## Model
		#model = model     +     (  (v/408) ** (beta + gamma*np.log(v/408))  ) * region_constants[i,:]   # 


	# Evaluating model
	model = 0
	n_par_sets = int(len(theta))
	for i in range(n_par_sets):

		# Parameters
		beta  = theta[i]

		# Model
		model = model     +     (  (v/408) ** beta  ) * region_constants[i,:]   # 


	return model











def spectral_index_model_18regions(theta, v, region_constants):


	model_LST = np.zeros((72, len(v)))

	for j in range(72):

		# Evaluating model
		model = 0
		#n_par_sets = int(len(theta)/2)
		#for i in range(n_par_sets):
		for i in range(len(theta)):

			# Parameters
			beta  = theta[i]
			gamma = 0 #theta[i + n_par_sets]

			# Model
			model = model     +     (  (v/408) ** (beta + gamma*np.log(v/408))  ) * region_constants[i,j,:]

		model_LST[j,:] = model 



	return model_LST











def spectral_index_error_function_18regions(theta, v, data, region_constants, error_format='1D'):

	model = spectral_index_model_18regions(theta, v, region_constants)
	error_2D = ((data - model).T/data[:,0]).T
	error_1D = np.concatenate(error_2D)

	if error_format == '1D':
		error = error_1D
	elif error_format == '2D':
		error = error_2D

	return error






def spectral_index_new_way_MCMC():

	path_data = home_folder + '/DATA/EDGES/spectra/level4/high_band/high_band_v1_fourpoint_s11day_157_recv_temp_full_correction.hdf5'

	v, t, m, w = level4read(path_data)


	path_beam_factor = home_folder + '/DATA/EDGES/beam_convolution/beam_factors/raul_beam_factor_fourpoint_infinite_18_regions.hdf5'
	LST, fbf, rbf = raul_beam_factor_read(path_beam_factor)



	## Separating the sky into two regions, high and low latitudes	
	#index_ll = np.array([8,9])
	#index_hl = np.array([0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17])


	#beam_factor_ll_sum = np.sum(rbf[index_ll,:,:], axis=0)
	#beam_factor_hl_sum = np.sum(rbf[index_hl,:,:], axis=0)



	#pp     = np.polyfit(fbf, beam_factor_ll_sum[50,:], 10)
	#bfm_ll = np.polyval(pp, v)


	#pp     = np.polyfit(fbf, beam_factor_hl_sum[50,:], 10)
	#bfm_hl = np.polyval(pp, v)


	#bfm = np.array([bfm_ll, bfm_hl])



	# Assuming a single spectral index for the beam-covered sky
	beam_factor_sum = np.sum(rbf, axis=0)
	pp  = np.polyfit(fbf, beam_factor_sum[50,:], 10)
	bfm = np.polyval(pp, v)




	Tcmb   = 2.725
	data   = t[50,10,:] - Tcmb  # 10 ~ 3.5 LST, day 100
	weight = w[50,10,:]



	# Noise estimation
	qq              = np.polyfit(v[weight>0], data[weight>0], 10)
	model_for_noise = np.polyval(qq, v)
	noise           = np.abs(data - model_for_noise)/1



	# MCMC
	ndim, nwalkers = 2, 100
	p0 = [(-2.1, -0.1) + np.random.rand(ndim) for i in range(nwalkers)]
	sampler = ec.EnsembleSampler(nwalkers, ndim, spectral_index_lnlike, args=(v[weight>0], bfm[weight>0].reshape(1,-1), data[weight>0], noise[weight>0]), threads=12)
	sampler.run_mcmc(p0, 10000)
	samples = sampler.chain[:, 50:, :].reshape((-1, ndim))
	#plt.plot(samples[:,0], samples[:,1],'.')

	best_fit_beta  = np.percentile(samples[:,0], 50, axis=0)
	best_fit_gamma = np.percentile(samples[:,1], 50, axis=0)	




	return samples















def data_analysis_low_band_MCMC_log_likelihood(theta, v, d, sigma_noise, model_fg='EDGES_polynomial', Nfg=4, vn=80, model_21cm='gaussian_frequency', N21=5, sine_cosine='no', tau0=7, tilt=0, a21_eor=0.028):


	# Evaluating model foregrounds
	if Nfg == 0:
		Tfg = 0
		log_priors_fg = 0

	elif Nfg > 0:
		Tfg = model_evaluate(model_fg, theta[0:Nfg], v/vn)
		log_priors_fg = data_analysis_low_band_MCMC_priors_foreground(theta[0:Nfg])







	# Evaluating model EoR
	if (model_21cm == 'gaussian_frequency') and len(theta) == (Nfg + 3):
		Tcosmo, x1, x2 = model_eor(v, T21=theta[Nfg], fr=theta[Nfg+1], df=theta[Nfg+2], model_type=model_21cm)
		log_priors_21 = data_analysis_low_band_MCMC_priors_gaussian_frequency(theta[Nfg::])




	elif ((model_21cm == 'gaussian_flattened_1') or (model_21cm == 'gaussian_flattened_2')) and len(theta) >= (Nfg + 3):
		if N21 > 3:
			tau0=theta[Nfg+3]
			if N21 > 4:
				tilt=theta[Nfg+4]

		Tcosmo = model_eor_flattened_gaussian(v, model_type=int(model_21cm[-1]), T21=theta[Nfg], vr=theta[Nfg+1], dv=theta[Nfg+2], tau0=tau0, tilt=tilt)
		
		if sine_cosine == 'no':
			log_priors_21 = data_analysis_low_band_MCMC_priors_gaussian_flattened(theta[Nfg::])
			
		elif sine_cosine == 'yes':
			log_priors_21 = data_analysis_low_band_MCMC_priors_gaussian_flattened(theta[Nfg:-2])
			





	elif (model_21cm == 'tanh_EoR') and (N21 <= 3):
		if N21 == 2:
			Tcosmo, x1, x2 = model_eor(v, T21=a21_eor, model_type='tanh', zr=theta[Nfg], dz=theta[Nfg+1])
		elif N21 == 3:
			Tcosmo, x1, x2 = model_eor(v, T21=theta[Nfg], model_type='tanh', zr=theta[Nfg+1], dz=theta[Nfg+2])
		log_priors_21 = data_analysis_low_band_MCMC_priors_tanh_EoR(theta[Nfg::])



	else:	
		Tcosmo = 0
		log_priors_21 = 0






	# Evaluating Sine and Cosine  (currently only works with flattened gaussians, not tanh)
	if sine_cosine == 'yes':
		Tsc = theta[-2]*np.sin(v/vn)  +  theta[-1]*np.cos(v/vn)
		log_priors_sc = data_analysis_low_band_MCMC_priors_sine_cosine(theta[-2::])
		
	elif sine_cosine == 'no':
		Tsc = 0
		log_priors_sc = 0
		
	







	# Full model
	Tfull = Tfg + Tcosmo + Tsc

	# Log-likelihood
	log_likelihood =  -(1/2)  *  np.sum(  ((d-Tfull)/sigma_noise)**2  )

	return log_priors_21 + log_priors_fg + log_likelihood + log_priors_sc


















def data_analysis_low_band_MCMC_priors_foreground(theta):

	# a0, a1, a2, a3 = theta
	len_theta = len(theta)

	# Counting the parameters with allowable values
	flag = 0
	for i in range(len_theta):
		if (-1e5 <= theta[i] <= 1e5):
			flag = flag + 1

	# Assign likelihood
	if flag == len_theta:
		out = 0
	else:
		out = -1e10

	return out





def data_analysis_low_band_MCMC_priors_gaussian_frequency(theta):

	T21, vr, dv = theta

	if (-0.3 < T21 <= -0.03) and (70 < vr < 90) and (5 < dv < 35):
		return 0

	return -1e10





def data_analysis_low_band_MCMC_priors_gaussian_flattened(theta, tau0=7, tilt=0):

	#T21, vr, dv, tau0, tilt = theta
	if len(theta) == 3:
		T21, vr, dv = theta
	elif len(theta) == 4:
		T21, vr, dv, tau0 = theta

	elif len(theta) == 5:
		T21, vr, dv, tau0, tilt = theta 			


	if (-2 <= T21 <= 2) and (51 < vr < 99) and (1 < dv < 50) and (0 < tau0 < 60) and (-1 < tilt < 1):
	#if (-2 <= T21 <= 2) and (70 < vr < 85) and (15 < dv < 25) and (0 < tau0 < 15) and (-1 < tilt < 1):		
		return 0

	return -1e10





def data_analysis_low_band_MCMC_priors_tanh_EoR(theta):

	if len(theta) == 2:
		zr, dz = theta
		if (11.4 < zr < 15.7) and (0 < dz < 1.49):
			return 0	

	if len(theta) == 3:
		T21, zr, dz = theta
		if (0 < T21 <= 0.3) and (11.4 < zr < 15.7) and (0 < dz < 1.49):
			return 0

	return -1e10





def data_analysis_low_band_MCMC_priors_sine_cosine(theta):
	
	As, Ac = theta
	if (-100 < As <= 100) and (-100 < Ac < 100):
		return 0
	
	return -1e10















def OLD_data_analysis_MCMC_parameter_estimation(case, model_fg='EDGES_polynomial', Nfg=4, model_21cm='gaussian_frequency', vn=80):

	# Simulated data	
	if case == 'sim1':
		v = np.arange(60, 100.2, 0.3906)

		par = [3000, -0.1, 0.1, 2, -0.1, 78, 22]
		dfg = model_evaluate('EDGES_polynomial', par[0:4], v/vn)
		d21, x1, x2 = model_eor(v, T21=par[Nfg], fr=par[Nfg+1], df=par[Nfg+2], model_type='gaussian_frequency')
		d_no_noise = dfg + d21
		sigma_noise = d_no_noise/np.sqrt(390600 * 60 * 60 * 48)
		noise = np.random.normal(0, sigma_noise)	
		d = d_no_noise + noise

		w = np.ones(len(v))


	if case == 'sim2':
		v = np.arange(60, 100.2, 0.3906)

		par = [3000, -0.1, 0.1, 2, -0.5, 78, 22, 7]
		dfg = model_evaluate('EDGES_polynomial', par[0:4], v/vn)
		d21, x1, x2 = model_eor(v, model_type='gaussian_flattened_1', T21=par[4], fr=par[5], df=par[6], tau0=par[7])
		d_no_noise = dfg + d21
		sigma_noise = d_no_noise/np.sqrt(390600 * 60 * 60 * 30)
		noise = np.random.normal(0, sigma_noise)	
		d = d_no_noise + noise

		w = np.ones(len(v))




	# Real data
	if case == 'real1':
		vr, tr, wr, d, at, ah, rc, rm  = level3_read(home_folder + '/DATA/EDGES/spectra/level3/low_band_2015/low_band_2015_LST_23.76_11.76_ID2_20170409.hdf5')

		# Used to model noise
		#avt1, avw1 = spectral_averaging(tr[0:60,:], wr[0:60,:])
		#avt2, avw2 = spectral_averaging(tr[60::,:], wr[60::,:])
		# 200 -> 20 mK at raw resolution
		#y = -3.6*f + 380


		# Linear model for noise AT RAW RESOLUTION !!!!
		#sigma      = -3.6*vr + 380
		avt, avw   = spectral_averaging(tr, wr)

		#fb, rb, wb, rms, rms_110 = data_analysis_residuals_array(fx, tx.reshape(1,-1), wx.reshape(1,-1), flow=flow, fhigh=fhigh, model_type=model_type, fnorm=fnorm, nfg=nfg, binning='yes', nsamples=64, rfi_flagging=post_rfi_flagging)
		#vb, tb, wb = data_analysis_spectrum_high_to_low_resolution(vr, avt, avw, flow=49, fhigh=101, fnorm=75, nfg=11, pre_rfi_flagging='yes', post_rfi_flagging='yes')

		vb, tb, wb = data_analysis_spectrum_high_to_low_resolution(vr, avt, avw, flow=49, fhigh=101, fnorm=75, nfg=5, pre_rfi_flagging='yes', post_rfi_flagging='yes')

		v = vb[vb >= 60]
		d = tb[vb >= 60]
		w = wb[vb >= 60]
		sigma_noise = (-0.5*v + 60)/1000  # in K



	# MCMC
	N21      = 3  # 3 or 4
	Ndim     = Nfg + N21
	Nwalkers = 2*Ndim + 2
	Nchain   = 100000
	Nthreads = 6

	p0 = (np.random.uniform(size=Ndim*Nwalkers).reshape((Nwalkers, Ndim)) - 0.5)/5
	#p0 = np.zeros((Nwalkers, Ndim))

	p0[:,0] = p0[:,0] + 1430 #np.mean(d[w>0])
	p0[:,4] = p0[:,4] - 0.25
	p0[:,5] = p0[:,5] + 78
	p0[:,6] = p0[:,6] + 20

	if N21 > 3:
		p0[:,7] = p0[:,7] + 4

	sampler = ec.EnsembleSampler(Nwalkers, Ndim, data_analysis_MCMC_log_likelihood, args=(v[w>0], d[w>0], sigma_noise[w>0]), kwargs={'model_fg':model_fg, 'Nfg':Nfg, 'model_21cm':model_21cm, 'vn':vn}, threads=Nthreads)
	sampler.run_mcmc(p0, Nchain)
	samples = sampler.chain[:, (np.int(0.8*Nchain)):, :].reshape((-1, Ndim))
	fig = corner.corner(samples, labels=["$a_0$", "$a_1$", "$a_2$", "$a_3$", '$A$', r'$\nu_r$', 'FWHM'], bins=50)  # truths=par, , r'$\tau$'




	# 68% and 95% ranges
	#print(  np.percentile(samples[:,4], [50-(68/2), 50, 50+(68/2)], axis=0)  )
	print(  np.percentile(samples[:,4], [50-(95/2), 50, 50+(95/2)], axis=0)  )

	#print(  np.percentile(samples[:,5], [50-(68/2), 50, 50+(68/2)], axis=0)  )
	print(  np.percentile(samples[:,5], [50-(95/2), 50, 50+(95/2)], axis=0)  )

	#print(  np.percentile(samples[:,6], [50-(68/2), 50, 50+(68/2)], axis=0)  )
	print(  np.percentile(samples[:,6], [50-(95/2), 50, 50+(95/2)], axis=0)  )

	#print(  np.percentile(samples[:,7], [50-(68/2), 50, 50+(68/2)], axis=0)  )
	if N21 > 3:
		print(  np.percentile(samples[:,7], [50-(95/2), 50, 50+(95/2)], axis=0)  )	


	return samples, v, d, w, sigma_noise




























def data_analysis_MCMC_dz_log_likelihood(theta, v, d, sigma_noise, model_fg='EDGES_polynomial', Nfg=5, model_21cm='tanh', vn=140):

	# Initial assumption for priors
	log_priors = 0

	# Evaluating foreground model
	if Nfg == 0:
		Tfg = 0
	elif Nfg > 0:
		Tfg = model_evaluate(model_fg, theta[0:Nfg], v/vn)


	# Evaluating EoR model
	if (model_21cm == 'tanh') and len(theta) == (Nfg + 1):
		T21, x1, x2 = model_eor(v, T21=0.028, zr=8.5, dz=theta[Nfg], model_type=model_21cm)
		log_priors = data_analysis_MCMC_dz_priors(theta[Nfg])
	else:	
		T21 = 0

	# Full model
	Tfull = Tfg + T21

	# Log-likelihood
	log_likelihood = -(1/2)  *  np.sum(  ((d-Tfull)/sigma_noise)**2  )

	return log_priors + log_likelihood






def data_analysis_MCMC_dz_priors(dz):
	if (0 < dz <= 2):
		return 0
	return -1e10








def data_analysis_MCMC_dz(data, model_fg='EDGES_polynomial', Nfg=4, model_21cm='tanh', vn=150):


	# Simulated data
	if data == 'sim':		
		v = np.arange(135, 165.2, 0.3906)

		tfg = model_evaluate('EDGES_polynomial', [1000, -0.1, 0.4, 4], v/vn)
		t21, x1, x2 = model_eor(v, T21=0.028, zr=8.5, dz=0.05, model_type='tanh')
		t_no_noise = tfg + t21
		sigma_noise = t_no_noise/np.sqrt(390600 * 60 * 60 * 1)
		noise = np.random.normal(0, sigma_noise)
		t = t_no_noise + noise

		w = np.ones(len(v))


	# Real
	if data == 'real':
		vr, tr, wr, d, at, ah, rc, rm  = level3_read(home_folder + '/DATA/EDGES/spectra/level3/high_band_2015/results_paper_1/high_band_2015_LST_0.26_6.26_dates_2015_250_299_nominal.hdf5')
		avt, avw                    = spectral_averaging(tr, wr)
		vb, tb, wb                  = data_analysis_spectrum_high_to_low_resolution(vr, avt, avw, pre_rfi_flagging='yes', post_rfi_flagging='yes')

		v = vb[(vb>=144) & (vb<=164)]
		t = tb[(vb>=144) & (vb<=164)]
		w = wb[(vb>=144) & (vb<=164)]


		p = fit_polynomial_fourier(model_fg, v[w>0], t[w>0], Nfg, Weights=w[w>0])
		noise_std = np.std(t[w>0]-p[1])
		sigma_noise = noise_std * np.ones(len(v))
		print(noise_std)
		print(len(w[w>0]))


	# MCMC
	N21      = 1
	Ndim     = Nfg + N21
	Nwalkers = 2*Ndim+2
	Nchain   = 10000
	Nthreads = 4

	p0 = (np.random.uniform(size=Ndim*Nwalkers).reshape((Nwalkers, Ndim)) - 0.5)/5  # +/- 0.1
	#p0 = np.zeros((Nwalkers, Ndim))

	p0[:,0]  = p0[:,0] + np.mean(t[w>0])    # T0
	p0[:,-1] = p0[:,-1] + 0.05  # dz

	sampler = ec.EnsembleSampler(Nwalkers, Ndim, data_analysis_MCMC_dz_log_likelihood, args=(v[w>0], t[w>0], sigma_noise[w>0]), kwargs={'model_fg':model_fg, 'Nfg':Nfg, 'model_21cm':model_21cm, 'vn':vn}, threads=Nthreads)
	sampler.run_mcmc(p0, Nchain)
	samples = sampler.chain[:, (np.int(0.8*Nchain)):, :].reshape((-1, Ndim))

	fig = corner.corner(samples, bins=50, labels=["$a_0$", "$a_1$", "$a_2$", r'$\Delta z$'])     # truths=par, labels=["$a_0$", "$a_1$", r'$\Delta z$']


	print(  np.percentile(samples[:,-1], [50-(68/2), 50, 50+(68/2)], axis=0)  )
	print(  np.percentile(samples[:,-1], [50-(95/2), 50, 50+(95/2)], axis=0)  )

	return samples #, p0, v, d21, sigma_noise

















def spectral_index_new_way_old_one_region(antenna_type):

	if antenna_type == 'fourpoint':
		data_file = 'high_band_v1_fourpoint_s11day_157_recv_temp_full_correction.hdf5'
		bf_file   = 'raul_beam_factor_fourpoint_infinite_18_regions.hdf5'

	elif antenna_type == 'blade':
		data_file = 'high_band_v1_blade_s11day_262_recv_temp_full_correction.hdf5'
		bf_file   = 'raul_beam_factor_blade_infinite_18_regions.hdf5'





	f, t, m, w = level4read(home_folder + '/DATA/EDGES/spectra/level4/high_band/' + data_file)

	LST, fbf, raul_beam_factor = raul_beam_factor_read(home_folder + '/DATA/EDGES/beam_convolution/beam_factors/' + bf_file)
	rbf = np.sum(raul_beam_factor, axis=0)

	#rbf0 = np.genfromtxt(home_folder + '/DATA/EDGES/beam_convolution/beam_factors/raul_beam_factor_fourpoint_infinite_full_map.txt')
	#rbf  = rbf0[:,1::]
	#fbf  = np.arange(100, 201, 1)



	Tcmb = 2.725

	lf   = len(f)
	lday = len(t[0,:,0])
	ratio     = np.zeros((72, lday, lf))
	residuals = np.zeros((72, lday, lf))
	param     = np.zeros((72, lday, 2))

	beta_mean  = np.zeros((len(LST),3))
	gamma_mean = np.zeros((len(LST),3))

	for j in range(72):

		# Interpolation of beam factor to data frequency
		par        = np.polyfit(fbf, rbf[j,:], 10)
		rbf_interp = np.polyval(par, f)		

		for i in range(lday):

			if (len(w[j,i,w[j,i,:]>0]) > 50) and (m[j,i,6]< -10):			

				# Dividing data by beam factor
				ratio[j,i,:] = (t[j,i,:] - Tcmb)/rbf_interp

				# Fit remaining spectra with a 2-parameter power law
				param[j,i,:]     = np.polyfit(np.log(f[w[j,i,:]>0]/408), np.log(ratio[j,i,w[j,i,:]>0]), 1)
				beta             = param[j,i,0]
				gamma            = param[j,i,1]
				model            = (  (f/408) ** (beta + gamma*np.log(f/408))  ) * rbf_interp
				residuals[j,i,:] = (t[j,i,:] - Tcmb) - model


		beta_mean[j,0]  = LST[j]
		gamma_mean[j,0] = LST[j]
		if len(param[j,np.abs(param[j,:,0])>0,0]) > 4:

			beta_mean[j,1]  = np.median(param[j,np.abs(param[j,:,0])>0,0])
			beta_mean[j,2]  = np.abs(np.percentile(param[j,np.abs(param[j,:,0])>0,0], 16) - beta_mean[j,1])

			gamma_mean[j,1] = np.median(param[j,np.abs(param[j,:,1])>0,1])
			gamma_mean[j,2] = np.abs(np.percentile(param[j,np.abs(param[j,:,1])>0,1], 16) - gamma_mean[j,1])


	# Now use: scipy.optimize.curve_fit		


	return beta_mean, gamma_mean, f, residuals











def spectral_index_new_way_old_several_regions(antenna_type):

	Tcmb = 2.725
	LST, f, data, meta, weights = spectral_index_LST_night_time_data(antenna_type)
	diff    = data - Tcmb







	if antenna_type == 'fourpoint':
		#data_file = 'high_band_v1_fourpoint_s11day_157_recv_temp_full_correction.hdf5'
		bf_file   = 'raul_beam_factor_fourpoint_infinite_18_regions.hdf5'

	elif antenna_type == 'blade':
		#data_file = 'high_band_v1_blade_s11day_262_recv_temp_full_correction.hdf5'
		bf_file   = 'raul_beam_factor_blade_infinite_18_regions.hdf5'


	#f, t, m, w                 = level4read(home_folder + '/DATA/EDGES/spectra/level4/high_band/' + data_file)	
	LST, fbf, raul_beam_factor = raul_beam_factor_read(home_folder + '/DATA/EDGES/beam_convolution/beam_factors/' + bf_file)

	# Regions 
	# -------
	#index_1  = np.array([8,9])
	#index_2  = np.array([0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17])

	#index_1  = np.array([4, 5, 6, 7,  8,  9, 10, 11, 12, 13])
	#index_2  = np.array([0, 1, 2, 3, 14, 15, 16, 17])


	#index_1  = np.array([8,9])
	#index_2  = np.array([4,5,6,7,10,11,12,13])
	#index_3  = np.array([0,1,2,3,14,15,16,17])


	index_1  = np.array([0,1,2,3])
	index_2  = np.array([4,5,6,7])
	index_3  = np.array([8,9])
	index_4  = np.array([10,11,12,13])
	index_5  = np.array([14,15,16,17])


	rbf_1    = np.sum(raul_beam_factor[index_1,:,:], axis=0)
	rbf_2    = np.sum(raul_beam_factor[index_2,:,:], axis=0)
	rbf_3    = np.sum(raul_beam_factor[index_3,:,:], axis=0)
	rbf_4    = np.sum(raul_beam_factor[index_4,:,:], axis=0)
	rbf_5    = np.sum(raul_beam_factor[index_5,:,:], axis=0)


	rbf_raw   = np.array([rbf_1, rbf_2, rbf_3, rbf_4, rbf_5])  #, rbf_3
	l_regions = 5 #len(raul_beam_factor[:,0,0])





	# Interpolation of beam factors to data frequency
	rbf = np.zeros((l_regions, 72, len(f)))
	for j in range(72):
		for i in range(l_regions):
			par        = np.polyfit(fbf, rbf_raw[i,j,:], 10)
			rbf[i,j,:] = np.polyval(par, f)			


	w1d     = np.prod(weights, axis=0)
	f_nz    = f[w1d>0]
	diff_nz = diff[:,w1d>0]
	rbf_nz  = rbf[:,:,w1d>0]










	start_parameters = np.array([-2.5, -2.5, -2.5, -2.5, -2.5])  #       #= np.append(-2.5*np.ones(18), 0*np.ones(18))
	#pp, C, info, msg, success = spo.leastsq(spectral_index_error_function_18regions, start_parameters, args=(f_nz, diff_nz, rbf_nz), full_output=1)







	#ww  = np.tile(w1d, (72,1))






	#rbf0 = np.genfromtxt(home_folder + '/DATA/EDGES/beam_convolution/beam_factors/raul_beam_factor_fourpoint_infinite_full_map.txt')
	#rbf  = rbf0[:,1::]
	#fbf  = np.arange(100, 201, 1)




	#lf   = len(f)
	#lday = len(t[0,:,0])

	#diff            = np.zeros((72, lday, lf))
	#diff_residuals  = np.zeros((72, lday, lf))
	#param           = np.zeros((72, lday, 2))

	#beta1_mean       = np.zeros((len(LST),3))
	#gamma1_mean      = np.zeros((len(LST),3))

	#beta2_mean       = np.zeros((len(LST),3))
	#gamma2_mean      = np.zeros((len(LST),3))	

	#start_parameters = [-2.5, -2.6] # [-2.5, -0.05, -2.6, -0.01]

	#for j in range(72):

		## Interpolation of beam factors to data frequency
		#par           = np.polyfit(fbf, rbf_ll[j,:], 10)
		#rbf_ll_interp = np.polyval(par, f)		

		#par           = np.polyfit(fbf, rbf_hl[j,:], 10)
		#rbf_hl_interp = np.polyval(par, f)

		#regions       = np.array([rbf_ll_interp, rbf_hl_interp])


		#for i in range(lday):

			#if (len(w[j,i,w[j,i,:]>0]) > 50) and (m[j,i,6]< -10):			

				## Data difference
				#diff[j,i,:] = t[j,i,:] - Tcmb

				## Fit data difference to the sum of two 2-parameter power laws
				#pp, C, info, msg, success = spo.leastsq(spectral_index_error_function, start_parameters, args=(f[w[j,i,:]>0], diff[j,i,w[j,i,:]>0], regions[:,w[j,i,:]>0]), full_output=1)
				#param[j,i,:] = pp

				#param[j,i,:] = np.polyfit(np.log(f[w[j,i,:]>0]/408), np.log(ratio[j,i,w[j,i,:]>0]), 1)
				#log_model  = np.polyval(param[j,i,:], np.log(f/408))
				#model      = np.exp(log_model) 
				#ratio_residuals[j,i,:] = ratio[j,i,:] - model


		#beta_mean[j,0]  = LST[j]
		#gamma_mean[j,0] = LST[j]
		#if len(param[j,np.abs(param[j,:,0])>0,0]) > 4:

			#beta_mean[j,1]  = np.median(param[j,np.abs(param[j,:,0])>0,0])
			#beta_mean[j,2]  = np.abs(np.percentile(param[j,np.abs(param[j,:,0])>0,0], 16) - beta_mean[j,1])

			#gamma_mean[j,1] = np.median(param[j,np.abs(param[j,:,1])>0,1])
			#gamma_mean[j,2] = np.abs(np.percentile(param[j,np.abs(param[j,:,1])>0,1], 16) - gamma_mean[j,1])


	# Now use: scipy.optimize.curve_fit		


	return f_nz, start_parameters, diff_nz, rbf_nz












def spectral_index_LST_night_time_data(antenna_type):

	if antenna_type == 'fourpoint':
		data_file = 'high_band_v1_fourpoint_s11day_157_recv_temp_full_correction.hdf5'

	elif antenna_type == 'blade':
		data_file = 'high_band_v1_blade_s11day_262_recv_temp_full_correction.hdf5'


	f, t, m, w = level4read(home_folder + '/DATA/EDGES/spectra/level4/high_band/' + data_file)

	data    = np.zeros((72, len(f)))
	meta    = np.zeros((72, len(m[0,0,:])))
	weights = np.zeros((72, len(f)))

	data[0:26,:]     = t[0:26, 115, :]
	data[26:47,:]    = t[26:47,205, :]
	data[46::,:]     = t[46::, 14,  :]

	meta[0:26,:]     = m[0:26, 115, :]
	meta[26:47,:]    = m[26:47,205, :]
	meta[46::,:]     = m[46::, 14,  :]	

	weights[0:26,:]  = w[0:26, 115, :]
	weights[26:47,:] = w[26:47,205, :]
	weights[46::,:]  = w[46::, 14,  :]	

	LST = np.arange(72)


	data3    = np.reshape(data,(72,1,-1))
	meta3    = np.reshape(meta,(72,1,-1))
	weights3 = np.reshape(weights,(72,1,-1))

	return f, data3, meta3, weights3  # LST, 








def alan_high_band_spectrum():

	data1 = np.genfromtxt(home_folder + '/DATA/EDGES/spectra/averages/high_band/alan_averages/forjudd_5term_only_numbers.txt')
	data2 = np.genfromtxt(home_folder + '/DATA/EDGES/spectra/averages/high_band/alan_averages/forjudd_5term_gha8_only_numbers.txt')

	d1 = data1[:,1]
	d2 = data2[:,1]

	f  = data2[:,0]
	w  = data2[:,4]

	return f, d1, d2, w








def alan_low_band_spectrum(case = 2):

	#data = np.genfromtxt(home_folder + '/DATA/EDGES/spectra/averages/low_band/alan_averages/just_numbers.txt')
	
	if case == 1:
		data = np.genfromtxt(home_folder + '/DATA/EDGES/spectra/averages/low_band/alan_averages/all_cases/2017-11-16/case1_5t_51-99.txt')
		print('------------------ Low-Band spectrum case 1 ------------------')
	
	elif case == 2:
		data = np.genfromtxt(home_folder + '/DATA/EDGES/spectra/averages/low_band/alan_averages/all_cases/2017-11-12/case2_5t_51-99.txt')
		print('------------------ Low-Band spectrum case 2 ------------------')

	elif case == 3:
		data = np.genfromtxt(home_folder + '/DATA/EDGES/spectra/averages/low_band/alan_averages/all_cases/2017-11-12/case3_5t_51-99.txt')
		print('------------------ Low-Band spectrum case 3 ------------------')

	elif case == 4:
		data = np.genfromtxt(home_folder + '/DATA/EDGES/spectra/averages/low_band/alan_averages/all_cases/2017-11-16/case4n_5t_51-99.txt')
		print('------------------ Low-Band spectrum case 4 ------------------')

	elif case == 5:
		data = np.genfromtxt(home_folder + '/DATA/EDGES/spectra/averages/low_band/alan_averages/all_cases/2017-11-12/case5_5t_51-99.txt')
		print('------------------ Low-Band spectrum case 5 ------------------')

	elif case == 6:
		data = np.genfromtxt(home_folder + '/DATA/EDGES/spectra/averages/low_band/alan_averages/all_cases/2017-11-12/case6_5t_51-99.txt')
		print('------------------ Low-Band spectrum case 6 ------------------')





	v = data[:,1]
	t = data[:,3]
	w = data[:,13]
	
	res1 = data[:,5]
	res2 = data[:,7]
	t21  = data[:,9]
	

	return v, t, w, res1, res2, t21




















def data_analysis_binning(f, ta_all, w_all, flow, fhigh, fstep):

	## Loading data
	#path_file = home_folder + '/DATA/EDGES/spectra/level3/' + band + '/' + band + '_' + version + '_' + antenna + '.hdf5'
	#f, ta_all, m_all, s_all, w_all = level3read(path_file)


	# Binning
	fb0    = np.arange(flow+(fstep/2), fhigh+(fstep/2), fstep) 
	lfb    = len(fb0)
	tb_all = np.zeros((len(ta_all[:,0,0]), len(ta_all[0,:,0]), lfb))
	wb_all = np.zeros((len(ta_all[:,0,0]), len(ta_all[0,:,0]), lfb))

	for k in range(len(ta_all[:,0,0])):
		for j in range(len(ta_all[0,:,0])):
			print('Binning: LST: ' + str(k) + ' of 72, Day: ' + str(j) + ' of ' + str(len(ta_all[0,:,0])))

			if np.sum(w_all[k,j,:]) > 1000:
				fb, tb, wb    = spectral_binning_fixed_frequency(flow+(fstep/2), fhigh-(fstep/2), fstep, f, ta_all[k,j,:], w_all[k,j,:])
				tb_all[k,j,:] = tb
				wb_all[k,j,:] = wb


	return fb, tb_all, wb_all










def data_analysis_RFI_removal(fb, tb, wb, n_bin = 6, n_sigma = 3.0, N_iter = 5):


	# Making sure the data do not have nans or infs
	if (np.sum(np.isnan(tb)) == 0) and (np.sum(np.isinf(tb)) == 0) and (np.sum(np.isnan(wb)) == 0) and (np.sum(np.isinf(wb)) == 0):


		# Initial quantities
		l_bin             = int(len(fb)/n_bin)
		small_sample_size = int(l_bin/4)
		N_repetitions     = 100         # repetitions when drawing small sample



		# Output arrays
		tb_new = np.copy(tb)
		wb_new = np.copy(wb)



		# Number of fitting parameters
		min_fb = np.min(fb)
		max_fb = np.max(fb)
		if (max_fb - min_fb) < 75:
			npar = 10
		elif (max_fb - min_fb) >= 75:
			npar = 16



		# Clean data iteratively
		for h in range(N_iter):

			# Clean if there are enough good data points
			if np.sum(wb_new) > 1000:
				pp        = fit_polynomial_fourier('EDGES_polynomial', fb, tb_new, npar, Weights = wb_new)
				model     = model_evaluate('EDGES_polynomial', pp[0], fb)
				residuals = tb_new - model


				# Computing STD within each range
				res_std = np.zeros(n_bin)
				for i in range(n_bin):  # For each range
					i1 = i*l_bin
					i2 = (i+1)*l_bin

					if i < (n_bin-1):
						res   = residuals[i1:i2]
						w_res = wb_new[i1:i2]

					elif i == (n_bin-1):
						res   = residuals[i1::]
						w_res = wb_new[i1::]


					# Computation of medians			
					flag = 0
					if len(res[w_res>0]) >= small_sample_size:
						for q in range(N_repetitions):
							res_choice = np.random.choice(res[w_res>0], small_sample_size)
							if flag == 0:
								res_choice_std = np.std(res_choice)
								flag = 1

							elif flag == 1:
								res_choice_std = np.append(res_choice_std, np.std(res_choice))

						res_std[i]  = np.median(res_choice_std)

					else:
						res_std[i]  = 0



				# Clean spectrum based on median STD for each range
				for i in range(len(fb)):

					index_range = int(i/l_bin)
					if index_range == n_bin:
						index_range = n_bin-1

					if res_std[index_range] > 0:
						if np.abs(residuals[i]) > n_sigma*res_std[index_range]:
							tb_new[i] = 0
							wb_new[i] = 0

					elif res_std[index_range] == 0:
						tb_new[i] = 0
						wb_new[i] = 0


	else:
		tb_new = np.zeros(len(fb))
		wb_new = np.zeros(len(fb))

	return tb_new, wb_new





def scaled_haslam_map(freq_in_MHz, band_deg=10, index_inband=2.5, index_outband=2.57):

	# Data paths
	path_root = home_folder + '/DATA/EDGES/'	
	path_data = path_root + 'beam_convolution/'	



	# Loading Haslam map
	haslam_map  = fits.open(path_data + 'haslam_map/lambda_haslam408_dsds.fits')
	haslam_nest = (haslam_map[1].data)['temperature'] # NESTED Healpix format




	# Loading galactic coordinates (the Haslam map is in NESTED Galactic Coordinates)
	coord              = fits.open(path_data + 'coordinate_maps/pixel_coords_map_nested_galactic_res9.fits')
	coord_array        = coord[1].data
	lon                = coord_array['LONGITUDE']
	lat                = coord_array['LATITUDE']




	# Scaling Haslam map to freq_in_MHz (the map contains the CMB, which has to be removed at 408 MHz, and then added back at freq_in_MHz)
	b0                 = band_deg # default 10 degrees, galactic elevation threshold for different spectral index
	scaled_haslam_nest = np.zeros(len(haslam_nest))
	Tcmb               = 2.725

	for i in range(len(lat)):
		if np.abs(lat[i]) <= b0:
			scaled_haslam_nest[i] = Tcmb + ((haslam_nest[i]-Tcmb)*(freq_in_MHz/408)**(-index_inband))
		elif np.abs(lat[i]) > b0:
			scaled_haslam_nest[i] = Tcmb + ((haslam_nest[i]-Tcmb)*(freq_in_MHz/408)**(-index_outband))



	# Convert to RING format
	scaled_haslam_ring = hp.reorder(scaled_haslam_nest, n2r=True)


	return scaled_haslam_ring


























def level1_to_level2_v2(band, year, day_hour, folder_data_save, folder_plot_save):


	# Paths and files
	path_level1      = home_folder + '/DATA/EDGES/spectra/level1/' + band + '/300_350/'
	path_logs        = home_folder + '/DATA/EDGES/spectra/auxiliary/'

	if band != 'low_band2':
		level1_file      = path_level1 + 'level1_' + year + '_' + day_hour + '_300_350.mat'
	elif band == 'low_band2':
		level1_file      = path_level1 + 'level1_' + year + '_' + day_hour + '_low2_300_350.mat'


	weather_file     = path_logs   + 'weather.txt'	

	if (band == 'low_band'):
		thermlog_file = path_logs + 'thermlog_low.txt'

	if (band == 'high_band') or (band == 'low_band2'):
		thermlog_file = path_logs + 'thermlog.txt'





	# EDGES coordinates
	EDGES_LAT = -26.7
	EDGES_LON = 116.6





	# Frequency and indices
	if band == 'low_band':
		#if (year == '2017') and (int(day_hour[0:3]) >= 150):
		flow  = 50
		fhigh = 120

		#else:
			#flow  = 50
			#fhigh = 100

	elif band == 'low_band2':
		flow  = 50
		fhigh = 100

	elif band == 'high_band':
		#flow  = 90
		#fhigh = 190
		
		flow  = 65
		fhigh = 195

	ff, il, ih = frequency_edges(flow, fhigh)
	fe = ff[il:ih+1]





	# Loading data
	ds, dd = level1_MAT(level1_file)
	tt     = ds[:,il:ih+1]





	# Seconds into measurement
	seconds_data = 3600*dd[:,3].astype(float) + 60*dd[:,4].astype(float) + dd[:,5].astype(float)





	# Auxiliary data
	year_int     = int(year)
	day_int      = int(day_hour[0:3])
	fraction_int = int(day_hour[4::])	
	aux1, aux2   = auxiliary_data(weather_file, thermlog_file, band, year_int, day_int)





	# Interpolate data
	amb_temp_interp  = np.interp(seconds_data, aux1[:,0], aux1[:,1]) - 273.15
	amb_hum_interp   = np.interp(seconds_data, aux1[:,0], aux1[:,2])
	rec1_temp_interp = np.interp(seconds_data, aux1[:,0], aux1[:,3]) - 273.15
	rec2_temp_interp = np.interp(seconds_data, aux2[:,0], aux2[:,1])





	# Combined auxiliary array
	aux_raw = np.array([amb_temp_interp, amb_hum_interp, rec1_temp_interp, rec2_temp_interp])
	aux_raw = aux_raw.T	





	# Sun/Moon coordinates
	sun_moon_azel = SUN_MOON_azel(EDGES_LAT, EDGES_LON, dd)	





	# LST
	LST = utc2lst(dd, EDGES_LON)





	# Galactic Hour Angle
	LST_gc = 17 + (45/60) + (40.04/(60*60))    # LST of Galactic Center
	GHA    = LST - LST_gc
	for i in range(len(GHA)):
		if GHA[i] < -12.0:
			GHA[i] = GHA[i] + 24





	# Meta
	year_column     = year_int * np.ones((len(LST),1))
	day_column      = day_int * np.ones((len(LST),1))
	fraction_column = fraction_int * np.ones((len(LST),1))
	LST_column      = LST.reshape(-1,1)
	GHA_column      = GHA.reshape(-1,1)
	meta            = np.concatenate((year_column, day_column, fraction_column, LST_column, GHA_column, sun_moon_azel, aux_raw), axis=1)





	# RFI cleaning	
	ww        = np.ones(len(fe))   # generic weight vector
	tt_no_rfi = np.zeros((len(LST), len(fe)))
	ww_no_rfi = np.zeros((len(LST), len(fe)))

	for i in range(len(LST)):

		if band == 'high_band':
			#print('RFI cleaning: ' + str(i+1) + ' of ' + str(len(LST)))		
			#wx       = RFI_cleaning_derivative(fe, tt[i,:], ww, Nterms_std=3, Nstd=5)
			#ty, wy   = RFI_excision_raw_frequency(fe, tt[i,:], wx)
			#wz       = RFI_cleaning_polynomial(fe, ty, wy, Nterms_fg=10, Nterms_std=3, Nstd=5)
			#tz       = np.copy(ty)
			#tz[wz == 0] = 0

			#tt_no_rfi[i,:] = tz
			#ww_no_rfi[i,:] = wz

			print('NO RFI CLEANING')
			tt_no_rfi[i,:] = tt[i,:]
			ww_no_rfi[i,:] = ww




		if (band == 'low_band') or (band == 'low_band2'):

			print('NO RFI CLEANING')
			tt_no_rfi[i,:] = tt[i,:]
			ww_no_rfi[i,:] = ww







	# Total power filter
	# ---------------------------------------

	# Frequency limits and thresholds
	if (band == 'low_band'):
		index_lim1         = 0
		index_lim2         = 6000		
		res_threshold      = 50000 
		ext_threshold_low  = 4e6
		ext_threshold_high = 1e7
		nterms_poly        = 14
		plot_ylim          = 1.2e7


	if (band == 'low_band2'):
		index_lim1         = 0
		index_lim2         = 6000		
		res_threshold      = 70000 
		ext_threshold_low  = 5e6
		ext_threshold_high = 1.5e7
		nterms_poly        = 14
		plot_ylim          = 1.6e7		



	if band == 'high_band':
		index_lim1         = 2950
		index_lim2         = len(fe)		
		res_threshold      = 1e20    # 70000
		ext_threshold_low  = 0       # 3.0e6
		ext_threshold_high = 1e20    # 1.35e7
		nterms_poly        = 15
		plot_ylim          = 1.5e7



	# Compute total power and weights
	tot_pow = np.sum(tt_no_rfi[:, index_lim1:index_lim2], axis=1)
	wei_pow = np.ones(len(tot_pow))
	ls      = np.arange(len(tot_pow))
	lsn     = ls/np.max(ls)



	# Original quantities
	tot_pow_orig = np.copy(tot_pow)
	wei_pow_orig = np.copy(wei_pow)



	# Process only nighttime data because daytime data has solar effects
	tot_pow_nt = tot_pow[meta[:,6] < 0]
	wei_pow_nt = wei_pow[meta[:,6] < 0]
	lsn_nt     = lsn[meta[:,6] < 0]
	ls_nt      = ls[meta[:,6] < 0]



	# Eliminate extreme points for nighttime data
	tot_pow_nt[ (tot_pow_nt < ext_threshold_low) | (tot_pow_nt > ext_threshold_high) ] = 0
	wei_pow_nt[ (tot_pow_nt < ext_threshold_low) | (tot_pow_nt > ext_threshold_high) ] = 0











	# Save
	if band == 'low_band':
		band_save = 'low_band_50_120MHz'

	elif band == 'low_band2':
		band_save = 'low_band2'

	elif band == 'high_band':
		band_save = 'high_band'



	# Continue processing if there are data points
	if (len(lsn_nt[wei_pow_nt > 0]) > 0) and (len(tot_pow_nt[wei_pow_nt > 0])):

		# Fit and remove model
		par    = np.polyfit(lsn_nt[wei_pow_nt > 0], tot_pow_nt[wei_pow_nt > 0], nterms_poly)
		model  = np.polyval(par, lsn_nt)
		res_nt = tot_pow_nt - model



		# Eliminating outliers in night-time vector
		tot_pow_nt[np.abs(res_nt) > res_threshold] = 0
		wei_pow_nt[np.abs(res_nt) > res_threshold] = 0



		# Total weight vector
		wei_pow[ls_nt[wei_pow_nt == 0]] = 0



		# Eliminating outliers in output arrays
		tt_no_rfi[ ls[wei_pow == 0], :] = 0
		ww_no_rfi[ ls[wei_pow == 0], :] = 0






		# Plots
		plt.close()
		plt.close()
		plt.close()

		size_x = 11
		size_y = 8
		f1  = plt.figure(num=1, figsize=(size_x, size_y))	

		plt.subplot(2,1,1)
		plt.plot(ls, tot_pow_orig, 'b')
		plt.plot(ls_nt, tot_pow_nt, 'r')
		plt.grid()
		plt.xlim([0, 2300])
		plt.ylim([0, plot_ylim])
		plt.ylabel('total temperature [K]')

		plt.subplot(2,1,2)
		plt.plot(ls_nt, res_nt, 'r')
		plt.plot(ls_nt,  res_threshold*np.ones(len(ls_nt)), 'c')
		plt.plot(ls_nt, -res_threshold*np.ones(len(ls_nt)), 'c')
		plt.grid()
		plt.xlim([0, 2300])
		plt.ylim([-1e5, 1e5])
		plt.xlabel('spectrum number')
		plt.ylabel('residuals [K]')

		path_plot_save = home_folder + '/DATA/EDGES/spectra/level2/' + band_save + '/' + folder_plot_save + '/'  #'/plots_total_temperature_v2/'
		plt.savefig(path_plot_save + year + '_' + day_hour + '.png', bbox_inches='tight')
		plt.close()	
		plt.close()




	save_file = home_folder + '/DATA/EDGES/spectra/level2/' + band_save + '/' + folder_data_save + '/' + year + '_' + day_hour + '.hdf5'  # _65_195_MHz

	with h5py.File(save_file, 'w') as hf:
		hf.create_dataset('frequency',           data = fe)
		hf.create_dataset('antenna_temperature', data = tt_no_rfi)
		hf.create_dataset('weights',             data = ww_no_rfi)	
		hf.create_dataset('metadata',            data = meta)


	return fe, tt_no_rfi, ww_no_rfi, meta   #, tot_pow_orig, wei_pow, ls_nt, tot_pow_nt, res_nt








def lst2gha(LST):

	# LST of Galactic Center
	LST_gc = 17 + (45/60) + (40.04/(60*60))

	# Conversion
	GHA    = LST - LST_gc


	# Wrapping to -12 to +12 Hr
	#for i in range(len(GHA)):
		#if GHA[i] < -12.0:
			#GHA[i] = GHA[i] + 24


	# Faster approach for wrapping to -12 to +12 Hr
	GHA_old = np.copy(GHA)	
	GHA[GHA_old < -12] = GHA[GHA_old < -12] + 24

	return GHA






































def level2_to_level3_v2(band, antenna, LST_1, LST_2, sun_el_max = -10, amb_hum_max = 90, flag_save = ''):

	version = 'v2'

	# Selecting band	
	if (band == 'high_band') and (antenna=='fourpoint'):

		path_data = home_folder + '/DATA/EDGES/spectra/level2/high_band/' + version + '/'

		dates   = ['2015_109_11', 
		           '2015_110_00', '2015_111_00', '2015_112_00', '2015_113_00', '2015_113_09', '2015_114_00', '2015_115_00', '2015_116_00', '2015_117_00', '2015_118_00', '2015_119_00', '2015_119_13', 
		           '2015_120_00', '2015_120_14', '2015_121_00', '2015_122_00', '2015_122_05', '2015_122_08', '2015_123_00', '2015_123_08', '2015_123_15', '2015_124_00', '2015_124_13', '2015_125_00', '2015_125_05', '2015_125_08', '2015_126_00', '2015_127_00', '2015_128_00', '2015_129_00', 
		           '2015_130_00', '2015_131_00', '2015_132_00', '2015_132_04', '2015_133_00', '2015_134_00', '2015_135_00', '2015_136_00', '2015_137_00', '2015_138_00', '2015_139_00', 
		           '2015_140_00', '2015_141_00', '2015_142_00', '2015_143_00', '2015_144_00', '2015_145_00', '2015_146_00', '2015_147_00', '2015_148_00', '2015_149_00', 
		           '2015_150_00', '2015_151_00', '2015_152_00', '2015_153_00', '2015_154_00', '2015_155_00', '2015_156_00', '2015_157_00', 
		           '2015_161_18', '2015_162_00', '2015_163_00', '2015_164_00', '2015_165_00', '2015_166_00', '2015_167_00', '2015_168_00', '2015_169_00', 
		           '2015_170_00', '2015_171_00', '2015_172_00', '2015_173_00', '2015_174_00', '2015_175_00', '2015_176_00', '2015_177_00', '2015_178_00', '2015_179_00', 
		           '2015_180_00', '2015_181_00', '2015_182_00', '2015_183_00', '2015_184_00', '2015_185_00', '2015_186_00', '2015_187_00', '2015_188_00', '2015_189_00', 
		           '2015_190_00', '2015_191_00', '2015_192_00', '2015_192_18', '2015_193_00', '2015_194_00', '2015_195_00', '2015_198_00']		






	if (band == 'high_band') and (antenna=='blade'):

		path_data = home_folder + '/DATA/EDGES/spectra/level2/high_band/' + version + '/'

		dates   = ['2015_206_00', '2015_207_00', '2015_208_00', '2015_209_00',
		           '2015_210_00', '2015_210_03', '2015_211_00', '2015_211_18', '2015_212_00', '2015_215_08', '2015_216_00', '2015_217_00', '2015_218_00', '2015_219_00',
		           '2015_220_00', '2015_221_00', '2015_222_00', '2015_223_00', '2015_224_00', '2015_225_00', '2015_226_00', '2015_227_00', '2015_228_00', '2015_229_00',
		           '2015_230_00', '2015_231_00', '2015_232_00', '2015_233_00', '2015_234_00', '2015_235_00', '2015_236_00', '2015_237_00', '2015_238_00', '2015_239_00',
		           '2015_240_00', '2015_241_00', '2015_242_00', '2015_243_00', '2015_245_00',
		           '2015_250_15', '2015_251_00', '2015_251_21', '2015_252_00', '2015_253_00', '2015_254_00', '2015_255_00', '2015_256_00', '2015_257_00', '2015_258_00', '2015_259_00',
		           '2015_260_00', '2015_261_00', '2015_262_00', '2015_265_19', '2015_266_00', '2015_267_00', '2015_268_00', '2015_269_00',
		           '2015_270_00', '2015_271_00', '2015_272_00', '2015_273_00', '2015_274_00', '2015_275_00', '2015_276_00', '2015_277_00', '2015_278_00', '2015_279_00',
		           '2015_280_00', '2015_281_17', '2015_282_00', '2015_283_00', '2015_284_00', '2015_285_00', '2015_286_00', '2015_287_00', '2015_288_00', '2015_289_00',
		           '2015_290_00', '2015_291_00', '2015_292_00', '2015_293_00', '2015_294_00', '2015_295_00', '2015_296_00', '2015_297_00', '2015_298_00', '2015_299_00',
		           '2015_300_00', '2015_301_00', '2015_302_00', '2015_303_00',
		           '2015_310_18', '2015_311_00', '2015_312_00', '2015_313_00', '2015_314_00', '2015_315_00', '2015_316_00', '2015_317_00', '2015_318_00', '2015_319_00',
		           '2015_320_00', '2015_321_00', '2015_322_00', '2015_323_00', '2015_324_00', '2015_325_00', '2015_326_00', '2015_327_00', '2015_328_00', '2015_329_00',
		           '2015_330_00', '2015_331_00', '2015_332_00', '2015_333_00', '2015_334_00', '2015_335_00', '2015_336_00', '2015_337_00', '2015_338_00', '2015_339_00',
		           '2015_340_00', '2015_341_00', '2015_342_00', '2015_343_00', '2015_344_00', '2015_345_00', '2015_346_00', '2015_347_00', '2015_348_00', '2015_349_00',
		           '2015_350_00', '2015_351_00', '2015_352_00', '2015_353_00', '2015_354_00', '2015_355_00', '2015_356_00', '2015_357_00', '2015_358_00', '2015_359_00',
		           '2015_360_00', '2015_361_00', '2015_362_00', '2015_363_00', '2015_364_00', '2015_365_00',
		           '2016_001_00', '2016_002_00', '2016_003_00', '2016_004_00', '2016_005_00', '2016_006_00', '2016_007_00', '2016_008_00', '2016_009_00',
		           '2016_010_00', '2016_011_00', '2016_012_00', '2016_013_00', '2016_014_00', '2016_015_00', '2016_016_00', '2016_017_00', '2016_018_00', '2016_019_00',
		           '2016_020_00', '2016_027_20', '2016_028_00', '2016_029_00', 
		           '2016_030_00', '2016_031_00', '2016_032_00', '2016_033_00', '2016_034_00', '2016_035_00', '2016_036_00', '2016_037_00', '2016_038_00', '2016_039_00',
		           '2016_040_00', '2016_041_00', '2016_042_00', '2016_043_00', '2016_044_00', '2016_045_00', '2016_046_00', '2016_047_00', '2016_048_00', '2016_049_00',
		           '2016_050_00', '2016_051_00', '2016_052_00', '2016_053_00', '2016_055_07', '2016_056_00', '2016_057_00', '2016_058_00', '2016_059_00',
		           '2016_060_00', '2016_061_00', '2016_062_00', '2016_063_00', '2016_064_00', '2016_065_00', '2016_066_00', '2016_067_00', '2016_068_00', '2016_069_00',
		           '2016_070_00', '2016_071_00', '2016_072_00', '2016_073_00', '2016_074_00', '2016_075_00', '2016_076_00', '2016_077_00', '2016_078_00', '2016_079_00',
		           '2016_080_00', '2016_081_00', '2016_082_00', '2016_083_00', '2016_084_00', '2016_085_00', '2016_086_00', '2016_087_00', '2016_088_00', '2016_089_00',
		           '2016_090_00', '2016_091_00', '2016_092_00', '2016_093_00', '2016_094_00', '2016_095_00', '2016_096_00', '2016_097_00', '2016_098_00', '2016_099_00',
		           '2016_100_00', '2016_101_00', '2016_102_00', '2016_103_00', '2016_104_00', '2016_107_00', '2016_108_00', '2016_109_00',
		           '2016_110_00', '2016_111_00', '2016_112_00', '2016_113_00', '2016_114_00', '2016_115_00', '2016_116_00', '2016_117_00', '2016_118_00',
		           '2016_123_00', '2016_124_00', '2016_125_00', '2016_126_00', '2016_127_00', '2016_128_00', '2016_129_00',
		           '2016_130_00', '2016_131_00', '2016_132_00', '2016_133_00', '2016_134_00', '2016_135_00', '2016_136_00', '2016_137_00', '2016_138_00', '2016_139_00',
		           '2016_140_00', '2016_141_00', '2016_142_00', '2016_143_00', '2016_144_00', '2016_145_00', '2016_146_00', '2016_147_00', '2016_148_00', '2016_149_00',
		           '2016_150_00', '2016_151_00', '2016_152_00', '2016_153_00', '2016_154_00', '2016_155_00', '2016_156_00', '2016_157_00', '2016_158_00', '2016_159_00',
		           '2016_160_00', '2016_161_00', '2016_162_00', '2016_163_00', '2016_164_00', '2016_165_00', '2016_166_00', '2016_167_00', '2016_168_00', '2016_169_00',
		           '2016_170_00', '2016_171_00', '2016_172_00', '2016_173_00', '2016_174_00', '2016_175_00', '2016_176_00', '2016_177_00', '2016_178_00', '2016_179_00',
		           '2016_180_00', '2016_181_00', '2016_182_00', '2016_183_00', '2016_184_00', '2016_185_00', '2016_186_00', '2016_187_00', '2016_188_00', '2016_189_00',
		           '2016_190_00', '2016_191_00', '2016_192_00', '2016_193_00', '2016_194_00', '2016_195_00', '2016_196_00', '2016_197_00', '2016_198_00', '2016_199_00',
		           '2016_200_00', '2016_201_00', '2016_202_00', '2016_203_00', '2016_204_00', '2016_205_00', '2016_206_00', '2016_207_00', '2016_208_00', '2016_209_00',
		           '2016_210_00', '2016_210_08', '2016_211_00', '2016_212_00', '2016_213_00', '2016_216_16', '2016_217_00', '2016_218_00', '2016_219_00', '2016_220_00',
		           '2016_221_00', '2016_223_18', '2016_224_00', '2016_225_00', '2016_226_00', '2016_227_00', '2016_228_00', '2016_229_00',
		           '2016_230_00', '2016_236_09', '2016_237_00', '2016_239_00',
		           '2016_240_00', '2016_241_00', '2016_242_00', '2016_243_00', '2016_244_07', '2016_245_00', '2016_246_00', '2016_247_00', '2016_248_00', '2016_248_06', '2016_249_00',
		           '2016_250_02', '2016_251_00', '2016_252_00', '2016_253_13', '2016_254_00', '2016_254_09', '2016_255_00', '2016_256_00', '2016_257_00', '2016_258_00']




	if (band == 'low_band') and (antenna=='blade'):

		path_data = home_folder + '/DATA/EDGES/spectra/level2/low_band/' + version + '/'

		dates   = ['2015_286_02', '2015_287_00', '2015_288_00', '2015_289_00',
		           '2015_291_00', '2015_292_00', '2015_293_00', '2015_294_00', '2015_295_00', '2015_296_00', '2015_297_00', '2015_298_00', '2015_299_00',
		           '2015_300_00', '2015_301_00', '2015_302_00', '2015_303_00',
		           '2015_310_18', '2015_311_00', '2015_312_00', '2015_313_00', '2015_314_00', '2015_315_00', '2015_316_00', '2015_317_00', '2015_318_00', '2015_319_00',
		           '2015_320_00', '2015_321_00', '2015_322_00', '2015_323_00', '2015_324_00', '2015_325_00', '2015_326_00', '2015_327_00', '2015_328_00', '2015_329_00',
		           '2015_330_00', '2015_331_00', '2015_332_00', '2015_333_00', '2015_334_00', '2015_335_00', '2015_336_00', '2015_337_00', '2015_338_00', '2015_339_00',
		           '2015_340_00', '2015_341_00', '2015_342_00', '2015_343_14', '2015_344_00', '2015_344_21', '2015_345_00', '2015_346_00', '2015_347_00', '2015_348_00', '2015_349_00',
		           '2015_350_00', '2015_351_00', '2015_352_00', '2015_353_00', '2015_354_00',
		           '2015_362_00', '2015_363_00', '2015_364_00', '2015_365_00',
		           '2016_001_00', '2016_002_00', '2016_003_00', '2016_004_00', '2016_005_00', '2016_006_00', '2016_007_00', '2016_008_00', '2016_009_00',
		           '2016_010_00', '2016_011_00', '2016_012_00', '2016_013_00', '2016_014_00', '2016_015_00', '2016_016_00', '2016_017_00', '2016_018_00', '2016_019_00',
		           '2016_020_00', '2016_028_00', '2016_029_00',
		           '2016_030_00', '2016_031_00', '2016_032_00', '2016_033_00', '2016_034_00', '2016_035_00', '2016_036_00', '2016_037_00', '2016_038_00', '2016_039_00',
		           '2016_040_00', '2016_041_00', '2016_042_00', '2016_043_00', '2016_044_00', '2016_045_00', '2016_046_00', '2016_047_00', '2016_048_00', '2016_049_00',
		           '2016_050_00', '2016_051_00', '2016_052_00', '2016_053_00', '2016_055_21', '2016_056_00', '2016_057_00', '2016_058_00', '2016_059_00',
		           '2016_060_00', '2016_061_00', '2016_062_00', '2016_063_00', '2016_064_00', '2016_065_00', '2016_066_00', '2016_067_00', '2016_068_00', '2016_069_00',
		           '2016_070_00', '2016_071_00', '2016_072_00', '2016_073_00', '2016_074_00', '2016_075_00', '2016_076_00', '2016_077_00', '2016_078_00', '2016_079_00',
		           '2016_080_00', '2016_081_00', '2016_082_00', '2016_083_00', '2016_084_00', '2016_085_00', '2016_086_00', '2016_087_00', '2016_088_00', '2016_089_00',
		           '2016_090_00', '2016_091_00', '2016_092_00', '2016_093_00', '2016_094_00', '2016_095_00', '2016_096_00', '2016_097_00', '2016_098_00', '2016_099_00',
		           '2016_100_00', '2016_101_00', '2016_102_00', '2016_103_00', '2016_104_00',
		           '2016_106_13', '2016_107_00', '2016_108_00', '2016_109_00', 
		           '2016_110_00', '2016_111_00', '2016_112_00', '2016_113_00', '2016_114_00', '2016_115_00', '2016_116_00', '2016_117_00', '2016_118_00',
		           '2016_122_16', '2016_123_00', '2016_124_00', '2016_125_00', '2016_126_00', '2016_127_00', '2016_128_00', '2016_129_00',
		           '2016_130_00', '2016_131_00', '2016_132_00', '2016_133_00', '2016_134_00', '2016_135_00', '2016_136_00', '2016_137_00', '2016_138_00', '2016_139_00',
		           '2016_140_00', '2016_141_00', '2016_142_00', '2016_143_00', '2016_144_00', '2016_145_00', '2016_146_00', '2016_147_00', '2016_148_00', '2016_149_00',
		           '2016_150_00', '2016_151_00', '2016_152_00', '2016_153_00', '2016_154_00', '2016_155_00', '2016_156_00', '2016_157_00', '2016_158_00', '2016_159_00',
		           '2016_160_00', '2016_167_00', '2016_168_00', '2016_169_00',
		           '2016_170_00', '2016_171_00', '2016_172_00', '2016_173_00',
		           '2016_180_15', '2016_181_00', '2016_182_00', '2016_183_00', '2016_184_00', '2016_185_00', '2016_186_00', '2016_187_00', '2016_188_00', '2016_189_00',
		           '2016_190_00', '2016_191_00', '2016_192_00', '2016_193_00', '2016_194_00', '2016_195_00', '2016_196_00', '2016_197_00', '2016_198_00', '2016_199_00',
		           '2016_200_00', '2016_201_00', '2016_202_00', '2016_203_00', '2016_204_00',
		           '2016_210_14', '2016_211_00', '2016_212_00']

		# Jumps: 292, 313, 314, 320, 365, 007, 43, 78, 84, 90, 100, 103, 107, 110, 113, 124, 128, 135, 145, 

		# Intermittency ??: 117, 









	# Loop over dates
	dates_numpy = np.zeros((len(dates), 3))
	flag = 0
	for i in range(len(dates)):


		# Saving date information as numpy array
		dates_numpy[i,0] = int(dates[i][0:4])
		dates_numpy[i,1] = int(dates[i][5:8])
		dates_numpy[i,2] = int(dates[i][9::])



		# Daily data selection
		f, t_sel2, w_sel2, wea_sel, LST_sel = data_selection_single_day_v2(band, dates[i], LST_1, LST_2, sun_el_max=sun_el_max, amb_hum_max=amb_hum_max, receiver_temp=27)



		# If there are data available
		if np.sum(t_sel2) > 0:

			print('-')
			print('---------------------------')
			print('Processing day: ' + str(dates[i]))
			print('---------------------------')


			# Averaging daily data
			tav0, wav0 = spectral_averaging(t_sel2, w_sel2)


			# Median weather / receiver temperatures for each day
			wea = np.median(wea_sel, axis=0) 


			# Continue if enough data available (weights greater than zero), no NaNs, and no indeterminate divisions 
			if (np.sum(wav0) > 0) and (np.sum(np.isnan(tav0)) == 0) and (np.sum(np.isinf(tav0)) == 0):


				# RFI-cleaning the average traces
				tav1, wav1 = RFI_excision_raw_frequency(f, tav0, wav0)
				tav, wav   = RFI_cleaning_std(f, tav1, wav1, n_sigma = 3.5, df_MHz = 20, npar = 4)				


				# Storing data
				if flag == 0:
					tav_all = np.copy(tav).reshape(1,-1)
					wav_all = np.copy(wav).reshape(1,-1)
					wea_all = np.copy(wea).reshape(1,-1)
					LST_all = np.copy(LST_sel)
					flag    = 1					

				elif flag > 0:
					tav_all = np.append(tav_all, tav.reshape(1,-1), axis=0)
					wav_all = np.append(wav_all, wav.reshape(1,-1), axis=0)
					wea_all = np.append(wea_all, wea.reshape(1,-1), axis=0)
					LST_all = np.append(LST_all, LST_sel, axis=0)



	# Save
	path_save = home_folder + '/DATA/EDGES/spectra/level3/' + band + '/v2/'
	save_file = path_save + band + '_v2_' + antenna + '_LST_' + str(LST_1) + '_' + str(LST_2) + flag_save + '.hdf5'	

	with h5py.File(save_file, 'w') as hf:
		hf.create_dataset('frequency',           data = f)
		hf.create_dataset('antenna_temperature', data = tav_all)
		hf.create_dataset('weights',             data = wav_all)
		hf.create_dataset('weather_receiver',    data = wea_all)
		hf.create_dataset('LST',                 data = LST_all)



	return f, tav_all, wav_all, wea_all, LST_all



















def level2_to_level3_v3(band, antenna, LST_1, LST_2, sun_el_max = -10, amb_hum_max = 90, flag_save = ''):

	version = 'v3'

	# Selecting band	
	if (band == 'high_band') and (antenna=='fourpoint'):

		path_data = home_folder + '/DATA/EDGES/spectra/level2/high_band/' + version + '/'

		dates   = ['2015_109_11', 
		           '2015_110_00', '2015_111_00', '2015_112_00', '2015_113_00', '2015_113_09', '2015_114_00', '2015_115_00', '2015_116_00', '2015_117_00', '2015_118_00', '2015_119_00', '2015_119_13', 
		           '2015_120_00', '2015_120_14', '2015_121_00', '2015_122_00', '2015_122_05', '2015_122_08', '2015_123_00', '2015_123_08', '2015_123_15', '2015_124_00', '2015_124_13', '2015_125_00', '2015_125_05', '2015_125_08', '2015_126_00', '2015_127_00', '2015_128_00', '2015_129_00', 
		           '2015_130_00', '2015_131_00', '2015_132_00', '2015_132_04', '2015_133_00', '2015_134_00', '2015_135_00', '2015_136_00', '2015_137_00', '2015_138_00', '2015_139_00', 
		           '2015_140_00', '2015_141_00', '2015_142_00', '2015_143_00', '2015_144_00', '2015_145_00', '2015_146_00', '2015_147_00', '2015_148_00', '2015_149_00', 
		           '2015_150_00', '2015_151_00', '2015_152_00', '2015_153_00', '2015_154_00', '2015_155_00', '2015_156_00', '2015_157_00', 
		           '2015_161_18', '2015_162_00', '2015_163_00', '2015_164_00', '2015_165_00', '2015_166_00', '2015_167_00', '2015_168_00', '2015_169_00', 
		           '2015_170_00', '2015_171_00', '2015_172_00', '2015_173_00', '2015_174_00', '2015_175_00', '2015_176_00', '2015_177_00', '2015_178_00', '2015_179_00', 
		           '2015_180_00', '2015_181_00', '2015_182_00', '2015_183_00', '2015_184_00', '2015_185_00', '2015_186_00', '2015_187_00', '2015_188_00', '2015_189_00', 
		           '2015_190_00', '2015_191_00', '2015_192_00', '2015_192_18', '2015_193_00', '2015_194_00', '2015_195_00', '2015_198_00']		






	if (band == 'high_band') and (antenna=='blade'):

		path_data = home_folder + '/DATA/EDGES/spectra/level2/high_band/' + version + '/'

		dates   = ['2015_206_00', '2015_207_00', '2015_208_00', '2015_209_00',
		           '2015_210_00', '2015_210_03', '2015_211_00', '2015_211_18', '2015_212_00', '2015_215_08', '2015_216_00', '2015_217_00', '2015_218_00', '2015_219_00',
		           '2015_220_00', '2015_221_00', '2015_222_00', '2015_223_00', '2015_224_00', '2015_225_00', '2015_226_00', '2015_227_00', '2015_228_00', '2015_229_00',
		           '2015_230_00', '2015_231_00', '2015_232_00', '2015_233_00', '2015_234_00', '2015_235_00', '2015_236_00', '2015_237_00', '2015_238_00', '2015_239_00',
		           '2015_240_00', '2015_241_00', '2015_242_00', '2015_243_00', '2015_245_00',
		           '2015_250_15', '2015_251_00', '2015_251_21', '2015_252_00', '2015_253_00', '2015_254_00', '2015_255_00', '2015_256_00', '2015_257_00', '2015_258_00', '2015_259_00',
		           '2015_260_00', '2015_261_00', '2015_262_00', '2015_265_19', '2015_266_00', '2015_267_00', '2015_268_00', '2015_269_00',
		           '2015_270_00', '2015_271_00', '2015_272_00', '2015_273_00', '2015_274_00', '2015_275_00', '2015_276_00', '2015_277_00', '2015_278_00', '2015_279_00',
		           '2015_280_00', '2015_281_17', '2015_282_00', '2015_283_00', '2015_284_00', '2015_285_00', '2015_286_00', '2015_287_00', '2015_288_00', '2015_289_00',
		           '2015_290_00', '2015_291_00', '2015_292_00', '2015_293_00', '2015_294_00', '2015_295_00', '2015_296_00', '2015_297_00', '2015_298_00', '2015_299_00',
		           '2015_300_00', '2015_301_00', '2015_302_00', '2015_303_00',
		           '2015_310_18', '2015_311_00', '2015_312_00', '2015_313_00', '2015_314_00', '2015_315_00', '2015_316_00', '2015_317_00', '2015_318_00', '2015_319_00',
		           '2015_320_00', '2015_321_00', '2015_322_00', '2015_323_00', '2015_324_00', '2015_325_00', '2015_326_00', '2015_327_00', '2015_328_00', '2015_329_00',
		           '2015_330_00', '2015_331_00', '2015_332_00', '2015_333_00', '2015_334_00', '2015_335_00', '2015_336_00', '2015_337_00', '2015_338_00', '2015_339_00',
		           '2015_340_00', '2015_341_00', '2015_342_00', '2015_343_00', '2015_344_00', '2015_345_00', '2015_346_00', '2015_347_00', '2015_348_00', '2015_349_00',
		           '2015_350_00', '2015_351_00', '2015_352_00', '2015_353_00', '2015_354_00', '2015_355_00', '2015_356_00', '2015_357_00', '2015_358_00', '2015_359_00',
		           '2015_360_00', '2015_361_00', '2015_362_00', '2015_363_00', '2015_364_00', '2015_365_00',
		           '2016_001_00', '2016_002_00', '2016_003_00', '2016_004_00', '2016_005_00', '2016_006_00', '2016_007_00', '2016_008_00', '2016_009_00',
		           '2016_010_00', '2016_011_00', '2016_012_00', '2016_013_00', '2016_014_00', '2016_015_00', '2016_016_00', '2016_017_00', '2016_018_00', '2016_019_00',
		           '2016_020_00', '2016_027_20', '2016_028_00', '2016_029_00', 
		           '2016_030_00', '2016_031_00', '2016_032_00', '2016_033_00', '2016_034_00', '2016_035_00', '2016_036_00', '2016_037_00', '2016_038_00', '2016_039_00',
		           '2016_040_00', '2016_041_00', '2016_042_00', '2016_043_00', '2016_044_00', '2016_045_00', '2016_046_00', '2016_047_00', '2016_048_00', '2016_049_00',
		           '2016_050_00', '2016_051_00', '2016_052_00', '2016_053_00', '2016_056_00', '2016_057_00', '2016_058_00', '2016_059_00',   # '2016_055_07',
		           '2016_060_00', '2016_061_00', '2016_062_00', '2016_063_00', '2016_064_00', '2016_065_00', '2016_066_00', '2016_067_00', '2016_068_00', '2016_069_00',
		           '2016_070_00', '2016_071_00', '2016_072_00', '2016_073_00', '2016_074_00', '2016_075_00', '2016_076_00', '2016_077_00', '2016_078_00', '2016_079_00',
		           '2016_080_00', '2016_081_00', '2016_082_00', '2016_083_00', '2016_084_00', '2016_085_00', '2016_086_00', '2016_087_00', '2016_088_00', '2016_089_00',
		           '2016_090_00', '2016_091_00', '2016_092_00', '2016_093_00', '2016_094_00', '2016_095_00', '2016_096_00', '2016_097_00', '2016_098_00', '2016_099_00',
		           '2016_100_00', '2016_101_00', '2016_102_00', '2016_103_00', '2016_104_00', '2016_107_00', '2016_108_00', '2016_109_00',
		           '2016_110_00', '2016_111_00', '2016_112_00', '2016_113_00', '2016_114_00', '2016_115_00', '2016_116_00', '2016_117_00', '2016_118_00',
		           '2016_123_00', '2016_124_00', '2016_125_00', '2016_126_00', '2016_127_00', '2016_128_00', '2016_129_00',
		           '2016_130_00', '2016_131_00', '2016_132_00', '2016_133_00', '2016_134_00', '2016_135_00', '2016_136_00', '2016_137_00', '2016_138_00', '2016_139_00',
		           '2016_140_00', '2016_141_00', '2016_142_00', '2016_143_00', '2016_144_00', '2016_145_00', '2016_146_00', '2016_147_00', '2016_148_00', '2016_149_00',
		           '2016_150_00', '2016_151_00', '2016_152_00', '2016_153_00', '2016_154_00', '2016_155_00', '2016_156_00', '2016_157_00', '2016_158_00', '2016_159_00',
		           '2016_160_00', '2016_161_00', '2016_162_00', '2016_163_00', '2016_164_00', '2016_165_00', '2016_166_00', '2016_167_00', '2016_168_00', '2016_169_00',
		           '2016_170_00', '2016_171_00', '2016_172_00', '2016_173_00', '2016_174_00', '2016_175_00', '2016_176_00', '2016_177_00', '2016_178_00', '2016_179_00',
		           '2016_180_00', '2016_181_00', '2016_182_00', '2016_183_00', '2016_184_00', '2016_185_00', '2016_186_00', '2016_187_00', '2016_188_00', '2016_189_00',
		           '2016_190_00', '2016_191_00', '2016_192_00', '2016_193_00', '2016_194_00', '2016_195_00', '2016_196_00', '2016_197_00', '2016_198_00', '2016_199_00',
		           '2016_200_00', '2016_201_00', '2016_202_00', '2016_203_00', '2016_204_00', '2016_205_00', '2016_206_00', '2016_207_00', '2016_208_00', '2016_209_00',
		           '2016_210_00', '2016_210_08', '2016_211_00', '2016_212_00', '2016_213_00', '2016_216_16', '2016_217_00', '2016_218_00', '2016_219_00', '2016_220_00',
		           '2016_221_00', '2016_223_18', '2016_224_00', '2016_225_00', '2016_226_00', '2016_227_00', '2016_228_00', '2016_229_00',
		           '2016_230_00', '2016_236_09', '2016_237_00', '2016_239_00',
		           '2016_240_00', '2016_241_00', '2016_242_00', '2016_243_00', '2016_244_07', '2016_245_00', '2016_246_00', '2016_247_00', '2016_248_00', '2016_248_06', '2016_249_00',
		           '2016_250_02', '2016_251_00', '2016_252_00', '2016_253_13', '2016_254_00', '2016_254_09', '2016_255_00', '2016_256_00', '2016_257_00', '2016_258_00']




	if (band == 'low_band') and (antenna=='blade'):

		path_data = home_folder + '/DATA/EDGES/spectra/level2/low_band/' + version + '/'

		dates   = ['2015_286_02', '2015_287_00', '2015_288_00', '2015_289_00',
		           '2015_291_00', '2015_292_00', '2015_293_00', '2015_294_00', '2015_295_00', '2015_296_00', '2015_297_00', '2015_298_00', '2015_299_00',
		           '2015_300_00', '2015_301_00', '2015_302_00', '2015_303_00',
		           '2015_310_18', '2015_311_00', '2015_312_00', '2015_313_00', '2015_314_00', '2015_315_00', '2015_316_00', '2015_317_00', '2015_318_00', '2015_319_00',
		           '2015_320_00', '2015_321_00', '2015_322_00', '2015_323_00', '2015_324_00', '2015_325_00', '2015_326_00', '2015_327_00', '2015_328_00', '2015_329_00',
		           '2015_330_00', '2015_331_00', '2015_332_00', '2015_333_00', '2015_334_00', '2015_335_00', '2015_336_00', '2015_337_00', '2015_338_00', '2015_339_00',
		           '2015_340_00', '2015_341_00', '2015_342_00', '2015_343_14', '2015_344_00', '2015_344_21', '2015_345_00', '2015_346_00', '2015_347_00', '2015_348_00', '2015_349_00',
		           '2015_350_00', '2015_351_00', '2015_352_00', '2015_353_00', '2015_354_00',
		           '2015_362_00', '2015_363_00', '2015_364_00', '2015_365_00',
		           '2016_001_00', '2016_002_00', '2016_003_00', '2016_004_00', '2016_005_00', '2016_006_00', '2016_007_00', '2016_008_00', '2016_009_00',
		           '2016_010_00', '2016_011_00', '2016_012_00', '2016_013_00', '2016_014_00', '2016_015_00', '2016_016_00', '2016_017_00', '2016_018_00', '2016_019_00',
		           '2016_020_00', '2016_028_00', '2016_029_00',
		           '2016_030_00', '2016_031_00', '2016_032_00', '2016_033_00', '2016_034_00', '2016_035_00', '2016_036_00', '2016_037_00', '2016_038_00', '2016_039_00',
		           '2016_040_00', '2016_041_00', '2016_042_00', '2016_043_00', '2016_044_00', '2016_045_00', '2016_046_00', '2016_047_00', '2016_048_00', '2016_049_00',
		           '2016_050_00', '2016_051_00', '2016_052_00', '2016_053_00', '2016_055_21', '2016_056_00', '2016_057_00', '2016_058_00', '2016_059_00',
		           '2016_060_00', '2016_061_00', '2016_062_00', '2016_063_00', '2016_064_00', '2016_065_00', '2016_066_00', '2016_067_00', '2016_068_00', '2016_069_00',
		           '2016_070_00', '2016_071_00', '2016_072_00', '2016_073_00', '2016_074_00', '2016_075_00', '2016_076_00', '2016_077_00', '2016_078_00', '2016_079_00',
		           '2016_080_00', '2016_081_00', '2016_082_00', '2016_083_00', '2016_084_00', '2016_085_00', '2016_086_00', '2016_087_00', '2016_088_00', '2016_089_00',
		           '2016_090_00', '2016_091_00', '2016_092_00', '2016_093_00', '2016_094_00', '2016_095_00', '2016_096_00', '2016_097_00', '2016_098_00', '2016_099_00',
		           '2016_100_00', '2016_101_00', '2016_102_00', '2016_103_00', '2016_104_00',
		           '2016_106_13', '2016_107_00', '2016_108_00', '2016_109_00', 
		           '2016_110_00', '2016_111_00', '2016_112_00', '2016_113_00', '2016_114_00', '2016_115_00', '2016_116_00', '2016_117_00', '2016_118_00',
		           '2016_122_16', '2016_123_00', '2016_124_00', '2016_125_00', '2016_126_00', '2016_127_00', '2016_128_00', '2016_129_00',
		           '2016_130_00', '2016_131_00', '2016_132_00', '2016_133_00', '2016_134_00', '2016_135_00', '2016_136_00', '2016_137_00', '2016_138_00', '2016_139_00',
		           '2016_140_00', '2016_141_00', '2016_142_00', '2016_143_00', '2016_144_00', '2016_145_00', '2016_146_00', '2016_147_00', '2016_148_00', '2016_149_00',
		           '2016_150_00', '2016_151_00', '2016_152_00', '2016_153_00', '2016_154_00', '2016_155_00', '2016_156_00', '2016_157_00', '2016_158_00', '2016_159_00',
		           '2016_160_00', '2016_167_00', '2016_168_00', '2016_169_00',
		           '2016_170_00', '2016_171_00', '2016_172_00', '2016_173_00',
		           '2016_180_15', '2016_181_00', '2016_182_00', '2016_183_00', '2016_184_00', '2016_185_00', '2016_186_00', '2016_187_00', '2016_188_00', '2016_189_00',
		           '2016_190_00', '2016_191_00', '2016_192_00', '2016_193_00', '2016_194_00', '2016_195_00', '2016_196_00', '2016_197_00', '2016_198_00', '2016_199_00',
		           '2016_200_00', '2016_201_00', '2016_202_00', '2016_203_00', '2016_204_00',
		           '2016_210_14', '2016_211_00', '2016_212_00']

		# Jumps: 292, 313, 314, 320, 365, 007, 43, 78, 84, 90, 100, 103, 107, 110, 113, 124, 128, 135, 145, 

		# Intermittency ??: 117, 









	# Loop over dates
	dates_numpy = np.zeros((len(dates), 3))
	flag = 0
	for i in range(len(dates)):  


		# Saving date information as numpy array
		dates_numpy[i,0] = int(dates[i][0:4])
		dates_numpy[i,1] = int(dates[i][5:8])
		dates_numpy[i,2] = int(dates[i][9::])



		# Daily data selection
		f, t_sel2, w_sel2, m_sel = data_selection_single_day_v2(band, dates[i], LST_1, LST_2, sun_el_max=sun_el_max, amb_hum_max=amb_hum_max, receiver_temp=27)



		# If there is at least 1 spectra with data in the daily selection
		#print(t_sel2)
		#ss = np.sum(t_sel2, axis=1)
		if  np.sum(t_sel2) > 0:

			print('-')
			print('---------------------------')
			print('Processing day: ' + str(dates[i]))
			print('---------------------------')


			# Averaging daily data for deeper RFI cleaning
			tav0, wav0 = spectral_averaging(t_sel2, w_sel2)


			# Median weather / receiver temperatures for each day
			# wea = np.median(wea_sel, axis=0) 


			# Continue if enough data available (weights greater than zero), no NaNs, and no indeterminate divisions 
			if (np.sum(wav0) > 0) and (np.sum(np.isnan(tav0)) == 0) and (np.sum(np.isinf(tav0)) == 0):


				# RFI-cleaning the average trace
				tav1, wav1 = RFI_excision_raw_frequency(f, tav0, wav0)
				tav, wav   = RFI_cleaning_std(f, tav1, wav1, n_sigma = 3.5, df_MHz = 20, npar = 4)


				# Run through single spectra in each daily selection
				for j in range(len(t_sel2[:,0])):

					# If the single spectrum has data
					if np.sum(t_sel2[j,wav>0]) > 0:

						# Excise channels with RFI
						t_spec = t_sel2[j,:]
						t_spec[wav==0] = 0


						# Storing single spectra
						if flag == 0:
							t_all = np.copy(t_spec).reshape(1,-1)
							w_all = np.copy(wav).reshape(1,-1)         # same weight array for all single spectra of the same day
							m_all = np.copy(m_sel[j,:]).reshape(1,-1)  
							flag  = 1					

						elif flag > 0:
							t_all = np.append(t_all, t_spec.reshape(1,-1), axis=0)
							w_all = np.append(w_all, wav.reshape(1,-1), axis=0)
							m_all = np.append(m_all, m_sel[j,:].reshape(1,-1), axis=0)



	# Save
	path_save = home_folder + '/DATA/EDGES/spectra/level3/' + band + '/v3/'
	save_file = path_save + band + '_v3_' + antenna + '_LST_' + str(LST_1) + '_' + str(LST_2) + flag_save + '.hdf5'	

	with h5py.File(save_file, 'w') as hf:
		hf.create_dataset('frequency',           data = f)
		hf.create_dataset('antenna_temperature', data = t_all)
		hf.create_dataset('weights',             data = w_all)
		hf.create_dataset('meta_data',           data = m_all)



	return f, t_all, w_all, m_all










































def RFI_cleaning_traces(f, t_2D, w_2D, n_traces, df_MHz = 10, npar = 4, n_sigma = 4):

	# Clean output arrays
	t_clean = np.copy(t_2D)
	w_clean = np.copy(w_2D)


	# Original index of traces
	index = np.arange(len(t_2D[:,0]))


	# Assigning the traces to "sets" of traces of length "n_traces"
	sets  = np.floor(index/n_traces)



	# If there is only one set of traces
	if np.max(sets) == 0:
		print('RFI cleaning: only 1 set.')
		tb, wb = spectral_averaging(t_2D, w_2D)

		print(len(f))
		print(len(tb))
		print(wb)		

		# If there are data points to clean
		if np.sum(wb) > 0:

			# Clean data
			tx, wx = RFI_cleaning_std(f, tb, wb, df_MHz = df_MHz, npar = npar, n_sigma = n_sigma)
			t_clean[:, wx==0] = 0
			w_clean[:, wx==0] = 0

		elif np.sum(wb) == 0:
			tx = np.zeros(len(f))
			wx = np.zeros(len(f))
			t_clean = np.zeros(len(f))
			w_clean = np.zeros(len(f))


		# Array of binned trace set
		t_sets = np.array([tx])
		w_sets = np.array([wx])



	# If there are many set of traces
	elif np.max(sets) > 0:



		# If last set has less than "n_traces" traces, push them to the previous set
		if len(sets[sets==np.max(sets)]) < n_traces:
			sets[sets==np.max(sets)] = np.max(sets)-1



		# Array of binned trace set
		t_sets = np.zeros((np.max(sets)+1, len(f)))
		w_sets = np.zeros((np.max(sets)+1, len(f)))



		# Apply RFI flagging to each set of traces
		for i in range(int(np.max(sets))+1):
			print('RFI cleaning: set ' + str(i) + ' of ' + str(np.max(sets)))
			index_set = index[sets == i] 
			print(index_set)
			tb, wb = spectral_averaging(t_2D[index_set,:], w_2D[index_set,:])

			# If there are data points to clean
			if np.sum(wb) > 0:

				# Clean data
				tx, wx = RFI_cleaning_std(f, tb, wb, df_MHz = df_MHz, npar = npar, n_sigma = n_sigma)
				for j in index_set:
					t_clean[j, wx == 0] = 0
					w_clean[j, wx == 0] = 0
				t_sets[i,:] = tx	
				w_sets[i,:] = wx


	return t_clean, w_clean, t_sets, w_sets

















def more_averaging():    #(f, t_2D, w_2D):


	#path_file = '/media/raul/DATA/EDGES/spectra/level3/high_band/v2/high_band_v2_blade_LST_23.76_3.76.hdf5'
	path_file = '/media/raul/DATA/EDGES/spectra/level3/low_band/v2/low_band_v2_blade_LST_23.76_9.76.hdf5'
	f, t_2D, w_2D  = level3_read_v2(path_file)




	# Spectra cleaning and binning
	# ----------------------------
	tnr_all  = np.zeros((len(t_2D[:,0]), len(f)))
	wnr_all  = np.zeros((len(t_2D[:,0]), len(f)))	


	#cg = combined_gain('high_band', f)
	cg = 1

	# Loop over spectra
	flag = 0
	for i in range(len(t_2D[:,0])):
		print(i)
		if (np.sum(w_2D[i,:]) > 0):

			flag = flag + 1


			# Calibration of spectrum
			#tc = data_calibration('high_band', 25, t_2D[i,:], f, 'blade', combined_gain = cg)
			tc = data_calibration('low_band', 25, t_2D[i,:], f, 'blade', combined_gain = cg)


			# Single spectrum RFI cleaning
			tnr, wnr    = RFI_cleaning_std(f, tc, w_2D[i,:], n_sigma=3.5)
			#fb, tb, wb = spectral_binning_fixed_frequency(90, 190, 0.4, f, tnr, wnr)
			fb, tb, wb  = spectral_binning_fixed_frequency(65, 95, 0.4, f, tnr, wnr)


			# Initializing arrays
			if flag == 1:
				res_all = np.zeros((len(t_2D[:,0]), len(fb)))
				tx_all  = np.zeros((len(t_2D[:,0]), len(fb)))
				wx_all  = np.zeros((len(t_2D[:,0]), len(fb)))
				RMS_all = np.zeros(len(t_2D[:,0]))	



			# Computing residuals

			if (np.sum(np.isnan(tb)) == 0) and (np.sum(np.isinf(tb)) == 0):

				#pp   = fit_polynomial_fourier('EDGES_polynomial', fb, tb, 10, Weights=wb)
				pp    = fit_polynomial_fourier('EDGES_polynomial', fb, tb, 5, Weights=wb)
				model = model_evaluate('EDGES_polynomial', pp[0], fb)
				res = tb - model
				RMS = np.sqrt(np.sum((res**2)[wb>0])/len(wb[wb>0]))

				# Storing clean raw spectra and weights
				tnr_all[i,:] = tnr
				wnr_all[i,:] = wnr

				# Storing clean binned spectra, weights, residuals, RMS
				tx_all[i,:]  = tb
				wx_all[i,:]  = wb
				res_all[i,:] = res
				RMS_all[i]   = RMS

			else:
				print('SPECTRUM WITH NAN')



	# RMS filter for all spectra
	# --------------------------

	RMS_median = np.median(RMS_all[RMS_all>0])
	print(RMS_median)

	for i in range(len(t_2D[:,0])):
		if (RMS_all[i] > 0) and (RMS_all[i] > 1.1*RMS_median):
			tx_all[i, :]  = 0
			wx_all[i, :]  = 0
			res_all[i, :] = 0






	# Second stage of RFI cleaning for binned spectra
	# -----------------------------------------------

	# Initializing arrays
	res_all2 = np.zeros((len(tx_all[:,0]), len(fb)))
	tx_all2  = np.zeros((len(tx_all[:,0]), len(fb)))
	wx_all2  = np.zeros((len(tx_all[:,0]), len(fb)))	

	# Looping over spectra
	for i in range(len(tx_all[:,0])):
		print(i)
		if np.sum(wx_all[i,:]) > 0:

			# Removing RFI
			tnr2, wnr2 = data_analysis_RFI_removal(fb, tx_all[i,:], wx_all[i,:], n_sigma=4.0, n_bin = 5)

			# Fitting and removing polynomial
			pp    = fit_polynomial_fourier('EDGES_polynomial', fb, tnr2, 5, Weights=wnr2)
			model = model_evaluate('EDGES_polynomial', pp[0], fb)
			res   = tnr2 - model

			# Storing clean spectrum, weights, and residuals
			tx_all2[i,:]  = tnr2
			wx_all2[i,:]  = wnr2			
			res_all2[i,:] = res






	# Remove "strange" spectra

	# This applies to file "high_band_v2_blade_LST_23.76_3.76.hdf5"
	# r1 = np.array([0,1,2,3,11,12,13,14,15,16,17,18,19,20,21,22,25,26,28,29,30,31,32,37,38,39,40,42,43,44,45,48,49,50,51,52,55,56,58,61,62,63,66,68,70,72,73,74,76,79,80,81,86,93,97,99,101,103,104,105,106,107,110,113,115,116,119,120,123,127,129,134,136,138,141,143,144,147,148,150,153])

	# This applies to file "low_band_v2_blade_LST_23.76_9.76.hdf5"
	#r1 = np.array([0,1,2,3,8,10,11,13,15,18,19,20,21,22,24,25,28,30,31,36,38,40,41,44,47,48,50,51,55,56,57,58,59,60,62,63,66,68,69,70,71,72,73,76,81,82,85,88,93,94,118,123,126,127,131,132,135,136,137,140,142,146,149,150,156])

	r1 = np.arange(0, len(tx_all2[:,0]), 1)




	#rx1 = np.arange(0, 16, 1)
	#rx2 = np.arange(128, 144, 1)
	#rx3 = np.arange(24, 32, 1)
	#rx4 = np.arange(112, 120, 1)
	#rx5 = np.arange(144, 152, 1)
	#rx6 = np.arange(40, 48, 1)

	#rx1 = np.arange(0,  10, 1)
	#rx2 = np.arange(30, 50, 1)
	#rx3 = np.arange(70, 90, 1)
	#rx4 = np.arange(120, 130, 1)
	#rx5 = np.arange(170, 180, 1)

	#rx1 = np.arange(40,   64, 1)
	#rx2 = np.arange(120, 136, 1)
	#rx3 = np.arange(72,   80, 1)
	#rx4 = np.arange(112, 120, 1)

	#ry1 = np.union1d(r0,  rx1)
	#ry2 = np.union1d(ry1, rx2)
	#ry3 = np.union1d(ry2, rx3)
	#ry4 = np.union1d(ry3, rx4)
	#ry5 = np.union1d(ry4, rx5)
	#ry6 = np.union1d(ry5, rx6)

	accepted = r1
	for i in range(len(t_2D[:,0])):
		if i not in accepted:
			tx_all2[i,:]  = np.zeros(len(fb))
			wx_all2[i,:]  = np.zeros(len(fb))
			res_all2[i,:] = np.zeros(len(fb))



	# Spectral averaging
	tt2, ww2 = spectral_averaging(tx_all2, wx_all2)

	# Fitting model
	#pp       = fit_polynomial_fourier('EDGES_polynomial', fb[45::], tt2[45::], 5, Weights=ww2[45::])
	pp       = fit_polynomial_fourier('EDGES_polynomial', fb, tt2, 5, Weights=ww2)
	mb2      = model_evaluate('EDGES_polynomial', pp[0], fb)					




	# Averaging every X traces
	K   = 6
	ll  = len(t_2D[:,0])
	Nav = round(ll/K)

	avT_K = np.zeros((Nav, len(fb)))
	avW_K = np.zeros((Nav, len(fb)))
	avR_K = np.zeros((Nav, len(fb)))

	for i in range(Nav):

		print(i)

		index1 = i*K
		if i < (Nav - 1):
			index2 = (i+1)*K

		elif i == (Nav - 1):
			index2 = ll-1


		tt2, ww2 = spectral_averaging(tx_all2[index1:index2,:], wx_all2[index1:index2,:])

		avT_K[i,:] = tt2
		avW_K[i,:] = ww2

		if np.sum(ww2) > 0:
			#pp    = fit_polynomial_fourier('EDGES_polynomial', fb[45::], tt2[45::], 5, Weights=ww2[45::])
			pp    = fit_polynomial_fourier('EDGES_polynomial', fb, tt2, 5, Weights=ww2)
			model = model_evaluate('EDGES_polynomial', pp[0], fb)
			res   = tt2 - model

			avR_K[i,:] = res 










	## MOVING Averaging every K traces
	#K = 3

	#MavT_K = np.zeros((ll-K, len(fb)))
	#MavW_K = np.zeros((ll-K, len(fb)))
	#MavR_K = np.zeros((ll-K, len(fb)))
	#for i in range(ll-K):


		#flag = 0
		#Kj   = 0
		#for j in range(K):
			#if np.sum(wx_all2[i+j,:]) > 0:
				#flag = flag+1
				#Kj   = np.copy(j)

		#if flag == 0:
			#tt2 = np.zeros(len(fb))
			#ww2 = np.zeros(len(fb))

		#elif flag == 1:
			#tt2 = np.copy(tx_all2[(i+Kj),:])
			#ww2 = np.copy(wx_all2[(i+Kj),:])

		#elif flag > 1:
			#tt2, ww2 = spectral_averaging(tx_all2[i:(i+K),:], wx_all2[i:(i+K),:])

		#MavT_K[i,:] = tt2
		#MavW_K[i,:] = ww2




		#if np.sum(ww2) > 0:
			#pp    = fit_polynomial_fourier('EDGES_polynomial', fb[45::], tt2[45::], 5, Weights=ww2[45::])
			#model = model_evaluate('EDGES_polynomial', pp[0], fb)
			#res   = tt2 - model

			#MavR_K[i,:] = res 



















	# Plotting
	# -----------------------------

	plt.close()
	plt.close()
	plt.close()
	plt.close()


	K = 1
	f1 = plt.figure(1)
	for i in range(len(t_2D[:,0])):
		plt.plot(fb, res_all2[i,:] + K*i)

	#plt.xlim([100, 190])
	plt.xlim([50, 100])
	plt.ylim([-3, K*(len(res_all2[:,0])+3)])
	plt.grid()



	K = 1
	f2 = plt.figure(2)
	for i in range(len(avR_K[:,0])):
		plt.plot(fb, avR_K[i,:] + K*i)

	#plt.xlim([100, 190])
	plt.xlim([50, 100])
	plt.ylim([-1, K*(len(avR_K[:,0])+3)])
	plt.grid()



	#K = 1
	#f3 = plt.figure(3)
	#for i in range(len(MavR_K[:,0])):
		#plt.plot(fb, MavR_K[i,:] + K*i)

	##plt.xlim([100, 190])
	#plt.xlim([50, 100])
	#plt.ylim([-1, K*(len(MavR_K[:,0])+3)])
	#plt.grid()






	return fb, tx_all2, wx_all2, res_all2, avT_K, avW_K, avR_K     #, MavR_K















def data_analysis_calibration_old(band, daily_or_season, save='no', season_file_number=1, daily_date='2015_317_00', daily_LST_1=0.76, daily_LST_2=6.76, receiver_temperature='actual', daily_sun_el_max = -10, daily_amb_hum_max = 90, daily_receiver_temp=27):

	"""

        Oct 29, 2016
	band: 'high_band_2015', etc.
        daily_or_season: 'daily', 'season'. For 'season', this function loads the data file, and applies the calibration on a day-by-day basis

	"""





	# Loading data
	if daily_or_season == 'daily':
		if band == 'high_band_2015':
			bandX = 'high_band'

		fin, t_2D, w_2D, m_2D = data_selection_single_day_v3(bandX, daily_date, daily_LST_1, daily_LST_2, sun_el_max = daily_sun_el_max, amb_hum_max = daily_amb_hum_max, receiver_temp=daily_receiver_temp)
		file_name = bandX + '_' + daily_date + '_' + daily_LST_1 + '_' + daily_LST_2








	if daily_or_season == 'season':

		if band == 'low_band_2015':

			bandX = 'low_band'
			path  = '/DATA/EDGES/spectra/level3/low_band/v3/'


			#if season_file_number == 1:
				#file_name = 'low_band_v2_blade_LST_0.76_6.76_20160823'

			#if season_file_number == 2:
				#file_name = 'low_band_v2_blade_LST_6.76_12.76_20160826'

			#if season_file_number == 3:
				#file_name = 'low_band_v2_blade_LST_12.76_18.76_20160826'

			#if season_file_number == 4:
				#file_name = 'low_band_v2_blade_LST_18.76_0.76_20160826'

			#if season_file_number == 5:
				#file_name = 'low_band_v2_blade_LST_2.76_4.76_20160905'






		if band == 'high_band_2015':

			bandX = 'high_band'
			path  = '/DATA/EDGES/spectra/level3/high_band/v3/'



			if season_file_number == 0:
				file_name = 'high_band_v3_blade_LST_0.26_1.26'

			if season_file_number == 1:
				file_name = 'high_band_v3_blade_LST_1.26_2.26'

			if season_file_number == 2:
				file_name = 'high_band_v3_blade_LST_2.26_3.26'

			if season_file_number == 3:
				file_name = 'high_band_v3_blade_LST_3.26_4.26'

			if season_file_number == 4:
				file_name = 'high_band_v3_blade_LST_4.26_5.26'

			if season_file_number == 5:
				file_name = 'high_band_v3_blade_LST_5.26_6.26'

			if season_file_number == 6:
				file_name = 'high_band_v3_blade_LST_6.26_7.26'

			if season_file_number == 7:
				file_name = 'high_band_v3_blade_LST_7.26_8.26'

			if season_file_number == 8:
				file_name = 'high_band_v3_blade_LST_8.26_9.26'

			if season_file_number == 9:
				file_name = 'high_band_v3_blade_LST_9.26_10.26'

			if season_file_number == 10:
				file_name = 'high_band_v3_blade_LST_10.26_11.26'

			if season_file_number == 11:
				file_name = 'high_band_v3_blade_LST_11.26_12.26'

			if season_file_number == 12:
				file_name = 'high_band_v3_blade_LST_12.26_13.26'

			if season_file_number == 13:
				file_name = 'high_band_v3_blade_LST_13.26_14.26'

			if season_file_number == 14:
				file_name = 'high_band_v3_blade_LST_14.26_15.26'

			if season_file_number == 15:
				file_name = 'high_band_v3_blade_LST_15.26_16.26'

			if season_file_number == 16:
				file_name = 'high_band_v3_blade_LST_16.26_17.26'

			if season_file_number == 17:
				file_name = 'high_band_v3_blade_LST_17.26_18.26'

			if season_file_number == 18:
				file_name = 'high_band_v3_blade_LST_18.26_19.26'

			if season_file_number == 19:
				file_name = 'high_band_v3_blade_LST_19.26_20.26'

			if season_file_number == 20:
				file_name = 'high_band_v3_blade_LST_20.26_21.26'

			if season_file_number == 21:
				file_name = 'high_band_v3_blade_LST_21.26_22.26'

			if season_file_number == 22:
				file_name = 'high_band_v3_blade_LST_22.26_23.26'

			if season_file_number == 23:	
				file_name = 'high_band_v3_blade_LST_23.26_0.26'


		path_file = home_folder + path + file_name + '.hdf5'
		fin, t_2D, w_2D, m_2D = level3_read_v3(path_file)






	# Settings
	ant_s11              = 'average' #262, 212  
	ground_loss_type     = 'value'   #'value'   # 'Alan', 'Tom'
	ground_loss_percent  = 0.5
	high_band_cal_file   = 1         # 1
	cwterms              = 7         # 6
	# receiver_temperature = '25' #'actual'      #'actual'  # '25' or 'actual' 




	# Combined gain / efficiency
	if band == 'high_band_2015':
		cg = combined_gain('high_band_2015', fin, antenna_s11_day = ant_s11, flag_ground_loss = 1, ground_loss_type = ground_loss_type, ground_loss_percent = ground_loss_percent, flag_antenna_loss = 1, flag_balun_connector_loss = 1, MC_ground_loss='no', MC_antenna_loss='no', MC_balun_connector='no')

	if band == 'low_band_2015':        
		#cg = combined_gain('low_band', fin, antenna_s11_day = 'average', flag_ground_loss = 1, ground_loss_type = 'value', ground_loss_percent = 0.0, flag_antenna_loss = 1, flag_balun_connector_loss = 1)
		cg = 1



	# Loop over day-average spectra
	flag = 0	
	for k in range(len(t_2D[:,0])):


		# Antenna S11 file based on date
		if (wea[k,0] == 2015) and (wea[k,1] <= 237):
			s11_day = 212

		elif (wea[k,0] == 2015) and (wea[k,1] > 237):
			s11_day = 262

		elif (wea[k,0] == 2016):
			s11_day = 262	

		#s11_day = 'average'




		# If spectrum has data
		if np.sum(w_2D[k,:]) > 0:

			print(k)


			# Average beam factor for the specific traces averaged
			if daily_or_season == 'daily':
				LST_sel = LST[k, :]

			if daily_or_season == 'season':
				LST_sel = LST[(LST[:,0]==wea[k,0]) & (LST[:,1]==wea[k,1]), :]




			if band == 'high_band_2015':
				#beam_factor = antenna_beam_factor_interpolation(band, np.array([LST_sel]), fin, case_beam_factor=1)
				beam_factor = antenna_beam_factor_interpolation(band, LST_sel[:,3], fin, case_beam_factor=1)
				#beam_factor = 1

			if band == 'low_band_2015':
				#beam_factor = antenna_beam_factor_interpolation(LST_sel, fin)
				beam_factor = 1






			# Calibration

			# Median receiver temperature for the period
			if (receiver_temperature == '25') or (receiver_temperature == 'actual'):
				if receiver_temperature == '25':
					RecTemp = 25

				elif receiver_temperature == 'actual':
					RecTemp = wea[k,-2]-0.4

				# Calibration
				print('Year ' + str(wea[k,0]) + ', Day ' + str(wea[k,1]) + '. Receiver temperature: ' + str(RecTemp))
				print('--------------------------------------------------------------------')			
				tc = data_calibration(band, RecTemp, t_2D[k,:], fin, 'blade', antenna_s11_day = s11_day, combined_gain = cg, high_band_cal_file = high_band_cal_file, beam_factor = beam_factor, cwterms=cwterms, MC_s11_ant_mag='no', MC_s11_ant_ang='no', MC_receiver='no')   # 'average'        
				wc = np.copy(w_2D[k,:])
				tc[wc==0] = 0
				best_temp = RecTemp



			elif receiver_temperature == 'optimal':
				if wea[k,-2] == 0:
					RecTemp = 25

				elif wea[k,-2] > 0:
					RecTemp = wea[k,-2]


				print('Year ' + str(wea[k,0]) + ', Day ' + str(wea[k,1]) + '. Receiver temperature: ' + str(RecTemp))
				print('--------------------------------------------------------------------')
				for j in range(41):
					OffTemp = (0.1*j-2)

					tc0 = data_calibration(band, RecTemp+OffTemp, t_2D[k,:], fin, 'blade', antenna_s11_day = s11_day, combined_gain = cg, high_band_cal_file = high_band_cal_file, beam_factor = beam_factor, cwterms=cwterms, MC_s11_ant_mag='no', MC_s11_ant_ang='no', MC_receiver='no')   # 'average'        
					wc0 = np.copy(w_2D[k,:])
					tc0[wc0==0] = 0

					fb, rb, wb, rr, rrx = data_analysis_residuals_array(fin, tc0.reshape(1,-1), wc0.reshape(1,-1), flow=89, fhigh=191, model_type='Physical_model', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')

					print('FILE NUMBER: ' + str(season_file_number) + ', HOLA ITERATION: '+ str(j) +', Temp: ' + str(RecTemp+OffTemp) + 'degC, RMS: ' + str(int(10000*rrx)/10) + ' mK')
					print(' ')
					print(' ')

					if j == 0:
						RR        = np.copy(rr)
						best_j    = np.copy(j)
						best_temp = np.copy(RecTemp)
						tc        = np.copy(tc0)
						wc        = np.copy(wc0)


					elif j > 0:
						if rr < RR:
							RR        = np.copy(rr)
							best_j    = np.copy(j)
							best_temp = np.copy(RecTemp+OffTemp)
							tc        = np.copy(tc0)
							wc        = np.copy(wc0)

				print('--------------------------------------------')
				print('BEST iteration:  ' + str(best_j))
				print('BEST residuals:  ' + str(int(10000*RR)/10) + ' mK')
				print('BEST temperature: ' + str(best_temp) + 'degC')
				print('--------------------------------------------')
				print(' ')
				print(' ')
				print(' ')
				print(' ')






			# Storing outputs
			if flag == 0:
				tc_all = np.copy(tc)
				wc_all = np.copy(wc)
				wea_all = np.copy(wea[k,:])
				LST_all = np.copy(LST[k,:])
				best_temp_all = np.copy(best_temp)
				flag = 1

			elif flag > 0:
				tc_all  = np.vstack((tc_all, tc))
				wc_all  = np.vstack((wc_all, wc))
				wea_all = np.vstack((wea_all, wea[k,:]))
				LST_all = np.vstack((LST_all, LST_sel))
				best_temp_all = np.vstack((best_temp_all, best_temp))



	# Saving data
	if save == 'yes':
		path_save = home_folder + '/DATA/EDGES/spectra/level4/'
		save_file = path_save + bandX + '/' + file_name + '.hdf5'	

		with h5py.File(save_file, 'w') as hf:
			hf.create_dataset('frequency',        data = fin)
			hf.create_dataset('sky_temperature',  data = tc_all)
			hf.create_dataset('weights',          data = wc_all)
			hf.create_dataset('weather_receiver', data = wea_all)
			hf.create_dataset('LST',              data = LST_all)
			hf.create_dataset('best_temp_all',    data = best_temp_all)



	return fin, tc_all, wc_all, wea_all, LST_all, best_temp_all














































def plot_average_high_band(fx, tx_all, wx_all, rx_all, wea, LST):


	flow  = np.min(fx)
	fhigh = np.max(fx)	




	#rejected  = [4, 17, 24, 43, 50, 54, 55, 59, 68, 72, 78, 80, 86, 90, 105, 140, 146, 150, 151, 153]   (For 23.76-3.76)


	#rejected = [26,30,31,40,44,48,49,51,54,55,56,65,76,77,80,82,83,87,91,92,94,96,97,103,113,115,116,140,142,143,151,159,175,197]  # (for 3.76-7.76)


	# File 3.76 - 7.76
	#accepted = np.array([[2015, 238], [2015, 251], [2015, 252], [2015, 253], 
				#[2015, 254], [2015, 255], [2015, 256], [2015, 257],
				#[2015, 258], [2015, 265], [2015, 266], [2015, 267],
				#[2015, 269], [2015, 270], [2015, 271], [2015, 273], 
				#[2015, 274], [2015, 278], [2015, 279], [2015, 280],
				#[2015, 281], [2015, 282], [2015, 283], [2015, 284],
				#[2015, 287], [2015, 288], [2015, 291], [2015, 296],
				#[2015, 298], [2015, 313], [2015, 315], [2015, 316],
				#[2015, 317], [2015, 321], [2015, 322], [2015, 323],
				#[2015, 324], [2015, 326], [2015, 327], [2015, 328],
				#[2015, 329], [2015, 330], [2015, 334], [2015, 336],
				#[2015, 341], [2015, 345], [2015, 354], [2015, 355],
				#[2015, 356], [2015, 357], [2015, 361], [2015, 362],
				#[2015, 364], [2015, 365], [2016, 7],   [2016, 9],
				#[2016, 12],  [2016, 13],  [2016, 15],  [2016, 16],
				#[2016, 18],  [2016, 19],  [2016, 28],  [2016, 29],
				#[2016, 30],  [2016, 36],  [2016, 38],  [2016, 43],
				#[2016, 44],  [2016, 46],  [2016, 47],  [2016, 51],
				#[2016, 58],  [2016, 60],  [2016, 62],  [2016, 64],
				#[2016, 65],  [2016, 66],  [2016, 67],  [2016, 68],
				#[2016, 69],  [2016, 70],  [2016, 71],  [2016, 73],
				#[2016, 74],  [2016, 77],  [2016, 78],  [2016, 80],
				#[2016, 83],  [2016, 87],  [2016, 88]])


	# File 23.76 - 3.76
	#accepted = wea[:,0:2]
	#accepted = np.array([[2015, 207], [2015, 208], [2015, 209], [2015, 211],
				#[2015, 215], [2015, 217], [2015, 224], [2015, 225],
				#[2015, 226], [2015, 227], [2015, 235], [2015, 237],
				#[2015, 238], [2015, 241], [2015, 242], [2015, 243],
				#[2015, 250], [2015, 251], [2015, 252], [2015, 253],
				#[2015, 255], [2015, 260], [2015, 267], [2015, 268],
				#[2015, 269], [2015, 270], [2015, 271], [2015, 274],
				#[2015, 280], [2015, 284], [2015, 286], [2015, 289],
				#[2015, 292], [2015, 293], [2015, 298], [2015, 299],
				#[2015, 301], [2015, 313], [2015, 314], [2015, 317],
				#[2015, 318], [2015, 319], [2015, 322], [2015, 323],
				#[2015, 324], [2015, 325], [2015, 326], [2015, 332],
				#[2015, 333], [2015, 334], [2015, 336], [2015, 337],
				#[2015, 338], [2015, 339], [2015, 341], [2015, 342],
				#[2015, 343], [2015, 344], [2015, 345], [2015, 346],
				#[2015, 347], [2015, 348], [2015, 350], [2015, 352],
				#[2015, 353], [2015, 354], [2015, 355], [2015, 356],
				#[2015, 359], [2015, 361], [2015, 362], [2015, 364],
				#[2015, 365], [2016, 2],   [2016, 3],   [2016, 4],
				#[2016, 7],   [2016, 186], [2016, 195], [2016, 197],
				#[2016, 198], [2016, 202], [2016, 204], [2016, 205],
				#[2016, 206], [2016, 207], [2016, 208], [2016, 210],
				#[2016, 211], [2016, 212]])



	# File 23.76 - 9.76    (Best range:   50-90)
	#accepted = np.array([[2015, 207], [2015, 208], [2015, 209], [2015, 211],
				#[2015, 215], [2015, 217], [2015, 218], [2015, 221],
				#[2015, 222], [2015, 224], [2015, 226], [2015, 227],
				#[2015, 229], [2015, 235], [2015, 237], [2015, 238],
				#[2015, 242], [2015, 243], [2015, 250], [2015, 251],
				#[2015, 252], [2015, 255], [2015, 257], [2015, 258],
				#[2015, 260], [2015, 261], [2015, 262], [2015, 265],
				#[2015, 266], [2015, 267], [2015, 268], [2015, 269],
				#[2015, 270], [2015, 271], [2015, 273], [2015, 274],
				#[2015, 275], [2015, 278], [2015, 279], [2015, 280],
				#[2015, 281], [2015, 282], [2015, 283], [2015, 284],
				#[2015, 286], [2015, 287], [2015, 288], [2015, 289],
				#[2015, 291], [2015, 292], [2015, 296], [2015, 298],
				#[2015, 315], [2015, 317], [2015, 318], [2015, 319],
				#[2015, 321], [2015, 322], [2015, 324], [2015, 326],
				#[2015, 327], [2015, 329], [2015, 330], [2015, 339],
				#[2015, 340], [2015, 341], [2015, 343], [2015, 344],
				#[2015, 345], [2015, 353], [2015, 354], [2015, 355],
				#[2015, 356], [2015, 361], [2015, 362], [2015, 364],
				#[2015, 365], [2016, 1], [2016, 8], [2016, 9],
				#[2016, 10], [2016, 12], [2016, 15], [2016, 16],
				#[2016, 17], [2016, 18], [2016, 19], [2016, 32],
				#[2016, 33], [2016, 34], [2016, 36], [2016, 37],
				#[2016, 38], [2016, 41], [2016, 42], [2016, 43],
				#[2016, 44], [2016, 49], [2016, 50], [2016, 51],
				#[2016, 52], [2016, 53], [2016, 56], [2016, 58],
				#[2016, 60], [2016, 64], [2016, 65], [2016, 66],
				#[2016, 67], [2016, 68], [2016, 69], [2016, 73],
				#[2016, 83], [2016, 88], [2016, 90], [2016, 91],
				#[2016, 92], [2016, 93], [2016, 94], [2016, 95],
				#[2016, 96], [2016, 97], [2016, 98], [2016, 99],
				#[2016, 102], [2016, 103], [2016, 108], [2016, 111],
				#[2016, 115], [2016, 117], [2016, 123], [2016, 125],
				#[2016, 127], [2016, 128], [2016, 130], [2016, 132],
				#[2016, 175], [2016, 178], [2016, 179], [2016, 181],
				#[2016, 185], [2016, 186], [2016, 195], [2016, 197],
				#[2016, 198], [2016, 204], [2016, 205], [2016, 206],
				#[2016, 207], [2016, 210], [2016, 211], [2016, 212]])



	# File 0.76 - 6.76   
	accepted = np.array([[2015, 209], [2015, 215], [2015, 217], [2015, 221],
	                     [2015, 222], [2015, 224], [2015, 225], [2015, 226],
	                     [2015, 227], [2015, 235], [2015, 236], [2015, 237],
	                     [2015, 238], [2015, 242], [2015, 243], [2015, 245],
	                     [2015, 250], [2015, 251], [2015, 252], [2015, 256],
	                     [2015, 257], [2015, 258], [2015, 259], [2015, 260],
	                     [2015, 261], [2015, 265], [2015, 266], [2015, 267],
	                     [2015, 268], [2015, 269], [2015, 270], [2015, 271],
	                     [2015, 274], [2015, 278], [2015, 279], [2015, 280],
	                     [2015, 281], [2015, 282], [2015, 283], [2015, 284],
	                     [2015, 285], [2015, 286], [2015, 287], [2015, 288],
	                     [2015, 289], [2015, 291], [2015, 292], [2015, 296],
	                     [2015, 298], [2015, 312], [2015, 313], [2015, 314],
	                     [2015, 315], [2015, 316], [2015, 317], [2015, 318],
	                     [2015, 319], [2015, 321], [2015, 322], [2015, 324],
	                     [2015, 325], [2015, 326], [2015, 327], [2015, 328],
	                     [2015, 329], [2015, 333], [2015, 334], [2015, 340],
	                     [2015, 341], [2015, 343], [2015, 344], [2015, 345],
	                     [2015, 354], [2015, 360], [2015, 361], [2015, 364],
	                     [2016, 2],   [2016, 6],   [2016, 7],   [2016, 13],
	                     [2016, 18],  [2016, 19],  [2016, 31],  [2016, 36],
	                     [2016, 41],  [2016, 51],  [2016, 55],  [2016, 60],
	                     [2016, 63],  [2016, 65],  [2016, 66],  [2016, 67],
	                     [2016, 197], [2016, 202], [2016, 204], [2016, 206],
	                     [2016, 210], [2016, 211], [2016, 212]])


	#accepted = np.array([[2015, 207],[2015, 208],[2015, 209], [2015, 215], [2015, 217], [2015, 218], [2015, 221],
				#[2015, 222],[2015, 223], [2015, 224], [2015, 225], [2015, 226],
				#[2015, 227],[2015, 229], [2015, 230], [2015, 235],[2015, 236], [2015, 237],
				#[2015, 238], [2015, 240],[2015, 242], [2015, 243], [2015, 245],
				#[2015, 250], [2015, 251], [2015, 252], [2015, 253],[2015, 254],[2015, 255],[2015, 256],
				#[2015, 257], [2015, 258], [2015, 259], [2015, 260],
				#[2015, 261], [2015, 262], [2015, 265], [2015, 266], [2015, 267],
				#[2015, 268], [2015, 269], [2015, 270], [2015, 271], [2015, 273],
				#[2015, 274], [2015, 278], [2015, 279], [2015, 280],
				#[2015, 281], [2015, 282], [2015, 283], [2015, 284],
				#[2015, 285], [2015, 286], [2015, 287], [2015, 288],
				#[2015, 289], [2015, 291], [2015, 292], [2015, 293], [2015, 296],
				#[2015, 298], [2015, 299], [2015, 311], [2015, 312], [2015, 313], [2015, 314],
				#[2015, 315], [2015, 316], [2015, 317], [2015, 318],
				#[2015, 319], [2015, 321], [2015, 322], [2015, 223], [2015, 324],
				#[2015, 325], [2015, 326], [2015, 327], [2015, 328],
				#[2015, 329], [2015, 330], [2015, 333], [2015, 334], [2015, 340],
				#[2015, 341], [2015, 343], [2015, 344], [2015, 345], [2015, 346], [2015, 348], [2015, 350],
				#[2015, 354], [2015, 355], [2015, 356], [2015, 357], [2015, 360], [2015, 361], [2015, 364], [2015, 365], 
				#[2016, 1],   [2016, 2],   [2016, 4], [2016, 6],   [2016, 7], [2016, 8], [2016, 9],[2016, 10],[2016, 11], [2016, 12], [2016, 13],
				#[2016, 18],  [2016, 19],  [2016, 31],  [2016, 36],
				#[2016, 41],  [2016, 51],  [2016, 55],  [2016, 60],
				#[2016, 63],  [2016, 65],  [2016, 66],  [2016, 67],
				#[2016, 197], [2016, 202], [2016, 204], [2016, 206],
				#[2016, 210], [2016, 211], [2016, 212]])

	#accepted = np.array([[2015, 227], [2015, 229], [2015, 230], [2015, 235],[2015, 236], [2015, 237],
				#[2015, 238], [2015, 240], [2015, 242], [2015, 243], [2015, 245], [2015, 250], [2015, 251], [2015, 252], [2015, 253],[2015, 254],[2015, 255],[2015, 256],
				#[2015, 257], [2015, 258], [2015, 259], [2015, 260], [2015, 261], [2015, 262], [2015, 265], [2015, 266], [2015, 267],
				#[2015, 268], [2015, 269], [2015, 270], [2015, 273], [2015, 274], [2015, 275], [2015, 279], [2015, 280], [2015, 286], [2015, 293], [2015, 298], [2015, 299],
				#[2015, 311], [2015, 312], [2015, 313], [2015, 314], [2015, 315], [2015, 316], [2015, 317], [2015, 318], [2015, 319], [2015, 321], [2015, 322], [2015, 223], [2015, 324],
				#[2015, 325], [2015, 326], [2015, 327], [2015, 328], [2015, 329], [2015, 330], [2015, 333], [2015, 334], [2015, 340],
				#[2015, 341], [2015, 343], [2015, 344], [2015, 345], [2015, 346], [2015, 348], [2015, 350], [2015, 354], [2015, 355], [2015, 356], [2015, 357], [2015, 360], [2015, 361], [2015, 364], [2015, 365],
				#[2016, 1],   [2016, 2],   [2016, 4], [2016, 6],   [2016, 7], [2016, 8], [2016, 9],[2016, 10],[2016, 11], [2016, 12], [2016, 13],
				#[2016, 18],  [2016, 19],  [2016, 31],  [2016, 36], [2016, 41],  [2016, 51],  [2016, 55],   [2016, 60],
				#[2016, 63],  [2016, 65],  [2016, 66],  [2016, 67],[2016, 197], [2016, 202], [2016, 204], [2016, 206],[2016, 210], [2016, 211], [2016, 212]])











	flag = 0
	for i in range(len(tx_all[:,0])):
		for j in range(len(accepted)):
			if (wea[i,0] == accepted[j,0]) and (wea[i,1] == accepted[j,1]):
				print(wea[i,0:2])
				if flag == 0:
					tx_raw0  = tx_all[i,:]
					rx_raw0  = rx_all[i,:]
					wx_raw0  = wx_all[i,:]
					wea_new0 = wea[i,:]
					flag = 1

				elif flag > 0:
					tx_raw0  = np.vstack((tx_raw0,  tx_all[i,:]))
					rx_raw0  = np.vstack((rx_raw0,  rx_all[i,:]))
					wx_raw0  = np.vstack((wx_raw0,  wx_all[i,:]))
					wea_new0 = np.vstack((wea_new0, wea[i,:]))


	n_sigma = 3
	npar    = 5
	df_MHz  = 20


	tx_raw = np.copy(tx_all)
	rx_raw = np.copy(rx_all)
	wx_raw = np.copy(wx_all)
	wea_new = np.copy(wea)





	#rav1, wav1 = spectral_averaging(rx_raw[0:66,:], wx_raw[0:66,:])
	#rav2, wav2 = spectral_averaging(rx_raw[66:134,:], wx_raw[66:134,:])
	#rav3, wav3 = spectral_averaging(rx_raw[134::,:], wx_raw[134::,:])


	#rav1_nr, wav1_nr = RFI_cleaning_std(fx, rav1, wav1, df_MHz = df_MHz, npar = npar, n_sigma = n_sigma)
	#rav2_nr, wav2_nr = RFI_cleaning_std(fx, rav2, wav2, df_MHz = df_MHz, npar = npar, n_sigma = n_sigma)
	#rav3_nr, wav3_nr = RFI_cleaning_std(fx, rav3, wav3, df_MHz = df_MHz, npar = npar, n_sigma = n_sigma)


	#rav_12 = np.vstack((rav1_nr, rav2_nr))
	#wav_12 = np.vstack((wav1_nr, wav2_nr))




	#rav_x, wav_x   = spectral_averaging(rx_raw[N1:N2,:], wx_raw[N1:N2,:])
	#rav_x1, wav_x1 = RFI_cleaning_std(fx, rav_x, wav_x, df_MHz = df_MHz, npar = npar, n_sigma = n_sigma)
	#fb, rb, wb = spectral_binning_fixed_frequency(flow, fhigh, 0.4, fx, rav_x1, wav_x1)
	#fb1 = np.copy(fb)
	#rb1 = np.copy(rb)
	#wb1 = np.copy(wb)



	#for i in range(round(len(tx_raw0[:,0])/2)):

		#n_traces = np.copy(i+1)
		#print(n_traces)

		#if n_traces < 9:
			#df_MHz = 40
			#npar = 5
			#n_sigma = 3.5

		#elif n_traces >= 9:
			#df_MHz = 20
			#npar = 5
			#n_sigma = 3.5


		#tx_raw0, wx_raw0, t_sets, w_sets = RFI_cleaning_traces(fx, tx_raw0, wx_raw0, n_traces, df_MHz = df_MHz, npar = npar, n_sigma = n_sigma)




	n_traces = 4
	t_clean0, w_clean0, t_sets0, w_sets0 = RFI_cleaning_traces(fx, tx_raw0,  wx_raw0,  n_traces, df_MHz = 40, npar = 5, n_sigma = 3.5)

	n_traces = 9
	t_clean1, w_clean1, t_sets1, w_sets1 = RFI_cleaning_traces(fx, t_clean0, w_clean0, n_traces, df_MHz = 20, npar = 5, n_sigma = 3.5)	

	n_traces = 16
	t_clean2, w_clean2, t_sets2, w_sets2 = RFI_cleaning_traces(fx, t_clean1, w_clean1, n_traces, df_MHz = 20, npar = 5, n_sigma = 3.5)

	n_traces = 25
	t_clean3, w_clean3, t_sets3, w_sets3 = RFI_cleaning_traces(fx, t_clean2, w_clean2, n_traces, df_MHz = 20, npar = 5, n_sigma = 3.5)

	n_traces = 36
	t_clean4, w_clean4, t_sets4, w_sets4 = RFI_cleaning_traces(fx, t_clean3, w_clean3, n_traces, df_MHz = 20, npar = 5, n_sigma = 3.5)	

	n_traces = 49
	t_clean, w_clean, t_sets, w_sets     = RFI_cleaning_traces(fx, t_clean4, w_clean4, n_traces, df_MHz = 20, npar = 5, n_sigma = 3.5)		


	r_sets = np.zeros((len(t_sets[:,0]), len(t_sets[0,:])))
	for i in range(len(t_sets[:,0])):
		pp          = fit_polynomial_fourier('EDGES_polynomial', fx/150, t_sets[i,:], 5, Weights=w_sets[i,:])
		model       = model_evaluate('EDGES_polynomial', pp[0], fx/150)
		r_sets[i,:] = t_sets[i,:] - model

















	#t_clean = np.copy(tx_raw0)
	#w_clean = np.copy(wx_raw0)


	N1 = 0
	N2 = 40	


	tav_x, wav_x   = spectral_averaging(t_clean[N1:N2,:], w_clean[N1:N2,:])
	pp    = fit_polynomial_fourier('Physical_model', fx/150, tav_x, 5, Weights=wav_x)    #  'Physical_model' 'EDGES_polynomial'
	model = model_evaluate('Physical_model', pp[0], fx/150)
	res   = tav_x-model
	rr, ww = RFI_cleaning_std(fx, res, wav_x, df_MHz = df_MHz, npar = npar, n_sigma = n_sigma)
	fb2, rb2, wb2 = spectral_binning_fixed_frequency(flow, fhigh, 0.4, fx, rr, ww)


	plt.close()
	plt.close()
	plt.close()
	plt.close()




	fig = plt.figure(5)
	ax  = fig.add_subplot(111)
	plt.plot(fb2[wb2>0], 1000*(rb2[wb2>0]), 'k', linewidth=3)
	plt.grid()
	plt.ylim([-150, 150])
	ax.set_yticks([-150, -100, -50, 0, 50, 100, 150])
	ax.set_yticklabels([])
	plt.xlabel('frequency [MHz]')
	plt.ylabel(r'$\Delta$ T  [50 mK / Div]')
	#plt.legend(loc=0)	






	flag = 0
	for i in range(len(rx_raw[:,0])):		

		if flag == 0:
			#residuals_raw =  rx_raw[i,:]
			#weights_raw   =  wx_all[i,:]
			#vert_raw.append(K*i)

			fb, rb, wb   = spectral_binning_fixed_frequency(flow, fhigh, 0.4, fx, rx_raw[i,:], wx_raw[i,:])
			rb_nr, wb_nr = RFI_cleaning_std(fb, rb, wb, n_sigma = 2.5, df_MHz = 20, npar = 4)
			residuals    = rb_nr
			weights      = wb_nr
			flag         = flag+1


		elif flag > 0:

			#residuals_raw = np.vstack((residuals_raw, r_all[i,:]))
			#weights_raw   = np.vstack((weights_raw,   w_all[i,:]))			
			#vert_raw.append(K*i)

			fb, rb, wb   = spectral_binning_fixed_frequency(flow, fhigh, 0.4, fx, rx_raw[i,:], wx_raw[i,:])
			rb_nr, wb_nr = RFI_cleaning_std(fb, rb, wb, n_sigma = 2.5, df_MHz = 20, npar = 4)
			residuals    = np.vstack((residuals, rb_nr))
			weights      = np.vstack((weights, wb_nr))
			flag         = flag+1









	size_y = 21
	ll = len(residuals[:,0])
	NC = np.ceil(ll/45)
	size_x = NC*6
	K = 0.5


	fig = plt.figure(num=2, figsize=(size_x, size_y))


	ax = fig.add_subplot(1,NC,1)
	if ll > 45:
		ll2 = 45
	else:
		ll2 = ll


	for i in np.arange(0,ll2):
		if (i % 2 == 0):
			ax.plot(fb[weights[i,:]>0], -residuals[i,weights[i,:]>0] + K*i, 'b')
		else:
			ax.plot(fb[weights[i,:]>0], -residuals[i,weights[i,:]>0] + K*i, 'r')
		ax.text(192, K*i+0.0, str(int(round(np.std(1000*residuals[i,weights[i,:]>0]))))+' mK', fontsize=8)
	plt.xlim([80, 210])
	plt.ylim([-K*1, K*45])
	plt.xlabel(r'$\nu$ [MHz]')
	plt.ylabel('day of year')
	ax.invert_yaxis()
	ax.set_yticks(K*np.arange(0,45,1))
	day_int = [int(l) for l in wea_new[0:45,1].tolist()]
	ax.set_yticklabels(day_int)



	if ll > 45:
		if ll > 90:
			ll2 = 90
		else:
			ll2 = ll		

		ax = fig.add_subplot(1,NC,2)
		for i in np.arange(45,ll2):
			if (i % 2 == 0):
				ax.plot(fb[weights[i,:]>0], -residuals[i,weights[i,:]>0] + K*i, 'b')
			else:
				ax.plot(fb[weights[i,:]>0], -residuals[i,weights[i,:]>0] + K*i, 'r')		
			ax.text(192, K*i+0.0, str(int(round(np.std(1000*residuals[i,weights[i,:]>0]))))+' mK', fontsize=8)
		plt.xlim([80, 210])	
		plt.ylim([K*44, K*90])
		plt.xlabel(r'$\nu$ [MHz]')
		ax.invert_yaxis()
		ax.set_yticks(K*np.arange(45,90,1))
		day_int = [int(l) for l in wea_new[45:90,1].tolist()]
		ax.set_yticklabels(day_int)




	if ll > 90:
		if ll > 135:
			ll2 = 135
		else:
			ll2 = ll		

		ax = fig.add_subplot(1,NC,3)
		for i in np.arange(90,ll2):
			if (i % 2 == 0):
				ax.plot(fb[weights[i,:]>0], -residuals[i,weights[i,:]>0] + K*i, 'b')
			else:
				ax.plot(fb[weights[i,:]>0], -residuals[i,weights[i,:]>0] + K*i, 'r')
			ax.text(192, K*i+0.0, str(int(round(np.std(1000*residuals[i,weights[i,:]>0]))))+' mK', fontsize=8)
		plt.xlim([80, 210])	
		plt.ylim([K*89, K*135])
		plt.xlabel(r'$\nu$ [MHz]')
		ax.invert_yaxis()
		ax.set_yticks(K*np.arange(90,135,1))
		day_int = [int(l) for l in wea_new[90:135,1].tolist()]
		ax.set_yticklabels(day_int)




	if ll > 135:
		if ll > 180:
			ll2 = 180
		else:
			ll2 = ll		

		ax = fig.add_subplot(1,NC,4)
		for i in np.arange(135,ll2):
			if (i % 2 == 0):
				ax.plot(fb[weights[i,:]>0], -residuals[i,weights[i,:]>0] + K*i, 'b')
			else:
				ax.plot(fb[weights[i,:]>0], -residuals[i,weights[i,:]>0] + K*i, 'r')
			ax.text(192, K*i+0.0, str(int(round(np.std(1000*residuals[i,weights[i,:]>0]))))+' mK', fontsize=8)
		plt.xlim([80, 210])
		plt.ylim([K*134, K*180])
		plt.xlabel(r'$\nu$ [MHz]')
		ax.invert_yaxis()
		ax.set_yticks(K*np.arange(135,180,1))
		day_int = [int(l) for l in wea_new[135:180,1].tolist()]
		ax.set_yticklabels(day_int)	




	if ll > 180:
		if ll > 225:
			ll2 = 225
		else:
			ll2 = ll		

		ax = fig.add_subplot(1,NC,5)	
		for i in np.arange(180,ll2):
			if (i % 2 == 0):
				ax.plot(fb[weights[i,:]>0], -residuals[i,weights[i,:]>0] + K*i, 'b')
			else:
				ax.plot(fb[weights[i,:]>0], -residuals[i,weights[i,:]>0] + K*i, 'r')
			ax.text(192, K*i+0.0, str(int(round(np.std(1000*residuals[i,weights[i,:]>0]))))+' mK', fontsize=8)	
		plt.xlim([80, 210])
		plt.ylim([K*179, K*225])
		plt.xlabel(r'$\nu$ [MHz]')
		ax.invert_yaxis()
		ax.set_yticks(K*np.arange(180,225,1))
		day_int = [int(l) for l in wea_new[180:len(residuals[:,0]),1].tolist()]
		ax.set_yticklabels(day_int)	




	if ll > 225:
		if ll > 270:
			ll2 = 270
		else:
			ll2 = ll		

		ax = fig.add_subplot(1,NC,6)
		for i in np.arange(225,ll2):
			if (i % 2 == 0):
				ax.plot(fb[weights[i,:]>0], -residuals[i,weights[i,:]>0] + K*i, 'b')
			else:
				ax.plot(fb[weights[i,:]>0], -residuals[i,weights[i,:]>0] + K*i, 'r')
			ax.text(192, K*i+0.0, str(int(round(np.std(1000*residuals[i,weights[i,:]>0]))))+' mK', fontsize=8)
		plt.xlim([80, 210])
		plt.ylim([K*224, K*270])
		plt.xlabel(r'$\nu$ [MHz]')
		ax.invert_yaxis()
		ax.set_yticks(K*np.arange(225,270,1))
		day_int = [int(l) for l in wea_new[225:len(residuals[:,0]),1].tolist()]
		ax.set_yticklabels(day_int)	




	if ll > 270:
		if ll > 315:
			ll2 = 315
		else:
			ll2 = ll		

		ax = fig.add_subplot(1,NC,7)
		for i in np.arange(270,ll2):
			if (i % 2 == 0):
				ax.plot(fb[weights[i,:]>0], -residuals[i,weights[i,:]>0] + K*i, 'b')
			else:
				ax.plot(fb[weights[i,:]>0], -residuals[i,weights[i,:]>0] + K*i, 'r')
			ax.text(192, K*i+0.0, str(int(round(np.std(1000*residuals[i,weights[i,:]>0]))))+' mK', fontsize=8)
		plt.xlim([80, 210])
		plt.ylim([K*269, K*315])
		plt.xlabel(r'$\nu$ [MHz]')
		ax.invert_yaxis()
		ax.set_yticks(K*np.arange(270,315,1))
		day_int = [int(l) for l in wea_new[270:len(residuals[:,0]),1].tolist()]
		ax.set_yticklabels(day_int)


	plt.savefig(home_folder + '/Desktop/daily_residuals.pdf', bbox_inches='tight')
	plt.close()	








	## Plot of the LSTs observed for each day
	#for k in range(len(index_new)):
		#LST_sel = LST[(LST[:,0] == wea_new[k,0]) & (LST[:,1] == wea_new[k,1]), 3]

		#if len(LST_sel[LST_sel > 12]) > 0:

			#LST_sel_1 = LST_sel[LST_sel > 12] - 24

			#if len(LST_sel[LST_sel < 12]) > 0:
				#LST_sel_0 = LST_sel[LST_sel < 12]
				#LST_max = np.max(LST_sel_0)

			#else:
				#LST_max = np.max(LST_sel_1)

			#LST_min = np.min(LST_sel_1)

		#else:
			#LST_max = np.max(LST_sel)
			#LST_min = np.min(LST_sel)

		#if k == 0:
			#LST_min_all = np.copy(LST_min)
			#LST_max_all = np.copy(LST_max)

		#else:
			#LST_min_all = np.append(LST_min_all, LST_min)
			#LST_max_all = np.append(LST_max_all, LST_max)

	#plt.figure(3)

	#plt.plot(wea_new[wea_new[:,0]==2016,1], LST_min_all[wea_new[:,0]==2016] - 0.0, 'd', markerfacecolor='none', markeredgecolor='g', label='2016')
	#plt.plot(wea_new[wea_new[:,0]==2016,1], LST_max_all[wea_new[:,0]==2016] - 0.0, 'd', markerfacecolor='none', markeredgecolor='m', label='2016')

	#plt.plot(wea_new[wea_new[:,0]==2015,1], LST_min_all[wea_new[:,0]==2015], 'b.', label='2015')
	#plt.plot(wea_new[wea_new[:,0]==2015,1], LST_max_all[wea_new[:,0]==2015], 'r.', label='2015')

	#plt.legend(loc=0)
	#plt.xlabel('day of year')
	#plt.ylabel('LST [hr]')
	#plt.xlim([0, 360])
	#plt.ylim([3, 8])
	#plt.grid()


	return fx, r_sets, w_sets #tx_raw0, wx_raw0   #fb2, rb2, wb2, tx_raw0  #, LST_min_all, LST_max_all     #1   #fb, residuals, weights

































def plot_average_low_band(band, fx, tx_all, wx_all, rx_all, wea, LST, model_of_average='EDGES_polynomial', npar=5):


	flow  = np.min(fx)
	fhigh = np.max(fx)	


	NN    = 35    # number of spectra per column
	FSRES = 10    #   

	if band == 'low_band':

		FN     = 75   # Normalization frequency for season-average modeling
		FLOW   = 63   # Low-end frequency in the plots
		FHIGH  = 113  # High-end frequency in the plots
		FRES   = 102  # Start frequency of the text reporting the residual
		FTLOW  = 70   # Low-end of frequency X-ticks
		FTHIGH = 100  # High-end of frequency X-ticks
		FTD    = 10   # Separation between frequency X-ticks



	elif band == 'high_band':

		FN     = 150   # Normalization frequency for season-average modeling
		FLOW   = 80    # Low-end frequency in the plots
		FHIGH  = 215   # High-end frequency in the plots
		FRES   = 192   # Start frequency of the text reporting the residual
		FTLOW  = 90    # Low-end of frequency X-ticks
		FTHIGH = 190   # High-end of frequency X-ticks
		FTD    = 20    # Separation between frequency X-ticks


















	if band == 'low_band':


		# File 2.76 - 4.76

		# All days







		# File 0.76 - 6.76
		# ----------------

		# All days
		accepted = np.array([[2015, 286], [2015, 287], [2015, 288], [2015, 289], [2015, 291], [2015, 292], [2015, 293], [2015, 294], [2015, 295], 
		                     [2015, 296], [2015, 297], [2015, 298], [2015, 299], [2015, 300], [2015, 301], [2015, 302], [2015, 311], [2015, 312], 
		                     [2015, 313], [2015, 314], [2015, 315], [2015, 316], [2015, 317], [2015, 318], [2015, 319], [2015, 320], [2015, 321],
		                     [2015, 322], [2015, 323], [2015, 324], [2015, 325], [2015, 326], [2015, 327], [2015, 328], [2015, 329], [2015, 330],
		                     [2015, 331], [2015, 332], [2015, 333], [2015, 334], [2015, 335], [2015, 336], [2015, 337], [2015, 338], [2015, 339],
		                     [2015, 340], [2015, 341], [2015, 343], [2015, 344], [2015, 345], [2015, 346], [2015, 347], [2015, 348], [2015, 349],
		                     [2015, 350], [2015, 351], [2015, 352], [2015, 353], [2015, 354], [2015, 362], [2015, 363], [2015, 364], [2015, 365],
		                     [2015, 1], [2015, 2], [2015, 3], [2015, 4], [2015, 5], [2015, 6], [2015, 7], [2015, 8], [2015, 9],
		                     [2015, 10], [2015, 11], [2015, 12], [2015, 13], [2015, 15], [2015, 16], [2015, 17], [2015, 18], [2015, 19],
		                     [2015, 28], [2015, 29], [2015, 30], [2015, 31], [2015, 32], [2015, 33], [2015, 34], [2015, 35], [2015, 36],
		                     [2015, 37], [2015, 38], [2015, 39], [2015, 40], [2015, 41], [2015, 42], [2015, 43], [2015, 44], [2015, 45], 
		                     [2015, 46], [2015, 47], [2015, 48], [2015, 49], [2015, 50], [2015, 51], [2015, 52], [2015, 53], [2015, 56], 
		                     [2015, 57], [2015, 58], [2015, 60], [2015, 61], [2015, 62], [2015, 63], [2015, 64], [2015, 65], [2015, 66], 
		                     [2015, 67], [2015, 68], [2015, 69], [2015, 70], [2015, 71], [2015, 72], [2015, 73], [2015, 74], [2015, 76], 
		                     [2015, 77], [2015, 78], [2015, 79], [2015, 185], [2015, 186], [2015, 189], [2015, 190], [2015, 194], [2015, 195], 
		                     [2015, 196], [2015, 197], [2015, 198], [2015, 201], [2015, 202], [2015, 210], [2015, 211]])



		# Relaxed RFI filter (50-100 MHz)
		#accepted = np.array([[2015, 287], [2015, 288], [2015, 289], [2015, 292], [2015, 293], [2015, 294], [2015, 295], 
					#[2015, 296], [2015, 297], [2015, 298], [2015, 300], [2015, 301], [2015, 302],  
					#[2015, 315], [2015, 317], [2015, 318], [2015, 319], [2015, 320], [2015, 321],
					#[2015, 322], [2015, 323], [2015, 324], [2015, 325], [2015, 326], [2015, 327], [2015, 330],
					#[2015, 334], [2015, 336], [2015, 337], [2015, 338],
					#[2015, 341], [2015, 345], [2015, 346], [2015, 347], [2015, 348], [2015, 349],
					#[2015, 350], [2015, 351], [2015, 362], 
					#[2016, 1], [2016, 3], [2016, 4], [2016, 5], [2016, 6], [2016, 7], [2016, 9],
					#[2016, 11], [2016, 13], [2016, 15], [2016, 17], [2016, 19],
					#[2016, 28], [2016, 29], [2016, 30], [2016, 31], [2016, 33], [2016, 34],
					#[2016, 40], [2016, 42], [2016, 45], 
					#[2016, 46], [2016, 50], [2016, 51],  
					#[2016, 57], [2016, 58], [2016, 60], [2016, 61], [2016, 63], [2016, 66], 
					#[2016, 69], [2016, 70], [2016, 71], [2016, 73], 
					#[2016, 190], [2016, 195], 
					#[2016, 197], [2016, 201], [2017, 211]])



		# Tight RFI filter (50-100 MHz)    (it produces same results as relaxed RFI filter)
		#accepted = np.array([[2015, 288], [2015, 293], [2015, 295], 
					#[2015, 296], [2015, 300], [2015, 302], [2015, 315], 
					#[2015, 317], [2015, 319], [2015, 323], [2016, 1], [2016, 4], [2016, 6], 
					#[2016, 10],  [2016, 11], [2016, 13], [2016, 15], [2016, 28], [2016, 30],
					#[2016, 33],  [2016, 34], [2016, 42], [2016, 46],  [2016, 50], [2016, 57], 
					#[2016, 58], [2016, 60], [2016, 61], [2016, 63], [2016, 69], [2016, 195], 
					#[2016, 197], [2016, 198], [2016, 201], [2016, 211]])












		# Relaxed RFI filter (70-99 MHz)
		#accepted = np.array([[2015, 286], [2015, 287], [2015, 288], [2015, 289], [2015, 291], [2015, 292], [2015, 293], [2015, 294], [2015, 295], 
					#[2015, 296], [2015, 297], [2015, 298], [2015, 299], [2015, 300], [2015, 301], [2015, 302], [2015, 311], [2015, 312], 
					#[2015, 313], [2015, 314], [2015, 315], [2015, 317], [2015, 318], [2015, 319], [2015, 320], [2015, 321],
					#[2015, 322], [2015, 323], [2015, 324], [2015, 325], [2015, 326], [2015, 327], [2015, 328], [2015, 329], [2015, 330],
					#[2015, 331], [2015, 332], [2015, 333], [2015, 334], [2015, 336], [2015, 337], [2015, 338], [2015, 339],
					#[2015, 340], [2015, 341], [2015, 345], [2015, 346], [2015, 347], [2015, 348], [2015, 349],
					#[2015, 350], [2015, 351], [2015, 352], [2015, 353], [2015, 354], [2015, 362], [2015, 363], [2015, 364], [2015, 365],
					#[2016, 1], [2016, 2], [2016, 3], [2016, 4], [2016, 5], [2016, 6], [2016, 7], [2016, 8], [2016, 9],
					#[2016, 10], [2016, 11], [2016, 12], [2016, 13], [2016, 15], [2016, 16], [2016, 17], [2016, 18], [2016, 19],
					#[2016, 28], [2016, 29], [2016, 30], [2016, 31], [2016, 32], [2016, 33], [2016, 34], [2016, 35], [2016, 36],
					#[2016, 37], [2016, 38], [2016, 39], [2016, 40], [2016, 41], [2016, 42], [2016, 43], [2016, 44], [2016, 45], 
					#[2016, 46], [2016, 47], [2016, 48], [2016, 49], [2016, 50], [2016, 51], [2016, 52], [2016, 53], [2016, 56], 
					#[2016, 57], [2016, 58], [2016, 60], [2016, 61], [2016, 63], [2016, 64], [2016, 65], [2016, 66], 
					#[2016, 67], [2016, 68], [2016, 69], [2016, 70], [2016, 71], [2016, 72], [2016, 74],  
					#[2016, 78], [2016, 79], [2016, 185], [2016, 186], [2016, 190], [2016, 194], [2016, 195], 
					#[2016, 196], [2016, 197], [2016, 198], [2016, 201], [2016, 202], [2016, 210], [2016, 211]])






























		# File 6.76 - 12.76
		# -----------------

		# All days
		#accepted = np.array([[2015, 298], [2015, 299], [2015, 300], [2015, 301], [2015, 302], [2015, 312], [2015, 313], [2015, 314], [2015, 315],
					#[2015, 316], [2015, 317], [2015, 318], [2015, 319], [2015, 320], [2015, 321], [2015, 322], [2015, 323], [2015, 324],
					#[2015, 325], [2015, 326], [2015, 327], [2015, 328], [2015, 329], [2015, 330], [2015, 331], [2015, 332], [2015, 333],
					#[2015, 334], [2015, 335], [2015, 337], [2015, 338], [2015, 339], [2015, 340], [2015, 341], [2015, 343], [2015, 344],
					#[2015, 345], [2015, 346], [2015, 347], [2015, 348], [2015, 349], [2015, 350], [2015, 351], [2015, 352], [2015, 353],
					#[2015, 354], [2015, 362], [2015, 363], [2015, 364], [2015, 365], [2016, 1], [2016, 2], [2016, 3], [2016, 4], 
					#[2016, 5],  [2016, 6],  [2016, 7],  [2016, 8],  [2016, 9],  [2016, 10], [2016, 11], [2016, 12], [2016, 13], 
					#[2016, 15], [2016, 16], [2016, 17], [2016, 18], [2016, 19], [2016, 28], [2016, 29], [2016, 30], [2016, 31], 
					#[2016, 32], [2016, 33], [2016, 34], [2016, 35], [2016, 36], [2016, 37], [2016, 38], [2016, 39], [2016, 40],
					#[2016, 41], [2016, 42], [2016, 43], [2016, 44], [2016, 45], [2016, 46], [2016, 47], [2016, 49], [2016, 50],
					#[2016, 51], [2016, 52], [2016, 53], [2016, 56], [2016, 57], [2016, 58], [2016, 59], [2016, 60], [2016, 61],
					#[2016, 62], [2016, 63], [2016, 64], [2016, 65], [2016, 66], [2016, 67], [2016, 68], [2016, 69], [2016, 70],
					#[2016, 71], [2016, 72], [2016, 73], [2016, 74], [2016, 75], [2016, 76], [2016, 77], [2016, 78], [2016, 79],
					#[2016, 80], [2016, 81], [2016, 82], [2016, 83], [2016, 84], [2016, 85], [2016, 87], [2016, 88], [2016, 89],
					#[2016, 90], [2016, 91], [2016, 92], [2016, 93], [2016, 94], [2016, 95], [2016, 96], [2016, 97], [2016, 98],
					#[2016, 99], [2016, 100], [2016, 101], [2016, 102], [2016, 103], [2016, 106], [2016, 107], [2016, 108], [2016, 109],
					#[2016, 110], [2016, 111], [2016, 112], [2016, 113], [2016, 114], [2016, 115], [2016, 116], [2016, 117], [2016, 123],
					#[2016, 124], [2016, 125], [2016, 126], [2016, 127], [2016, 128], [2016, 129], [2016, 130], [2016, 131], [2016, 132],
					#[2016, 133], [2016, 134], [2016, 135], [2016, 136], [2016, 137], [2016, 138], [2016, 139], [2016, 141], [2016, 143],
					#[2016, 144], [2016, 145], [2016, 146], [2016, 147], [2016, 148], [2016, 149], [2016, 150], [2016, 151], [2016, 152],
					#[2016, 153], [2016, 154], [2016, 155], [2016, 158], [2016, 159], [2016, 160], [2016, 167], [2016, 168], [2016, 169],
					#[2016, 170], [2016, 171], [2016, 172], [2016, 181], [2016, 182], [2016, 183]])


		# Accepted days
		#accepted = np.array([[2015, 298], [2015, 299], [2015, 300], [2015, 301], [2015, 302], [2015, 312], [2015, 313], [2015, 314], [2015, 315],
					#[2015, 316], [2015, 317], [2015, 318], [2015, 319], [2015, 320], [2015, 322], [2015, 323], [2015, 324],
					#[2015, 325], [2015, 326], [2015, 327], [2015, 328], [2015, 329], [2015, 330], [2015, 331], [2015, 332], [2015, 333],
					#[2015, 334], [2015, 337], [2015, 338], [2015, 339], [2015, 340], [2015, 341], 
					#[2015, 345], [2015, 346], [2015, 347], [2015, 348], [2015, 349], [2015, 350], [2015, 351], [2015, 352], [2015, 353],
					#[2015, 354], [2015, 362], [2015, 363], [2015, 364], [2015, 365], [2016, 1], [2016, 2], [2016, 3], [2016, 4],
					#[2016, 5],  [2016, 6],  [2016, 7],  [2016, 8],  [2016, 9],  [2016, 10], [2016, 11], [2016, 12], [2016, 13],
					#[2016, 15], [2016, 16], [2016, 17], [2016, 18], [2016, 28], [2016, 29], [2016, 31],
					#[2016, 32], [2016, 33], [2016, 34], [2016, 35], [2016, 36], [2016, 37], [2016, 38], [2016, 39], [2016, 40],
					#[2016, 41], [2016, 42], [2016, 43], [2016, 44], [2016, 45], [2016, 47], [2016, 49], [2016, 50],
					#[2016, 51], [2016, 52], [2016, 53], [2016, 56], [2016, 57], [2016, 58], [2016, 59], [2016, 60], [2016, 61],
					#[2016, 62], [2016, 65], [2016, 67], [2016, 68], [2016, 69], [2016, 70],
					#[2016, 71], [2016, 72], [2016, 73], [2016, 74], [2016, 76], [2016, 77], [2016, 78], [2016, 79],
					#[2016, 80], [2016, 81], [2016, 82], [2016, 83], [2016, 84], [2016, 85], [2016, 87], [2016, 88], [2016, 89],
					#[2016, 90], [2016, 91], [2016, 92], [2016, 93], [2016, 94], [2016, 95], [2016, 96], [2016, 97], [2016, 98],
					#[2016, 99], [2016, 100], [2016, 101], [2016, 102], [2016, 103], [2016, 107], [2016, 108], [2016, 109],
					#[2016, 110], [2016, 111], [2016, 112], [2016, 113], [2016, 114], [2016, 115], [2016, 116], [2016, 117], [2016, 123],
					#[2016, 124], [2016, 125], [2016, 126], [2016, 127], [2016, 128], [2016, 129], [2016, 130], [2016, 131], [2016, 132],
					#[2016, 133], [2016, 134], [2016, 135], [2016, 136], [2016, 137], [2016, 138], [2016, 139], [2016, 141], [2016, 143],
					#[2016, 144], [2016, 145], [2016, 147], [2016, 148], [2016, 149], [2016, 150], [2016, 151], [2016, 152],
					#[2016, 153], [2016, 154], [2016, 155], [2016, 158]])
















		# File 12.76 - 18.76
		# ------------------
		## All days
		#accepted = np.array([[2016, 28], [2016, 29], [2016, 30], [2016, 31], [2016, 32], [2016, 33], [2016, 34], [2016, 35], [2016, 36], 
					#[2016, 37], [2016, 38], [2016, 39], [2016, 40], [2016, 41], [2016, 42], [2016, 43], [2016, 44], [2016, 45],
					#[2016, 46], [2016, 47], [2016, 49], [2016, 50], [2016, 51], [2016, 52], [2016, 53], [2016, 55], [2016, 56],
					#[2016, 57], [2016, 58], [2016, 59], [2016, 60], [2016, 61], [2016, 62], [2016, 63], [2016, 64], [2016, 65],
					#[2016, 66], [2016, 67], [2016, 68], [2016, 69], [2016, 70], [2016, 71], [2016, 72], [2016, 73], [2016, 74],
					#[2016, 75], [2016, 76], [2016, 77], [2016, 78], [2016, 79], [2016, 80], [2016, 81], [2016, 82], [2016, 83],
					#[2016, 84], [2016, 85], [2016, 87], [2016, 88], [2016, 89], [2016, 90], [2016, 91], [2016, 92], [2016, 93],
					#[2016, 94], [2016, 95], [2016, 96], [2016, 97], [2016, 98], [2016, 99], [2016, 100], [2016, 101], [2016, 102],
					#[2016, 103], [2016, 106], [2016, 107], [2016, 108], [2016, 109], [2016, 110], [2016, 111], [2016, 112], [2016, 113],
					#[2016, 114], [2016, 115], [2016, 116], [2016, 117], [2016, 122], [2016, 123], [2016, 124], [2016, 125], [2016, 126],
					#[2016, 127], [2016, 128], [2016, 129], [2016, 130], [2016, 131], [2016, 132], [2016, 133], [2016, 134], [2016, 135],
					#[2016, 136], [2016, 137], [2016, 138], [2016, 139], [2016, 141], [2016, 142], [2016, 143], [2016, 145], [2016, 146],
					#[2016, 147], [2016, 148], [2016, 149], [2016, 150], [2016, 151], [2016, 152], [2016, 153], [2016, 154], [2016, 155],
					#[2016, 158], [2016, 159], [2016, 160], [2016, 167], [2016, 168], [2016, 169], [2016, 170], [2016, 171], [2016, 180],
					#[2016, 181], [2016, 182], [2016, 183], [2016, 185], [2016, 186], [2016, 188], [2016, 189], [2016, 190], [2016, 191],
					#[2016, 192], [2016, 193], [2016, 194], [2016, 195], [2016, 196], [2016, 197], [2016, 198], [2016, 200], [2016, 201],
					#[2016, 202], [2016, 203], [2016, 211], [2016, 212]])



		# Accepted set 1
		# --------------
		#accepted = np.array([[2016, 28], [2016, 30], [2016, 31], [2016, 32], [2016, 33], [2016, 34], [2016, 35], [2016, 36], [2016, 37],
					#[2016, 38], [2016, 39], [2016, 40], [2016, 41], [2016, 42], [2016, 43], [2016, 45], [2016, 46], [2016, 47],
					#[2016, 49], [2016, 50], [2016, 52], [2016, 58], [2016, 59], 
					#[2016, 60], [2016, 61], [2016, 62], [2016, 63], [2016, 64], [2016, 65], [2016, 66], [2016, 67], [2016, 68], [2016, 69], 
					#[2016, 70], [2016, 71], [2016, 72], [2016, 73], [2016, 74], [2016, 75], [2016, 77], [2016, 78], [2016, 79], [2016, 80], 
					#[2016, 82], [2016, 83], [2016, 84], [2016, 85], [2016, 87], [2016, 88], [2016, 89], [2016, 91], [2016, 92], [2016, 93]])

		# Accepted set 2
		# --------------
		#accepted = np.array([[2016, 94], [2016, 95], [2016, 96], [2016, 97], [2016, 98], [2016, 100], [2016, 102], [2016, 103], [2016, 106], 
					#[2016, 107], [2016, 108], [2016, 109], [2016, 111], [2016, 112], [2016, 113],
					#[2016, 115], [2016, 116], [2016, 117], [2016, 122], [2016, 123], [2016, 124], [2016, 125], [2016, 126],
					#[2016, 127], [2016, 128], [2016, 129], [2016, 130], [2016, 131], [2016, 132], [2016, 133], [2016, 134], [2016, 135],
					#[2016, 136], [2016, 137], [2016, 138], [2016, 139], [2016, 141], [2016, 142], [2016, 143], [2016, 145],
					#[2016, 147], [2016, 149], [2016, 150], [2016, 152], [2016, 153], [2016, 154], [2016, 155],
					#[2016, 168], [2016, 169], [2016, 170], [2016, 171], 
					#[2016, 181], [2016, 182], [2016, 183], [2016, 185], [2016, 186], [2016, 188], [2016, 189], [2016, 190], [2016, 191],
					#[2016, 192], [2016, 193], [2016, 194], [2016, 195], [2016, 196], [2016, 197], [2016, 198], [2016, 201],
					#[2016, 202], [2016, 211]])















		# File 18.76 - 00.76
		# ------------------
		## All days
		#accepted = np.array([[2015, 286], [2015, 287], [2015, 288], [2015, 289], [2015, 291], [2015, 292], [2015, 293], [2015, 294], [2015, 295], [2015, 296], 
					#[2015, 297], [2015, 298], [2015, 299], [2015, 300], [2015, 301], [2015, 302], [2015, 311], [2015, 312], [2015, 313], [2015, 314],
					#[2015, 315], [2015, 316], [2015, 317], [2015, 318], [2015, 319], [2015, 320], [2015, 321], [2015, 322], [2015, 323], [2015, 324],
					#[2015, 325], [2015, 326], [2015, 327], [2015, 328], [2015, 329], [2015, 330], [2015, 331], [2015, 332], [2015, 333], [2015, 334],
					#[2015, 337], [2015, 338], [2015, 339], [2015, 340], [2015, 341], [2016, 100], [2016, 101], [2016, 102], [2016, 103], 
					#[2016, 106], [2016, 107], [2016, 108], [2016, 109], [2016, 110], [2016, 111], [2016, 112], [2016, 113], [2016, 114], [2016, 115], 
					#[2016, 116], [2016, 117], [2016, 122], [2016, 123], [2016, 124], [2016, 125], [2016, 126], [2016, 127], [2016, 128], [2016, 129],
					#[2016, 130], [2016, 131], [2016, 132], [2016, 133], [2016, 134], [2016, 135], [2016, 136], [2016, 137], [2016, 138], [2016, 139], 
					#[2016, 141], [2016, 143], [2016, 144], [2016, 146], [2016, 147], [2016, 148], [2016, 149], [2016, 150], [2016, 152], 
					#[2016, 153], [2016, 154], [2016, 155], [2016, 167], [2016, 168], [2016, 169], [2016, 170], [2016, 171],
					#[2016, 181], [2016, 182], [2016, 183], [2016, 185], [2016, 186], [2016, 189], [2016, 194], [2016, 195],
					#[2016, 196], [2016, 197], [2016, 198], [2016, 201], [2016, 202], [2016, 203], [2016, 210], [2016, 211]])


		# Accepted set
		# ALL, but average about 20 traces at a time, but not all. The best average is in the range 0-50





	if band == 'high_band':
		# File 3.76 - 7.76
		#accepted = np.array([[2015, 238], [2015, 251], [2015, 252], [2015, 253], 
					#[2015, 254], [2015, 255], [2015, 256], [2015, 257],
					#[2015, 258], [2015, 265], [2015, 266], [2015, 267],
					#[2015, 269], [2015, 270], [2015, 271], [2015, 273], 
					#[2015, 274], [2015, 278], [2015, 279], [2015, 280],
					#[2015, 281], [2015, 282], [2015, 283], [2015, 284],
					#[2015, 287], [2015, 288], [2015, 291], [2015, 296],
					#[2015, 298], [2015, 313], [2015, 315], [2015, 316],
					#[2015, 317], [2015, 321], [2015, 322], [2015, 323],
					#[2015, 324], [2015, 326], [2015, 327], [2015, 328],
					#[2015, 329], [2015, 330], [2015, 334], [2015, 336],
					#[2015, 341], [2015, 345], [2015, 354], [2015, 355],
					#[2015, 356], [2015, 357], [2015, 361], [2015, 362],
					#[2015, 364], [2015, 365], [2016, 7],   [2016, 9],
					#[2016, 12],  [2016, 13],  [2016, 15],  [2016, 16],
					#[2016, 18],  [2016, 19],  [2016, 28],  [2016, 29],
					#[2016, 30],  [2016, 36],  [2016, 38],  [2016, 43],
					#[2016, 44],  [2016, 46],  [2016, 47],  [2016, 51],
					#[2016, 58],  [2016, 60],  [2016, 62],  [2016, 64],
					#[2016, 65],  [2016, 66],  [2016, 67],  [2016, 68],
					#[2016, 69],  [2016, 70],  [2016, 71],  [2016, 73],
					#[2016, 74],  [2016, 77],  [2016, 78],  [2016, 80],
					#[2016, 83],  [2016, 87],  [2016, 88]])


		# File 23.76 - 3.76
		#accepted = wea[:,0:2]
		#accepted = np.array([[2015, 207], [2015, 208], [2015, 209], [2015, 211],
					#[2015, 215], [2015, 217], [2015, 224], [2015, 225],
					#[2015, 226], [2015, 227], [2015, 235], [2015, 237],
					#[2015, 238], [2015, 241], [2015, 242], [2015, 243],
					#[2015, 250], [2015, 251], [2015, 252], [2015, 253],
					#[2015, 255], [2015, 260], [2015, 267], [2015, 268],
					#[2015, 269], [2015, 270], [2015, 271], [2015, 274],
					#[2015, 280], [2015, 284], [2015, 286], [2015, 289],
					#[2015, 292], [2015, 293], [2015, 298], [2015, 299],
					#[2015, 301], [2015, 313], [2015, 314], [2015, 317],
					#[2015, 318], [2015, 319], [2015, 322], [2015, 323],
					#[2015, 324], [2015, 325], [2015, 326], [2015, 332],
					#[2015, 333], [2015, 334], [2015, 336], [2015, 337],
					#[2015, 338], [2015, 339], [2015, 341], [2015, 342],
					#[2015, 343], [2015, 344], [2015, 345], [2015, 346],
					#[2015, 347], [2015, 348], [2015, 350], [2015, 352],
					#[2015, 353], [2015, 354], [2015, 355], [2015, 356],
					#[2015, 359], [2015, 361], [2015, 362], [2015, 364],
					#[2015, 365], [2016, 2],   [2016, 3],   [2016, 4],
					#[2016, 7],   [2016, 186], [2016, 195], [2016, 197],
					#[2016, 198], [2016, 202], [2016, 204], [2016, 205],
					#[2016, 206], [2016, 207], [2016, 208], [2016, 210],
					#[2016, 211], [2016, 212]])



		# File 23.76 - 9.76    (Best range:   50-90)
		#accepted = np.array([[2015, 207], [2015, 208], [2015, 209], [2015, 211],
					#[2015, 215], [2015, 217], [2015, 218], [2015, 221],
					#[2015, 222], [2015, 224], [2015, 226], [2015, 227],
					#[2015, 229], [2015, 235], [2015, 237], [2015, 238],
					#[2015, 242], [2015, 243], [2015, 250], [2015, 251],
					#[2015, 252], [2015, 255], [2015, 257], [2015, 258],
					#[2015, 260], [2015, 261], [2015, 262], [2015, 265],
					#[2015, 266], [2015, 267], [2015, 268], [2015, 269],
					#[2015, 270], [2015, 271], [2015, 273], [2015, 274],
					#[2015, 275], [2015, 278], [2015, 279], [2015, 280],
					#[2015, 281], [2015, 282], [2015, 283], [2015, 284],
					#[2015, 286], [2015, 287], [2015, 288], [2015, 289],
					#[2015, 291], [2015, 292], [2015, 296], [2015, 298],
					#[2015, 315], [2015, 317], [2015, 318], [2015, 319],
					#[2015, 321], [2015, 322], [2015, 324], [2015, 326],
					#[2015, 327], [2015, 329], [2015, 330], [2015, 339],
					#[2015, 340], [2015, 341], [2015, 343], [2015, 344],
					#[2015, 345], [2015, 353], [2015, 354], [2015, 355],
					#[2015, 356], [2015, 361], [2015, 362], [2015, 364],
					#[2015, 365], [2016, 1], [2016, 8], [2016, 9],
					#[2016, 10], [2016, 12], [2016, 15], [2016, 16],
					#[2016, 17], [2016, 18], [2016, 19], [2016, 32],
					#[2016, 33], [2016, 34], [2016, 36], [2016, 37],
					#[2016, 38], [2016, 41], [2016, 42], [2016, 43],
					#[2016, 44], [2016, 49], [2016, 50], [2016, 51],
					#[2016, 52], [2016, 53], [2016, 56], [2016, 58],
					#[2016, 60], [2016, 64], [2016, 65], [2016, 66],
					#[2016, 67], [2016, 68], [2016, 69], [2016, 73],
					#[2016, 83], [2016, 88], [2016, 90], [2016, 91],
					#[2016, 92], [2016, 93], [2016, 94], [2016, 95],
					#[2016, 96], [2016, 97], [2016, 98], [2016, 99],
					#[2016, 102], [2016, 103], [2016, 108], [2016, 111],
					#[2016, 115], [2016, 117], [2016, 123], [2016, 125],
					#[2016, 127], [2016, 128], [2016, 130], [2016, 132],
					#[2016, 175], [2016, 178], [2016, 179], [2016, 181],
					#[2016, 185], [2016, 186], [2016, 195], [2016, 197],
					#[2016, 198], [2016, 204], [2016, 205], [2016, 206],
					#[2016, 207], [2016, 210], [2016, 211], [2016, 212]])



		# File 0.76 - 6.76
		# Tight selection
		#accepted = np.array([[2015, 209], [2015, 215], [2015, 217], [2015, 221],
					#[2015, 222], [2015, 224], [2015, 225], [2015, 226],
					#[2015, 227], [2015, 235], [2015, 236], [2015, 237],
					#[2015, 238], [2015, 242], [2015, 243], [2015, 245],
					#[2015, 250], [2015, 251], [2015, 252], [2015, 256],
					#[2015, 257], [2015, 258], [2015, 259], [2015, 260],
					#[2015, 261], [2015, 265], [2015, 266], [2015, 267],
					#[2015, 268], [2015, 269], [2015, 270], [2015, 271],
					#[2015, 274], [2015, 278], [2015, 279], [2015, 280],
					#[2015, 281], [2015, 282], [2015, 283], [2015, 284],
					#[2015, 285], [2015, 286], [2015, 287], [2015, 288],
					#[2015, 289], [2015, 291], [2015, 292], [2015, 296],
					#[2015, 298], [2015, 312], [2015, 313], [2015, 314],
					#[2015, 315], [2015, 316], [2015, 317], [2015, 318],
					#[2015, 319], [2015, 321], [2015, 322], [2015, 324],
					#[2015, 325], [2015, 326], [2015, 327], [2015, 328],
					#[2015, 329], [2015, 333], [2015, 334], [2015, 340],
					#[2015, 341], [2015, 343], [2015, 344], [2015, 345],
					#[2015, 354], [2015, 360], [2015, 361], [2015, 364],
					#[2016, 2],   [2016, 6],   [2016, 7],   [2016, 13],
					#[2016, 18],  [2016, 19],  [2016, 31],  [2016, 36],
					#[2016, 41],  [2016, 51],  [2016, 55],  [2016, 60],
					#[2016, 63],  [2016, 65],  [2016, 66],  [2016, 67],
					#[2016, 197], [2016, 202], [2016, 204], [2016, 206],
					#[2016, 210], [2016, 211], [2016, 212]])

		# Relaxed selection
		accepted = np.array([[2015, 207],[2015, 208],[2015, 209], [2015, 215], [2015, 217], [2015, 218], [2015, 221],
		                     [2015, 222],[2015, 223], [2015, 224], [2015, 225], [2015, 226],
		                     [2015, 227],[2015, 229], [2015, 230], [2015, 235],[2015, 236], [2015, 237],
		                     [2015, 238], [2015, 240],[2015, 242], [2015, 243], [2015, 245],
		                     [2015, 250], [2015, 251], [2015, 252], [2015, 253],[2015, 254],[2015, 255],[2015, 256],
		                     [2015, 257], [2015, 258], [2015, 259], [2015, 260],
		                     [2015, 261], [2015, 262], [2015, 265], [2015, 266], [2015, 267],
		                     [2015, 268], [2015, 269], [2015, 270], [2015, 271], [2015, 273],
		                     [2015, 274], [2015, 275], [2015, 278], [2015, 279], [2015, 280],
		                     [2015, 281], [2015, 282], [2015, 283], [2015, 284],
		                     [2015, 285], [2015, 286], [2015, 287], [2015, 288],
		                     [2015, 289], [2015, 291], [2015, 292], [2015, 293], [2015, 296],
		                     [2015, 298], [2015, 299], [2015, 311], [2015, 312], [2015, 313], [2015, 314],
		                     [2015, 315], [2015, 316], [2015, 317], [2015, 318],
		                     [2015, 319], [2015, 321], [2015, 322], [2015, 223], [2015, 324],
		                     [2015, 325], [2015, 326], [2015, 327], [2015, 328],
		                     [2015, 329], [2015, 330], [2015, 333], [2015, 334], [2015, 336], [2015, 337], [2015, 338], [2015, 339], [2015, 340],
		                     [2015, 341], [2015, 343], [2015, 344], [2015, 345], [2015, 346], [2015, 348], [2015, 350],
		                     [2015, 354], [2015, 355], [2015, 356], [2015, 357], [2015, 360], [2015, 361], [2015, 362], [2015, 363], [2015, 364], [2015, 365], 
		                     [2016, 1],   [2016, 2],   [2016, 4], [2016, 6],   [2016, 7], [2016, 8], [2016, 9],[2016, 10],[2016, 11], [2016, 12], [2016, 13], [2016, 16],
		                     [2016, 18],  [2016, 19],  [2016, 28],  [2016, 30], [2016, 31], [2016, 32], [2016, 33], [2016, 35], [2016, 36], [2016, 37], [2016, 40],
		                     [2016, 41],  [2016, 42],  [2016, 43],  [2016, 44], [2016, 45], [2016, 46], [2016, 47], [2016, 48], [2016, 49], [2016, 50], [2016, 51], [2016, 53], [2016, 55], [2016, 56], [2016, 58], [2016, 60],
		                     [2016, 63],  [2016, 64],  [2016, 65],  [2016, 66],  [2016, 67], [2016, 68], [2016, 69], [2016, 70], [2016, 71], [2016, 72], [2016, 73], [2016, 74], [2016, 76], [2016, 77], [2016, 78], [2016, 79],
		                     [2016, 185], [2016, 186], [2016, 190], [2016, 194], [2016, 195], [2016, 196], [2016, 197], [2016, 198], [2016, 201], [2016, 202], [2016, 204], [2016, 205], [2016, 206], [2016, 207], [2016, 208], [2016, 209],
		                     [2016, 210], [2016, 211], [2016, 212]])

		#accepted = np.array([[2015, 227], [2015, 229], [2015, 230], [2015, 235],[2015, 236], [2015, 237],
					#[2015, 238], [2015, 240], [2015, 242], [2015, 243], [2015, 245], [2015, 250], [2015, 251], [2015, 252], [2015, 253],[2015, 254],[2015, 255],[2015, 256],
					#[2015, 257], [2015, 258], [2015, 259], [2015, 260], [2015, 261], [2015, 262], [2015, 265], [2015, 266], [2015, 267],
					#[2015, 268], [2015, 269], [2015, 270], [2015, 273], [2015, 274], [2015, 275], [2015, 279], [2015, 280], [2015, 286], [2015, 293], [2015, 298], [2015, 299],
					#[2015, 311], [2015, 312], [2015, 313], [2015, 314], [2015, 315], [2015, 316], [2015, 317], [2015, 318], [2015, 319], [2015, 321], [2015, 322], [2015, 223], [2015, 324],
					#[2015, 325], [2015, 326], [2015, 327], [2015, 328], [2015, 329], [2015, 330], [2015, 333], [2015, 334], [2015, 340],
					#[2015, 341], [2015, 343], [2015, 344], [2015, 345], [2015, 346], [2015, 348], [2015, 350], [2015, 354], [2015, 355], [2015, 356], [2015, 357], [2015, 360], [2015, 361], [2015, 364], [2015, 365],
					#[2016, 1],   [2016, 2],   [2016, 4], [2016, 6],   [2016, 7], [2016, 8], [2016, 9],[2016, 10],[2016, 11], [2016, 12], [2016, 13],
					#[2016, 18],  [2016, 19],  [2016, 31],  [2016, 36], [2016, 41],  [2016, 51],  [2016, 55],   [2016, 60],
					#[2016, 63],  [2016, 65],  [2016, 66],  [2016, 67],[2016, 197], [2016, 202], [2016, 204], [2016, 206],[2016, 210], [2016, 211], [2016, 212]])













	# Create array of accepted observations
	flag = 0
	for i in range(len(tx_all[:,0])):
		for j in range(len(accepted)):
			if (wea[i,0] == accepted[j,0]) and (wea[i,1] == accepted[j,1]):
				print(wea[i,0:2])
				if flag == 0:
					tx_raw0  = tx_all[i,:]
					rx_raw0  = rx_all[i,:]
					wx_raw0  = wx_all[i,:]
					wea_new0 = wea[i,:]
					flag = 1

				elif flag > 0:
					tx_raw0  = np.vstack((tx_raw0,  tx_all[i,:]))
					rx_raw0  = np.vstack((rx_raw0,  rx_all[i,:]))
					wx_raw0  = np.vstack((wx_raw0,  wx_all[i,:]))
					wea_new0 = np.vstack((wea_new0, wea[i,:]))


	#n_sigma = 3
	#npar    = 5
	#df_MHz  = 20


	#tx_raw = np.copy(tx_all)
	#rx_raw = np.copy(rx_all)
	#wx_raw = np.copy(wx_all)
	#wea_new = np.copy(wea)


	#rav1, wav1 = spectral_averaging(rx_raw[0:66,:], wx_raw[0:66,:])
	#rav2, wav2 = spectral_averaging(rx_raw[66:134,:], wx_raw[66:134,:])
	#rav3, wav3 = spectral_averaging(rx_raw[134::,:], wx_raw[134::,:])


	#rav1_nr, wav1_nr = RFI_cleaning_std(fx, rav1, wav1, df_MHz = df_MHz, npar = npar, n_sigma = n_sigma)
	#rav2_nr, wav2_nr = RFI_cleaning_std(fx, rav2, wav2, df_MHz = df_MHz, npar = npar, n_sigma = n_sigma)
	#rav3_nr, wav3_nr = RFI_cleaning_std(fx, rav3, wav3, df_MHz = df_MHz, npar = npar, n_sigma = n_sigma)


	#rav_12 = np.vstack((rav1_nr, rav2_nr))
	#wav_12 = np.vstack((wav1_nr, wav2_nr))




	#rav_x, wav_x   = spectral_averaging(rx_raw[N1:N2,:], wx_raw[N1:N2,:])
	#rav_x1, wav_x1 = RFI_cleaning_std(fx, rav_x, wav_x, df_MHz = df_MHz, npar = npar, n_sigma = n_sigma)
	#fb, rb, wb = spectral_binning_fixed_frequency(flow, fhigh, 0.4, fx, rav_x1, wav_x1)
	#fb1 = np.copy(fb)
	#rb1 = np.copy(rb)
	#wb1 = np.copy(wb)



	#for i in range(round(len(tx_raw0[:,0])/2)):

		#n_traces = np.copy(i+1)
		#print(n_traces)

		#if n_traces < 9:
			#df_MHz = 40
			#npar = 5
			#n_sigma = 3.5

		#elif n_traces >= 9:
			#df_MHz = 20
			#npar = 5
			#n_sigma = 3.5


		#tx_raw0, wx_raw0, t_sets, w_sets = RFI_cleaning_traces(fx, tx_raw0, wx_raw0, n_traces, df_MHz = df_MHz, npar = npar, n_sigma = n_sigma)






	# Clean RFI for different trace averages
	n_traces = 4
	t_clean0, w_clean0, t_sets0, w_sets0 = RFI_cleaning_traces(fx, tx_raw0,  wx_raw0,  n_traces, df_MHz = 40, npar = 5, n_sigma = 3.5)

	n_traces = 9
	t_clean1, w_clean1, t_sets1, w_sets1 = RFI_cleaning_traces(fx, t_clean0, w_clean0, n_traces, df_MHz = 20, npar = 5, n_sigma = 3.5)	

	n_traces = 16
	t_clean2, w_clean2, t_sets2, w_sets2 = RFI_cleaning_traces(fx, t_clean1, w_clean1, n_traces, df_MHz = 20, npar = 5, n_sigma = 3.5)

	n_traces = 25
	t_clean3, w_clean3, t_sets3, w_sets3 = RFI_cleaning_traces(fx, t_clean2, w_clean2, n_traces, df_MHz = 20, npar = 5, n_sigma = 3.5)

	n_traces = 36
	t_clean4, w_clean4, t_sets4, w_sets4 = RFI_cleaning_traces(fx, t_clean3, w_clean3, n_traces, df_MHz = 20, npar = 5, n_sigma = 3.5)	

	n_traces = 49
	t_clean, w_clean, t_sets, w_sets     = RFI_cleaning_traces(fx, t_clean4, w_clean4, n_traces, df_MHz = 20, npar = 5, n_sigma = 3.5)		





	# Examining sets of averages
	t_setsX = np.copy(t_sets4)
	w_setsX = np.copy(w_sets4)

	for i in range(len(t_setsX[:,0])):
		pp            = fit_polynomial_fourier(model_of_average, fx/FN, t_setsX[i,:], npar, Weights=w_setsX[i,:])
		model         = model_evaluate(model_of_average, pp[0], fx/FN)
		rs            = t_setsX[i,:] - model
		fbs, rbs, wbs = spectral_binning_fixed_frequency(flow, fhigh, 0.4, fx, rs, w_setsX[i,:])

		if i == 0:
			rss = np.copy(rbs)
			wss = np.copy(wbs)

		elif i > 0:
			rss = np.vstack((rss, rbs))
			wss = np.vstack((wss, wbs))










	# Computing average of accepted traces, and fit and remove a model, and binning residuals

	t_clean = np.copy(tx_raw0)
	w_clean = np.copy(wx_raw0)

	#t_clean = np.copy(t_clean0)
	#w_clean = np.copy(w_clean0)        


	N1 = 0
	N2 = 200 #500

	df_MHz  = 20
	npar    = 5	
	n_sigma = 3   # 3 for high-band


	tav_x, wav_x   = spectral_averaging(t_clean[N1:N2,:], w_clean[N1:N2,:])
	tav_xc, wav_xc = RFI_cleaning_std(fx, tav_x, wav_x, df_MHz = df_MHz, npar = npar, n_sigma = n_sigma)



	pp            = fit_polynomial_fourier(model_of_average, fx/FN, tav_xc, npar, Weights=wav_xc)    #  'Physical_model' 'EDGES_polynomial'
	model         = model_evaluate(model_of_average, pp[0], fx/FN)
	res           = tav_xc-model
	fb2, rb2, wb2 = spectral_binning_fixed_frequency(flow, fhigh, 0.4, fx, res, wav_xc)



	# Plotting binned averaged residuals
	plt.close()
	plt.close()
	plt.close()
	plt.close()        
	fig = plt.figure(1)
	ax  = fig.add_subplot(111)
	plt.plot(fb2[wb2>0], 1000*(rb2[wb2>0]), 'k', linewidth=3)

	if band == 'low_band':
		A = 1000
		plt.ylim([-A, A])
		ax.set_yticks(np.arange(-1000, 1000, 100))
		plt.ylabel(r'$\Delta$ T  [100 mK / Div]')

	if band == 'high_band':
		plt.ylim([-150, 150])
		ax.set_yticks([-150, -100, -50, 0, 50, 100, 150])
		plt.ylabel(r'$\Delta$ T  [50 mK / Div]')	

	plt.grid()
	ax.set_yticklabels([])
	plt.xlabel('frequency [MHz]')

	#plt.legend(loc=0)	



















	# Binning, cleaning, and plotting daily residual spectra 
	for k in [0,1]:

		# All spectra, not only those selected through the 'accepted' array.
		if k == 0:                
			tx_raw = np.copy(tx_all)
			rx_raw = np.copy(rx_all)
			wx_raw = np.copy(wx_all)
			wea_new = np.copy(wea)


		# Only those selected through the 'accepted' array.       
		elif k == 1:
			tx_raw = np.copy(tx_raw0)
			rx_raw = np.copy(rx_raw0)
			wx_raw = np.copy(wx_raw0)
			wea_new = np.copy(wea_new0)                        



		# Binning and RFI cleaning     
		flag = 0
		for i in range(len(rx_raw[:,0])):		

			if flag == 0:

				fb, rb, wb   = spectral_binning_fixed_frequency(flow, fhigh, 0.4, fx, rx_raw[i,:], wx_raw[i,:])
				rb_nr, wb_nr = RFI_cleaning_std(fb, rb, wb, n_sigma = 2.5, df_MHz = 20, npar = 4)
				residuals    = rb_nr
				weights      = wb_nr
				flag         = flag+1


			elif flag > 0:

				fb, rb, wb   = spectral_binning_fixed_frequency(flow, fhigh, 0.4, fx, rx_raw[i,:], wx_raw[i,:])
				rb_nr, wb_nr = RFI_cleaning_std(fb, rb, wb, n_sigma = 2.5, df_MHz = 20, npar = 4)
				residuals    = np.vstack((residuals, rb_nr))
				weights      = np.vstack((weights, wb_nr))
				flag         = flag+1




		# Plotting binned daily residual spectra

		size_y = 20 #16#21
		ll = len(residuals[:,0])
		NC = np.ceil(ll/NN)
		size_x = NC*4.5 #6


		if band == 'high_band':
			K = 0.5

		elif band == 'low_band':
			K = 2		


		fig = plt.figure(num=2, figsize=(size_x, size_y))


		ax = fig.add_subplot(1,NC,1)
		if ll > NN:
			ll2 = NN
		else:
			ll2 = ll


		for i in np.arange(0,ll2):
			if (i % 2 == 0):
				ax.plot(fb[weights[i,:]>0], -residuals[i,weights[i,:]>0] + K*i, 'b')
			else:
				ax.plot(fb[weights[i,:]>0], -residuals[i,weights[i,:]>0] + K*i, 'r')
			ax.text(FRES, K*i+0.0, str(int(round(np.std(1000*residuals[i,weights[i,:]>0]))))+' mK', fontsize=FSRES, fontweight='bold')
		plt.xlim([FLOW, FHIGH])
		plt.ylim([-K*1, K*NN])
		plt.xlabel('FREQUENCY [MHz]')
		plt.ylabel('DAY OF YEAR')
		ax.invert_yaxis()
		ax.set_xticks(np.arange(FTLOW, FTHIGH+1, FTD))
		ax.set_yticks(K*np.arange(0,NN,1))
		day_int = [int(l) for l in wea_new[0:NN,1].tolist()]
		ax.set_yticklabels(day_int)



		if ll > NN:
			if ll > 2*NN:
				ll2 = 2*NN
			else:
				ll2 = ll		

			ax = fig.add_subplot(1,NC,2)
			for i in np.arange(NN,ll2):
				if (i % 2 == 0):
					ax.plot(fb[weights[i,:]>0], -residuals[i,weights[i,:]>0] + K*i, 'b')
				else:
					ax.plot(fb[weights[i,:]>0], -residuals[i,weights[i,:]>0] + K*i, 'r')		
				ax.text(FRES, K*i+0.0, str(int(round(np.std(1000*residuals[i,weights[i,:]>0]))))+' mK', fontsize=FSRES, fontweight='bold')
			plt.xlim([FLOW, FHIGH])
			plt.ylim([K*(NN-1), K*(2*NN)])
			plt.xlabel('FREQUENCY [MHz]')
			ax.invert_yaxis()
			ax.set_xticks(np.arange(FTLOW, FTHIGH+1, FTD))
			ax.set_yticks(K*np.arange(NN,2*NN,1))
			day_int = [int(l) for l in wea_new[NN:2*NN,1].tolist()]
			ax.set_yticklabels(day_int)




		if ll > 2*NN:
			if ll > 3*NN:
				ll2 = 3*NN
			else:
				ll2 = ll		

			ax = fig.add_subplot(1,NC,3)
			for i in np.arange(2*NN,ll2):
				if (i % 2 == 0):
					ax.plot(fb[weights[i,:]>0], -residuals[i,weights[i,:]>0] + K*i, 'b')
				else:
					ax.plot(fb[weights[i,:]>0], -residuals[i,weights[i,:]>0] + K*i, 'r')
				ax.text(FRES, K*i+0.0, str(int(round(np.std(1000*residuals[i,weights[i,:]>0]))))+' mK', fontsize=FSRES, fontweight='bold')
			plt.xlim([FLOW, FHIGH])
			plt.ylim([K*(2*NN-1), K*(3*NN)])
			plt.xlabel('FREQUENCY [MHz]')
			ax.invert_yaxis()
			ax.set_xticks(np.arange(FTLOW, FTHIGH+1, FTD))
			ax.set_yticks(K*np.arange(2*NN,3*NN,1))
			day_int = [int(l) for l in wea_new[(2*NN):(3*NN),1].tolist()]
			ax.set_yticklabels(day_int)




		if ll > 3*NN:
			if ll > 4*NN:
				ll2 = 4*NN
			else:
				ll2 = ll		

			ax = fig.add_subplot(1,NC,4)
			for i in np.arange(3*NN,ll2):
				if (i % 2 == 0):
					ax.plot(fb[weights[i,:]>0], -residuals[i,weights[i,:]>0] + K*i, 'b')
				else:
					ax.plot(fb[weights[i,:]>0], -residuals[i,weights[i,:]>0] + K*i, 'r')
				ax.text(FRES, K*i+0.0, str(int(round(np.std(1000*residuals[i,weights[i,:]>0]))))+' mK', fontsize=FSRES, fontweight='bold')
			plt.xlim([FLOW, FHIGH])
			plt.ylim([K*(3*NN-1), K*(4*NN)])
			plt.xlabel('FREQUENCY [MHz]')
			ax.invert_yaxis()
			ax.set_xticks(np.arange(FTLOW, FTHIGH+1, FTD))
			ax.set_yticks(K*np.arange(3*NN,4*NN,1))
			day_int = [int(l) for l in wea_new[3*NN:4*NN,1].tolist()]
			ax.set_yticklabels(day_int)	




		if ll > 4*NN:
			if ll > 5*NN:
				ll2 = 5*NN
			else:
				ll2 = ll		

			ax = fig.add_subplot(1,NC,5)	
			for i in np.arange(4*NN,ll2):
				if (i % 2 == 0):
					ax.plot(fb[weights[i,:]>0], -residuals[i,weights[i,:]>0] + K*i, 'b')
				else:
					ax.plot(fb[weights[i,:]>0], -residuals[i,weights[i,:]>0] + K*i, 'r')
				ax.text(FRES, K*i+0.0, str(int(round(np.std(1000*residuals[i,weights[i,:]>0]))))+' mK', fontsize=FSRES, fontweight='bold')	
			plt.xlim([FLOW, FHIGH])
			plt.ylim([K*(4*NN-1), K*(5*NN)])
			plt.xlabel('FREQUENCY [MHz]')
			ax.invert_yaxis()
			ax.set_xticks(np.arange(FTLOW, FTHIGH+1, FTD))
			ax.set_yticks(K*np.arange(4*NN,5*NN,1))
			day_int = [int(l) for l in wea_new[(4*NN):len(residuals[:,0]),1].tolist()]
			ax.set_yticklabels(day_int)	




		if ll > 5*NN:
			if ll > 6*NN:
				ll2 = 6*NN
			else:
				ll2 = ll		

			ax = fig.add_subplot(1,NC,6)
			for i in np.arange(5*NN,ll2):
				if (i % 2 == 0):
					ax.plot(fb[weights[i,:]>0], -residuals[i,weights[i,:]>0] + K*i, 'b')
				else:
					ax.plot(fb[weights[i,:]>0], -residuals[i,weights[i,:]>0] + K*i, 'r')
				ax.text(FRES, K*i+0.0, str(int(round(np.std(1000*residuals[i,weights[i,:]>0]))))+' mK', fontsize=FSRES, fontweight='bold')
			plt.xlim([FLOW, FHIGH])
			plt.ylim([K*(5*NN-1), K*(6*NN)])
			plt.xlabel('FREQUENCY [MHz]')
			ax.invert_yaxis()
			ax.set_xticks(np.arange(FTLOW, FTHIGH+1, FTD))
			ax.set_yticks(K*np.arange(5*NN,6*NN,1))
			day_int = [int(l) for l in wea_new[(5*NN):len(residuals[:,0]),1].tolist()]
			ax.set_yticklabels(day_int)	




		if ll > 6*NN:
			if ll > 7*NN:
				ll2 = 7*NN
			else:
				ll2 = ll		

			ax = fig.add_subplot(1,NC,7)
			for i in np.arange(6*NN,ll2):
				if (i % 2 == 0):
					ax.plot(fb[weights[i,:]>0], -residuals[i,weights[i,:]>0] + K*i, 'b')
				else:
					ax.plot(fb[weights[i,:]>0], -residuals[i,weights[i,:]>0] + K*i, 'r')
				ax.text(FRES, K*i+0.0, str(int(round(np.std(1000*residuals[i,weights[i,:]>0]))))+' mK', fontsize=FSRES, fontweight='bold')
			plt.xlim([FLOW, FHIGH])
			plt.ylim([K*(6*NN-1), K*(7*NN)])
			plt.xlabel('FREQUENCY [MHz]')
			ax.invert_yaxis()
			ax.set_xticks(np.arange(FTLOW, FTHIGH+1, FTD))
			ax.set_yticks(K*np.arange(6*NN,7*NN,1))
			day_int = [int(l) for l in wea_new[(6*NN):len(residuals[:,0]),1].tolist()]
			ax.set_yticklabels(day_int)



		# Saving figure
		if k == 0:
			plt.savefig(home_folder + '/Desktop/daily_residuals_' + band + '_all_days.pdf', bbox_inches='tight')
			plt.close()

		if k == 1:
			plt.savefig(home_folder + '/Desktop/daily_residuals_' + band + '_accepted_days.pdf', bbox_inches='tight')
			plt.close()                








	## Plot of the LSTs observed for each day
	#for k in range(len(index_new)):
		#LST_sel = LST[(LST[:,0] == wea_new[k,0]) & (LST[:,1] == wea_new[k,1]), 3]

		#if len(LST_sel[LST_sel > 12]) > 0:

			#LST_sel_1 = LST_sel[LST_sel > 12] - 24

			#if len(LST_sel[LST_sel < 12]) > 0:
				#LST_sel_0 = LST_sel[LST_sel < 12]
				#LST_max = np.max(LST_sel_0)

			#else:
				#LST_max = np.max(LST_sel_1)

			#LST_min = np.min(LST_sel_1)

		#else:
			#LST_max = np.max(LST_sel)
			#LST_min = np.min(LST_sel)

		#if k == 0:
			#LST_min_all = np.copy(LST_min)
			#LST_max_all = np.copy(LST_max)

		#else:
			#LST_min_all = np.append(LST_min_all, LST_min)
			#LST_max_all = np.append(LST_max_all, LST_max)

	#plt.figure(3)

	#plt.plot(wea_new[wea_new[:,0]==2016,1], LST_min_all[wea_new[:,0]==2016] - 0.0, 'd', markerfacecolor='none', markeredgecolor='g', label='2016')
	#plt.plot(wea_new[wea_new[:,0]==2016,1], LST_max_all[wea_new[:,0]==2016] - 0.0, 'd', markerfacecolor='none', markeredgecolor='m', label='2016')

	#plt.plot(wea_new[wea_new[:,0]==2015,1], LST_min_all[wea_new[:,0]==2015], 'b.', label='2015')
	#plt.plot(wea_new[wea_new[:,0]==2015,1], LST_max_all[wea_new[:,0]==2015], 'r.', label='2015')

	#plt.legend(loc=0)
	#plt.xlabel('day of year')
	#plt.ylabel('LST [hr]')
	#plt.xlim([0, 360])
	#plt.ylim([3, 8])
	#plt.grid()


	return fb, -residuals, weights, fbs, rss, wss



























def guzman_45MHz_map():
	
	# 45-MHz map. The map is in Plate Caree projection (unprojected, see https://en.wikipedia.org/wiki/Equirectangular_projection)
	map45_fit = fits.open(home_folder + '/DATA/EDGES/calibration/sky/map_45MHz/wlb45.fits')	
	map45     = map45_fit[0].data
	map45_1D  = map45.flatten() 

	# Coordinate grid
	lat    = np.arange(-90,90.25,0.25)
	lon    = np.arange(180,-180.25,-0.25)
	lat_2D = np.tile(lat.reshape(-1,1), len(map45[0,:]))
	lon_2D = np.tile(lon.reshape(-1,1), len(map45[:,0]))
	lon_2D = lon_2D.T

	# Converting to Healpix Nside=128
	hp_pix_2D = hp.ang2pix(128, (np.pi/180)*(90-lat_2D), (np.pi/180)*lon_2D)
	hp_pix    = hp_pix_2D.flatten()

	# Index for pixels with data, in the format Healpix Nside=128
	unique_hp_pix, unique_hp_pix_index = np.unique(hp_pix, return_index=True)

	# Map in format Healpix Nside=128
	map45_hp = np.zeros(12*128**2)
	map45_hp[unique_hp_pix]   = map45_1D[unique_hp_pix_index]
	map45_hp[map45_hp < 3300] = hp.UNSEEN   # assigning a characteristic value to the hole at high declinations

	# Converting map to format Healpix Nside=512 (same as Haslam map)
	map45_512  = hp.pixelfunc.ud_grade(map45_hp, nside_out=512)
	
	# Converting map from RING to NESTED
	m = hp.reorder(map45_512, r2n=True)
	


	# Loading celestial coordinates to fill in the temperature hole around the north pole
	coord              = fits.open(home_folder + '/DATA/EDGES/calibration/sky/coordinate_maps/pixel_coords_map_nested_celestial_res9.fits')
	coord_array        = coord[1].data
	RA                 = coord_array['LONGITUDE']
	DEC                = coord_array['LATITUDE']

	# Filling the hole
	m[DEC>68] = np.mean(m[(DEC>60) & (DEC<68)])	
	


	
	return m

























def sky_spectral_index_from_45_408_MHz_maps():

	# Data paths
	path_root = home_folder + '/DATA/EDGES/'	
	path_data = path_root + 'beam_convolution/'


	# Loading original Haslam map, NESTED Healpix format Nside=512
	haslam_map  = fits.open(home_folder + '/DATA/EDGES/calibration/sky/haslam_map/lambda_haslam408_dsds.fits')
	haslam_nest = (haslam_map[1].data)['temperature']

	# Convert to RING format
	map408_512 = hp.reorder(haslam_nest, n2r=True)





	# 45-MHz map. The map is in Plate Caree projection (unprojected, see https://en.wikipedia.org/wiki/Equirectangular_projection)
	map45_fit = fits.open(home_folder + '/DATA/EDGES/calibration/sky/map_45MHz/wlb45.fits')	
	map45     = map45_fit[0].data
	map45_1D  = map45.flatten() 

	# Coordinate grid
	lat    = np.arange(-90,90.25,0.25)
	lon    = np.arange(180,-180.25,-0.25)
	lat_2D = np.tile(lat.reshape(-1,1), len(map45[0,:]))
	lon_2D = np.tile(lon.reshape(-1,1), len(map45[:,0]))
	lon_2D = lon_2D.T

	# Converting to Healpix Nside=128
	hp_pix_2D = hp.ang2pix(128, (np.pi/180)*(90-lat_2D), (np.pi/180)*lon_2D)
	hp_pix    = hp_pix_2D.flatten()

	# Index for pixels with data, in the format Healpix Nside=128
	unique_hp_pix, unique_hp_pix_index = np.unique(hp_pix, return_index=True)

	# Map in format Healpix Nside=128
	map45_hp = np.zeros(12*128**2)
	map45_hp[unique_hp_pix]   = map45_1D[unique_hp_pix_index]
	map45_hp[map45_hp < 3300] = hp.UNSEEN   # assigning a characteristic value to the hole at high declinations

	# Converting map to format Healpix Nside=512 (same as Haslam map)
	map45_512  = hp.pixelfunc.ud_grade(map45_hp, nside_out=512)





	# # Smoothing of 45 and 408 MHz maps to 5 degrees
	# FWHM_rad = (np.pi/180)*5
	# map45_5deg  = hp.smoothing(map45_512, FWHM_rad)
	# map408_5deg = hp.smoothing(map408_512, FWHM_rad)



	# # Applying offset coerrections from table 5, Guzman et al(2010)
	# Tcmb    = 2.725  # CMB correction
	# Tzlc45  = -544   # Zero level correction
	# Tzlc408 = -3.46  # Zero level correction

	# map45_final  = map45_5deg      # - Tcmb - Tzlc45
	# map408_final = map408_5deg - 3  # - Tcmb - Tzlc408


	# # Computing spectral indices
	# BETA = -np.log(map45_final/map408_final)/np.log(45/408)



	# # GSM045, GSM408
	# gsm45    = np.genfromtxt(path_data + 'gsm/data/sky_045.dat')
	# gsm408   = np.genfromtxt(path_data + 'gsm/data/sky_408.dat')
	# BETA_gsm = -np.log(gsm45/gsm408)/np.log(45/408)




	# # Save
	# path_save  = home_folder + '/DATA/EDGES/beam_convolution/sky_spectral_indices/'
	# save_file1 = path_save + 'sky_spectral_index_original_45_408_MHz_maps_galactic_coordinates_nside_512_ring_3Ksubtracted.hdf5'
	# save_file2 = path_save + 'sky_spectral_index_GSM_45_408_MHz_maps_galactic_coordinates_nside_512_ring.hdf5'

	# with h5py.File(save_file1, 'w') as hf:
		# hf.create_dataset('spectral_index',  data = BETA)

	# with h5py.File(save_file2, 'w') as hf:
		# hf.create_dataset('spectral_index',  data = BETA_gsm)	





	# # Plots
	# plt.close()
	# plt.close()
	# plt.close()
	# plt.close()
	# plt.close()
	# plt.close()

	# hp.mollview(map45_512-2.725 - gsm45, min=-3000, max=3000, title=r'(map_45MHz - $T_{CMB}$) - GSM_45MHz', unit='[K]') 
	# hp.graticule()
	# plt.xlabel('')

	# hp.mollview(map408_512-2.725 - gsm408, min=-2, max=2, title=r'(Haslam_408MHz - $T_{CMB}$) - GSM_408MHz', unit='[K]')
	# hp.graticule()

	# hp.mollview(BETA, min=2.3, max=2.6, title='From Original 45,408-MHz maps', unit=r'$\beta$')
	# hp.graticule()

	# hp.mollview(BETA_gsm, min=2.3, max=2.6, title='From GSM 45,408-MHz maps', unit=r'$\beta$')
	# hp.graticule()	

	return map45_512  #map45_5deg, map408_5deg, BETA, BETA_gsm






def sky_model_45_408_MHz(freq, maps_45_408='original'):

	path = home_folder + '/DATA/EDGES/beam_convolution'


	# Haslam 408 MHz
	if maps_45_408 == 'original':

		# Spectral index in HEALPix RING Galactic Coordinates, nside=512
		beta_file = path + '/sky_spectral_indices/sky_spectral_index_original_45_408_MHz_maps_galactic_coordinates_nside_512_ring_3Ksubtracted.hdf5'
		with h5py.File(beta_file, 'r') as hf:			
			hf_beta = hf.get('spectral_index')
			beta    = np.array(hf_beta)


		# Loading original Haslam map, nside=512
		haslam_map  = fits.open(path + '/haslam_map/lambda_haslam408_dsds.fits')
		haslam_nest = (haslam_map[1].data)['temperature'] # NESTED Healpix format


		# Convert to RING format
		haslam = hp.reorder(haslam_nest, n2r=True)		


		# Remove offsets
		Tcmb = 2.725
		Tzlc = -3.46		
		T408 = np.copy(haslam) - 3    # - Tcmb - Tzlc   # Corrections necessary


		# Produce map at the chosen frequency	
		T_no_cmb = T408 * (freq/408)**(-beta)		





	# GSM 408 MHz	
	elif maps_45_408 == 'gsm':

		# Spectral index in HEALPix RING Galactic Coordinates, nside=512
		beta_file = path + '/sky_spectral_indices/sky_spectral_index_GSM_45_408_MHz_maps_galactic_coordinates_nside_512_ring.hdf5'
		with h5py.File(beta_file, 'r') as hf:
			hf_beta = hf.get('spectral_index')
			beta    = np.array(hf_beta)


		# Loading map, already in RING format, nside=512
		gsm408 = np.genfromtxt(path + '/gsm/data/sky_408.dat')
		T408   = np.copy(gsm408) # No corrections necessary


		# Produce map at the chosen frequency	
		T_no_cmb = T408 * (freq/408)**(-beta)	


	# Loading RING celestial coordinates, nside=512
	coord              = fits.open(path + '/coordinate_maps/pixel_coords_map_ring_celestial_res9.fits')
	coord_array        = coord[1].data
	lon                = coord_array['LONGITUDE']
	lat                = coord_array['LATITUDE']


	# Blanking out region with DEC > 65 degrees
	T_no_cmb_blank = np.copy(T_no_cmb)
	T_no_cmb_blank[lat > 65] = np.nan


	return T_no_cmb_blank, beta














def model_eor_anastasia(model_number, fnew, interpolation_kind='linear'):

	"""
	model_number: 0 through 285

	This is a set larger than that in Cohen et al. (2017)

	"""


	# Loading files
	path_file  = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/second_set/model_data.txt'
	just_for_z = np.genfromtxt(path_file)
	z          = just_for_z[:, 0]


	# Set of models
	path_file = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/20170426/Data042617.mat'
	d         = sio.loadmat(path_file)
	data_all  = d['NewDat']


	# Selecting model number
	model     = data_all[model_number,:]		


	# Interpolating to input frequency
	freq       = redshift2frequency(z)
	func_model = spi.interp1d(freq, model, kind=interpolation_kind)
	mnew       = func_model(fnew)


	# Empty auxiliary output
	ao = (mnew/1000, 0)


	return mnew/1000, ao















def model_eor_anastasia_old(model_number, fnew, interpolation_kind='linear'):

	"""
	model_number: 0 through 194

	NOTE: The last 36 models are the same as all the models in "model_eor_anastasia_paper_2016_02"

	"""


	# Loading files
	path_file  = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/second_set/model_data.txt'
	just_for_z = np.genfromtxt(path_file)
	z          = just_for_z[:, 0]


	if model_number == 108:
		# Cleaned model from email 2016-11-23
		path_file = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/sixth_set_cleaned/Model109B.mat'
		d         = sio.loadmat(path_file)
		data_all  = d['Model109B']

		model = data_all[:,0]


	else:

		# New set of cleaned models, of paper 2016-09, but from email 2016-11-23
		path_file = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/sixth_set_cleaned/Dat_112316.mat'
		d         = sio.loadmat(path_file)
		data_all  = d['NewDat']

		# Selecting model number
		model     = data_all[model_number,:]		


	# Interpolating to input frequency
	freq       = redshift2frequency(z)
	func_model = spi.interp1d(freq, model, kind=interpolation_kind)
	mnew       = func_model(fnew)



	return (1/1000)*mnew












def model_eor_anastasia_artificial_numerical_artifacts(model_number, fnew):

	"""
	from mail received on 08/02/2016

	model_number: 0 through 11

	NOTE: this is a function to test for numerical instabilities. DO NOT USE.
	"""

	path_file = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/fourth_set_artificial_numerical_artifacts/Dat.mat'
	d         = sio.loadmat(path_file)
	data_all  = d['Dat']
	model     = data_all[model_number,:]


	z = np.arange(6,50.1,0.1)

	freq = redshift2frequency(z)

	# Interpolating to input frequency
	func_model = spi.interp1d(freq, model, kind='cubic')
	mnew       = func_model(fnew)

	return (1/1000)*mnew






def model_eor_anastasia_paper_2016_02(model_number, fnew, interpolation_kind='linear'):

	"""
	from mail received on 08/30/2016

	model_number: 0 through 35

	NOTE: All these models are the same as the last 36 models in "model_eor_anastasia"
	"""

	path_file = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/sixth_set_paper_2016_02/T21atData.mat'
	d         = sio.loadmat(path_file)
	data1     = d['T21atData']

	path_file = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/sixth_set_paper_2016_02/T21hhData.mat'
	d         = sio.loadmat(path_file)
	data2     = d['T21hhData']

	data_all  = np.vstack((data1, data2))
	model     = data_all[model_number,:]


	path_file = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/sixth_set_paper_2016_02/zspec.mat'
	zz        = sio.loadmat(path_file)
	z         = zz['zspec'][0,:]


	freq = redshift2frequency(z)

	# Interpolating to input frequency
	func_model = spi.interp1d(freq, model, kind=interpolation_kind)
	mnew       = func_model(fnew)

	return (1/1000)*mnew


















def model_eor_jordan(model_number, fnew, interpolation_kind='linear', xi_min=0.9, tau_e_min = 0.02, tau_e_max = 0.25):

	"""
        Total current number of models: 33+358 = 391
	"""


	# Data from Figures 2, 5, and 6 in Jordan's paper
	if model_number == 0:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig2/gs_dpl.history.pkl', 'rb')
	if model_number == 1:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig2/gs_floor.history.pkl', 'rb')
	if model_number == 2:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig2/gs_steep.history.pkl', 'rb')
	if model_number == 3:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig5/gs_Z-0.001_sfe-dpl.history.pkl', 'rb')
	if model_number == 4:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig5/gs_Z-0.001_sfe-dpl_ZdepLxSFR.history.pkl', 'rb')
	if model_number == 5:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig5/gs_Z-0.001_sfe-floor_ZdepLxSFR.history.pkl', 'rb')
	if model_number == 6:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig5/gs_Z-0.001_sfe-steep_ZdepLxSFR.history.pkl', 'rb')
	if model_number == 7:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig5/gs_Z-0.004_sfe-dpl.history.pkl', 'rb')
	if model_number == 8:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig5/gs_Z-0.004_sfe-dpl_ZdepLxSFR.history.pkl', 'rb')
	if model_number == 9:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig5/gs_Z-0.004_sfe-floor_ZdepLxSFR.history.pkl', 'rb')
	if model_number == 10:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig5/gs_Z-0.004_sfe-steep_ZdepLxSFR.history.pkl', 'rb')
	if model_number == 11:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig5/gs_Z-0.008_sfe-dpl.history.pkl', 'rb')
	if model_number == 12:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig5/gs_Z-0.008_sfe-dpl_ZdepLxSFR.history.pkl', 'rb')
	if model_number == 13:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig5/gs_Z-0.008_sfe-floor_ZdepLxSFR.history.pkl', 'rb')
	if model_number == 14:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig5/gs_Z-0.008_sfe-steep_ZdepLxSFR.history.pkl', 'rb')
	if model_number == 15:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig5/gs_Z-0.02_sfe-dpl.history.pkl', 'rb')
	if model_number == 16:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig5/gs_Z-0.02_sfe-dpl_ZdepLxSFR.history.pkl', 'rb')
	if model_number == 17:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig5/gs_Z-0.02_sfe-dpl_ZdepLxSFR_hack.history.pkl', 'rb')
	if model_number == 18:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig5/gs_Z-0.02_sfe-floor_ZdepLxSFR.history.pkl', 'rb')
	if model_number == 19:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig5/gs_Z-0.02_sfe-steep_ZdepLxSFR.history.pkl', 'rb')
	if model_number == 20:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig5/gs_Z-0.04_sfe-dpl.history.pkl', 'rb')
	if model_number == 21:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig5/gs_Z-0.04_sfe-dpl_ZdepLxSFR.history.pkl', 'rb')
	if model_number == 22:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig5/gs_Z-0.04_sfe-floor_ZdepLxSFR.history.pkl', 'rb')
	if model_number == 23:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig5/gs_Z-0.04_sfe-steep_ZdepLxSFR.history.pkl', 'rb')			
	if model_number == 24:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig6/dpl_fesc_lyc_0.1_fesc_lw_1_logN_-inf_Z_0.02.history.pkl', 'rb')
	if model_number == 25:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig6/dpl_fesc_lyc_0.2_fesc_lw_0.6_logN_-inf_Z_0.02.history.pkl', 'rb')
	if model_number == 26:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig6/dpl_fesc_lyc_0.2_fesc_lw_0.8_logN_-inf_Z_0.02.history.pkl', 'rb')
	if model_number == 27:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig6/dpl_fesc_lyc_0.2_fesc_lw_1_logN_21_Z_0.02.history.pkl', 'rb')
	if model_number == 28:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig6/dpl_fesc_lyc_0.2_fesc_lw_1_logN_22_Z_0.02.history.pkl', 'rb')
	if model_number == 29:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig6/dpl_fesc_lyc_0.2_fesc_lw_1_logN_-inf_Z_0.02.history.pkl', 'rb')
	if model_number == 30:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig6/dpl_fesc_lyc_0.3_fesc_lw_1_logN_-inf_Z_0.02.history.pkl', 'rb')
	if model_number == 31:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig6/dpl_fesc_lyc_0.4_fesc_lw_1_logN_-inf_Z_0.02.history.pkl', 'rb')
	if model_number == 32:
		data_file = open(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/m16_fig6/dpl_fesc_lyc_0.5_fesc_lw_1_logN_-inf_Z_0.02.history.pkl', 'rb')	


	if model_number < 33:

		# Loading data
		d         = pickle.load(data_file, encoding='latin1')
		z         = d['z']
		f         = redshift2frequency(z)
		dd        = d['dTb']


		# Interpolating to input frequency array
		func_model = spi.interp1d(f, dd, kind=interpolation_kind)
		mnew       = func_model(fnew)

		# Auxiliary output
		ao = ()











	# Cold EoR cases (original set, no heating and tau compatible with Planck) (358 Cold EoR models)
	if (model_number > 32) and (model_number < (33+358)):
		path_file = home_folder + '/DATA/EDGES/global_21cm_models/mirocha/cold_EoR/cold_EoR_grid.hdf5'
		with h5py.File(path_file,'r') as hf:

			hf_freq  = hf.get('frequencies')
			freq     = np.array(hf_freq)

			hf_model = hf.get('model_' + str(model_number-33).zfill(4))
			model    = np.array(hf_model)


		func_model = spi.interp1d(freq, model, kind=interpolation_kind)
		mnew       = func_model(fnew)


		# Auxiliary output
		ao = ()





	# Additional Models from Mirocha et al (2017a), from extrapolations of the High-z Galaxy Luminosity Function
	if (model_number >= (33+358)) and (model_number <= 7089):  # first model is 391. Last one is 7089.
		f = h5py.File(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/models_edges_high_band_paper2/dpl_mc_8d_reion_lim.v2.hdf5', 'r') # latest file, with xHI constraints applied
		# print([key for key in f['blobs'].keys()])
		# KEYS:     ['Ts', 'cgm_h_2', 'dTb', 'dTb_B', 'dTb_C', 'dTb_D', 'z_B', 'z_C', 'z_D']

		# print([key for key in f['axes'].keys()])
		# KEYS:  ['pop_Tmin{0}', 'pop_Z{0}', 'pop_fesc_LW{0}', 'pop_fesc{0}', 'pop_logN{1}', 'pop_rad_yield_Z_index{1}', 'pop_rad_yield{1}', 'pq_func_par2{0}[1]']


		# Models and redshift
		model = f['blobs']['dTb']
		z     = f['blobs']['dTb'].attrs.get('ivar').squeeze()

		# Spin temperature and ionized fraction
		Ts    = f['blobs']['Ts'].value		# Already in Kelvin, not mK
		xi    = f['blobs']['cgm_h_2'].value

		# Turning point C
		TC    = f['blobs']['dTb_C'].value
		zC    = f['blobs']['z_C'].value
		vC    = redshift2frequency(zC)

		# Turning point D
		TD    = f['blobs']['dTb_D'].value
		zD    = f['blobs']['z_D'].value
		vD    = redshift2frequency(zD)

		# Physical parameters
		log10_Tmin = f['axes']['pop_Tmin{0}'].value   
		Tmin       = 10**log10_Tmin                         	  # Minimum Virial temperature. It goes between 500 and 3e5
		gamma_z    = f['axes']['pq_func_par2{0}[1]'].value        # Spectral index

		log10_Z    = f['axes']['pop_Z{0}'].value   
		Z          = 10**log10_Z                                  # Stellar  metallicity
		cx         = f['axes']['pop_rad_yield{1}'].value          # Lx-SFR normalization
		Bx         = f['axes']['pop_rad_yield_Z_index{1}'].value  # Lx-SFR spectral index

		log10_N    = f['axes']['pop_logN{1}'].value      	  
		N          = 10**log10_N				  # Neutral absorption column
		LW         = f['axes']['pop_fesc_LW{0}'].value   	  # Lyman Werner escape fraction
		LC         = f['axes']['pop_fesc{0}'].value      	  # LyC escape fraction





		# Interpolation of models
		freq = redshift2frequency(z)

		func_Ts    = spi.interp1d(freq, Ts[model_number-(33+358),:], kind=interpolation_kind)    # first model is 391. Last one is 7089.
		Tsnew      = func_Ts(fnew)

		func_xi    = spi.interp1d(freq, xi[model_number-(33+358),:], kind=interpolation_kind)    # first model is 391. Last one is 7089.
		xinew      = func_xi(fnew)		

		func_model = spi.interp1d(freq, model[model_number-(33+358),:], kind=interpolation_kind) # first model is 391. Last one is 7089.
		mnew       = func_model(fnew)                             # actual output model		

		# Model FWHM
		fhires     = np.arange(np.min(freq), np.max(freq), 0.01)  # high resolution frequency vector to compute absorption FWHM
		mhires     = func_model(fhires)                           # high resolution model
		TCm        = TC[model_number - (33+358)]		
		vlim1      = np.nan
		vlim2      = np.nan
		for i in range(len(fhires)-1):
			if (mhires[i] >= (TCm/2)) and (mhires[i+1] < (TCm/2)):
				vlim1 = fhires[i]
				# print('lim1: ' + str(lim1))
			if (mhires[i] <= (TCm/2)) and (mhires[i+1] > (TCm/2)):
				vlim2 = fhires[i]	
				# print('lim2: ' + str(lim2))

		dv = vlim2 - vlim1                                            # FWHM in frequency
		dz = frequency2redshift(vlim1) - frequency2redshift(vlim2)    # FHWM in redshift			
		#print(dv)
		#print(dz)


		# Auxiliary output
		ao = (Tsnew, xinew, mnew/1000, TC[model_number-(33+358)]/1000, zC[model_number-(33+358)], vC[model_number-(33+358)], TD[model_number-(33+358)]/1000, zD[model_number-(33+358)], vD[model_number-(33+358)], dz, dv, Tmin[model_number-(33+358)], gamma_z[model_number-(33+358)], Z[model_number-(33+358)], cx[model_number-(33+358)], Bx[model_number-(33+358)], N[model_number-(33+358)], LW[model_number-(33+358)], LC[model_number-(33+358)])







	# Cold EoR, tau_e=[0.04, 0.1]
	if (model_number >= 7090):  # first model 7090.
		f = h5py.File(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/cold_EoR/tanh_cold_EoR.hdf5', 'r') # latest file, with xHI constraints applied
		# print([key for key in f['blobs'].keys()])
		# KEYS: ['cgm_h_2', 'dTb', 'dTb_B', 'dTb_C', 'dTb_D', 'tau_e', 'z_B', 'z_C', 'z_D']

		# print([key for key in f['axes'].keys()])
		# KEYS: ['tanh_xdz', 'tanh_xz0']


		# Models
		all_models_with_glitch = f['blobs']['dTb']
		z_with_glitch          = f['blobs']['dTb'].attrs.get('ivar').squeeze()


		# Remove glitch
		all_models = all_models_with_glitch[:,z_with_glitch >= 6.099]
		z          = z_with_glitch[z_with_glitch >= 6.099]


		# Parameters
		all_xi_with_glitch = f['blobs']['cgm_h_2'].value
		all_xi             = all_xi_with_glitch[:,z_with_glitch >= 6.099]		
		all_tau_e          = f['blobs']['tau_e'].value


		all_tanh_xz0 = np.array(f['axes']['tanh_xz0'])
		all_tanh_xdz = np.array(f['axes']['tanh_xdz'])

		all_dTb_C    = f['blobs']['dTb_C'].value
		all_z_C      = f['blobs']['z_C'].value		



		# Apply cuts
		index     = np.arange(len(all_xi))
		index_OK  = index[(all_tau_e >= tau_e_min) & (all_tau_e <= tau_e_max) & (all_xi_with_glitch[:,10] >= xi_min)]    # z=6 is index 10 (from zero)
		print('Number of models: ' + str(len(index_OK)))

		model     = all_models[index_OK,:]
		xi	  = all_xi[index_OK,:]
		tau_e	  = all_tau_e[index_OK]
		z0        = all_tanh_xz0[index_OK]
		dz        = all_tanh_xdz[index_OK]		
		zC        = all_z_C[index_OK]
		TC        = all_dTb_C[index_OK]


		# Interpolation of models
		freq = redshift2frequency(z)

		func_xi    = spi.interp1d(freq, xi[model_number-(7090),:], kind=interpolation_kind) # first model is 7090. Last model depends on the cuts applied (xi, tau)
		xinew      = func_xi(fnew)		

		func_model = spi.interp1d(freq, model[model_number-(7090),:], kind=interpolation_kind) # first model is 7090. Last model depends on the cuts applied (xi, tau)
		mnew       = func_model(fnew)


		# Auxiliary output
		ao = (xinew, mnew/1000, tau_e[model_number-(7090)], z0[model_number-(7090)], dz[model_number-(7090)], zC[model_number-(7090)], TC[model_number-(7090)]/1000)


	return mnew/1000, ao














def data_analysis_LF_models_least_squares_v2(Nmodels=100, Nfg=5, interpolation_kind='linear'):


	"""

	July 30, 2017

	Newer version of  "data_analysis_LF_models_least_squares()"   line ~ 38373


	"""




	# Input data
	# -------------------
	print('Loading spectrum ...')
	fraw, t, w, d, at, ah, rc, rm  = level3_read(home_folder + '/DATA/EDGES/spectra/level3/high_band_2015/results_paper_1/high_band_2015_LST_0.26_6.26_dates_2015_250_299_nominal.hdf5')
	avt, avw                       = spectral_averaging(t, w)
	fb, tb, wb                     = data_analysis_spectrum_high_to_low_resolution(fraw, avt, avw, flow=89, fhigh=191, fnorm=140, pre_rfi_flagging='yes', post_rfi_flagging='yes')
	tb[wb==0]  = 0




	# Latest file with 100,000 physical models
	# -------------------------------------------
	print('Loading models ...')
	f = h5py.File(home_folder + '/DATA/EDGES/global_21cm_models/mirocha/ares_8d/ares_8d_for_edges_hi.hdf5', 'r')




	# Very useful information
	# ------------------------------
	# >> list(f.keys())
	# >> ['blobs', 'chain', 'mask']

	# print([key for key in f['blobs'].keys()])
	# KEYS: ['Ts', 'cgm_h_2', 'dTb', 'dTb_B', 'dTb_C', 'dTb_D', 'popII_sfrd_tot', 'sfrd_slope', 'tau_e', 'z_B', 'z_C', 'z_D']

	# Listing names of independent variables
	# names = f['chain'].attrs.get('names')
	# for i in range(len(names)):
	# print(names[i])

	# ---------------
	# b'pop_Z{0}'
	# b'pop_fesc{0}'
	# b'pop_rad_yield{1}'
	# b'pop_rad_yield_Z_index{1}'
	# b'pop_logN{1}'
	# b'pq_func_par2{0}[1]'
	# b'pop_Tmin{0}'
	# b'pq_func_par0{0}[5]'
	# b'pq_func_par1{0}[5]'




	# Models 
	# -----------------------
	model = f['blobs']['dTb']                 # in mK
	z     = f['blobs']['dTb'].attrs.get('ivar').squeeze()
	freq  = redshift2frequency(z)

	# Redshift and frequency over the whole original range, for cuts based on xi at z=6
	z_long  = np.arange(np.min(z), np.max(z)+0.005, 0.01)
	f_long  = redshift2frequency(z_long)



	# Parameters
	# -----------------------

	# Turning point C
	TC    = (f['blobs']['dTb_C'].value)/1000  # in K
	zC    = f['blobs']['z_C'].value
	vC    = redshift2frequency(zC)

	# Turning point D
	TD    = (f['blobs']['dTb_D'].value)/1000  # in K
	zD    = f['blobs']['z_D'].value
	vD    = redshift2frequency(zD)

	# Spin temperature and ionized fraction
	Ts    = f['blobs']['Ts'].value		# Already in Kelvin, not mK
	xi    = f['blobs']['cgm_h_2'].value

	# PopII Star Formation Rate Density
	sfrd       = f['blobs']['popII_sfrd_tot'].value
	sfrd_slope = f['blobs']['sfrd_slope'].value
	z_sfrd     = np.arange(5,60.1,0.1)
	freq_sfrd  = redshift2frequency(z_sfrd)		

	# Optical depth
	tau_e     = f['blobs']['tau_e'].value

	# Independent parameters
	ip = f['chain'].value

	log10_Z    = ip[:,0]
	Z          = 10**log10_Z        # Stellar  metallicity

	LC         = ip[:,1]            # LyC escape fraction
	cx         = ip[:,2]            # Lx-SFR normalization
	Bx         = ip[:,3]            # Lx-SFR spectral index

	log10_N    = ip[:,4]
	N          = 10**log10_N        # Neutral absorption column

	gamma_z    = ip[:,5]            # Spectral index

	log10_Tmin = ip[:,6]            
	Tmin       = 10**log10_Tmin     # Minimum Virial temperature. It goes between 500 and 3e5

	par0       = ip[:,7]            # What the hell 1?
	par1       = ip[:,8]		# What the hell 2?








	# Probing models
	# --------------------------------	

	# Initializing output arrays
	# --------------------------------
	model_all    = np.zeros((Nmodels, len(fb)))
	Ts_all       = np.zeros((Nmodels, len(fb)))
	xi_all       = np.zeros((Nmodels, len(fb)))
	sfrd_all     = np.zeros((Nmodels, len(fb)))

	xi_long_all  = np.zeros((Nmodels, len(f_long)))

	phenom_all   = np.zeros((Nmodels, 8))
	physical_all = np.zeros((Nmodels, 11))

	a21_all      = np.zeros((Nmodels, 2))




	# Sweeping over models
	# ---------------------------------
	for model_number in range(Nmodels):



		print(model_number+1)



		# Interpolation of frequency-dependent quantities
		# ------------------------------------------------------
		func_model = spi.interp1d(freq, model[model_number,:], kind=interpolation_kind)
		mnew       = func_model(fb)/1000   # in K                                 				

		func_Ts    = spi.interp1d(freq, Ts[model_number,:], kind=interpolation_kind)
		Tsnew      = func_Ts(fb)

		func_xi    = spi.interp1d(freq, xi[model_number,:], kind=interpolation_kind)
		xinew      = func_xi(fb)
		xi_long    = func_xi(f_long)	# for cuts based on xi at z=6

		func_sfrd  = spi.interp1d(freq_sfrd, sfrd[model_number,:], kind=interpolation_kind)
		sfrdnew    = func_sfrd(fb)




		# Linear Fit 
		# ------------------------------------
		fit = fit_polynomial_fourier('EDGES_polynomial_plus_external', fb, tb, Nfg, Weights=wb, external_function_in_K=mnew)
		a21 = fit[0][-1]
		d21 = np.sqrt(np.diag(fit[3])[-1])




		# Model FWHM
		# ------------------------------------
		fhires     = np.arange(np.min(freq), np.max(freq), 0.01)  # high resolution frequency vector to compute absorption FWHM
		mhires     = func_model(fhires)/1000   # in K             # high resolution model

		TCm        = TC[model_number]
		vlim1      = np.nan
		vlim2      = np.nan
		for i in range(len(fhires)-1):
			if (mhires[i] >= (TCm/2)) and (mhires[i+1] < (TCm/2)):
				vlim1 = fhires[i]				# print('lim1: ' + str(lim1))

			if (mhires[i] <= (TCm/2)) and (mhires[i+1] > (TCm/2)):
				vlim2 = fhires[i]				# print('lim2: ' + str(lim2))

		FWHM_v = vlim2 - vlim1                                          # FWHM in frequency
		FWHM_z = frequency2redshift(vlim1) - frequency2redshift(vlim2)  # FHWM in redshift			




		# Output
		# -------------------------------------
		model_all[model_number, :]     = mnew
		Ts_all[model_number, :]        = Tsnew
		xi_all[model_number, :]        = xinew
		sfrd_all[model_number, :]      = sfrdnew

		xi_long_all[model_number, :]   = xi_long

		phenom_all[model_number, 0]    = TC[model_number]
		phenom_all[model_number, 1]    = zC[model_number]
		phenom_all[model_number, 2]    = vC[model_number]
		phenom_all[model_number, 3]    = TD[model_number]
		phenom_all[model_number, 4]    = zD[model_number]
		phenom_all[model_number, 5]    = vD[model_number]
		phenom_all[model_number, 6]    = FWHM_z
		phenom_all[model_number, 7]    = FWHM_v

		physical_all[model_number, 0]  = sfrd_slope[model_number]
		physical_all[model_number, 1]  = tau_e[model_number]
		physical_all[model_number, 2]  = Z[model_number]
		physical_all[model_number, 3]  = LC[model_number]
		physical_all[model_number, 4]  = cx[model_number]
		physical_all[model_number, 5]  = Bx[model_number]
		physical_all[model_number, 6]  = N[model_number]
		physical_all[model_number, 7]  = gamma_z[model_number]
		physical_all[model_number, 8]  = Tmin[model_number]
		physical_all[model_number, 9]  = par0[model_number]
		physical_all[model_number, 10] = par1[model_number]

		a21_all[model_number, 0]       = a21
		a21_all[model_number, 1]       = d21



	# Saving data
	save_file = home_folder + '/DATA/EDGES/results/high_band/products/model_rejection/least_squares_LF/results_LF_all_models_20170730.hdf5'
	with h5py.File(save_file, 'w') as hf:

		hf.create_dataset('f',         data = fb)
		hf.create_dataset('models',    data = model_all)
		hf.create_dataset('Ts',        data = Ts_all)
		hf.create_dataset('xi',        data = xi_all)
		hf.create_dataset('sfrd',      data = sfrd_all)
		hf.create_dataset('z_long',    data = z_long)
		hf.create_dataset('f_long',    data = f_long)
		hf.create_dataset('xi_long',   data = xi_long_all)
		hf.create_dataset('phenom',    data = phenom_all)
		hf.create_dataset('physical',  data = physical_all)
		hf.create_dataset('a21',       data = a21_all)		


	return 0     # fb, model_all, Ts_all, xi_all, sfrd_all, z_long, f_long, xi_long_all, phenom_all, physical_all, a21_all




# physical correlation:     1-6, 1-10, 0-10














def read_LF_least_squares_v2(filename):

	"""
	Created 2017-07-30

	"""



	path = home_folder + '/DATA/EDGES/results/high_band/products/model_rejection/least_squares_LF/'
	with h5py.File(path + filename,'r') as hf:


		h = hf.get('f')
		f = np.array(h)

		h = hf.get('models')
		models = np.array(h)

		h = hf.get('Ts')
		Ts = np.array(h)

		h = hf.get('xi')
		xi = np.array(h)



		h = hf.get('sfrd')
		sfrd = np.array(h)


		h = hf.get('z_long')
		z_long = np.array(h)

		h = hf.get('f_long')
		f_long = np.array(h)



		h = hf.get('xi_long')
		xi_long = np.array(h)


		h = hf.get('phenom')
		phenom = np.array(h)



		h = hf.get('physical')
		physical = np.array(h) 


		h = hf.get('a21')
		a21 = np.array(h)


	return f, models, Ts, xi, sfrd,  z_long, f_long, xi_long, phenom, physical, a21
























def RFI_cleaning_spectrum(fr, tr, wr, Nsamples=32, Nterms_fg=16, Nterms_std=3, Nsigma=2.5):

	"""
	Latest update: 2017-08-04

	This function assigns zero weights after modeling the residuals to a "many-term" polynomial with another, low-order polynomial.

	"""


	wr_new     = np.copy(wr)
	sum_wr_old = np.sum(wr_new)
	sum_wr_new = 0 #np.copy(sum_wr_old)

	x = 0
	while sum_wr_old > sum_wr_new:

		fb, tb, wb  = spectral_binning_number_of_samples(fr, tr, wr_new, nsamples=Nsamples)
		par_tb      = fit_polynomial_fourier('EDGES_polynomial', fb/200, tb, Nterms_fg, Weights=wb)
		model_tr    = model_evaluate('EDGES_polynomial', par_tb[0], fr/200)
		rr          = tr - model_tr      
		abs_rr      = np.abs(rr)

		fb, arb, wb = spectral_binning_number_of_samples(fr, abs_rr, wr_new, nsamples=Nsamples)
		par_arb     = fit_polynomial_fourier('EDGES_polynomial', fb/200, arb, Nterms_std, Weights=wb)
		model_arr   = model_evaluate('EDGES_polynomial', par_arb[0], fr/200)



		sum_wr_old = np.sum(wr_new)
		wr_new[(wr_new > 0) & (abs_rr > (Nsigma * model_arr))] = 0
		sum_wr_new = np.sum(wr_new)

		x = x+1

	return wr_new   




def RFI_cleaning_negative_reference(f, t, w, df_MHz = 10, npar = 4):

	# Clean output arrays
	t_clean = np.copy(t)
	w_clean = np.copy(w)


	# Original index of points
	index    = np.arange(len(f))


	# Assigning the raw points to bin elements of width "df_MHz"
	freq_bin = np.floor((f - f[0])/df_MHz)


	# If last bin only has a few points (less than half the previous one), push them to the previous bin
	if len(freq_bin[freq_bin==np.max(freq_bin)]) < (1/2)*len(freq_bin[freq_bin==(np.max(freq_bin)-1)]):
		freq_bin[freq_bin==np.max(freq_bin)] = np.max(freq_bin)-1


	# Excise RFI in inch bin
	for k in range(int(np.max(freq_bin)+1)):


		# Assign data to each bin
		index_bin = index[freq_bin == k]
		fb = f[index_bin]
		tb = t[index_bin]
		wb = w[index_bin]


		# To each bin, fit polynomial and compute residual
		# Assign zero weight and value to positive residuals higher than the lowest negative residual in the bin
		# Repeat this process until there are no "high peaks" remaining
		flag_termination = 0
		while flag_termination == 0:


			# Fit a low-order polynomial ("npar" number of parameters) to the data in the bin
			# For the fit only use data with weights higher than zero
			par = np.polyfit(fb[wb>0]/df_MHz, tb[wb>0], npar-1)
			mb  = np.polyval(par, fb/df_MHz)


			# Compute fit residuals
			rb = tb-mb


			# Minimum data value in the bin (with weight higher than zero)
			min_b = np.min(rb[wb>0])


			# Assign zero weight and value to positive data points higher than the lowest negative data point
			count = 0
			for i in range(len(rb)):
				if (wb[i] > 0) and (rb[i] > 0) and (rb[i] > -min_b):
					wb[i] = 0
					tb[i] = 0
					t_clean[index_bin[i]] = 0
					w_clean[index_bin[i]] = 0
					count = count + 1


			# Check condition for termination
			if count == 0:
				flag_termination = 1


	return t_clean, w_clean



def RFI_cleaning_negative_reference_v2(f, t, w, bin_MHz=1, Nfg=16):

	"""
	September 4, 2017

	Use this version instead of original function above

	"""

	# Number of frequency bins. Frequency vector assumed to be in MHz
	fmin = np.min(f)
	fmax = np.max(f)
	Nbin = int(np.ceil(fmax-fmin))

	fbin_all     = np.zeros(Nbin)
	fbin_max_all = np.zeros(Nbin)
	tbin_all     = np.zeros(Nbin)
	tbin_max_all = np.zeros(Nbin)

	index = np.arange(len(f))
	for i in range(Nbin):


		flow  = fmin + i*bin_MHz
		fhigh = fmin + (i+1)*bin_MHz


		#fbin = flow + (fhigh-flow)/2

		fx = f[(f>=flow) & (f<=fhigh)]
		tx = t[(f>=flow) & (f<=fhigh)]
		wx = w[(f>=flow) & (f<=fhigh)]
		tbin = np.min( tx[wx>0] )
		tbin_max = np.max( tx[wx>0] )
		fbin = fx[tx == tbin]
		fbin_max = fx[tx == tbin_max]


		fbin_all[i] = fbin
		fbin_max_all[i] = fbin_max

		tbin_all[i] = tbin
		tbin_max_all[i] = tbin_max


	par = np.polyfit(fbin_all/200, tbin_all, Nfg)
	model = np.polyval(par, f/200)

	res = t-model
	par = np.polyfit([(fbin_max_all[0])/200, (fbin_max_all[-1])/200], [tbin_max_all[0]-tbin_all[0], tbin_max_all[-1]-tbin_all[-1]], 1)
	model_std = np.polyval(par, f/200)



	dt = np.zeros(len(f)-1)
	for i in range(len(f)-1):
		if (w[i+1]>0) and (w[i]>0):
			dt[i] = t[i+1] - t[i]




	return fbin_all, tbin_all, model, model_std, dt





def RFI_cleaning_std(f, t, w, df_MHz = 10, npar = 4, n_sigma = 4):

	# Clean output arrays
	t_clean = np.copy(t)
	w_clean = np.copy(w)


	# Original index of points
	index    = np.arange(len(f))


	# Assigning the raw points to bin elements of width "df_MHz"
	freq_bin = np.floor((f - f[0])/df_MHz)


	# If last bin only has a few points (less than half the previous one), push them to the previous bin
	if len(freq_bin[freq_bin==np.max(freq_bin)]) < (1/2)*len(freq_bin[freq_bin==(np.max(freq_bin)-1)]):
		freq_bin[freq_bin==np.max(freq_bin)] = np.max(freq_bin)-1


	# Excise RFI in each bin
	for k in range(int(np.max(freq_bin)+1)):


		# Assign data to each bin
		index_bin = index[freq_bin == k]
		#print(index_bin)
		fb = f[index_bin]
		tb = t[index_bin]
		wb = w[index_bin]


		# To each bin, fit polynomial and compute residual
		# Repeat this process until there are no "high peaks" remaining
		flag_termination = 0
		while (flag_termination == 0) and (len(tb[wb>0]) > npar):


			# Fit a low-order polynomial ("npar" number of parameters) to the data in the bin
			# For the fit only use data with weights higher than zero
			par = np.polyfit(fb[wb>0]/df_MHz, tb[wb>0], npar-1)
			mb  = np.polyval(par, fb/df_MHz)


			# Compute fit residuals
			rb = tb-mb


			# Compute normalized histogram
			std = np.std(rb[wb>0])


			# Assign zero weight and value to residual points beyond 4 sigma
			count = 0
			for i in range(len(rb)):
				if (wb[i] > 0) and (np.abs(rb[i]) > n_sigma*std):
					tb[i] = 0
					wb[i] = 0
					t_clean[index_bin[i]] = 0
					w_clean[index_bin[i]] = 0
					count = count + 1


			# Check condition for termination
			if count == 0:
				flag_termination = 1


	return t_clean, w_clean





























def RFI_cleaning_derivative(fin, tin, win, Nterms_std=3, Nstd=5):

	"""
	September 4, 2017

	This function removes points based on the channel-to-channel temperature difference. 
	It iteratively adjusts the allowed range as more points are removed.

	"""


	f = np.copy(fin)
	t = np.copy(tin)
	w = np.copy(win)

	dt = np.zeros(len(f))
	for i in range(len(f)-1):
		if (w[i+1]>0) and (w[i]>0):
			dt[i+1] = t[i+1] - t[i]


	# Maximum std at the low frequency end		
	dtx = dt[0:164]
	max_std = np.std(dtx[dtx>0])

	for i in range(len(f)-1):
		if dt[i+1] > Nstd*max_std:
			dt[i+1] = 0
			t[i+1] = 0
			w[i+1] = 0

		if dt[i+1] < -Nstd*max_std:
			dt[i+1] = 0
			t[i] = 0
			w[i] = 0		


	sum_rfi_old = 2e9
	sum_rfi     = 1e9
	while (sum_rfi > 0) and (sum_rfi < sum_rfi_old):


		par       = np.polyfit(f[dt>0]/200, np.abs(dt[dt>0]), Nterms_std-1)
		model_std = np.polyval(par, f/200)

		sum_rfi_old = np.copy(sum_rfi)
		sum_rfi     = 0
		for i in range(len(f)-1):
			if dt[i+1] > Nstd*model_std[i+1]:
				dt[i+1] = 0
				t[i+1] = 0
				w[i+1] = 0
				sum_rfi = sum_rfi + 1

			if dt[i+1] < -Nstd*model_std[i+1]:
				dt[i+1] = 0
				t[i] = 0
				w[i] = 0
				sum_rfi = sum_rfi + 1

		#print(sum_rfi)		





	return w








def RFI_cleaning_polynomial(fin, tin, win, Nterms_fg=10, Nterms_std=3, Nstd=5):

	"""

	September 4, 2017

	This function fits a log-log polynomial to spectrum, and then, iteratively, removes the points that fall outside the allowed range.
	The allowed range is determined as Nsigma x a polynomial with terms Nterms_std  

	"""



	f = np.copy(fin)
	t = np.copy(tin)
	w = np.copy(win)





	sum_RFI     = 2
	sum_RFI_old = 1
	while sum_RFI > sum_RFI_old:


		# Remove points with temperature equal to zero, NaN, and +/- Inf
		ff = f[(t > 0) & (w > 0) & (np.isnan(t) == False) & (np.isinf(t) == False)]
		tt = t[(t > 0) & (w > 0) & (np.isnan(t) == False) & (np.isinf(t) == False)]
		ww = w[(t > 0) & (w > 0) & (np.isnan(t) == False) & (np.isinf(t) == False)]

		# Log of frequency and temperature, for data with non-zero weights
		log_f = np.log10(ff/200)
		log_t = np.log10(tt)

		# Remove points with Log_t equal to NaN and +/- Inf
		log_ff = log_f[(np.isnan(log_t) == False) & (np.isinf(log_t) == False)]
		log_tt = log_t[(np.isnan(log_t) == False) & (np.isinf(log_t) == False)]






		par   = np.polyfit(log_ff, log_tt, Nterms_fg-1)
		log_model = np.polyval(par, np.log10(f/200))
		model = 10**log_model

		#par    = fit_polynomial_fourier('EDGES_polynomial', f/90, t, Nterms_fg, Weights=w)
		#model  = par[1]


		res = t - model
		rr  = res[(t > 0) & (w > 0) & (np.isnan(t) == False) & (np.isinf(t) == False)]

		#print(len(ff))
		#print(len(rr))
		#print(len(ww))

		par       = np.polyfit(ff[ww>0]/200, np.abs(rr)[ww>0], Nterms_std-1)
		model_std = np.polyval(par, f/200)

		RFI = np.zeros(len(fin))
		t[ np.abs(res) > Nstd*model_std ] = 0
		w[ np.abs(res) > Nstd*model_std ] = 0
		RFI[ np.abs(res) > Nstd*model_std ] = 1

		sum_RFI_old = np.copy(sum_RFI)
		sum_RFI     = np.sum(RFI)

		#print(sum_RFI)

	return w





def RFI_cleaning_spectrum_raw(f, t, w, Nterms_fg=16, Nsigma=2.5):

	"""
	Latest update: 2017-08-05

	Use this function to clean final LOW-BAND averages at raw resolution.

	"""

	par         = fit_polynomial_fourier('EDGES_polynomial', f/200, t, Nterms_fg, Weights=w)
	model_data  = par[1]
	abs_r       = np.abs(t - model_data)

	par       = np.polyfit(f, abs_r, 2)
	model_std = np.polyval(par, f)

	w_out = np.copy(w)
	w_out[abs_r > Nsigma*model_std] = 0

	return w_out










def RFI_cleaning_sweep(f, d, w, window_width_MHz=4, Npolyterms_block=4, N_choice=20, N_sigma=2.5):

	"""
	June 3, 2016

	This function cleans a single spectrum. It selects a frequency window at the beginning of the spectrum, and computes the STD of noise.
	Then, it sweeps the window in frequency, point by point, and cleanning the new point if necessary, if this point falls outside N_sigma x STD of the noise of previous step.

	"""

	# Initialization of output arrays
	d_out = np.copy(d)
	w_out = np.copy(w)
	index = np.arange(len(f))


	# Initial section of data of width "window_width_MHz"
	f_start_block = f[f <= (f[0] + window_width_MHz)]
	d_start_block = d[f <= (f[0] + window_width_MHz)]
	w_start_block = w[f <= (f[0] + window_width_MHz)]


	# Computing residuals for initial section
	par           = np.polyfit(f_start_block[w_start_block>0], d_start_block[w_start_block>0], Npolyterms_block-1)
	m_start_block = np.polyval(par, f_start_block)
	r_start_block = d_start_block - m_start_block


	# Computation of STD for initial section using the median statistic
	small_sample_size = round(len(r_start_block)/2)  # number datapoints drawn for repetitions
	flag = 0
	for i in range(N_choice):
		r_choice = np.random.choice(r_start_block[w_start_block>0], small_sample_size)
		if flag == 0:
			r_choice_std = np.std(r_choice)
			flag = 1

		elif flag == 1:
			r_choice_std = np.append(r_choice_std, np.std(r_choice))
	r_std  = np.median(r_choice_std)


	# From the initial section remove peaks larger than N_sigma x STD of noise
	d_out[np.abs(r_start_block) - (N_sigma * r_std) > 0] = 0
	w_out[np.abs(r_start_block) - (N_sigma * r_std) > 0] = 0




	# Sweep the window over frequency, point by point
	# -------------------------------------------------------

	# Initial window limits
	index_low  = 0
	index_high = len(f_start_block)-1


	# Sweeping in frequency
	count = 0
	while index_high < (len(f)-1):

		# Advancing the window limits
		index_low  = index_low + 1
		index_high = index_high + 1


		# Selecting section of data of width "window_width_MHz"
		if index_high < (len(f)-1):		
			f_block = f[index_low:(index_high+1)]
			d_block = d_out[index_low:(index_high+1)]
			w_block = w_out[index_low:(index_high+1)]
			i_block = index[index_low:(index_high+1)]

		elif index_high == (len(f)-1):		
			f_block = f[index_low::]
			d_block = d_out[index_low::]
			w_block = w_out[index_low::]
			i_block = index[index_low::]


		# Computing residuals within window
		par     = np.polyfit(f_block[w_block>0], d_block[w_block>0], Npolyterms_block-1)
		m_block = np.polyval(par, f_block)
		r_block = d_block - m_block


		# Delete new point if it falls outside N_sigma x previous STD of noise
		if np.abs(r_block[-1]) > (N_sigma * r_std):
			w_block[-1] = 0

			d_out[i_block[-1]] = 0
			w_out[i_block[-1]] = 0


		# Compute STD for the current window using only good data
		r_std = np.std(r_block[w_block > 0])


		# Update loop counter
		# print(count)
		count = count+1



	return d_out, w_out








def RFI_excision_raw_frequency(f, d, w):


	"""

	Update: September 23, 2017

	"""

	if (len(d.shape) == 1) and (len(w.shape) == 1):
		dd = np.copy(d.reshape((1,-1)))
		ww = np.copy(w.reshape((1,-1)))

	else:
		dd = np.copy(d)
		ww = np.copy(w)

	dd[:,(f > 87.57) & (f < 87.63)] = 0
	dd[:,(f > 87.78) & (f < 87.88)] = 0
	dd[:,(f > 87.95) & (f < 88.05)] = 0
	dd[:,(f > 88.06) & (f < 88.14)] = 0
	dd[:,(f > 88.35) & (f < 88.40)] = 0
	dd[:,(f > 88.45) & (f < 88.55)] = 0
	dd[:,(f > 88.68) & (f < 88.74)] = 0
	dd[:,(f > 89.07) & (f < 89.15)] = 0
	dd[:,(f > 89.28) & (f < 89.32)] = 0
	dd[:,(f > 89.48) & (f < 89.52)] = 0
	dd[:,(f > 89.65) & (f < 89.75)] = 0
	dd[:,(f > 89.87) & (f < 89.93)] = 0
	dd[:,(f > 89.95) & (f < 89.99)] = 0
	dd[:,(f > 90.06) & (f < 90.11)] = 0
	dd[:,(f > 90.38) & (f < 90.42)] = 0
	dd[:,(f > 90.47) & (f < 90.54)] = 0
	dd[:,(f > 90.68) & (f < 90.74)] = 0
	dd[:,(f > 90.80) & (f < 91.15)] = 0
	dd[:,(f > 91.27) & (f < 91.33)] = 0
	dd[:,(f > 91.47) & (f < 91.53)] = 0
	dd[:,(f > 91.57) & (f < 91.78)] = 0
	dd[:,(f > 91.84) & (f < 91.97)] = 0
	dd[:,(f > 92.01) & (f < 92.21)] = 0
	dd[:,(f > 92.28) & (f < 92.32)] = 0
	dd[:,(f > 92.42) & (f < 92.55)] = 0
	dd[:,(f > 92.66) & (f < 92.74)] = 0
	dd[:,(f > 92.79) & (f < 92.98)] = 0
	dd[:,(f > 93.07) & (f < 93.12)] = 0
	dd[:,(f > 93.23) & (f < 93.35)] = 0
	dd[:,(f > 93.60) & (f < 93.83)] = 0
	dd[:,(f > 93.87) & (f < 93.94)] = 0
	dd[:,(f > 93.99) & (f < 94.35)] = 0
	dd[:,(f > 94.40) & (f < 94.60)] = 0
	dd[:,(f > 94.80) & (f < 95.15)] = 0
	dd[:,(f > 95.22) & (f < 95.35)] = 0
	dd[:,(f > 95.47) & (f < 95.53)] = 0
	dd[:,(f > 95.63) & (f < 95.80)] = 0
	dd[:,(f > 95.98) & (f < 96.19)] = 0
	dd[:,(f > 96.25) & (f < 96.75)] = 0
	dd[:,(f > 96.83) & (f < 96.96)] = 0
	dd[:,(f > 97.06) & (f < 97.15)] = 0
	dd[:,(f > 97.24) & (f < 97.38)] = 0
	dd[:,(f > 97.65) & (f < 97.75)] = 0
	dd[:,(f > 97.85) & (f < 98.22)] = 0
	dd[:,(f > 98.26) & (f < 98.35)] = 0
	dd[:,(f > 98.41) & (f < 98.58)] = 0
	dd[:,(f > 98.65) & (f < 99.01)] = 0
	dd[:,(f > 99.22) & (f < 99.38)] = 0
	dd[:,(f > 99.49) & (f < 99.51)] = 0
	dd[:,(f > 99.57) & (f < 99.95)] = 0
	dd[:,(f > 100.02) & (f < 100.17)] = 0
	dd[:,(f > 100.27) & (f < 100.33)] = 0
	dd[:,(f > 100.46) & (f < 100.54)] = 0
	dd[:,(f > 100.68) & (f < 100.71)] = 0
	dd[:,(f > 100.83) & (f < 100.95)] = 0
	dd[:,(f > 101.02) & (f < 101.18)] = 0
	dd[:,(f > 101.22) & (f < 101.38)] = 0
	dd[:,(f > 101.46) & (f < 101.52)] = 0
	dd[:,(f > 101.65) & (f < 101.75)] = 0
	dd[:,(f > 101.88) & (f < 101.91)] = 0	
	dd[:,(f > 102.06) & (f < 102.14)] = 0
	dd[:,(f > 102.25) & (f < 102.35)] = 0
	dd[:,(f > 102.47) & (f < 102.52)] = 0
	dd[:,(f > 102.66) & (f < 102.74)] = 0
	dd[:,(f > 102.78) & (f < 102.82)] = 0
	dd[:,(f > 102.86) & (f < 102.96)] = 0
	dd[:,(f > 103.02) & (f < 103.19)] = 0
	dd[:,(f > 103.29) & (f < 103.32)] = 0
	dd[:,(f > 103.49) & (f < 103.52)] = 0
	dd[:,(f > 103.65) & (f < 103.75)] = 0
	dd[:,(f > 103.86) & (f < 103.94)] = 0
	dd[:,(f > 103.99) & (f < 104.01)] = 0
	dd[:,(f > 104.08) & (f < 104.12)] = 0
	dd[:,(f > 104.29) & (f < 104.32)] = 0
	dd[:,(f > 104.45) & (f < 104.55)] = 0
	dd[:,(f > 104.66) & (f < 104.73)] = 0
	dd[:,(f > 104.88) & (f < 104.93)] = 0
	dd[:,(f > 105.06) & (f < 105.14)] = 0
	dd[:,(f > 105.27) & (f < 105.33)] = 0
	dd[:,(f > 105.49) & (f < 105.52)] = 0
	dd[:,(f > 105.65) & (f < 105.73)] = 0
	dd[:,(f > 105.88) & (f < 105.92)] = 0
	dd[:,(f > 106.07) & (f < 106.13)] = 0
	dd[:,(f > 106.22) & (f < 106.38)] = 0
	dd[:,(f > 106.46) & (f < 106.53)] = 0
	dd[:,(f > 106.68) & (f < 106.72)] = 0
	dd[:,(f > 106.85) & (f < 106.93)] = 0
	dd[:,(f > 107.08) & (f < 107.12)] = 0
	dd[:,(f > 107.27) & (f < 107.34)] = 0
	dd[:,(f > 107.45) & (f < 107.55)] = 0
	dd[:,(f > 107.64) & (f < 107.76)] = 0
	dd[:,(f > 107.85) & (f < 107.95)] = 0
	dd[:,(f > 112.38) & (f < 112.42)] = 0
	dd[:,(f > 112.88) & (f < 112.92)] = 0
	dd[:,(f > 112.98) & (f < 113.02)] = 0
	dd[:,(f > 113.88) & (f < 113.92)] = 0
	dd[:,(f > 114.08) & (f < 114.12)] = 0
	dd[:,(f > 114.28) & (f < 114.32)] = 0
	dd[:,(f > 121.13) & (f < 121.20)] = 0
	dd[:,(f > 128.43) & (f < 128.46)] = 0
	dd[:,(f > 130.02) & (f < 130.12)] = 0
	dd[:,(f > 130.52) & (f < 130.59)] = 0
	dd[:,(f > 131.52) & (f < 131.59)] = 0
	#dd[(f > 135.50) & (f < 138.50)] = 0   # This is for testing only, remove ORBCOM some other way !!!    ALSO WEIGHTS BELOW !!!!
	dd[:,(f > 144.12) & (f < 144.15)] = 0
	dd[:,(f > 148.60) & (f < 148.65)] = 0
	dd[:,(f > 149.02) & (f < 149.07)] = 0	
	dd[:,(f > 145.78) & (f < 146.10)] = 0
	dd[:,(f > 149.85) & (f < 150.04)] = 0
	dd[:,(f > 150.15) & (f < 150.30)] = 0
	dd[:,(f > 150.32) & (f < 150.46)] = 0
	dd[:,(f > 150.58) & (f < 150.66)] = 0
	dd[:,(f > 151.30) & (f < 151.50)] = 0
	dd[:,(f > 155.30) & (f < 155.35)] = 0


	dd[:,(f > 118.23) & (f < 118.40)] = 0
	dd[:,(f > 118.90) & (f < 119.10)] = 0
	dd[:,(f > 119.61) & (f < 119.70)] = 0
	dd[:,(f > 120.76) & (f < 120.86)] = 0
	dd[:,(f > 121.46) & (f < 121.54)] = 0
	dd[:,(f > 125.16) & (f < 125.25)] = 0
	dd[:,(f > 126.50) & (f < 126.60)] = 0
	dd[:,(f > 126.76) & (f < 126.85)] = 0
	dd[:,(f > 126.96) & (f < 127.05)] = 0
	dd[:,(f > 127.24) & (f < 127.37)] = 0
	dd[:,(f > 128.11) & (f < 128.20)] = 0
	dd[:,(f > 128.65) & (f < 128.86)] = 0
	dd[:,(f > 129.20) & (f < 129.30)] = 0
	dd[:,(f > 129.70) & (f < 130.15)] = 0
	dd[:,(f > 130.35) & (f < 130.45)] = 0
	dd[:,(f > 131.20) & (f < 131.34)] = 0
	dd[:,(f > 131.42) & (f < 131.62)] = 0
	dd[:,(f > 131.68) & (f < 131.78)] = 0
	dd[:,(f > 131.90) & (f < 132.06)] = 0
	dd[:,(f > 132.13) & (f < 132.18)] = 0
	dd[:,(f > 133.58) & (f < 133.62)] = 0
	dd[:,(f > 133.68) & (f < 133.73)] = 0
	dd[:,(f > 133.88) & (f < 133.93)] = 0
	dd[:,(f > 134.16) & (f < 134.24)] = 0
	dd[:,(f > 136.23) & (f < 136.29)] = 0
	dd[:,(f > 136.37) & (f < 136.47)] = 0
	dd[:,(f > 136.60) & (f < 136.73)] = 0
	dd[:,(f > 136.84) & (f < 137.98)] = 0
	dd[:,(f > 147.50) & (f < 147.57)] = 0





	dd[:,(f > 90.14) & (f < 90.16)] = 0
	dd[:,(f > 100.66) & (f < 100.73)] = 0
	dd[:,(f > 117.19) & (f < 117.21)] = 0
	dd[:,(f > 118.295) & (f < 118.307)] = 0
	dd[:,(f > 120.79) & (f < 120.81)] = 0
	dd[:,(f > 121.125) & (f < 121.214)] = 0
	dd[:,(f > 122.084) & (f < 122.120)] = 0
	dd[:,(f > 122.39) & (f < 122.41)] = 0
	dd[:,(f > 122.586) & (f < 122.617)] = 0
	dd[:,(f > 123.391) & (f < 123.41)] = 0
	dd[:,(f > 124.485) & (f < 124.515)] = 0
	dd[:,(f > 124.79) & (f < 124.815)] = 0
	dd[:,(f > 125.418) & (f < 125.46)] = 0
	dd[:,(f > 125.687) & (f < 125.724)] = 0
	dd[:,(f > 125.888) & (f < 125.938)] = 0
	dd[:,(f > 126.694) & (f < 126.705)] = 0
	dd[:,(f > 127.28) & (f < 127.324)] = 0
	dd[:,(f > 128.59) & (f < 128.611)] = 0
	dd[:,(f > 128.794) & (f < 128.812)] = 0
	dd[:,(f > 129.248) & (f < 129.257)] = 0
	dd[:,(f > 129.482) & (f < 129.52)] = 0
	dd[:,(f > 129.813) & (f < 129.99)] = 0
	dd[:,(f > 130.337) & (f < 130.356)] = 0
	dd[:,(f > 131.131) & (f < 131.168)] = 0
	dd[:,(f > 131.436) & (f < 131.467)] = 0
	dd[:,(f > 131.943) & (f < 131.961)] = 0
	dd[:,(f > 131.984) & (f < 132.018)] = 0
	dd[:,(f > 133.481) & (f < 133.517)] = 0
	dd[:,(f > 133.78) & (f < 133.823)] = 0
	dd[:,(f > 133.988) & (f < 134.012)] = 0
	dd[:,(f > 134.183) & (f < 134.216)] = 0
	dd[:,(f > 135.336) & (f < 135.367)] = 0
	dd[:,(f > 136.252) & (f < 136.276)] = 0
	dd[:,(f > 136.398) & (f < 136.453)] = 0
	dd[:,(f > 136.429) & (f < 136.453)] = 0
	dd[:,(f > 136.624) & (f < 136.703)] = 0
	dd[:,(f > 136.759) & (f < 136.813)] = 0
	dd[:,(f > 136.96) & (f < 137.472)] = 0
	dd[:,(f > 137.491) & (f < 137.657)] = 0
	dd[:,(f > 137.662) & (f < 137.832)] = 0
	dd[:,(f > 137.863) & (f < 137.949)] = 0
	dd[:,(f > 145.761) & (f < 145.777)] = 0
	dd[:,(f > 153.885) & (f < 153.921)] = 0
	dd[:,(f > 179.996) & (f < 180.03)] = 0
	
	
	


	ww[:,(f > 90.14) & (f < 90.16)] = 0
	ww[:,(f > 87.57) & (f < 87.63)] = 0
	ww[:,(f > 87.78) & (f < 87.88)] = 0
	ww[:,(f > 87.95) & (f < 88.05)] = 0
	ww[:,(f > 88.06) & (f < 88.14)] = 0
	ww[:,(f > 88.35) & (f < 88.40)] = 0
	ww[:,(f > 88.45) & (f < 88.55)] = 0
	ww[:,(f > 88.68) & (f < 88.74)] = 0
	ww[:,(f > 89.07) & (f < 89.15)] = 0
	ww[:,(f > 89.28) & (f < 89.32)] = 0
	ww[:,(f > 89.48) & (f < 89.52)] = 0
	ww[:,(f > 89.65) & (f < 89.75)] = 0
	ww[:,(f > 89.87) & (f < 89.93)] = 0
	ww[:,(f > 89.95) & (f < 89.99)] = 0
	ww[:,(f > 90.06) & (f < 90.11)] = 0
	ww[:,(f > 90.38) & (f < 90.42)] = 0
	ww[:,(f > 90.47) & (f < 90.54)] = 0
	ww[:,(f > 90.68) & (f < 90.74)] = 0
	ww[:,(f > 90.80) & (f < 91.15)] = 0
	ww[:,(f > 91.27) & (f < 91.33)] = 0
	ww[:,(f > 91.47) & (f < 91.53)] = 0
	ww[:,(f > 91.57) & (f < 91.78)] = 0
	ww[:,(f > 91.84) & (f < 91.97)] = 0
	ww[:,(f > 92.01) & (f < 92.21)] = 0
	ww[:,(f > 92.28) & (f < 92.32)] = 0
	ww[:,(f > 92.42) & (f < 92.55)] = 0
	ww[:,(f > 92.66) & (f < 92.74)] = 0
	ww[:,(f > 92.79) & (f < 92.98)] = 0
	ww[:,(f > 93.07) & (f < 93.12)] = 0
	ww[:,(f > 93.23) & (f < 93.35)] = 0
	ww[:,(f > 93.60) & (f < 93.83)] = 0
	ww[:,(f > 93.87) & (f < 93.94)] = 0
	ww[:,(f > 93.99) & (f < 94.35)] = 0
	ww[:,(f > 94.40) & (f < 94.60)] = 0
	ww[:,(f > 94.80) & (f < 95.15)] = 0
	ww[:,(f > 95.22) & (f < 95.35)] = 0
	ww[:,(f > 95.47) & (f < 95.53)] = 0
	ww[:,(f > 95.63) & (f < 95.80)] = 0
	ww[:,(f > 95.98) & (f < 96.19)] = 0
	ww[:,(f > 96.25) & (f < 96.75)] = 0
	ww[:,(f > 96.83) & (f < 96.96)] = 0
	ww[:,(f > 97.06) & (f < 97.15)] = 0
	ww[:,(f > 97.24) & (f < 97.38)] = 0
	ww[:,(f > 97.65) & (f < 97.75)] = 0
	ww[:,(f > 97.85) & (f < 98.22)] = 0
	ww[:,(f > 98.26) & (f < 98.35)] = 0
	ww[:,(f > 98.41) & (f < 98.58)] = 0
	ww[:,(f > 98.65) & (f < 99.01)] = 0
	ww[:,(f > 99.22) & (f < 99.38)] = 0
	ww[:,(f > 99.49) & (f < 99.51)] = 0
	ww[:,(f > 99.57) & (f < 99.95)] = 0
	ww[:,(f > 100.02) & (f < 100.17)] = 0
	ww[:,(f > 100.27) & (f < 100.33)] = 0
	ww[:,(f > 100.46) & (f < 100.54)] = 0
	ww[:,(f > 100.68) & (f < 100.71)] = 0
	ww[:,(f > 100.83) & (f < 100.95)] = 0
	ww[:,(f > 101.02) & (f < 101.18)] = 0
	ww[:,(f > 101.22) & (f < 101.38)] = 0
	ww[:,(f > 101.46) & (f < 101.52)] = 0
	ww[:,(f > 101.65) & (f < 101.75)] = 0
	ww[:,(f > 101.88) & (f < 101.91)] = 0	
	ww[:,(f > 102.06) & (f < 102.14)] = 0
	ww[:,(f > 102.25) & (f < 102.35)] = 0
	ww[:,(f > 102.47) & (f < 102.52)] = 0
	ww[:,(f > 102.66) & (f < 102.74)] = 0
	ww[:,(f > 102.78) & (f < 102.82)] = 0
	ww[:,(f > 102.86) & (f < 102.96)] = 0
	ww[:,(f > 103.02) & (f < 103.19)] = 0
	ww[:,(f > 103.29) & (f < 103.32)] = 0
	ww[:,(f > 103.49) & (f < 103.52)] = 0
	ww[:,(f > 103.65) & (f < 103.75)] = 0
	ww[:,(f > 103.86) & (f < 103.94)] = 0
	ww[:,(f > 103.99) & (f < 104.01)] = 0
	ww[:,(f > 104.08) & (f < 104.12)] = 0
	ww[:,(f > 104.29) & (f < 104.32)] = 0
	ww[:,(f > 104.45) & (f < 104.55)] = 0
	ww[:,(f > 104.66) & (f < 104.73)] = 0
	ww[:,(f > 104.88) & (f < 104.93)] = 0
	ww[:,(f > 105.06) & (f < 105.14)] = 0
	ww[:,(f > 105.27) & (f < 105.33)] = 0
	ww[:,(f > 105.49) & (f < 105.52)] = 0
	ww[:,(f > 105.65) & (f < 105.73)] = 0
	ww[:,(f > 105.88) & (f < 105.92)] = 0
	ww[:,(f > 106.07) & (f < 106.13)] = 0
	ww[:,(f > 106.22) & (f < 106.38)] = 0
	ww[:,(f > 106.46) & (f < 106.53)] = 0
	ww[:,(f > 106.68) & (f < 106.72)] = 0
	ww[:,(f > 106.85) & (f < 106.93)] = 0
	ww[:,(f > 107.08) & (f < 107.12)] = 0
	ww[:,(f > 107.27) & (f < 107.34)] = 0
	ww[:,(f > 107.45) & (f < 107.55)] = 0
	ww[:,(f > 107.64) & (f < 107.76)] = 0
	ww[:,(f > 107.85) & (f < 107.95)] = 0
	ww[:,(f > 112.38) & (f < 112.42)] = 0
	ww[:,(f > 112.88) & (f < 112.92)] = 0
	ww[:,(f > 112.98) & (f < 113.02)] = 0
	ww[:,(f > 113.88) & (f < 113.92)] = 0
	ww[:,(f > 114.08) & (f < 114.12)] = 0
	ww[:,(f > 114.28) & (f < 114.32)] = 0
	ww[:,(f > 121.13) & (f < 121.20)] = 0
	ww[:,(f > 128.43) & (f < 128.46)] = 0
	ww[:,(f > 130.02) & (f < 130.12)] = 0
	ww[:,(f > 130.52) & (f < 130.59)] = 0
	ww[:,(f > 131.52) & (f < 131.59)] = 0
	#ww[(f > 135.50) & (f < 138.50)] = 0      # This is for testing only, remove ORBCOM some other way !!!
	ww[:,(f > 144.12) & (f < 144.15)] = 0
	ww[:,(f > 148.60) & (f < 148.65)] = 0
	ww[:,(f > 149.02) & (f < 149.07)] = 0	
	ww[:,(f > 145.78) & (f < 146.10)] = 0
	ww[:,(f > 149.85) & (f < 150.04)] = 0
	ww[:,(f > 150.15) & (f < 150.30)] = 0
	ww[:,(f > 150.32) & (f < 150.46)] = 0
	ww[:,(f > 150.58) & (f < 150.66)] = 0
	ww[:,(f > 151.30) & (f < 151.50)] = 0
	ww[:,(f > 155.30) & (f < 155.35)] = 0



	ww[:,(f > 100.66) & (f < 100.73)] = 0
	ww[:,(f > 117.19) & (f < 117.21)] = 0
	ww[:,(f > 118.295) & (f < 118.307)] = 0
	ww[:,(f > 120.79) & (f < 120.81)] = 0
	ww[:,(f > 121.125) & (f < 121.214)] = 0
	ww[:,(f > 122.084) & (f < 122.120)] = 0
	ww[:,(f > 122.39) & (f < 122.41)] = 0
	ww[:,(f > 122.586) & (f < 122.617)] = 0
	ww[:,(f > 123.391) & (f < 123.41)] = 0
	ww[:,(f > 124.485) & (f < 124.515)] = 0
	ww[:,(f > 124.79) & (f < 124.815)] = 0
	ww[:,(f > 125.418) & (f < 125.46)] = 0
	ww[:,(f > 125.687) & (f < 125.724)] = 0
	ww[:,(f > 125.888) & (f < 125.938)] = 0
	ww[:,(f > 126.694) & (f < 126.705)] = 0
	ww[:,(f > 127.28) & (f < 127.324)] = 0
	ww[:,(f > 128.59) & (f < 128.611)] = 0
	ww[:,(f > 128.794) & (f < 128.812)] = 0
	ww[:,(f > 129.248) & (f < 129.257)] = 0
	ww[:,(f > 129.482) & (f < 129.52)] = 0
	ww[:,(f > 129.813) & (f < 129.99)] = 0
	ww[:,(f > 130.337) & (f < 130.356)] = 0
	ww[:,(f > 131.131) & (f < 131.168)] = 0
	ww[:,(f > 131.436) & (f < 131.467)] = 0
	ww[:,(f > 131.943) & (f < 131.961)] = 0
	ww[:,(f > 131.984) & (f < 132.018)] = 0
	ww[:,(f > 133.481) & (f < 133.517)] = 0
	ww[:,(f > 133.78) & (f < 133.823)] = 0
	ww[:,(f > 133.988) & (f < 134.012)] = 0
	ww[:,(f > 134.183) & (f < 134.216)] = 0
	ww[:,(f > 135.336) & (f < 135.367)] = 0
	ww[:,(f > 136.252) & (f < 136.276)] = 0
	ww[:,(f > 136.398) & (f < 136.453)] = 0
	ww[:,(f > 136.429) & (f < 136.453)] = 0
	ww[:,(f > 136.624) & (f < 136.703)] = 0
	ww[:,(f > 136.759) & (f < 136.813)] = 0
	ww[:,(f > 136.96) & (f < 137.472)] = 0
	ww[:,(f > 137.491) & (f < 137.657)] = 0
	ww[:,(f > 137.662) & (f < 137.832)] = 0
	ww[:,(f > 137.863) & (f < 137.949)] = 0
	ww[:,(f > 145.761) & (f < 145.777)] = 0
	ww[:,(f > 153.885) & (f < 153.921)] = 0
	ww[:,(f > 179.996) & (f < 180.03)] = 0

	ww[:,(f > 118.23) & (f < 118.40)] = 0
	ww[:,(f > 118.90) & (f < 119.10)] = 0
	ww[:,(f > 119.61) & (f < 119.70)] = 0
	ww[:,(f > 120.76) & (f < 120.86)] = 0
	ww[:,(f > 121.46) & (f < 121.54)] = 0
	ww[:,(f > 125.16) & (f < 125.25)] = 0
	ww[:,(f > 126.50) & (f < 126.60)] = 0
	ww[:,(f > 126.76) & (f < 126.85)] = 0
	ww[:,(f > 126.96) & (f < 127.05)] = 0
	ww[:,(f > 127.24) & (f < 127.37)] = 0
	ww[:,(f > 128.11) & (f < 128.20)] = 0
	ww[:,(f > 128.65) & (f < 128.86)] = 0
	ww[:,(f > 129.20) & (f < 129.30)] = 0
	ww[:,(f > 129.70) & (f < 130.15)] = 0
	ww[:,(f > 130.35) & (f < 130.45)] = 0
	ww[:,(f > 131.20) & (f < 131.34)] = 0
	ww[:,(f > 131.42) & (f < 131.62)] = 0
	ww[:,(f > 131.68) & (f < 131.78)] = 0
	ww[:,(f > 131.90) & (f < 132.06)] = 0
	ww[:,(f > 132.13) & (f < 132.18)] = 0
	ww[:,(f > 133.58) & (f < 133.62)] = 0
	ww[:,(f > 133.68) & (f < 133.73)] = 0
	ww[:,(f > 133.88) & (f < 133.93)] = 0
	ww[:,(f > 134.16) & (f < 134.24)] = 0
	ww[:,(f > 136.23) & (f < 136.29)] = 0
	ww[:,(f > 136.37) & (f < 136.47)] = 0
	ww[:,(f > 136.60) & (f < 136.73)] = 0
	ww[:,(f > 136.84) & (f < 137.98)] = 0
	ww[:,(f > 147.50) & (f < 147.57)] = 0



















	dd[:,(f > 120.12) & (f < 120.20)] = 0
	dd[:,(f > 126.67) & (f < 126.73)] = 0
	dd[:,(f > 129.12) & (f < 129.18)] = 0
	dd[:,(f > 130.50) & (f < 130.62)] = 0
	dd[:,(f > 133.52) & (f < 133.58)] = 0
	dd[:,(f > 136.20) & (f < 136.30)] = 0
	dd[:,(f > 152.32) & (f < 152.37)] = 0
	dd[:,(f > 159.59) & (f < 159.65)] = 0
	dd[:,(f > 159.75) & (f < 159.80)] = 0
	
	ww[:,(f > 120.12) & (f < 120.20)] = 0
	ww[:,(f > 126.67) & (f < 126.73)] = 0
	ww[:,(f > 129.12) & (f < 129.18)] = 0
	ww[:,(f > 130.50) & (f < 130.62)] = 0
	ww[:,(f > 133.52) & (f < 133.58)] = 0
	ww[:,(f > 136.20) & (f < 136.30)] = 0
	ww[:,(f > 152.32) & (f < 152.37)] = 0
	ww[:,(f > 159.59) & (f < 159.65)] = 0
	ww[:,(f > 159.75) & (f < 159.80)] = 0






	if (len(d.shape) == 1) and (len(w.shape) == 1):
		dd = np.copy(dd.flatten())
		ww = np.copy(ww.flatten())


	return dd, ww




















def low_band_s11_calibration_measurements_june_2016(flag=''):



	# Data paths
	main_path               = home_folder + '/DATA/EDGES/receiver_calibration/calibration_june_2016/LNA/S11/raw/receiver_input_and_calibration_verification_loads/'

	path_LNA1               = main_path + 'receiver_input_two_measurements/'
	path_LNA2               = main_path + 'receiver_input_third_measurement/'

	path_ambient_before     = main_path + 'ambient_load_before/'
	path_ambient_after      = main_path + 'ambient_load_after/'

	path_hot_before         = main_path + 'hot_load_before/'
	path_hot_after          = main_path + 'hot_load_after/'	

	path_open_cable         = main_path + 'long_cable_open/'
	path_shorted_cable      = main_path + 'long_cable_short/'

	#path_open_cable         = main_path + '25Credo/Cable_Open_after_spectra/'
	#path_shorted_cable      = main_path + '25Credo/Cable_Shorted_after_spectra_2/'

	path_simulator1_before  = main_path + 'antenna_simulator1_before/'
	path_simulator1_after   = main_path + 'antenna_simulator1_after/'

	path_simulator2         = main_path + 'antenna_simulator2/'

	path_alans_cable_before = main_path + 'alans_simulator/alans_cable_before/'
	path_alans_cable_after  = main_path + 'alans_simulator/alans_cable_after/'

	path_alans_board_before = main_path + 'alans_simulator/alans_board_before/'
	path_alans_board_after  = main_path + 'alans_simulator/alans_board_after/'

	path_alans_board_and_cable_before = main_path + 'alans_simulator/alans_board_and_cable_before/'
	path_alans_board_and_cable_after  = main_path + 'alans_simulator/alans_board_and_cable_after/'






	# Receiver reflection coefficient
	# -------------------------------

	# Reading measurements
	o1,    fr = rc.s1p_read(path_LNA1 + 'female_calibration_Open_s11.s1p')
	s1,    fr = rc.s1p_read(path_LNA1 + 'female_calibration_Short_s11.s1p')
	l1,    fr = rc.s1p_read(path_LNA1 + 'female_calibration_Load_49.97_s11.s1p')
	LNA11, fr = rc.s1p_read(path_LNA1 + 'lowband_receiver_input_s11.s1p')
	LNA12, fr = rc.s1p_read(path_LNA1 + 'lowband_receiver_input_s11_second_measurement.s1p')

	o2,    fr = rc.s1p_read(path_LNA2 + 'Open_S11.s1p')
	s2,    fr = rc.s1p_read(path_LNA2 + 'Short_S11.s1p')
	l2,    fr = rc.s1p_read(path_LNA2 + 'Match_S11_49.97.s1p')	
	LNA2,  fr = rc.s1p_read(path_LNA2 + 'Receiver_S11.s1p')


	# Models of standards
	resistance_of_match = 49.97 # female
	md = 1
	oa, sa, la = rc.agilent_85033E(fr, resistance_of_match, md)	


	# Correction of measurements
	LNA11c, x1, x2, x3  = rc.de_embed(oa, sa, la, o1, s1, l1, LNA11)
	LNA12c, x1, x2, x3  = rc.de_embed(oa, sa, la, o1, s1, l1, LNA12)
	LNA2c,  x1, x2, x3  = rc.de_embed(oa, sa, la, o2, s2, l2, LNA2)




	LNA_ff = LNA12c[(fr/1e6>=50) & (fr/1e6<=100)]
	fr_ff  = fr[(fr/1e6>=50) & (fr/1e6<=100)]












	# Calibration loads
	# -----------------


	# Ambient load before
	# -------------------
	o_m,  f_a1 = rc.s1p_read(path_ambient_before + 'Open_S11.s1p')
	s_m,  f_a1 = rc.s1p_read(path_ambient_before + 'Short_S11.s1p')
	l_m,  f_a1 = rc.s1p_read(path_ambient_before + 'Match_S11.s1p')
	a1_m, f_a1 = rc.s1p_read(path_ambient_before + 'Ext_load_S11.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_a1))
	s_sw = -1 * np.ones(len(f_a1))
	l_sw =  0 * np.ones(len(f_a1))


	# Correction at switch
	a1_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, a1_m)


	# Correction at receiver input
	a1_c = low_band_switch_correction_june_2016(a1_sw_c, f_in = f_a1, verification = 'no')



	a1_ff  = a1_c[(f_a1/1e6>=50) & (f_a1/1e6<=100)]
	fa1_ff = f_a1[(f_a1/1e6>=50) & (f_a1/1e6<=100)]






	# Ambient load after  (BETTER !!)
	# -------------------
	o_m,  f_a2 = rc.s1p_read(path_ambient_after + 'Open_S11.s1p')
	s_m,  f_a2 = rc.s1p_read(path_ambient_after + 'Short_S11.s1p')
	l_m,  f_a2 = rc.s1p_read(path_ambient_after + 'Match_S11.s1p')
	a2_m, f_a2 = rc.s1p_read(path_ambient_after + 'External_S11.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_a1))
	s_sw = -1 * np.ones(len(f_a1))
	l_sw =  0 * np.ones(len(f_a1))	


	# Correction at switch
	a2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, a2_m)


	# Correction at receiver input
	a2_c = low_band_switch_correction_june_2016(a2_sw_c, f_in = f_a2, verification = 'no')	



	a2_ff  = a2_c[(f_a2/1e6>=50) & (f_a2/1e6<=100)]
	fa2_ff = f_a2[(f_a2/1e6>=50) & (f_a2/1e6<=100)]












	# Hot load before
	# -------------------
	o_m,  f_h1 = rc.s1p_read(path_hot_before + 'Open_S11.s1p')
	s_m,  f_h1 = rc.s1p_read(path_hot_before + 'Short_S11.s1p')
	l_m,  f_h1 = rc.s1p_read(path_hot_before + 'Match_S11.s1p')
	h1_m, f_h1 = rc.s1p_read(path_hot_before + 'External_S11.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_h1))
	s_sw = -1 * np.ones(len(f_h1))
	l_sw =  0 * np.ones(len(f_h1))	


	# Correction at switch
	h1_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, h1_m)


	# Correction at receiver input
	h1_c = low_band_switch_correction_june_2016(h1_sw_c, f_in = f_h1, verification = 'no')



	h1_ff  = h1_c[(f_h1/1e6>=50) & (f_h1/1e6<=100)]
	fh1_ff = f_h1[(f_h1/1e6>=50) & (f_h1/1e6<=100)]	







	# Hot load after (BETTER !!!)
	# --------------
	o_m,  f_h2 = rc.s1p_read(path_hot_after + 'Open_S11.s1p')
	s_m,  f_h2 = rc.s1p_read(path_hot_after + 'Short_S11.s1p')
	l_m,  f_h2 = rc.s1p_read(path_hot_after + 'Match_S11.s1p')
	h2_m, f_h2 = rc.s1p_read(path_hot_after + 'External_S11.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_h1))
	s_sw = -1 * np.ones(len(f_h1))
	l_sw =  0 * np.ones(len(f_h1))	


	# Correction at switch
	h2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, h2_m)


	# Correction at receiver input
	h2_c = low_band_switch_correction_june_2016(h2_sw_c, f_in = f_h2, verification = 'no')	



	h2_ff  = h2_c[(f_h2/1e6>=50) & (f_h2/1e6<=100)]
	fh2_ff = f_h2[(f_h2/1e6>=50) & (f_h2/1e6<=100)]	












	# Open cable
	# ----------
	o_m,    f_oc = rc.s1p_read(path_open_cable + 'Open_S11.s1p')
	s_m,    f_oc = rc.s1p_read(path_open_cable + 'Short_S11.s1p')
	l_m,    f_oc = rc.s1p_read(path_open_cable + 'Match_S11.s1p')
	oc_m,   f_oc = rc.s1p_read(path_open_cable + 'long_cable_S11.s1p')	

	#o_m,    f_oc = rc.s1p_read(path_open_cable + 'Open_S11.s1p')
	#s_m,    f_oc = rc.s1p_read(path_open_cable + 'Short_S11.s1p')
	#l_m,    f_oc = rc.s1p_read(path_open_cable + 'Match_S11.s1p')
	#oc_m,   f_oc = rc.s1p_read(path_open_cable + 'External_S11.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_oc))
	s_sw = -1 * np.ones(len(f_oc))
	l_sw =  0 * np.ones(len(f_oc))


	# Correction at switch
	oc_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, oc_m)


	# Correction at receiver input
	oc_c = low_band_switch_correction_june_2016(oc_sw_c, f_in = f_oc, verification = 'no')



	oc_ff  = oc_c[(f_oc/1e6>=50) & (f_oc/1e6<=100)]
	foc_ff = f_oc[(f_oc/1e6>=50) & (f_oc/1e6<=100)]









	# Shorted cable
	# -------------
	o_m,    f_sc = rc.s1p_read(path_shorted_cable + 'Open_S11.s1p')
	s_m,    f_sc = rc.s1p_read(path_shorted_cable + 'Short_S11.s1p')
	l_m,    f_sc = rc.s1p_read(path_shorted_cable + 'Match_S11.s1p')
	sc_m,   f_sc = rc.s1p_read(path_shorted_cable + 'Cable_S11.s1p')

	#o_m,    f_sc = rc.s1p_read(path_shorted_cable + 'Open1_S11.s1p')
	#s_m,    f_sc = rc.s1p_read(path_shorted_cable + 'Short1_S11.s1p')
	#l_m,    f_sc = rc.s1p_read(path_shorted_cable + 'Match1_S11.s1p')
	#sc_m,   f_sc = rc.s1p_read(path_shorted_cable + 'External1_S11.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_sc))
	s_sw = -1 * np.ones(len(f_sc))
	l_sw =  0 * np.ones(len(f_sc))	


	# Correction at switch
	sc_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, sc_m)


	# Correction at receiver input
	sc_c = low_band_switch_correction_june_2016(sc_sw_c, f_in = f_sc, verification = 'no')



	sc_ff  = sc_c[(f_sc/1e6>=50) & (f_sc/1e6<=100)]
	fsc_ff = f_sc[(f_sc/1e6>=50) & (f_sc/1e6<=100)]









	# Antenna simulator 1 before
	# -------------------------- 
	o_m,    f_s11 = rc.s1p_read(path_simulator1_before + 'Open_S11.s1p')
	s_m,    f_s11 = rc.s1p_read(path_simulator1_before + 'Short_S11.s1p')
	l_m,    f_s11 = rc.s1p_read(path_simulator1_before + 'Match_S11.s1p')
	s11_m,  f_s11 = rc.s1p_read(path_simulator1_before + 'External_S11.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_s11))
	s_sw = -1 * np.ones(len(f_s11))
	l_sw =  0 * np.ones(len(f_s11))


	# Correction at switch
	s11_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, s11_m)


	# Correction at receiver input
	s11_c = low_band_switch_correction_june_2016(s11_sw_c, f_in = f_s11, verification = 'no')



	s11_ff  = s11_c[(f_s11/1e6>=50) & (f_s11/1e6<=100)]
	fs11_ff = f_s11[(f_s11/1e6>=50) & (f_s11/1e6<=100)]





	# Antenna simulator 1 after
	# -------------------------- 
	o_m,    f_s12 = rc.s1p_read(path_simulator1_after + 'Open_S11.s1p')
	s_m,    f_s12 = rc.s1p_read(path_simulator1_after + 'Short_S11.s1p')
	l_m,    f_s12 = rc.s1p_read(path_simulator1_after + 'Match_S11.s1p')
	s12_m,  f_s12 = rc.s1p_read(path_simulator1_after + 'External_S11.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_s12))
	s_sw = -1 * np.ones(len(f_s12))
	l_sw =  0 * np.ones(len(f_s12))


	# Correction at switch
	s12_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, s12_m)


	# Correction at receiver input
	s12_c = low_band_switch_correction_june_2016(s12_sw_c, f_in = f_s12, verification = 'no')



	s12_ff  = s12_c[(f_s12/1e6>=50) & (f_s12/1e6<=100)]
	fs12_ff = f_s12[(f_s12/1e6>=50) & (f_s12/1e6<=100)]









	# Antenna simulator 2
	# -------------------------- 
	o_m,  f_s2 = rc.s1p_read(path_simulator2 + 'Open_S11.s1p')
	s_m,  f_s2 = rc.s1p_read(path_simulator2 + 'Short_S11.s1p')
	l_m,  f_s2 = rc.s1p_read(path_simulator2 + 'Match_S11.s1p')
	s2_m, f_s2 = rc.s1p_read(path_simulator2 + 'External_S11.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_s2))
	s_sw = -1 * np.ones(len(f_s2))
	l_sw =  0 * np.ones(len(f_s2))


	# Correction at switch
	s2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, s2_m)


	# Correction at receiver input
	s2_c = low_band_switch_correction_june_2016(s2_sw_c, f_in = f_s2, verification = 'no')



	s2_ff  = s2_c[(f_s2/1e6>=50) & (f_s2/1e6<=100)]
	fs2_ff = f_s2[(f_s2/1e6>=50) & (f_s2/1e6<=100)]








	# Alans board before
	# -------------------------- 
	o_m,   f_abb = rc.s1p_read(path_alans_board_before + 'Open_S11.s1p')
	s_m,   f_abb = rc.s1p_read(path_alans_board_before + 'Short_S11.s1p')
	l_m,   f_abb = rc.s1p_read(path_alans_board_before + 'Match_S11.s1p')
	abb_m, f_abb = rc.s1p_read(path_alans_board_before + 'External_S11.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_abb))
	s_sw = -1 * np.ones(len(f_abb))
	l_sw =  0 * np.ones(len(f_abb))


	# Correction at switch
	abb_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, abb_m)


	# Correction at receiver input
	abb_c = low_band_switch_correction_june_2016(abb_sw_c, f_in = f_abb, verification = 'no')



	abb_ff  = abb_c[(f_abb/1e6>=50) & (f_abb/1e6<=100)]
	fabb_ff = f_abb[(f_abb/1e6>=50) & (f_abb/1e6<=100)]









	# Alans board after
	# -------------------------- 
	o_m,   f_aba = rc.s1p_read(path_alans_board_after + 'Open_S11.s1p')
	s_m,   f_aba = rc.s1p_read(path_alans_board_after + 'Short_S11.s1p')
	l_m,   f_aba = rc.s1p_read(path_alans_board_after + 'Match_S11.s1p')
	aba_m, f_aba = rc.s1p_read(path_alans_board_after + 'External_S11.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_aba))
	s_sw = -1 * np.ones(len(f_aba))
	l_sw =  0 * np.ones(len(f_aba))


	# Correction at switch
	aba_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, aba_m)


	# Correction at receiver input
	aba_c = low_band_switch_correction_june_2016(aba_sw_c, f_in = f_aba, verification = 'no')



	aba_ff  = aba_c[(f_aba/1e6>=50) & (f_aba/1e6<=100)]
	faba_ff = f_aba[(f_aba/1e6>=50) & (f_aba/1e6<=100)]








	# Alans board and cable before
	# ---------------------------- 
	o_m,   f_abcb  = rc.s1p_read(path_alans_board_and_cable_before + 'Open_S11.s1p')
	s_m,   f_abcb  = rc.s1p_read(path_alans_board_and_cable_before + 'Short_S11.s1p')
	l_m,   f_abcb  = rc.s1p_read(path_alans_board_and_cable_before + 'Match_S11.s1p')
	abcb_m, f_abcb = rc.s1p_read(path_alans_board_and_cable_before + 'External_S11.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_abcb))
	s_sw = -1 * np.ones(len(f_abcb))
	l_sw =  0 * np.ones(len(f_abcb))


	# Correction at switch
	abcb_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, abcb_m)


	# Correction at receiver input
	abcb_c = low_band_switch_correction_june_2016(abcb_sw_c, f_in = f_abcb, verification = 'no')



	abcb_ff  = abcb_c[(f_abcb/1e6>=50) & (f_abcb/1e6<=100)]
	fabcb_ff = f_abcb[(f_abcb/1e6>=50) & (f_abcb/1e6<=100)]








	# Alans board and cable after
	# --------------------------- 
	o_m,   f_abca  = rc.s1p_read(path_alans_board_and_cable_after + 'Open_S11.s1p')
	s_m,   f_abca  = rc.s1p_read(path_alans_board_and_cable_after + 'Short_S11.s1p')
	l_m,   f_abca  = rc.s1p_read(path_alans_board_and_cable_after + 'Match_S11.s1p')
	abca_m, f_abca = rc.s1p_read(path_alans_board_and_cable_after + 'External_S11.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_abca))
	s_sw = -1 * np.ones(len(f_abca))
	l_sw =  0 * np.ones(len(f_abca))


	# Correction at switch
	abca_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, abca_m)


	# Correction at receiver input
	abca_c = low_band_switch_correction_june_2016(abca_sw_c, f_in = f_abca, verification = 'no')



	abca_ff  = abca_c[(f_abca/1e6>=50) & (f_abca/1e6<=100)]
	fabca_ff = f_abca[(f_abca/1e6>=50) & (f_abca/1e6<=100)]	








	# S-parameters of Alans cable before
	#-----------------------------------
	ovm,   fc  = rc.s1p_read(path_alans_cable_before + 'VNA_port_directly/Open_S11.s1p')
	svm,   fc  = rc.s1p_read(path_alans_cable_before + 'VNA_port_directly/Short_S11.s1p')
	lvm,   fc  = rc.s1p_read(path_alans_cable_before + 'VNA_port_directly/Load_S11.s1p')
	ocm,   fc  = rc.s1p_read(path_alans_cable_before + 'CableBoxItself/Open_S11.s1p')
	scm,   fc  = rc.s1p_read(path_alans_cable_before + 'CableBoxItself/Short_S11.s1p')
	lcm,   fc  = rc.s1p_read(path_alans_cable_before + 'CableBoxItself/Load_S11.s1p')	


	# Models of standards
	resistance_of_match = 50.01 # male
	md = 1
	oa, sa, la = rc.agilent_85033E(fc, resistance_of_match, md)	


	# Correcting measurements at VNA input
	occ, x1, x2, x3 = rc.de_embed(oa, sa, la, ovm, svm, lvm, ocm)
	scc, x1, x2, x3 = rc.de_embed(oa, sa, la, ovm, svm, lvm, scm)
	lcc, x1, x2, x3 = rc.de_embed(oa, sa, la, ovm, svm, lvm, lcm)


	# S-parameters of cable
	xx, s11b, s12s21b, s22b = rc.de_embed(oa, sa, la, occ, scc, lcc, occ)



	s11b_ff     = s11b[(fc/1e6>=50) & (fc/1e6<=100)]
	s12s21b_ff  = s12s21b[(fc/1e6>=50) & (fc/1e6<=100)]
	s22b_ff     = s22b[(fc/1e6>=50) & (fc/1e6<=100)]
	fs11b_ff    = fc[(fc/1e6>=50) & (fc/1e6<=100)]









	# S-parameters of Alans cable after
	#----------------------------------
	ovm,   fc  = rc.s1p_read(path_alans_cable_after + 'VNA/Open_S11.s1p')
	svm,   fc  = rc.s1p_read(path_alans_cable_after + 'VNA/Short_S11.s1p')
	lvm,   fc  = rc.s1p_read(path_alans_cable_after + 'VNA/Match_S11.s1p')
	ocm,   fc  = rc.s1p_read(path_alans_cable_after + 'Cable_Box/Open_S11.s1p')
	scm,   fc  = rc.s1p_read(path_alans_cable_after + 'Cable_Box/Short_S11.s1p')
	lcm,   fc  = rc.s1p_read(path_alans_cable_after + 'Cable_Box/Match_S11.s1p')	


	# Models of standards
	resistance_of_match = 50.01 # male
	md = 1
	oa, sa, la = rc.agilent_85033E(fc, resistance_of_match, md)	


	# Correcting measurements at VNA input
	occ, x1, x2, x3 = rc.de_embed(oa, sa, la, ovm, svm, lvm, ocm)
	scc, x1, x2, x3 = rc.de_embed(oa, sa, la, ovm, svm, lvm, scm)
	lcc, x1, x2, x3 = rc.de_embed(oa, sa, la, ovm, svm, lvm, lcm)


	# S-parameters of cable
	xx, s11a, s12s21a, s22a = rc.de_embed(oa, sa, la, occ, scc, lcc, occ)



	s11a_ff     = s11a[(fc/1e6>=50) & (fc/1e6<=100)]
	s12s21a_ff  = s12s21a[(fc/1e6>=50) & (fc/1e6<=100)]
	s22a_ff     = s22a[(fc/1e6>=50) & (fc/1e6<=100)]
	fs11a_ff    = fc[(fc/1e6>=50) & (fc/1e6<=100)]






	# S-parameters of semi-rigid cable (they are already at 250 kHz)
	# --------------------------------------------------------------
	d = np.genfromtxt(home_folder + '/DATA/EDGES/receiver_calibration/calibration_august_2015/LNA/S11/corrected/s11_calibration_low_band_LNA25degC_2015-09-16-20-09-50_simulator2_long_new_LNA3.txt')

	sr_s11r    = d[:,11]
	sr_s11i    = d[:,12]
	sr_s12s21r = d[:,13]
	sr_s12s21i = d[:,14]
	sr_s22r    = d[:,15]
	sr_s22i    = d[:,16]




	# Now, saving data
	temp = np.array([ fs11a_ff/1e6, 
	                  np.real(LNA_ff),  np.imag(LNA_ff), 
	                  np.real(a2_ff),   np.imag(a2_ff),   np.real(h2_ff),      np.imag(h2_ff),
	                  np.real(oc_ff),   np.imag(oc_ff),   np.real(sc_ff),      np.imag(sc_ff),
	                  sr_s11r,          sr_s11i,          sr_s12s21r,          sr_s12s21i,          sr_s22r,          sr_s22i,
	                  np.real(s11_ff),  np.imag(s11_ff),  np.real(s2_ff),      np.imag(s2_ff),
	                  np.real(abcb_ff), np.imag(abcb_ff), np.real(abb_ff),     np.imag(abb_ff),   
	                  np.real(s11a_ff), np.imag(s11a_ff), np.real(s12s21a_ff), np.imag(s12s21a_ff), np.real(s22a_ff), np.imag(s22a_ff) ])






	# Now, saving data
	# temp = np.array([ fs11a_ff/1e6, np.real(lnac), np.imag(lnac), \
				#np.real(ambc),     np.imag(ambc),     np.real(hotc),         np.imag(hotc), \
				#np.real(occ),      np.imag(occ),      np.real(scc),          np.imag(scc),  \
				#np.real(s11_sr),   np.imag(s11_sr),   np.real(s12s21_sr),    np.imag(s12s21_sr), np.real(s22_sr), np.imag(s22_sr), \
				#np.real(s1c),      np.imag(s1c),      np.real(s2c),          np.imag(s2c)  ])



	output_file     = temp.T
	save_path       = home_folder + '/DATA/EDGES/receiver_calibration/calibration_june_2016/LNA/S11/corrected/'
	temperature_LNA = '25degC'
	output_file_str = save_path + 's11_calibration_low_band_LNA' + temperature_LNA + '_' + tt.strftime('%Y-%m-%d-%H-%M-%S') + flag + '.txt'
	np.savetxt(output_file_str, output_file)

	print('File saved to: ' + output_file_str)		




	return output_file



























def low_band_s11_calibration_measurements_june_2016_25Credo(save='no', flag=''):



	# Data paths
	main_path  = home_folder + '/DATA/EDGES/receiver_calibration/calibration_june_2016/LNA/S11/raw/receiver_input_and_calibration_verification_loads/25Credo/'

	path_LNA1  = main_path + 'Receiver_S11/Pass01/'
	path_LNA2  = main_path + 'Receiver_S11/Pass02/'
	path_LNA3  = main_path + 'Receiver_S11/Pass03/'
	path_LNA4  = main_path + 'Receiver_S11/Pass04/'
	path_LNA5  = main_path + 'Receiver_S11/Pass05/'
	path_LNA6  = main_path + 'Receiver_S11/Pass06/'
	path_LNA7  = main_path + 'Receiver_S11/Pass07/'
	path_LNA8  = main_path + 'Receiver_S11/Pass08/'
	path_LNA9  = main_path + 'Receiver_S11/Pass09/'
	path_LNA10 = main_path + 'Receiver_S11/Pass10/'
	path_LNA11 = main_path + 'Receiver_S11/Pass11/'
	path_LNA12 = main_path + 'Receiver_S11/Pass12/'
	path_LNA13 = main_path + 'Receiver_S11/Pass13/'
	path_LNA14 = main_path + 'Receiver_S11/Pass14/'
	path_LNA15 = main_path + 'Receiver_S11/Pass15/'
	path_LNA16 = main_path + 'Receiver_S11/Pass16_after_traveling/'
	path_LNA17 = main_path + 'Receiver_S11/Pass17_3hrs_later/'





	path_ambient_before     = main_path + 'Ambient_before/'
	path_ambient_after      = main_path + 'Ambient_after/'

	path_hot_after          = main_path + 'hot_after/'	

	path_open_cable_before  = main_path + 'Cable_Open_before_spectra/'
	path_open_cable_after   = main_path + 'Cable_Open_after_spectra/'

	path_shorted_cable_before = main_path + 'Cable_Shorted_before_spectra_2/'
	path_shorted_cable_after  = main_path + 'Cable_Shorted_after_spectra_2/'

	path_simulator1_before  = main_path + 'Cable_Short_before_spectra/'   # Actually, we measured the long cable terminated at th5 50-ohm load
	path_simulator1_after   = main_path + 'Cable_Short_after_spectra/'    # Actually, we measured the long cable terminated at th5 50-ohm load

	path_simulator2_before  = main_path + 'Sim2_before/'
	path_simulator2_after   = main_path + 'Sim2_after/'




	# Receiver reflection coefficient
	# -------------------------------

	# Reading measurements
	o1,    fr = rc.s1p_read(path_LNA1 + 'Open1.s1p')
	s1,    fr = rc.s1p_read(path_LNA1 + 'Short1.s1p')
	l1,    fr = rc.s1p_read(path_LNA1 + 'Match1.s1p')
	LNA1,  fr = rc.s1p_read(path_LNA1 + 'Receiver1.s1p')

	o2,    fr = rc.s1p_read(path_LNA2 + 'Open.s1p')
	s2,    fr = rc.s1p_read(path_LNA2 + 'Short.s1p')
	l2,    fr = rc.s1p_read(path_LNA2 + 'Match.s1p')	
	LNA2,  fr = rc.s1p_read(path_LNA2 + 'Receiver.s1p')

	o3,    fr = rc.s1p_read(path_LNA3 + 'Open.s1p')
	s3,    fr = rc.s1p_read(path_LNA3 + 'Short.s1p')
	l3,    fr = rc.s1p_read(path_LNA3 + 'Match.s1p')	
	LNA3,  fr = rc.s1p_read(path_LNA3 + 'Receiver.s1p')

	o4,    fr = rc.s1p_read(path_LNA4 + 'Open.s1p')
	s4,    fr = rc.s1p_read(path_LNA4 + 'Short.s1p')
	l4,    fr = rc.s1p_read(path_LNA4 + 'Match.s1p')	
	LNA4,  fr = rc.s1p_read(path_LNA4 + 'Receiver.s1p')

	o5,    fr = rc.s1p_read(path_LNA5 + 'Open.s1p')
	s5,    fr = rc.s1p_read(path_LNA5 + 'Short.s1p')
	l5,    fr = rc.s1p_read(path_LNA5 + 'Load.s1p')	
	LNA5,  fr = rc.s1p_read(path_LNA5 + 'Receiver.s1p')


	o6,    fr = rc.s1p_read(path_LNA5 + 'Open.s1p')
	s6,    fr = rc.s1p_read(path_LNA5 + 'Short.s1p')
	l6,    fr = rc.s1p_read(path_LNA5 + 'Load.s1p')	
	LNA6,  fr = rc.s1p_read(path_LNA6 + 'Receiver.s1p')

	o7,    fr = rc.s1p_read(path_LNA5 + 'Open.s1p')
	s7,    fr = rc.s1p_read(path_LNA5 + 'Short.s1p')
	l7,    fr = rc.s1p_read(path_LNA5 + 'Load.s1p')	
	LNA7,  fr = rc.s1p_read(path_LNA7 + 'Receiver.s1p')        

	o8,    fr = rc.s1p_read(path_LNA5 + 'Open.s1p')
	s8,    fr = rc.s1p_read(path_LNA5 + 'Short.s1p')
	l8,    fr = rc.s1p_read(path_LNA5 + 'Load.s1p')	
	LNA8,  fr = rc.s1p_read(path_LNA8 + 'Receiver.s1p')

	o9,    fr = rc.s1p_read(path_LNA9 + 'Open.s1p')
	s9,    fr = rc.s1p_read(path_LNA9 + 'Short.s1p')
	l9,    fr = rc.s1p_read(path_LNA9 + 'Load.s1p')	
	LNA9,  fr = rc.s1p_read(path_LNA9 + 'Receiver.s1p')

	o10,    fr = rc.s1p_read(path_LNA10 + 'Open.s1p')
	s10,    fr = rc.s1p_read(path_LNA10 + 'Short.s1p')
	l10,    fr = rc.s1p_read(path_LNA10 + 'Match.s1p')	
	LNA10,  fr = rc.s1p_read(path_LNA10 + 'Receiver.s1p')  

	o11,    fr = rc.s1p_read(path_LNA11 + 'Open.s1p')
	s11,    fr = rc.s1p_read(path_LNA11 + 'Short.s1p')
	l11,    fr = rc.s1p_read(path_LNA11 + 'Match.s1p')	
	LNA11,  fr = rc.s1p_read(path_LNA11 + 'Receiver.s1p')         

	o12,    fr = rc.s1p_read(path_LNA12 + 'Open.s1p')
	s12,    fr = rc.s1p_read(path_LNA12 + 'Short.s1p')
	l12,    fr = rc.s1p_read(path_LNA12 + 'Match.s1p')	
	LNA12,  fr = rc.s1p_read(path_LNA12 + 'Receiver.s1p')

	o12,    fr = rc.s1p_read(path_LNA12 + 'Open.s1p')
	s12,    fr = rc.s1p_read(path_LNA12 + 'Short.s1p')
	l12,    fr = rc.s1p_read(path_LNA12 + 'Match.s1p')	
	LNA12,  fr = rc.s1p_read(path_LNA12 + 'Receiver.s1p')        

	o13,    fr = rc.s1p_read(path_LNA12 + 'Open.s1p')
	s13,    fr = rc.s1p_read(path_LNA12 + 'Short.s1p')
	l13,    fr = rc.s1p_read(path_LNA12 + 'Match.s1p')	
	LNA13,  fr = rc.s1p_read(path_LNA13 + 'Receiver_early_reading_after30mins.s1p')               

	o14,    fr = rc.s1p_read(path_LNA14 + 'Open.s1p')
	s14,    fr = rc.s1p_read(path_LNA14 + 'Short.s1p')
	l14,    fr = rc.s1p_read(path_LNA14 + 'Match.s1p')	
	LNA14,  fr = rc.s1p_read(path_LNA14 + 'Receiver.s1p')

	o15,    fr = rc.s1p_read(path_LNA15 + 'Open.s1p')
	s15,    fr = rc.s1p_read(path_LNA15 + 'Short.s1p')
	l15,    fr = rc.s1p_read(path_LNA15 + 'Match.s1p')	
	LNA15,  fr = rc.s1p_read(path_LNA15 + 'Receiver.s1p')        

	o16,    fr = rc.s1p_read(path_LNA16 + 'Open.s1p')
	s16,    fr = rc.s1p_read(path_LNA16 + 'Short.s1p')
	l16,    fr = rc.s1p_read(path_LNA16 + 'Match.s1p')	
	LNA16,  fr = rc.s1p_read(path_LNA16 + 'Receiver.s1p')        

	o17,    fr = rc.s1p_read(path_LNA17 + 'Open.s1p')
	s17,    fr = rc.s1p_read(path_LNA17 + 'Short.s1p')
	l17,    fr = rc.s1p_read(path_LNA17 + 'Match.s1p')	
	LNA17,  fr = rc.s1p_read(path_LNA17 + 'Receiver.s1p')          



	# Models of standards
	resistance_of_match = 49.97 # female
	md = 1
	oa, sa, la = rc.agilent_85033E(fr, resistance_of_match, md)	


	# Correction of measurements
	LNA1c, x1, x2, x3  = rc.de_embed(oa, sa, la, o1, s1, l1, LNA1)
	LNA2c, x1, x2, x3  = rc.de_embed(oa, sa, la, o2, s2, l2, LNA2)
	LNA3c, x1, x2, x3  = rc.de_embed(oa, sa, la, o3, s3, l3, LNA3)
	LNA4c, x1, x2, x3  = rc.de_embed(oa, sa, la, o4, s4, l4, LNA4)
	LNA5c, x1, x2, x3  = rc.de_embed(oa, sa, la, o5, s5, l5, LNA5)
	LNA6c, x1, x2, x3  = rc.de_embed(oa, sa, la, o6, s6, l6, LNA6)
	LNA7c, x1, x2, x3  = rc.de_embed(oa, sa, la, o7, s7, l7, LNA7)
	LNA8c, x1, x2, x3  = rc.de_embed(oa, sa, la, o8, s8, l8, LNA8)
	LNA9c, x1, x2, x3  = rc.de_embed(oa, sa, la, o9, s9, l9, LNA9)
	LNA10c, x1, x2, x3  = rc.de_embed(oa, sa, la, o10, s10, l10, LNA10)
	LNA11c, x1, x2, x3  = rc.de_embed(oa, sa, la, o11, s11, l11, LNA11)
	LNA12c, x1, x2, x3  = rc.de_embed(oa, sa, la, o12, s12, l12, LNA12)
	LNA13c, x1, x2, x3  = rc.de_embed(oa, sa, la, o13, s13, l13, LNA13)
	LNA14c, x1, x2, x3  = rc.de_embed(oa, sa, la, o14, s14, l14, LNA14)
	LNA15c, x1, x2, x3  = rc.de_embed(oa, sa, la, o15, s15, l15, LNA15)
	LNA16c, x1, x2, x3  = rc.de_embed(oa, sa, la, o16, s16, l16, LNA16)
	LNA17c, x1, x2, x3  = rc.de_embed(oa, sa, la, o17, s17, l17, LNA17)


	LNA_ff = LNA15c[(fr/1e6>=50) & (fr/1e6<=100)]   # Choosing LNA measurement (best is LNA2c, at 25degC)
	fr_ff  = fr[(fr/1e6>=50) & (fr/1e6<=100)]












	# Calibration loads
	# -----------------


	# Ambient load before
	# -------------------
	o_m,  f_a1 = rc.s1p_read(path_ambient_before + 'Open1_S11.s1p')
	s_m,  f_a1 = rc.s1p_read(path_ambient_before + 'Short1_S11.s1p')
	l_m,  f_a1 = rc.s1p_read(path_ambient_before + 'Match1_S11.s1p')
	a1_m, f_a1 = rc.s1p_read(path_ambient_before + 'External1_S11.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_a1))
	s_sw = -1 * np.ones(len(f_a1))
	l_sw =  0 * np.ones(len(f_a1))


	# Correction at switch
	a1_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, a1_m)


	# Correction at receiver input
	a1_c = low_band_switch_correction_june_2016(a1_sw_c, f_in = f_a1, verification = 'no')



	a1_ff  = a1_c[(f_a1/1e6>=50) & (f_a1/1e6<=100)]
	fa1_ff = f_a1[(f_a1/1e6>=50) & (f_a1/1e6<=100)]






	# Ambient load after  (BETTER !!)
	# -------------------
	o_m,  f_a2 = rc.s1p_read(path_ambient_after + 'Open1_S11.s1p')
	s_m,  f_a2 = rc.s1p_read(path_ambient_after + 'Short1_S11.s1p')
	l_m,  f_a2 = rc.s1p_read(path_ambient_after + 'Match1_S11.s1p')
	a2_m, f_a2 = rc.s1p_read(path_ambient_after + 'External1_S11.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_a1))
	s_sw = -1 * np.ones(len(f_a1))
	l_sw =  0 * np.ones(len(f_a1))	


	# Correction at switch
	a2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, a2_m)


	# Correction at receiver input
	a2_c = low_band_switch_correction_june_2016(a2_sw_c, f_in = f_a2, verification = 'no')	



	a2_ff  = a2_c[(f_a2/1e6>=50) & (f_a2/1e6<=100)]
	fa2_ff = f_a2[(f_a2/1e6>=50) & (f_a2/1e6<=100)]














	# Hot load after (there is no BEFORE, because it would not be valid)
	# ------------------------------------------------------------------
	o_m,  f_h2 = rc.s1p_read(path_hot_after + 'Open1_S11.s1p')
	s_m,  f_h2 = rc.s1p_read(path_hot_after + 'Short1_S11.s1p')
	l_m,  f_h2 = rc.s1p_read(path_hot_after + 'Match1_S11.s1p')
	h2_m, f_h2 = rc.s1p_read(path_hot_after + 'External1_S11.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_h2))
	s_sw = -1 * np.ones(len(f_h2))
	l_sw =  0 * np.ones(len(f_h2))	


	# Correction at switch
	h2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, h2_m)


	# Correction at receiver input
	h2_c = low_band_switch_correction_june_2016(h2_sw_c, f_in = f_h2, verification = 'no')	



	h2_ff  = h2_c[(f_h2/1e6>=50) & (f_h2/1e6<=100)]
	fh2_ff = f_h2[(f_h2/1e6>=50) & (f_h2/1e6<=100)]	












	# Open cable (BEFORE)
	# ----------
	o_m,    f_oc1 = rc.s1p_read(path_open_cable_before + 'Open_S11.s1p')
	s_m,    f_oc1 = rc.s1p_read(path_open_cable_before + 'Short_S11.s1p')
	l_m,    f_oc1 = rc.s1p_read(path_open_cable_before + 'Match_S11.s1p')
	oc1_m,  f_oc1 = rc.s1p_read(path_open_cable_before + 'External_S11.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_oc1))
	s_sw = -1 * np.ones(len(f_oc1))
	l_sw =  0 * np.ones(len(f_oc1))


	# Correction at switch
	oc1_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, oc1_m)


	# Correction at receiver input
	oc1_c = low_band_switch_correction_june_2016(oc1_sw_c, f_in = f_oc1, verification = 'no')



	oc1_ff  = oc1_c[(f_oc1/1e6>=50) & (f_oc1/1e6<=100)]
	foc1_ff = f_oc1[(f_oc1/1e6>=50) & (f_oc1/1e6<=100)]






	# Open cable (AFTER)
	# ----------
	o_m,    f_oc2 = rc.s1p_read(path_open_cable_after + 'Open_S11.s1p')
	s_m,    f_oc2 = rc.s1p_read(path_open_cable_after + 'Short_S11.s1p')
	l_m,    f_oc2 = rc.s1p_read(path_open_cable_after + 'Match_S11.s1p')
	oc2_m,  f_oc2 = rc.s1p_read(path_open_cable_after + 'External_S11.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_oc2))
	s_sw = -1 * np.ones(len(f_oc2))
	l_sw =  0 * np.ones(len(f_oc2))


	# Correction at switch
	oc2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, oc2_m)


	# Correction at receiver input
	oc2_c = low_band_switch_correction_june_2016(oc2_sw_c, f_in = f_oc2, verification = 'no')



	oc2_ff  = oc2_c[(f_oc2/1e6>=50) & (f_oc2/1e6<=100)]
	foc2_ff = f_oc2[(f_oc2/1e6>=50) & (f_oc2/1e6<=100)]






	# Shorted cable (BEFORE)
	# -------------
	o_m,    f_sc1 = rc.s1p_read(path_shorted_cable_before + 'Open2_s11.s1p')
	s_m,    f_sc1 = rc.s1p_read(path_shorted_cable_before + 'Short2_s11.s1p')
	l_m,    f_sc1 = rc.s1p_read(path_shorted_cable_before + 'Match2_s11.s1p')
	sc1_m,  f_sc1 = rc.s1p_read(path_shorted_cable_before + 'External2_S11.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_sc1))
	s_sw = -1 * np.ones(len(f_sc1))
	l_sw =  0 * np.ones(len(f_sc1))	


	# Correction at switch
	sc1_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, sc1_m)


	# Correction at receiver input
	sc1_c = low_band_switch_correction_june_2016(sc1_sw_c, f_in = f_sc1, verification = 'no')



	sc1_ff  = sc1_c[(f_sc1/1e6>=50) & (f_sc1/1e6<=100)]
	fsc1_ff = f_sc1[(f_sc1/1e6>=50) & (f_sc1/1e6<=100)]






	# Shorted cable (AFTER)
	# -------------
	o_m,    f_sc2 = rc.s1p_read(path_shorted_cable_after + 'Open1_S11.s1p')
	s_m,    f_sc2 = rc.s1p_read(path_shorted_cable_after + 'Short1_S11.s1p')
	l_m,    f_sc2 = rc.s1p_read(path_shorted_cable_after + 'Match1_S11.s1p')
	sc2_m,  f_sc2 = rc.s1p_read(path_shorted_cable_after + 'External1_S11.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_sc2))
	s_sw = -1 * np.ones(len(f_sc2))
	l_sw =  0 * np.ones(len(f_sc2))	


	# Correction at switch
	sc2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, sc2_m)


	# Correction at receiver input
	sc2_c = low_band_switch_correction_june_2016(sc2_sw_c, f_in = f_sc2, verification = 'no')



	sc2_ff  = sc2_c[(f_sc2/1e6>=50) & (f_sc2/1e6<=100)]
	fsc2_ff = f_sc2[(f_sc2/1e6>=50) & (f_sc2/1e6<=100)]













	# Antenna simulator 1 before
	# -------------------------- 
	o_m,    f_s11 = rc.s1p_read(path_simulator1_before + 'Open_S11.s1p')
	s_m,    f_s11 = rc.s1p_read(path_simulator1_before + 'Short_S11.s1p')
	l_m,    f_s11 = rc.s1p_read(path_simulator1_before + 'Match_S11.s1p')
	s11_m,  f_s11 = rc.s1p_read(path_simulator1_before + 'External_S11.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_s11))
	s_sw = -1 * np.ones(len(f_s11))
	l_sw =  0 * np.ones(len(f_s11))


	# Correction at switch
	s11_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, s11_m)


	# Correction at receiver input
	s11_c = low_band_switch_correction_june_2016(s11_sw_c, f_in = f_s11, verification = 'no')



	s11_ff  = s11_c[(f_s11/1e6>=50) & (f_s11/1e6<=100)]
	fs11_ff = f_s11[(f_s11/1e6>=50) & (f_s11/1e6<=100)]





	# Antenna simulator 1 after
	# -------------------------- 
	o_m,    f_s12 = rc.s1p_read(path_simulator1_after + 'Open1_S11.s1p')
	s_m,    f_s12 = rc.s1p_read(path_simulator1_after + 'Short1_S11.s1p')
	l_m,    f_s12 = rc.s1p_read(path_simulator1_after + 'Match1_S11.s1p')
	s12_m,  f_s12 = rc.s1p_read(path_simulator1_after + 'External1_S11.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_s12))
	s_sw = -1 * np.ones(len(f_s12))
	l_sw =  0 * np.ones(len(f_s12))


	# Correction at switch
	s12_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, s12_m)


	# Correction at receiver input
	s12_c = low_band_switch_correction_june_2016(s12_sw_c, f_in = f_s12, verification = 'no')



	s12_ff  = s12_c[(f_s12/1e6>=50) & (f_s12/1e6<=100)]
	fs12_ff = f_s12[(f_s12/1e6>=50) & (f_s12/1e6<=100)]


















	# Antenna simulator 2 (BEFORE)
	# -------------------------- 
	o_m,  f_s21  = rc.s1p_read(path_simulator2_before + 'Open2_S11.s1p')
	s_m,  f_s21  = rc.s1p_read(path_simulator2_before + 'Short2_S11.s1p')
	l_m,  f_s21  = rc.s1p_read(path_simulator2_before + 'Match2_S11.s1p')
	s21_m, f_s21 = rc.s1p_read(path_simulator2_before + 'External2_S11.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_s21))
	s_sw = -1 * np.ones(len(f_s21))
	l_sw =  0 * np.ones(len(f_s21))


	# Correction at switch
	s21_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, s21_m)


	# Correction at receiver input
	s21_c = low_band_switch_correction_june_2016(s21_sw_c, f_in = f_s21, verification = 'no')



	s21_ff  = s21_c[(f_s21/1e6>=50) & (f_s21/1e6<=100)]
	fs21_ff = f_s21[(f_s21/1e6>=50) & (f_s21/1e6<=100)]












	# Antenna simulator 2 (AFTER)
	# -------------------------- 
	o_m,  f_s22  = rc.s1p_read(path_simulator2_after + 'Open1_S11.s1p')
	s_m,  f_s22  = rc.s1p_read(path_simulator2_after + 'Short1_S11.s1p')
	l_m,  f_s22  = rc.s1p_read(path_simulator2_after + 'Match1_s11.s1p')
	s22_m, f_s22 = rc.s1p_read(path_simulator2_after + 'External1_s11.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_s22))
	s_sw = -1 * np.ones(len(f_s22))
	l_sw =  0 * np.ones(len(f_s22))


	# Correction at switch
	s22_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, s22_m)


	# Correction at receiver input
	s22_c = low_band_switch_correction_june_2016(s22_sw_c, f_in = f_s22, verification = 'no')



	s22_ff  = s22_c[(f_s22/1e6>=50) & (f_s22/1e6<=100)]
	fs22_ff = f_s22[(f_s22/1e6>=50) & (f_s22/1e6<=100)]












	if save == 'yes':

		# S-parameters of semi-rigid cable (they are already at 250 kHz)
		# --------------------------------------------------------------
		d = np.genfromtxt(home_folder + '/DATA/EDGES/receiver_calibration/calibration_august_2015/LNA/S11/corrected/s11_calibration_low_band_LNA25degC_2015-09-16-20-09-50_simulator2_long_new_LNA3.txt')

		sr_s11r    = d[:,11]
		sr_s11i    = d[:,12]
		sr_s12s21r = d[:,13]
		sr_s12s21i = d[:,14]
		sr_s22r    = d[:,15]
		sr_s22i    = d[:,16]




		# Now, saving data
		temp = np.array([ fs22_ff/1e6, 
		                  np.real(LNA_ff),  np.imag(LNA_ff), # the best case for LNA is LNA2
		                  np.real(a2_ff),   np.imag(a2_ff),   np.real(h2_ff),      np.imag(h2_ff),
		                  np.real(oc2_ff),  np.imag(oc2_ff),  np.real(sc2_ff),     np.imag(sc2_ff),  # "best" case for the open is oc1
		                  sr_s11r,          sr_s11i,          sr_s12s21r,          sr_s12s21i,          sr_s22r,          sr_s22i,
		                  np.real(s12_ff),  np.imag(s12_ff),  np.real(s22_ff),     np.imag(s22_ff) ])





		output_file     = temp.T
		save_path       = home_folder + '/DATA/EDGES/receiver_calibration/calibration_june_2016/LNA/S11/corrected/'
		temperature_LNA = '25degC'
		output_file_str = save_path + 's11_calibration_low_band_LNA' + temperature_LNA + '_' + tt.strftime('%Y-%m-%d-%H-%M-%S') + flag + '.txt'
		np.savetxt(output_file_str, output_file)

		print('File saved to: ' + output_file_str)		




	return 0














def low_band_september_2016_noise_source_sparameters():


	# Measurements of noise source with no attenuator in front, and with 3-dB and 6-dB attenuators
	# At VNA
	om, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/Powered_Noise_Source/S11_Open_VNApower_m20dBm.s1p')
	sm, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/Powered_Noise_Source/S11_Short_VNApower_m20dBm.s1p')
	mm, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/Powered_Noise_Source/S11_Match_VNApower_m20dBm.s1p')

	attn0, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/Powered_Noise_Source/S11_0dB_atten_VNApower_m20dBm.s1p')
	attn3, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/Powered_Noise_Source/S11_3dB_atten_VNApower_m20dBm.s1p')
	attn6, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/Powered_Noise_Source/S11_6dB_atten_VNApower_m20dBm.s1p')


	# Models of standards
	resistance_of_match = 50.11 # male
	oa, sa, ma = rc.agilent_85033E(fs, resistance_of_match)


	# Correction at VNA
	attn0c, x1, x2, x3  = rc.de_embed(oa, sa, ma, om, sm, mm, attn0)
	attn3c, x1, x2, x3  = rc.de_embed(oa, sa, ma, om, sm, mm, attn3)
	attn6c, x1, x2, x3  = rc.de_embed(oa, sa, ma, om, sm, mm, attn6)







	# Measurements of noise source with cable box and 3-dB attenuator in front
	# At VNA
	om, fs   = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/04days_3dB_atten_with_cable/S11_VNA_at_m20dBm_power/Open.s1p')
	sm, fs   = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/04days_3dB_atten_with_cable/S11_VNA_at_m20dBm_power/Short.s1p')
	mm, fs   = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/04days_3dB_atten_with_cable/S11_VNA_at_m20dBm_power/Match.s1p')
	cm0m, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/04days_3dB_atten_with_cable/S11_VNA_at_m20dBm_power/External.s1p')

	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(fs))
	s_sw = -1 * np.ones(len(fs))
	m_sw =  0 * np.ones(len(fs))


	# Correction at switch
	cm0x, x1, x2, x3  = rc.de_embed(o_sw, s_sw, m_sw, om, sm, mm, cm0m)


	# Correction at receiver input
	cm0cc = low_band_switch_correction_june_2016(cm0x, f_in = fs, verification = 'no')


















	## Reflection coefficient of noise source alone
	#om, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/03days_0dB_atten/S11_VNA_at_m20dBm_power/Open2.s1p')
	#sm, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/03days_0dB_atten/S11_VNA_at_m20dBm_power/Short2.s1p')
	#lm, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/03days_0dB_atten/S11_VNA_at_m20dBm_power/Match2.s1p')
	#attn0m, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/03days_0dB_atten/S11_VNA_at_m20dBm_power/External2.s1p')


	## Standards assumed at the switch
	#o_sw =  1 * np.ones(len(fs))
	#s_sw = -1 * np.ones(len(fs))
	#l_sw =  0 * np.ones(len(fs))


	## Correction at switch
	#attn0x, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, om, sm, lm, attn0m)


	## Correction at receiver input
	#attn0cc = low_band_switch_correction_june_2016(attn0x, f_in = fs, verification = 'no')





	## Reflection coefficient
	#om, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/03days_3dB_atten/S11_VNA_at_m20dBm_power/Open2.s1p')
	#sm, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/03days_3dB_atten/S11_VNA_at_m20dBm_power/Short2.s1p')
	#lm, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/03days_3dB_atten/S11_VNA_at_m20dBm_power/Match2.s1p')
	#attn3m, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/03days_3dB_atten/S11_VNA_at_m20dBm_power/External2.s1p')


	## Standards assumed at the switch
	#o_sw =  1 * np.ones(len(fs))
	#s_sw = -1 * np.ones(len(fs))
	#l_sw =  0 * np.ones(len(fs))


	## Correction at switch
	#attn3x, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, om, sm, lm, attn3m)


	## Correction at receiver input
	#attn3cc = low_band_switch_correction_june_2016(attn3x, f_in = fs, verification = 'no')





	## Reflection coefficient
	#om, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/03days_6dB_atten/S11_VNA_at_m20dBm_power/Open2.s1p')
	#sm, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/03days_6dB_atten/S11_VNA_at_m20dBm_power/Short2.s1p')
	#lm, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/03days_6dB_atten/S11_VNA_at_m20dBm_power/Match2.s1p')
	#attn6m, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/03days_6dB_atten/S11_VNA_at_m20dBm_power/External2.s1p')


	## Standards assumed at the switch
	#o_sw =  1 * np.ones(len(fs))
	#s_sw = -1 * np.ones(len(fs))
	#l_sw =  0 * np.ones(len(fs))


	## Correction at switch
	#attn6x, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, om, sm, lm, attn6m)


	## Correction at receiver input
	#attn6cc = low_band_switch_correction_june_2016(attn6x, f_in = fs, verification = 'no')









	# S-parameters of attenuators

	# At VNA
	om, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/OSL_male_at_VNA/Open.s1p')
	sm, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/OSL_male_at_VNA/Short.s1p')
	mm, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/OSL_male_at_VNA/Match.s1p')

	om3, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/OSL_male_Atten_3dB/Open.s1p')
	sm3, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/OSL_male_Atten_3dB/Short.s1p')
	mm3, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/OSL_male_Atten_3dB/Match.s1p')

	om6, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/OSL_male_Atten_6dB/Open.s1p')
	sm6, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/OSL_male_Atten_6dB/Short.s1p')
	mm6, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/OSL_male_Atten_6dB/Match.s1p')


	# Models of standards
	resistance_of_match = 50.11 # male
	oa, sa, ma = rc.agilent_85033E(fs, resistance_of_match)


	# 3-dB Attn
	om3c, x1, x2, x3  = rc.de_embed(oa, sa, ma, om, sm, mm, om3)
	sm3c, x1, x2, x3  = rc.de_embed(oa, sa, ma, om, sm, mm, sm3)
	mm3c, x1, x2, x3  = rc.de_embed(oa, sa, ma, om, sm, mm, mm3)

	xx, s11a3, s12s21a3, s22a3  = rc.de_embed(oa, sa, ma, om3c, sm3c, mm3c, om3c)


	# 6-dB Attn
	om6c, x1, x2, x3  = rc.de_embed(oa, sa, ma, om, sm, mm, om6)
	sm6c, x1, x2, x3  = rc.de_embed(oa, sa, ma, om, sm, mm, sm6)
	mm6c, x1, x2, x3  = rc.de_embed(oa, sa, ma, om, sm, mm, mm6)

	xx, s11a6, s12s21a6, s22a6  = rc.de_embed(oa, sa, ma, om6c, sm6c, mm6c, om6c)	





	# S-parameters of Cable Box

	# At VNA
	om, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/Cable_box/Open_at_VNA.s1p')
	sm, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/Cable_box/Short_at_VNA.s1p')
	mm, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/Cable_box/Match_at_VNA.s1p')

	omc, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/Cable_box/Open_at_cable_box.s1p')
	smc, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/Cable_box/Short_at_cable_box.s1p')
	mmc, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/raw/AlansLoad/Cable_box/Match_at_cable_box.s1p')	


	omcc, x1, x2, x3  = rc.de_embed(oa, sa, ma, om, sm, mm, omc)
	smcc, x1, x2, x3  = rc.de_embed(oa, sa, ma, om, sm, mm, smc)
	mmcc, x1, x2, x3  = rc.de_embed(oa, sa, ma, om, sm, mm, mmc)

	xx, s11c, s12s21c, s22c  = rc.de_embed(oa, sa, ma, omcc, smcc, mmcc, omcc)











	# Saving data
	temp = np.array([ fs/1e6, 
	                  np.real(attn0c),    np.imag(attn0c),   # reflection coefficient, just noise source
	                  np.real(attn3c),    np.imag(attn3c),   # reflection coefficient, 3-dB attenuator in front of noise source
	                  np.real(attn6c),    np.imag(attn6c),   # reflection coefficient, 6-dB attenuator in front of noise source
	                  np.real(cm0cc),     np.imag(cm0cc),    # reflection coefficient, cable box in front of 3-dB attenuator, in front of noise source
	                  np.real(s11a3),     np.imag(s11a3),    # S-parameters of 3-dB attenuator 
	                  np.real(s12s21a3),  np.imag(s12s21a3), # S-parameters of 3-dB attenuator 
	                  np.real(s22a3),     np.imag(s22a3),    # S-parameters of 3-dB attenuator 
	                  np.real(s11a6),     np.imag(s11a6),    # S-parameters of 6-dB attenuator
	                  np.real(s12s21a6),  np.imag(s12s21a6), # S-parameters of 6-dB attenuator
	                  np.real(s22a6),     np.imag(s22a6),    # S-parameters of 6-dB attenuator
	                  np.real(s11c),      np.imag(s11c),     # S-parameters of cable box
	                  np.real(s12s21c),   np.imag(s12s21c),  # S-parameters of cable_box
	                  np.real(s22c),      np.imag(s22c) ])   # S-parameters of cable_box


	output_file = temp.T
	file_name   = home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_september_2016/LNA/S11/corrected/noise_source_s-parameters.txt'
	np.savetxt(file_name, output_file)


	return 0





























def low_band_s11_calibration_measurements_september_2016_25C(save='no', flag=''):


	# Data paths
	main_path    = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band/2016_09_25C/LNA/S11/raw/'
	main_path2   = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band/2017_02_25C/LNA/S11/raw/'

	path_LNA     = main_path  + 'Receiver_at_start/'
	path_LNA2    = main_path2 + '25C_reading_1/'

	path_ambient = main_path + 'ambient_3days/'
	path_hot     = main_path + 'hot_3days/'
	path_open    = main_path + 'open_cable_2days/'
	path_shorted = main_path + 'shorted_cable_2days/'
	path_sim1    = main_path + 'ant_sim1_4days/'
	path_sim2    = main_path + 'ant_sim2_4days/'



	# Receiver reflection coefficient
	# -------------------------------

	#o0,   fr = rc.s1p_read(home_folder + '/DATA/EDGES/receiver_calibration/calibration_june_2016/LNA/S11/raw/receiver_input_and_calibration_verification_loads/25Credo/Receiver_S11/Pass16_after_traveling/Open.s1p')
	#s0,   fr = rc.s1p_read(home_folder + '/DATA/EDGES/receiver_calibration/calibration_june_2016/LNA/S11/raw/receiver_input_and_calibration_verification_loads/25Credo/Receiver_S11/Pass16_after_traveling/Short.s1p')
	#l0,   fr = rc.s1p_read(home_folder + '/DATA/EDGES/receiver_calibration/calibration_june_2016/LNA/S11/raw/receiver_input_and_calibration_verification_loads/25Credo/Receiver_S11/Pass16_after_traveling/Match.s1p')
	#LNA0, fr = rc.s1p_read(home_folder + '/DATA/EDGES/receiver_calibration/calibration_june_2016/LNA/S11/raw/receiver_input_and_calibration_verification_loads/25Credo/Receiver_S11/Pass16_after_traveling/Receiver.s1p')


	#o1,   fr = rc.s1p_read(home_folder + '/DATA/EDGES/receiver_calibration/calibration_june_2016/LNA/S11/raw/receiver_input_and_calibration_verification_loads/25Credo/Receiver_S11/Pass10/Open.s1p')
	#s1,   fr = rc.s1p_read(home_folder + '/DATA/EDGES/receiver_calibration/calibration_june_2016/LNA/S11/raw/receiver_input_and_calibration_verification_loads/25Credo/Receiver_S11/Pass10/Short.s1p')
	#l1,   fr = rc.s1p_read(home_folder + '/DATA/EDGES/receiver_calibration/calibration_june_2016/LNA/S11/raw/receiver_input_and_calibration_verification_loads/25Credo/Receiver_S11/Pass10/Match.s1p')
	#LNA1, fr = rc.s1p_read(home_folder + '/DATA/EDGES/receiver_calibration/calibration_june_2016/LNA/S11/raw/receiver_input_and_calibration_verification_loads/25Credo/Receiver_S11/Pass10/Receiver.s1p')	




	# Reading measurements (from September 2016)
	#o,   fr0  = rc.s1p_read(path_LNA + 'Open.s1p')
	#s,   fr0  = rc.s1p_read(path_LNA + 'Short.s1p')
	#l,   fr0  = rc.s1p_read(path_LNA + 'Match.s1p')
	#LNA0, fr0 = rc.s1p_read(path_LNA + 'Receiver.s1p')

	# Reading measurements (from February 2017)
	o,   fr0  = rc.s1p_read(path_LNA2 + 'Open.s1p')
	s,   fr0  = rc.s1p_read(path_LNA2 + 'Short.s1p')
	l,   fr0  = rc.s1p_read(path_LNA2 + 'Match.s1p')
	LNA0, fr0 = rc.s1p_read(path_LNA2 + 'R01.s1p')


	# Models of standards
	resistance_of_match = 49.97 # female
	md = 1
	oa, sa, la = rc.agilent_85033E(fr0, resistance_of_match, md)



	# Correction of measurements
	#LNAc0, x1, x2, x3  = rc.de_embed(oa, sa, la, o0, s0, l0, LNA0)
	#LNAc1, x1, x2, x3  = rc.de_embed(oa, sa, la, o1, s1, l1, LNA1)
	LNAc, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA0)


	LNA = LNAc[(fr0/1e6>=50) & (fr0/1e6<=100)]   # Choosing LNA measurement (best is LNA2c, at 25degC)
	fr  = fr0[(fr0/1e6>=50) & (fr0/1e6<=100)]


















	# Calibration loads
	# -----------------




	# Ambient load before
	# -------------------
	o_m,  f_a1 = rc.s1p_read(path_ambient + 'Open.s1p')
	s_m,  f_a1 = rc.s1p_read(path_ambient + 'Short.s1p')
	l_m,  f_a1 = rc.s1p_read(path_ambient + 'Match.s1p')
	a1_m, f_a1 = rc.s1p_read(path_ambient + 'External.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_a1))
	s_sw = -1 * np.ones(len(f_a1))
	l_sw =  0 * np.ones(len(f_a1))


	# Correction at switch
	a1_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, a1_m)


	# Correction at receiver input
	a1_c = low_band_switch_correction_june_2016(a1_sw_c, f_in = f_a1, verification = 'no')


	a1  = a1_c[(f_a1/1e6>=50) & (f_a1/1e6<=100)]
	fa1 = f_a1[(f_a1/1e6>=50) & (f_a1/1e6<=100)]







	# Ambient load after
	# -------------------
	o_m,  f_a2 = rc.s1p_read(path_ambient + 'Open2.s1p')
	s_m,  f_a2 = rc.s1p_read(path_ambient + 'Short2.s1p')
	l_m,  f_a2 = rc.s1p_read(path_ambient + 'Match2.s1p')
	a2_m, f_a2 = rc.s1p_read(path_ambient + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_a2))
	s_sw = -1 * np.ones(len(f_a2))
	l_sw =  0 * np.ones(len(f_a2))


	# Correction at switch
	a2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, a2_m)


	# Correction at receiver input
	a2_c = low_band_switch_correction_june_2016(a2_sw_c, f_in = f_a2, verification = 'no')


	a2  = a2_c[(f_a2/1e6>=50) & (f_a2/1e6<=100)]
	fa2 = f_a2[(f_a2/1e6>=50) & (f_a2/1e6<=100)]










	# Hot load before
	# -------------------
	o_m,  f_h1 = rc.s1p_read(path_hot + 'Open.s1p')
	s_m,  f_h1 = rc.s1p_read(path_hot + 'Short.s1p')
	l_m,  f_h1 = rc.s1p_read(path_hot + 'Match.s1p')
	h1_m, f_h1 = rc.s1p_read(path_hot + 'External.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_h1))
	s_sw = -1 * np.ones(len(f_h1))
	l_sw =  0 * np.ones(len(f_h1))


	# Correction at switch
	h1_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, h1_m)


	# Correction at receiver input
	h1_c = low_band_switch_correction_june_2016(h1_sw_c, f_in = f_h1, verification = 'no')


	h1  = h1_c[(f_h1/1e6>=50) & (f_h1/1e6<=100)]
	fh1 = f_h1[(f_h1/1e6>=50) & (f_h1/1e6<=100)]






	# Hot load after
	# -------------------
	o_m,  f_h2 = rc.s1p_read(path_hot + 'Open2.s1p')
	s_m,  f_h2 = rc.s1p_read(path_hot + 'Short2.s1p')
	l_m,  f_h2 = rc.s1p_read(path_hot + 'Match2.s1p')
	h2_m, f_h2 = rc.s1p_read(path_hot + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_h2))
	s_sw = -1 * np.ones(len(f_h2))
	l_sw =  0 * np.ones(len(f_h2))


	# Correction at switch
	h2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, h2_m)


	# Correction at receiver input
	h2_c = low_band_switch_correction_june_2016(h2_sw_c, f_in = f_h2, verification = 'no')


	h2  = h2_c[(f_h2/1e6>=50) & (f_h2/1e6<=100)]
	fh2 = f_h2[(f_h2/1e6>=50) & (f_h2/1e6<=100)]	












	# Open Cable before
	# -------------------
	o_m,  f_o1 = rc.s1p_read(path_open + 'Open.s1p')
	s_m,  f_o1 = rc.s1p_read(path_open + 'Short.s1p')
	l_m,  f_o1 = rc.s1p_read(path_open + 'Match.s1p')
	o1_m, f_o1 = rc.s1p_read(path_open + 'External.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_o1))
	s_sw = -1 * np.ones(len(f_o1))
	l_sw =  0 * np.ones(len(f_o1))


	# Correction at switch
	o1_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, o1_m)


	# Correction at receiver input
	o1_c = low_band_switch_correction_june_2016(o1_sw_c, f_in = f_o1, verification = 'no')


	o1  = o1_c[(f_o1/1e6>=50) & (f_o1/1e6<=100)]
	fo1 = f_o1[(f_o1/1e6>=50) & (f_o1/1e6<=100)]






	# Open Cable after
	# -------------------
	o_m,  f_o2 = rc.s1p_read(path_open + 'Open2.s1p')
	s_m,  f_o2 = rc.s1p_read(path_open + 'Short2.s1p')
	l_m,  f_o2 = rc.s1p_read(path_open + 'Match2.s1p')
	o2_m, f_o2 = rc.s1p_read(path_open + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_o2))
	s_sw = -1 * np.ones(len(f_o2))
	l_sw =  0 * np.ones(len(f_o2))


	# Correction at switch
	o2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, o2_m)


	# Correction at receiver input
	o2_c = low_band_switch_correction_june_2016(o2_sw_c, f_in = f_o2, verification = 'no')


	o2  = o2_c[(f_o2/1e6>=50) & (f_o2/1e6<=100)]
	fo2 = f_o2[(f_o2/1e6>=50) & (f_o2/1e6<=100)]












	# Short Cable before
	# -------------------
	o_m,  f_s1 = rc.s1p_read(path_shorted + 'Open.s1p')
	s_m,  f_s1 = rc.s1p_read(path_shorted + 'Short.s1p')
	l_m,  f_s1 = rc.s1p_read(path_shorted + 'Match.s1p')
	s1_m, f_s1 = rc.s1p_read(path_shorted + 'External.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_s1))
	s_sw = -1 * np.ones(len(f_s1))
	l_sw =  0 * np.ones(len(f_s1))


	# Correction at switch
	s1_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, s1_m)


	# Correction at receiver input
	s1_c = low_band_switch_correction_june_2016(s1_sw_c, f_in = f_s1, verification = 'no')


	s1  = s1_c[(f_s1/1e6>=50) & (f_s1/1e6<=100)]
	fs1 = f_s1[(f_s1/1e6>=50) & (f_s1/1e6<=100)]







	# Short Cable after
	# -------------------
	o_m,  f_s2 = rc.s1p_read(path_shorted + 'Open2.s1p')
	s_m,  f_s2 = rc.s1p_read(path_shorted + 'Short2.s1p')
	l_m,  f_s2 = rc.s1p_read(path_shorted + 'Match2.s1p')
	s2_m, f_s2 = rc.s1p_read(path_shorted + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_s2))
	s_sw = -1 * np.ones(len(f_s2))
	l_sw =  0 * np.ones(len(f_s2))


	# Correction at switch
	s2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, s2_m)


	# Correction at receiver input
	s2_c = low_band_switch_correction_june_2016(s2_sw_c, f_in = f_s2, verification = 'no')


	s2  = s2_c[(f_s2/1e6>=50) & (f_s2/1e6<=100)]
	fs2 = f_s2[(f_s2/1e6>=50) & (f_s2/1e6<=100)]	















	# Antenna Simulator 1 before
	# --------------------------
	o_m,  f_q11  = rc.s1p_read(path_sim1 + 'Open.s1p')
	s_m,  f_q11  = rc.s1p_read(path_sim1 + 'Short.s1p')
	l_m,  f_q11  = rc.s1p_read(path_sim1 + 'Match.s1p')
	q11_m, f_q11 = rc.s1p_read(path_sim1 + 'External.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_q11))
	s_sw = -1 * np.ones(len(f_q11))
	l_sw =  0 * np.ones(len(f_q11))


	# Correction at switch
	q11_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, q11_m)


	# Correction at receiver input
	q11_c = low_band_switch_correction_june_2016(q11_sw_c, f_in = f_q11, verification = 'no')


	q11  = q11_c[(f_q11/1e6>=50) & (f_q11/1e6<=100)]
	fq11 = f_q11[(f_q11/1e6>=50) & (f_q11/1e6<=100)]





	# Antenna Simulator 1 after
	# -------------------------
	o_m,  f_q12  = rc.s1p_read(path_sim1 + 'Open2.s1p')
	s_m,  f_q12  = rc.s1p_read(path_sim1 + 'Short2.s1p')
	l_m,  f_q12  = rc.s1p_read(path_sim1 + 'Match2.s1p')
	q12_m, f_q12 = rc.s1p_read(path_sim1 + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_q12))
	s_sw = -1 * np.ones(len(f_q12))
	l_sw =  0 * np.ones(len(f_q12))


	# Correction at switch
	q12_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, q12_m)


	# Correction at receiver input
	q12_c = low_band_switch_correction_june_2016(q12_sw_c, f_in = f_q12, verification = 'no')


	q12  = q12_c[(f_q12/1e6>=50) & (f_q12/1e6<=100)]
	fq12 = f_q12[(f_q12/1e6>=50) & (f_q12/1e6<=100)]










	# Antenna Simulator 2 before
	# --------------------------
	o_m,  f_q21  = rc.s1p_read(path_sim2 + 'Open.s1p')
	s_m,  f_q21  = rc.s1p_read(path_sim2 + 'Short.s1p')
	l_m,  f_q21  = rc.s1p_read(path_sim2 + 'Match.s1p')
	q21_m, f_q21 = rc.s1p_read(path_sim2 + 'External.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_q21))
	s_sw = -1 * np.ones(len(f_q21))
	l_sw =  0 * np.ones(len(f_q21))


	# Correction at switch
	q21_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, q21_m)


	# Correction at receiver input
	q21_c = low_band_switch_correction_june_2016(q21_sw_c, f_in = f_q21, verification = 'no')


	q21  = q21_c[(f_q21/1e6>=50) & (f_q21/1e6<=100)]
	fq21 = f_q21[(f_q21/1e6>=50) & (f_q21/1e6<=100)]








	# Antenna Simulator 2 after
	# --------------------------
	o_m,  f_q22  = rc.s1p_read(path_sim2 + 'Open2.s1p')
	s_m,  f_q22  = rc.s1p_read(path_sim2 + 'Short2.s1p')
	l_m,  f_q22  = rc.s1p_read(path_sim2 + 'Match2.s1p')
	q22_m, f_q22 = rc.s1p_read(path_sim2 + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_q22))
	s_sw = -1 * np.ones(len(f_q22))
	l_sw =  0 * np.ones(len(f_q22))


	# Correction at switch
	q22_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, q22_m)


	# Correction at receiver input
	q22_c = low_band_switch_correction_june_2016(q22_sw_c, f_in = f_q22, verification = 'no')


	q22  = q22_c[(f_q22/1e6>=50) & (f_q22/1e6<=100)]
	fq22 = f_q22[(f_q22/1e6>=50) & (f_q22/1e6<=100)]




	# Saving
	if save == 'yes':

		# Loading S-parameters of semi-rigid cable (they are already at 250 kHz)
		# --------------------------------------------------------------
		d = np.genfromtxt(home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band/2015_08_25C/LNA/S11/corrected/s11_calibration_low_band_LNA25degC_2015-09-16-20-09-50_simulator2_long_new_LNA3.txt')

		sr_s11r    = d[:,11]
		sr_s11i    = d[:,12]
		sr_s12s21r = d[:,13]
		sr_s12s21i = d[:,14]
		sr_s22r    = d[:,15]
		sr_s22i    = d[:,16]




		# Now, saving data
		temp = np.array([ fr/1e6, 
		                  np.real(LNA),  np.imag(LNA),  # the best case for LNA is LNA2
		                  np.real(a1),   np.imag(a1),   np.real(h1),    np.imag(h1),
		                  np.real(o1),   np.imag(o1),   np.real(s1),    np.imag(s1),  # "best" case for the open is oc1
		                  sr_s11r,       sr_s11i,       sr_s12s21r,     sr_s12s21i,      sr_s22r,       sr_s22i,
		                  np.real(q11),  np.imag(q11),  np.real(q21),   np.imag(q21) ])





		output_file     = temp.T
		save_path       = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band/2016_09_25C/LNA/S11/corrected/'
		temperature_LNA = '25degC'
		output_file_str = save_path + 's11_calibration_low_band_LNA' + temperature_LNA + '_' + tt.strftime('%Y-%m-%d-%H-%M-%S') + flag + '.txt'
		np.savetxt(output_file_str, output_file)

		print('File saved to: ' + output_file_str)



	return 0





















def low_band_s11_calibration_measurements_november_2016_15C(save='no', flag=''):


	# Data paths
	main_path    = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band/2016_11_15C/LNA/S11/raw/'
	main_path2   = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band/2017_02_25C/LNA/S11/raw/'

	path_LNA     = main_path + 'ReceiverS11_25C_final_measurement/'
	path_LNA2    = main_path2 + '15C_reading/'

	path_ambient = main_path + 'AmbientLoad/'
	path_hot     = main_path + 'HotLoad/'
	path_open    = main_path + 'OpenCable/'
	path_shorted = main_path + 'ShortedCable/'
	path_sim1    = main_path + 'SimAnt1/'
	path_sim2    = main_path + 'SimAnt2/'
	path_sim2r2  = main_path + 'SimAnt2_Round2/'


	# Receiver reflection coefficient
	# -------------------------------

	# Reading measurements
	#o,   fr0  = rc.s1p_read(path_LNA + 'Open.s1p')
	#s,   fr0  = rc.s1p_read(path_LNA + 'Short.s1p')
	#l,   fr0  = rc.s1p_read(path_LNA + 'Match.s1p')
	#LNA0, fr0 = rc.s1p_read(path_LNA + 'Receiver.s1p')


	# Reading measurements
	o,   fr0  = rc.s1p_read(path_LNA2 + 'Open.s1p')
	s,   fr0  = rc.s1p_read(path_LNA2 + 'Short.s1p')
	l,   fr0  = rc.s1p_read(path_LNA2 + 'Match.s1p')
	LNA0, fr0 = rc.s1p_read(path_LNA2 + 'R01.s1p')







	# Models of standards
	resistance_of_match = 49.97 # female
	md = 1
	oa, sa, la = rc.agilent_85033E(fr0, resistance_of_match, md)



	# Correction of measurements
	LNAc, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA0)


	LNA = LNAc[(fr0/1e6>=50) & (fr0/1e6<=100)]   
	fr  = fr0[(fr0/1e6>=50) & (fr0/1e6<=100)]


















	# Calibration loads
	# -----------------



	# -----------------------------------------------------------------------------------------
	# Ambient load before
	# -------------------
	o_m,  f_a1 = rc.s1p_read(path_ambient + 'Open.s1p')
	s_m,  f_a1 = rc.s1p_read(path_ambient + 'Short.s1p')
	l_m,  f_a1 = rc.s1p_read(path_ambient + 'Match.s1p')
	a1_m, f_a1 = rc.s1p_read(path_ambient + 'External.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_a1))
	s_sw = -1 * np.ones(len(f_a1))
	l_sw =  0 * np.ones(len(f_a1))


	# Correction at switch
	a1_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, a1_m)


	# Correction at receiver input
	a1_c = low_band_switch_correction_june_2016(a1_sw_c, f_in = f_a1, verification = 'no')


	a1  = a1_c[(f_a1/1e6>=50) & (f_a1/1e6<=100)]
	fa1 = f_a1[(f_a1/1e6>=50) & (f_a1/1e6<=100)]







	# Ambient load after
	# -------------------
	o_m,  f_a2 = rc.s1p_read(path_ambient + 'Open2.s1p')
	s_m,  f_a2 = rc.s1p_read(path_ambient + 'Short2.s1p')
	l_m,  f_a2 = rc.s1p_read(path_ambient + 'Match2.s1p')
	a2_m, f_a2 = rc.s1p_read(path_ambient + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_a2))
	s_sw = -1 * np.ones(len(f_a2))
	l_sw =  0 * np.ones(len(f_a2))


	# Correction at switch
	a2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, a2_m)


	# Correction at receiver input
	a2_c = low_band_switch_correction_june_2016(a2_sw_c, f_in = f_a2, verification = 'no')


	a2  = a2_c[(f_a2/1e6>=50) & (f_a2/1e6<=100)]
	fa2 = f_a2[(f_a2/1e6>=50) & (f_a2/1e6<=100)]









	# -----------------------------------------------------------------------------------------
	# Hot load before
	# -------------------
	o_m,  f_h1 = rc.s1p_read(path_hot + 'Open.s1p')
	s_m,  f_h1 = rc.s1p_read(path_hot + 'Short.s1p')
	l_m,  f_h1 = rc.s1p_read(path_hot + 'Match.s1p')
	h1_m, f_h1 = rc.s1p_read(path_hot + 'External.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_h1))
	s_sw = -1 * np.ones(len(f_h1))
	l_sw =  0 * np.ones(len(f_h1))


	# Correction at switch
	h1_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, h1_m)


	# Correction at receiver input
	h1_c = low_band_switch_correction_june_2016(h1_sw_c, f_in = f_h1, verification = 'no')


	h1  = h1_c[(f_h1/1e6>=50) & (f_h1/1e6<=100)]
	fh1 = f_h1[(f_h1/1e6>=50) & (f_h1/1e6<=100)]






	# Hot load after
	# -------------------
	o_m,  f_h2 = rc.s1p_read(path_hot + 'Open2.s1p')
	s_m,  f_h2 = rc.s1p_read(path_hot + 'Short2.s1p')
	l_m,  f_h2 = rc.s1p_read(path_hot + 'Match2.s1p')
	h2_m, f_h2 = rc.s1p_read(path_hot + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_h2))
	s_sw = -1 * np.ones(len(f_h2))
	l_sw =  0 * np.ones(len(f_h2))


	# Correction at switch
	h2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, h2_m)


	# Correction at receiver input
	h2_c = low_band_switch_correction_june_2016(h2_sw_c, f_in = f_h2, verification = 'no')


	h2  = h2_c[(f_h2/1e6>=50) & (f_h2/1e6<=100)]
	fh2 = f_h2[(f_h2/1e6>=50) & (f_h2/1e6<=100)]	











	# -----------------------------------------------------------------------------------------
	# Open Cable before
	# -------------------
	o_m,  f_o1 = rc.s1p_read(path_open + 'Open.s1p')
	s_m,  f_o1 = rc.s1p_read(path_open + 'Short.s1p')
	l_m,  f_o1 = rc.s1p_read(path_open + 'Match.s1p')
	o1_m, f_o1 = rc.s1p_read(path_open + 'External.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_o1))
	s_sw = -1 * np.ones(len(f_o1))
	l_sw =  0 * np.ones(len(f_o1))


	# Correction at switch
	o1_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, o1_m)


	# Correction at receiver input
	o1_c = low_band_switch_correction_june_2016(o1_sw_c, f_in = f_o1, verification = 'no')


	o1  = o1_c[(f_o1/1e6>=50) & (f_o1/1e6<=100)]
	fo1 = f_o1[(f_o1/1e6>=50) & (f_o1/1e6<=100)]






	# Open Cable after
	# -------------------
	o_m,  f_o2 = rc.s1p_read(path_open + 'Open2.s1p')
	s_m,  f_o2 = rc.s1p_read(path_open + 'Short2.s1p')
	l_m,  f_o2 = rc.s1p_read(path_open + 'Match2.s1p')
	o2_m, f_o2 = rc.s1p_read(path_open + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_o2))
	s_sw = -1 * np.ones(len(f_o2))
	l_sw =  0 * np.ones(len(f_o2))


	# Correction at switch
	o2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, o2_m)


	# Correction at receiver input
	o2_c = low_band_switch_correction_june_2016(o2_sw_c, f_in = f_o2, verification = 'no')


	o2  = o2_c[(f_o2/1e6>=50) & (f_o2/1e6<=100)]
	fo2 = f_o2[(f_o2/1e6>=50) & (f_o2/1e6<=100)]











	# -----------------------------------------------------------------------------------------
	# Short Cable before
	# -------------------
	o_m,  f_s1 = rc.s1p_read(path_shorted + 'Open.s1p')
	s_m,  f_s1 = rc.s1p_read(path_shorted + 'Short.s1p')
	l_m,  f_s1 = rc.s1p_read(path_shorted + 'Match.s1p')
	s1_m, f_s1 = rc.s1p_read(path_shorted + 'External.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_s1))
	s_sw = -1 * np.ones(len(f_s1))
	l_sw =  0 * np.ones(len(f_s1))


	# Correction at switch
	s1_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, s1_m)


	# Correction at receiver input
	s1_c = low_band_switch_correction_june_2016(s1_sw_c, f_in = f_s1, verification = 'no')


	s1  = s1_c[(f_s1/1e6>=50) & (f_s1/1e6<=100)]
	fs1 = f_s1[(f_s1/1e6>=50) & (f_s1/1e6<=100)]







	# Short Cable after
	# -------------------
	o_m,  f_s2 = rc.s1p_read(path_shorted + 'Open2.s1p')
	s_m,  f_s2 = rc.s1p_read(path_shorted + 'Short2.s1p')
	l_m,  f_s2 = rc.s1p_read(path_shorted + 'Match2.s1p')
	s2_m, f_s2 = rc.s1p_read(path_shorted + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_s2))
	s_sw = -1 * np.ones(len(f_s2))
	l_sw =  0 * np.ones(len(f_s2))


	# Correction at switch
	s2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, s2_m)


	# Correction at receiver input
	s2_c = low_band_switch_correction_june_2016(s2_sw_c, f_in = f_s2, verification = 'no')


	s2  = s2_c[(f_s2/1e6>=50) & (f_s2/1e6<=100)]
	fs2 = f_s2[(f_s2/1e6>=50) & (f_s2/1e6<=100)]	














	# -----------------------------------------------------------------------------------------
	# Antenna Simulator 1 before
	# --------------------------
	o_m,  f_q11  = rc.s1p_read(path_sim1 + 'Open.s1p')
	s_m,  f_q11  = rc.s1p_read(path_sim1 + 'Short.s1p')
	l_m,  f_q11  = rc.s1p_read(path_sim1 + 'Match.s1p')
	q11_m, f_q11 = rc.s1p_read(path_sim1 + 'External.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_q11))
	s_sw = -1 * np.ones(len(f_q11))
	l_sw =  0 * np.ones(len(f_q11))


	# Correction at switch
	q11_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, q11_m)


	# Correction at receiver input
	q11_c = low_band_switch_correction_june_2016(q11_sw_c, f_in = f_q11, verification = 'no')


	q11  = q11_c[(f_q11/1e6>=50) & (f_q11/1e6<=100)]
	fq11 = f_q11[(f_q11/1e6>=50) & (f_q11/1e6<=100)]





	# Antenna Simulator 1 after
	# -------------------------
	o_m,  f_q12  = rc.s1p_read(path_sim1 + 'Open2.s1p')
	s_m,  f_q12  = rc.s1p_read(path_sim1 + 'Short2.s1p')
	l_m,  f_q12  = rc.s1p_read(path_sim1 + 'Match2.s1p')
	q12_m, f_q12 = rc.s1p_read(path_sim1 + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_q12))
	s_sw = -1 * np.ones(len(f_q12))
	l_sw =  0 * np.ones(len(f_q12))


	# Correction at switch
	q12_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, q12_m)


	# Correction at receiver input
	q12_c = low_band_switch_correction_june_2016(q12_sw_c, f_in = f_q12, verification = 'no')


	q12  = q12_c[(f_q12/1e6>=50) & (f_q12/1e6<=100)]
	fq12 = f_q12[(f_q12/1e6>=50) & (f_q12/1e6<=100)]









	# -----------------------------------------------------------------------------------------
	# Antenna Simulator 2 before
	# --------------------------
	o_m,  f_q21  = rc.s1p_read(path_sim2 + 'Open.s1p')
	s_m,  f_q21  = rc.s1p_read(path_sim2 + 'Short.s1p')
	l_m,  f_q21  = rc.s1p_read(path_sim2 + 'Match.s1p')
	q21_m, f_q21 = rc.s1p_read(path_sim2 + 'External.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_q21))
	s_sw = -1 * np.ones(len(f_q21))
	l_sw =  0 * np.ones(len(f_q21))


	# Correction at switch
	q21_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, q21_m)


	# Correction at receiver input
	q21_c = low_band_switch_correction_june_2016(q21_sw_c, f_in = f_q21, verification = 'no')


	q21  = q21_c[(f_q21/1e6>=50) & (f_q21/1e6<=100)]
	fq21 = f_q21[(f_q21/1e6>=50) & (f_q21/1e6<=100)]








	# Antenna Simulator 2 after
	# --------------------------
	o_m,  f_q22  = rc.s1p_read(path_sim2 + 'Open2.s1p')
	s_m,  f_q22  = rc.s1p_read(path_sim2 + 'Short2.s1p')
	l_m,  f_q22  = rc.s1p_read(path_sim2 + 'Match2.s1p')
	q22_m, f_q22 = rc.s1p_read(path_sim2 + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_q22))
	s_sw = -1 * np.ones(len(f_q22))
	l_sw =  0 * np.ones(len(f_q22))


	# Correction at switch
	q22_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, q22_m)


	# Correction at receiver input
	q22_c = low_band_switch_correction_june_2016(q22_sw_c, f_in = f_q22, verification = 'no')


	q22  = q22_c[(f_q22/1e6>=50) & (f_q22/1e6<=100)]
	fq22 = f_q22[(f_q22/1e6>=50) & (f_q22/1e6<=100)]












	# -----------------------------------------------------------------------------------------
	# Antenna Simulator 2 ROUND 2, before
	# -----------------------------------
	o_m,  f_q21r2    = rc.s1p_read(path_sim2r2 + 'Open.s1p')
	s_m,  f_q21r2    = rc.s1p_read(path_sim2r2 + 'Short.s1p')
	l_m,  f_q21r2    = rc.s1p_read(path_sim2r2 + 'Match.s1p')
	q21r2_m, f_q21r2 = rc.s1p_read(path_sim2r2 + 'External.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_q21r2))
	s_sw = -1 * np.ones(len(f_q21r2))
	l_sw =  0 * np.ones(len(f_q21r2))


	# Correction at switch
	q21r2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, q21r2_m)


	# Correction at receiver input
	q21r2_c = low_band_switch_correction_june_2016(q21r2_sw_c, f_in = f_q21r2, verification = 'no')


	q21r2  = q21r2_c[(f_q21r2/1e6>=50) & (f_q21r2/1e6<=100)]
	fq21r2 = f_q21r2[(f_q21r2/1e6>=50) & (f_q21r2/1e6<=100)]








	# Antenna Simulator 2 ROUND 2, after
	# ----------------------------------
	o_m,  f_q22r2    = rc.s1p_read(path_sim2r2 + 'Open2.s1p')
	s_m,  f_q22r2    = rc.s1p_read(path_sim2r2 + 'Short2.s1p')
	l_m,  f_q22r2    = rc.s1p_read(path_sim2r2 + 'Match2.s1p')
	q22r2_m, f_q22r2 = rc.s1p_read(path_sim2r2 + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_q22r2))
	s_sw = -1 * np.ones(len(f_q22r2))
	l_sw =  0 * np.ones(len(f_q22r2))


	# Correction at switch
	q22r2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, q22r2_m)


	# Correction at receiver input
	q22r2_c = low_band_switch_correction_june_2016(q22r2_sw_c, f_in = f_q22r2, verification = 'no')


	q22r2  = q22r2_c[(f_q22r2/1e6>=50) & (f_q22r2/1e6<=100)]
	fq22r2 = f_q22r2[(f_q22r2/1e6>=50) & (f_q22r2/1e6<=100)]









	# -----------------------------------------------------------------------------------------
	# Saving
	if save == 'yes':

		# Loading S-parameters of semi-rigid cable (they are already at 250 kHz)
		# --------------------------------------------------------------
		d = np.genfromtxt(home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band/2015_08_25C/LNA/S11/corrected/s11_calibration_low_band_LNA25degC_2015-09-16-20-09-50_simulator2_long_new_LNA3.txt')

		sr_s11r    = d[:,11]
		sr_s11i    = d[:,12]
		sr_s12s21r = d[:,13]
		sr_s12s21i = d[:,14]
		sr_s22r    = d[:,15]
		sr_s22i    = d[:,16]




		# Now, saving data
		temp = np.array([ fr/1e6, 
		                  np.real(LNA),  np.imag(LNA),  # the best case for LNA is LNA2
		                  np.real(a1),   np.imag(a1),   np.real(h2),    np.imag(h2),   # the second Hot Load measurement is a little smoother
		                  np.real(o1),   np.imag(o1),   np.real(s1),    np.imag(s1),
		                  sr_s11r,       sr_s11i,       sr_s12s21r,     sr_s12s21i,      sr_s22r,       sr_s22i,
		                  np.real(q11),  np.imag(q11),  np.real(q21),   np.imag(q21),
		                  np.real(q21r2),   np.imag(q21r2)])         # second round of Sim2 measurements





		output_file     = temp.T
		save_path       = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band/2016_11_15C/LNA/S11/corrected/'
		temperature_LNA = '15degC'
		output_file_str = save_path + 's11_calibration_low_band_LNA' + temperature_LNA + '_' + tt.strftime('%Y-%m-%d-%H-%M-%S') + flag + '.txt'
		#output_file_str = save_path + 'test.txt'
		np.savetxt(output_file_str, output_file, header='freq [MHz]	re(LNA)	im(LNA)	re(amb)	im(amb)	re(hot)	im(hot)	re(open)	im(open)	re(shorted)	im(shorted)	re(semirigid_s11)	im(semirigid_s11)	re(semirigid_s12s21) im(semirigid_s12s21)	re(semirigid_s22)	im(semirigid_s22)	re(ant_sim1)	im(ant_sim1)	re(ant_sim2)	im(ant_sim2)	re(ant_sim2_REP2)	im(ant_sim2_REP2)')

		print('File saved to: ' + output_file_str)


	return 0







































def low_band_s11_calibration_measurements_november_2016_35C(save='no', flag=''):




	# Data paths
	main_path    = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band/2016_11_35C/LNA/S11/raw/'
	main_path2   = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band/2017_02_25C/LNA/S11/raw/'

	path_LNA     = main_path  + 'Receiver_25C_nov_21_2016/'
	path_LNA_2   = main_path2 + '35C_reading_1/'

	path_ambient = main_path + 'AmbientLoad/'
	path_hot     = main_path + 'HotLoad/'
	path_open    = main_path + 'CableOpen/'
	path_shorted = main_path + 'CableShorted/'
	path_sim1    = main_path + 'Sim1/'
	path_sim2    = main_path + 'Sim2/'



	## Receiver reflection coefficient (Nov 2016)
	## -------------------------------

	## Reading measurements
	#o,   fr0  = rc.s1p_read(path_LNA + 'Open.s1p')
	#s,   fr0  = rc.s1p_read(path_LNA + 'Short.s1p')
	#l,   fr0  = rc.s1p_read(path_LNA + 'Match.s1p')
	#LNA0, fr0 = rc.s1p_read(path_LNA + 'Receiver.s1p')


	## Models of standards
	#resistance_of_match = 49.97 # female
	#md = 1
	#oa, sa, la = rc.agilent_85033E(fr0, resistance_of_match, md)


	## Correction of measurements
	#LNAc, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA0)


	#LNA = LNAc[(fr0/1e6>=50) & (fr0/1e6<=100)]   
	#fr  = fr0[(fr0/1e6>=50) & (fr0/1e6<=100)]




	# Receiver reflection coefficient (Feb 2017)
	# -------------------------------

	# Reading measurements
	o,   fr0  = rc.s1p_read(path_LNA_2 + 'Open2.s1p')
	s,   fr0  = rc.s1p_read(path_LNA_2 + 'Short2.s1p')
	l,   fr0  = rc.s1p_read(path_LNA_2 + 'Match2.s1p')
	LNA0, fr0 = rc.s1p_read(path_LNA_2 + 'R01.s1p')


	# Models of standards
	resistance_of_match = 49.97 # female
	md = 1
	oa, sa, la = rc.agilent_85033E(fr0, resistance_of_match, md)


	# Correction of measurements
	LNAc, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA0)


	LNA = LNAc[(fr0/1e6>=50) & (fr0/1e6<=100)]
	fr  = fr0[(fr0/1e6>=50) & (fr0/1e6<=100)]









	# Calibration loads
	# -----------------



	# -----------------------------------------------------------------------------------------
	# Ambient load before
	# -------------------
	o_m,  f_a1 = rc.s1p_read(path_ambient + 'Open.s1p')
	s_m,  f_a1 = rc.s1p_read(path_ambient + 'Short.s1p')
	l_m,  f_a1 = rc.s1p_read(path_ambient + 'Match.s1p')
	a1_m, f_a1 = rc.s1p_read(path_ambient + 'External.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_a1))
	s_sw = -1 * np.ones(len(f_a1))
	l_sw =  0 * np.ones(len(f_a1))


	# Correction at switch
	a1_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, a1_m)


	# Correction at receiver input
	a1_c = low_band_switch_correction_june_2016(a1_sw_c, f_in = f_a1, verification = 'no')


	a1  = a1_c[(f_a1/1e6>=50) & (f_a1/1e6<=100)]
	fa1 = f_a1[(f_a1/1e6>=50) & (f_a1/1e6<=100)]







	# Ambient load after
	# -------------------
	o_m,  f_a2 = rc.s1p_read(path_ambient + 'Open2.s1p')
	s_m,  f_a2 = rc.s1p_read(path_ambient + 'Short2.s1p')
	l_m,  f_a2 = rc.s1p_read(path_ambient + 'Match2.s1p')
	a2_m, f_a2 = rc.s1p_read(path_ambient + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_a2))
	s_sw = -1 * np.ones(len(f_a2))
	l_sw =  0 * np.ones(len(f_a2))


	# Correction at switch
	a2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, a2_m)


	# Correction at receiver input
	a2_c = low_band_switch_correction_june_2016(a2_sw_c, f_in = f_a2, verification = 'no')


	a2  = a2_c[(f_a2/1e6>=50) & (f_a2/1e6<=100)]
	fa2 = f_a2[(f_a2/1e6>=50) & (f_a2/1e6<=100)]









	# -----------------------------------------------------------------------------------------
	# Hot load before
	# -------------------
	o_m,  f_h1 = rc.s1p_read(path_hot + 'Open.s1p')
	s_m,  f_h1 = rc.s1p_read(path_hot + 'Short.s1p')
	l_m,  f_h1 = rc.s1p_read(path_hot + 'Match.s1p')
	h1_m, f_h1 = rc.s1p_read(path_hot + 'External.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_h1))
	s_sw = -1 * np.ones(len(f_h1))
	l_sw =  0 * np.ones(len(f_h1))


	# Correction at switch
	h1_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, h1_m)


	# Correction at receiver input
	h1_c = low_band_switch_correction_june_2016(h1_sw_c, f_in = f_h1, verification = 'no')


	h1  = h1_c[(f_h1/1e6>=50) & (f_h1/1e6<=100)]
	fh1 = f_h1[(f_h1/1e6>=50) & (f_h1/1e6<=100)]






	# Hot load after
	# -------------------
	o_m,  f_h2 = rc.s1p_read(path_hot + 'Open2.s1p')
	s_m,  f_h2 = rc.s1p_read(path_hot + 'Short2.s1p')
	l_m,  f_h2 = rc.s1p_read(path_hot + 'Match2.s1p')
	h2_m, f_h2 = rc.s1p_read(path_hot + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_h2))
	s_sw = -1 * np.ones(len(f_h2))
	l_sw =  0 * np.ones(len(f_h2))


	# Correction at switch
	h2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, h2_m)


	# Correction at receiver input
	h2_c = low_band_switch_correction_june_2016(h2_sw_c, f_in = f_h2, verification = 'no')


	h2  = h2_c[(f_h2/1e6>=50) & (f_h2/1e6<=100)]
	fh2 = f_h2[(f_h2/1e6>=50) & (f_h2/1e6<=100)]	











	# -----------------------------------------------------------------------------------------
	# Open Cable before
	# -------------------
	o_m,  f_o1 = rc.s1p_read(path_open + 'Open.s1p')
	s_m,  f_o1 = rc.s1p_read(path_open + 'Short.s1p')
	l_m,  f_o1 = rc.s1p_read(path_open + 'Match.s1p')
	o1_m, f_o1 = rc.s1p_read(path_open + 'External.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_o1))
	s_sw = -1 * np.ones(len(f_o1))
	l_sw =  0 * np.ones(len(f_o1))


	# Correction at switch
	o1_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, o1_m)


	# Correction at receiver input
	o1_c = low_band_switch_correction_june_2016(o1_sw_c, f_in = f_o1, verification = 'no')


	o1  = o1_c[(f_o1/1e6>=50) & (f_o1/1e6<=100)]
	fo1 = f_o1[(f_o1/1e6>=50) & (f_o1/1e6<=100)]






	# Open Cable after
	# -------------------
	o_m,  f_o2 = rc.s1p_read(path_open + 'Open2.s1p')
	s_m,  f_o2 = rc.s1p_read(path_open + 'Short2.s1p')
	l_m,  f_o2 = rc.s1p_read(path_open + 'Match2.s1p')
	o2_m, f_o2 = rc.s1p_read(path_open + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_o2))
	s_sw = -1 * np.ones(len(f_o2))
	l_sw =  0 * np.ones(len(f_o2))


	# Correction at switch
	o2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, o2_m)


	# Correction at receiver input
	o2_c = low_band_switch_correction_june_2016(o2_sw_c, f_in = f_o2, verification = 'no')


	o2  = o2_c[(f_o2/1e6>=50) & (f_o2/1e6<=100)]
	fo2 = f_o2[(f_o2/1e6>=50) & (f_o2/1e6<=100)]











	# -----------------------------------------------------------------------------------------
	# Short Cable before
	# -------------------
	o_m,  f_s1 = rc.s1p_read(path_shorted + 'Open.s1p')
	s_m,  f_s1 = rc.s1p_read(path_shorted + 'Short.s1p')
	l_m,  f_s1 = rc.s1p_read(path_shorted + 'Match.s1p')
	s1_m, f_s1 = rc.s1p_read(path_shorted + 'External.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_s1))
	s_sw = -1 * np.ones(len(f_s1))
	l_sw =  0 * np.ones(len(f_s1))


	# Correction at switch
	s1_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, s1_m)


	# Correction at receiver input
	s1_c = low_band_switch_correction_june_2016(s1_sw_c, f_in = f_s1, verification = 'no')


	s1  = s1_c[(f_s1/1e6>=50) & (f_s1/1e6<=100)]
	fs1 = f_s1[(f_s1/1e6>=50) & (f_s1/1e6<=100)]







	# Short Cable after
	# -------------------
	o_m,  f_s2 = rc.s1p_read(path_shorted + 'Open2.s1p')
	s_m,  f_s2 = rc.s1p_read(path_shorted + 'Short2.s1p')
	l_m,  f_s2 = rc.s1p_read(path_shorted + 'Match2.s1p')
	s2_m, f_s2 = rc.s1p_read(path_shorted + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_s2))
	s_sw = -1 * np.ones(len(f_s2))
	l_sw =  0 * np.ones(len(f_s2))


	# Correction at switch
	s2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, s2_m)


	# Correction at receiver input
	s2_c = low_band_switch_correction_june_2016(s2_sw_c, f_in = f_s2, verification = 'no')


	s2  = s2_c[(f_s2/1e6>=50) & (f_s2/1e6<=100)]
	fs2 = f_s2[(f_s2/1e6>=50) & (f_s2/1e6<=100)]	














	# -----------------------------------------------------------------------------------------
	# Antenna Simulator 1 before
	# --------------------------
	o_m,  f_q11  = rc.s1p_read(path_sim1 + 'Open.s1p')
	s_m,  f_q11  = rc.s1p_read(path_sim1 + 'Short.s1p')
	l_m,  f_q11  = rc.s1p_read(path_sim1 + 'Match.s1p')
	q11_m, f_q11 = rc.s1p_read(path_sim1 + 'External.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_q11))
	s_sw = -1 * np.ones(len(f_q11))
	l_sw =  0 * np.ones(len(f_q11))


	# Correction at switch
	q11_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, q11_m)


	# Correction at receiver input
	q11_c = low_band_switch_correction_june_2016(q11_sw_c, f_in = f_q11, verification = 'no')


	q11  = q11_c[(f_q11/1e6>=50) & (f_q11/1e6<=100)]
	fq11 = f_q11[(f_q11/1e6>=50) & (f_q11/1e6<=100)]





	# Antenna Simulator 1 after
	# -------------------------
	o_m,  f_q12  = rc.s1p_read(path_sim1 + 'Open2.s1p')
	s_m,  f_q12  = rc.s1p_read(path_sim1 + 'Short2.s1p')
	l_m,  f_q12  = rc.s1p_read(path_sim1 + 'Match2.s1p')
	q12_m, f_q12 = rc.s1p_read(path_sim1 + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_q12))
	s_sw = -1 * np.ones(len(f_q12))
	l_sw =  0 * np.ones(len(f_q12))


	# Correction at switch
	q12_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, q12_m)


	# Correction at receiver input
	q12_c = low_band_switch_correction_june_2016(q12_sw_c, f_in = f_q12, verification = 'no')


	q12  = q12_c[(f_q12/1e6>=50) & (f_q12/1e6<=100)]
	fq12 = f_q12[(f_q12/1e6>=50) & (f_q12/1e6<=100)]









	# -----------------------------------------------------------------------------------------
	# Antenna Simulator 2 before
	# --------------------------
	o_m,  f_q21  = rc.s1p_read(path_sim2 + 'Open.s1p')
	s_m,  f_q21  = rc.s1p_read(path_sim2 + 'Short.s1p')
	l_m,  f_q21  = rc.s1p_read(path_sim2 + 'Match.s1p')
	q21_m, f_q21 = rc.s1p_read(path_sim2 + 'External.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_q21))
	s_sw = -1 * np.ones(len(f_q21))
	l_sw =  0 * np.ones(len(f_q21))


	# Correction at switch
	q21_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, q21_m)


	# Correction at receiver input
	q21_c = low_band_switch_correction_june_2016(q21_sw_c, f_in = f_q21, verification = 'no')


	q21  = q21_c[(f_q21/1e6>=50) & (f_q21/1e6<=100)]
	fq21 = f_q21[(f_q21/1e6>=50) & (f_q21/1e6<=100)]








	# Antenna Simulator 2 after
	# --------------------------
	o_m,  f_q22  = rc.s1p_read(path_sim2 + 'Open2.s1p')
	s_m,  f_q22  = rc.s1p_read(path_sim2 + 'Short2.s1p')
	l_m,  f_q22  = rc.s1p_read(path_sim2 + 'Match2.s1p')
	q22_m, f_q22 = rc.s1p_read(path_sim2 + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_q22))
	s_sw = -1 * np.ones(len(f_q22))
	l_sw =  0 * np.ones(len(f_q22))


	# Correction at switch
	q22_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, q22_m)


	# Correction at receiver input
	q22_c = low_band_switch_correction_june_2016(q22_sw_c, f_in = f_q22, verification = 'no')


	q22  = q22_c[(f_q22/1e6>=50) & (f_q22/1e6<=100)]
	fq22 = f_q22[(f_q22/1e6>=50) & (f_q22/1e6<=100)]













	# -----------------------------------------------------------------------------------------
	# Saving
	if save == 'yes':

		# Loading S-parameters of semi-rigid cable (they are already at 250 kHz)
		# --------------------------------------------------------------
		d = np.genfromtxt(home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band/2015_08_25C/LNA/S11/corrected/s11_calibration_low_band_LNA25degC_2015-09-16-20-09-50_simulator2_long_new_LNA3.txt')

		sr_s11r    = d[:,11]
		sr_s11i    = d[:,12]
		sr_s12s21r = d[:,13]
		sr_s12s21i = d[:,14]
		sr_s22r    = d[:,15]
		sr_s22i    = d[:,16]




		# Now, saving data
		temp = np.array([ fr/1e6, 
		                  np.real(LNA),  np.imag(LNA),
		                  np.real(a1),   np.imag(a1),   np.real(h2),    np.imag(h2),   # h2 is best Hot Load
		                  np.real(o1),   np.imag(o1),   np.real(s1),    np.imag(s1),
		                  sr_s11r,       sr_s11i,       sr_s12s21r,     sr_s12s21i,      sr_s22r,       sr_s22i,
		                  np.real(q11),  np.imag(q11),  np.real(q21),   np.imag(q21)])





		output_file     = temp.T
		save_path       = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band/2016_11_35C/LNA/S11/corrected/'
		temperature_LNA = '35degC'
		output_file_str = save_path + 's11_calibration_low_band_LNA' + temperature_LNA + '_' + tt.strftime('%Y-%m-%d-%H-%M-%S') + flag + '.txt'
		#output_file_str = save_path + 'test.txt'
		np.savetxt(output_file_str, output_file)

		print('File saved to: ' + output_file_str)


	return 0























def low_band_receiver_s11_repeatability_2017_february(flow=50, fhigh=100):

	main_path    = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band/2017_02_25C/LNA/S11/raw'
	path_LNA_R1  = main_path + '/25C_reading_1/'
	path_LNA_R2  = main_path + '/25C_reading_2/'
	path_LNA_R3  = main_path + '/25C_reading_3/'
	path_LNA_15  = main_path + '/15C_reading/'
	path_LNA_35  = main_path + '/35C_reading_1/'


	# Measurements from previous calibrations
	d15C = np.genfromtxt(home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band/2016_11_15C/LNA/S11/corrected/s11_calibration_low_band_LNA15degC_2016-12-14-23-01-53.txt')
	d25C = np.genfromtxt(home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band/2016_09_25C/LNA/S11/corrected/s11_calibration_low_band_LNA25degC_2016-10-31-13-02-58.txt')
	d35C = np.genfromtxt(home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band/2016_11_35C/LNA/S11/corrected/s11_calibration_low_band_LNA35degC_2016-12-14-23-35-37.txt')





	# SET 1 --- 1hr REPETITIONS
	# ------------------------
	# Reading measurements
	o,   fr     = rc.s1p_read(path_LNA_R1 + 'Open.s1p')
	s,   fr     = rc.s1p_read(path_LNA_R1 + 'Short.s1p')
	l,   fr     = rc.s1p_read(path_LNA_R1 + 'Match.s1p')
	LNA_R01, fr = rc.s1p_read(path_LNA_R1 + 'R01.s1p')
	LNA_R02, fr = rc.s1p_read(path_LNA_R1 + 'R02.s1p')
	LNA_R03, fr = rc.s1p_read(path_LNA_R1 + 'R03.s1p')
	LNA_R04, fr = rc.s1p_read(path_LNA_R1 + 'R04.s1p')
	LNA_R05, fr = rc.s1p_read(path_LNA_R1 + 'R05.s1p')
	LNA_R06, fr = rc.s1p_read(path_LNA_R1 + 'R06.s1p')
	LNA_R07, fr = rc.s1p_read(path_LNA_R1 + 'R07.s1p')
	LNA_R08, fr = rc.s1p_read(path_LNA_R1 + 'R08.s1p')
	LNA_R09, fr = rc.s1p_read(path_LNA_R1 + 'R09.s1p')
	LNA_R10, fr = rc.s1p_read(path_LNA_R1 + 'R10.s1p')

	# Models of standards
	resistance_of_match = 49.97 # female
	md = 1
	oa, sa, la = rc.agilent_85033E(fr, resistance_of_match, md)

	# Correction of measurements
	LNAc_R01, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R01)
	LNAc_R02, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R02)
	LNAc_R03, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R03)
	LNAc_R04, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R04)
	LNAc_R05, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R05)
	LNAc_R06, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R06)
	LNAc_R07, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R07)
	LNAc_R08, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R08)
	LNAc_R09, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R09)
	LNAc_R10, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R10)

	# 50-100 MHz
	LNAxR01 = LNAc_R01[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAxR02 = LNAc_R02[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAxR03 = LNAc_R03[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAxR04 = LNAc_R04[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAxR05 = LNAc_R05[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAxR06 = LNAc_R06[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAxR07 = LNAc_R07[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAxR08 = LNAc_R08[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAxR09 = LNAc_R09[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAxR10 = LNAc_R10[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	frxR    = fr[(fr/1e6>=flow) & (fr/1e6<=fhigh)]






	# SET 2 --- 1hr REPETITIONS
	# ------------------------
	# Reading measurements
	o,   fr     = rc.s1p_read(path_LNA_R2 + 'Open2.s1p')
	s,   fr     = rc.s1p_read(path_LNA_R2 + 'Short2.s1p')
	l,   fr     = rc.s1p_read(path_LNA_R2 + 'Match2.s1p')
	LNA_R01, fr = rc.s1p_read(path_LNA_R2 + 'R01.s1p')
	LNA_R02, fr = rc.s1p_read(path_LNA_R2 + 'R02.s1p')
	LNA_R03, fr = rc.s1p_read(path_LNA_R2 + 'R03.s1p')
	LNA_R04, fr = rc.s1p_read(path_LNA_R2 + 'R04.s1p')
	LNA_R05, fr = rc.s1p_read(path_LNA_R2 + 'R05.s1p')
	LNA_R06, fr = rc.s1p_read(path_LNA_R2 + 'R06.s1p')
	LNA_R07, fr = rc.s1p_read(path_LNA_R2 + 'R07.s1p')
	LNA_R08, fr = rc.s1p_read(path_LNA_R2 + 'R08.s1p')
	LNA_R09, fr = rc.s1p_read(path_LNA_R2 + 'R09.s1p')
	LNA_R10, fr = rc.s1p_read(path_LNA_R2 + 'R10.s1p')

	# Models of standards
	resistance_of_match = 49.97 # female
	md = 1
	oa, sa, la = rc.agilent_85033E(fr, resistance_of_match, md)

	# Correction of measurements
	LNAc_R01, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R01)
	LNAc_R02, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R02)
	LNAc_R03, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R03)
	LNAc_R04, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R04)
	LNAc_R05, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R05)
	LNAc_R06, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R06)
	LNAc_R07, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R07)
	LNAc_R08, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R08)
	LNAc_R09, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R09)
	LNAc_R10, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R10)

	# 50-100 MHz
	LNAyR01 = LNAc_R01[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAyR02 = LNAc_R02[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAyR03 = LNAc_R03[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAyR04 = LNAc_R04[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAyR05 = LNAc_R05[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAyR06 = LNAc_R06[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAyR07 = LNAc_R07[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAyR08 = LNAc_R08[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAyR09 = LNAc_R09[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAyR10 = LNAc_R10[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	fryR    = fr[(fr/1e6>=flow) & (fr/1e6<=fhigh)]






	# SET 3 --- 1hr REPETITIONS
	# ------------------------
	# Reading measurements
	o,   fr     = rc.s1p_read(path_LNA_R3 + 'Open2.s1p')
	s,   fr     = rc.s1p_read(path_LNA_R3 + 'Short2.s1p')
	l,   fr     = rc.s1p_read(path_LNA_R3 + 'Match2.s1p')
	LNA_R01, fr = rc.s1p_read(path_LNA_R3 + 'R01.s1p')
	LNA_R02, fr = rc.s1p_read(path_LNA_R3 + 'R02.s1p')
	LNA_R03, fr = rc.s1p_read(path_LNA_R3 + 'R03.s1p')
	LNA_R04, fr = rc.s1p_read(path_LNA_R3 + 'R04.s1p')
	LNA_R05, fr = rc.s1p_read(path_LNA_R3 + 'R05.s1p')
	LNA_R06, fr = rc.s1p_read(path_LNA_R3 + 'R06.s1p')
	LNA_R07, fr = rc.s1p_read(path_LNA_R3 + 'R07.s1p')
	LNA_R08, fr = rc.s1p_read(path_LNA_R3 + 'R08.s1p')
	LNA_R09, fr = rc.s1p_read(path_LNA_R3 + 'R09.s1p')
	LNA_R10, fr = rc.s1p_read(path_LNA_R3 + 'R10.s1p')

	# Models of standards
	resistance_of_match = 49.97 # female
	md = 1
	oa, sa, la = rc.agilent_85033E(fr, resistance_of_match, md)

	# Correction of measurements
	LNAc_R01, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R01)
	LNAc_R02, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R02)
	LNAc_R03, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R03)
	LNAc_R04, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R04)
	LNAc_R05, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R05)
	LNAc_R06, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R06)
	LNAc_R07, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R07)
	LNAc_R08, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R08)
	LNAc_R09, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R09)
	LNAc_R10, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R10)

	# 50-100 MHz
	LNAzR01 = LNAc_R01[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAzR02 = LNAc_R02[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAzR03 = LNAc_R03[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAzR04 = LNAc_R04[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAzR05 = LNAc_R05[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAzR06 = LNAc_R06[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAzR07 = LNAc_R07[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAzR08 = LNAc_R08[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAzR09 = LNAc_R09[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAzR10 = LNAc_R10[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	frzR    = fr[(fr/1e6>=flow) & (fr/1e6<=fhigh)]

















	# SET 1 - 15degC --- 1hr REPETITIONS
	# ------------------------
	# Reading measurements
	o,   fr     = rc.s1p_read(path_LNA_15 + 'Open.s1p')
	s,   fr     = rc.s1p_read(path_LNA_15 + 'Short.s1p')
	l,   fr     = rc.s1p_read(path_LNA_15 + 'Match.s1p')
	LNA_R01, fr = rc.s1p_read(path_LNA_15 + 'R01.s1p')
	LNA_R02, fr = rc.s1p_read(path_LNA_15 + 'R02.s1p')
	LNA_R03, fr = rc.s1p_read(path_LNA_15 + 'R03.s1p')
	LNA_R04, fr = rc.s1p_read(path_LNA_15 + 'R04.s1p')
	LNA_R05, fr = rc.s1p_read(path_LNA_15 + 'R05.s1p')
	LNA_R06, fr = rc.s1p_read(path_LNA_15 + 'R06.s1p')
	LNA_R07, fr = rc.s1p_read(path_LNA_15 + 'R07.s1p')
	LNA_R08, fr = rc.s1p_read(path_LNA_15 + 'R08.s1p')
	LNA_R09, fr = rc.s1p_read(path_LNA_15 + 'R09.s1p')
	LNA_R10, fr = rc.s1p_read(path_LNA_15 + 'R10.s1p')

	# Models of standards
	resistance_of_match = 49.97 # female
	md = 1
	oa, sa, la = rc.agilent_85033E(fr, resistance_of_match, md)

	# Correction of measurements
	LNAc_R01, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R01)
	LNAc_R02, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R02)
	LNAc_R03, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R03)
	LNAc_R04, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R04)
	LNAc_R05, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R05)
	LNAc_R06, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R06)
	LNAc_R07, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R07)
	LNAc_R08, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R08)
	LNAc_R09, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R09)
	LNAc_R10, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R10)

	# 50-100 MHz
	LNAkR01 = LNAc_R01[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAkR02 = LNAc_R02[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAkR03 = LNAc_R03[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAkR04 = LNAc_R04[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAkR05 = LNAc_R05[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAkR06 = LNAc_R06[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAkR07 = LNAc_R07[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAkR08 = LNAc_R08[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAkR09 = LNAc_R09[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAkR10 = LNAc_R10[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	frkR    = fr[(fr/1e6>=flow) & (fr/1e6<=fhigh)]










	# SET 1 - 35degC --- 1hr REPETITIONS
	# ----------------------------------
	# Reading measurements
	o,   fr     = rc.s1p_read(path_LNA_35 + 'Open.s1p')
	s,   fr     = rc.s1p_read(path_LNA_35 + 'Short.s1p')
	l,   fr     = rc.s1p_read(path_LNA_35 + 'Match.s1p')
	LNA_R01, fr = rc.s1p_read(path_LNA_35 + 'R01.s1p')
	LNA_R02, fr = rc.s1p_read(path_LNA_35 + 'R02.s1p')
	LNA_R03, fr = rc.s1p_read(path_LNA_35 + 'R03.s1p')
	LNA_R04, fr = rc.s1p_read(path_LNA_35 + 'R04.s1p')
	LNA_R05, fr = rc.s1p_read(path_LNA_35 + 'R05.s1p')
	LNA_R06, fr = rc.s1p_read(path_LNA_35 + 'R06.s1p')
	LNA_R07, fr = rc.s1p_read(path_LNA_35 + 'R07.s1p')
	LNA_R08, fr = rc.s1p_read(path_LNA_35 + 'R08.s1p')
	LNA_R09, fr = rc.s1p_read(path_LNA_35 + 'R09.s1p')
	LNA_R10, fr = rc.s1p_read(path_LNA_35 + 'R10.s1p')

	# Models of standards
	resistance_of_match = 49.97 # female
	md = 1
	oa, sa, la = rc.agilent_85033E(fr, resistance_of_match, md)

	# Correction of measurements
	LNAc_R01, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R01)
	LNAc_R02, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R02)
	LNAc_R03, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R03)
	LNAc_R04, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R04)
	LNAc_R05, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R05)
	LNAc_R06, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R06)
	LNAc_R07, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R07)
	LNAc_R08, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R08)
	LNAc_R09, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R09)
	LNAc_R10, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R10)

	# 50-100 MHz
	LNAjR01 = LNAc_R01[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAjR02 = LNAc_R02[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAjR03 = LNAc_R03[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAjR04 = LNAc_R04[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAjR05 = LNAc_R05[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAjR06 = LNAc_R06[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAjR07 = LNAc_R07[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAjR08 = LNAc_R08[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAjR09 = LNAc_R09[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAjR10 = LNAc_R10[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	frjR    = fr[(fr/1e6>=flow) & (fr/1e6<=fhigh)]	
















	# Plotting 
	# -------------------------------------------------



	# Measurements at 25degC
	# ----------------------
	plt.close()
	plt.close()
	plt.close()
	plt.close()
	plt.close()

	plt.figure(1, figsize=[12,10])
	plt.subplot(2,2,1)
	plt.plot(d25C[:,0], 20*np.log10(np.abs(d25C[:,1]+1j*d25C[:,2])), 'k', linewidth=2)
	plt.plot(frxR/1e6, 20*np.log10(np.abs(LNAxR01)), 'b')
	plt.plot(frxR/1e6, 20*np.log10(np.abs(LNAxR02)), 'b--')
	plt.plot(frxR/1e6, 20*np.log10(np.abs(LNAxR03)), 'b:')
	plt.plot(frxR/1e6, 20*np.log10(np.abs(LNAxR04)), 'g')
	plt.plot(frxR/1e6, 20*np.log10(np.abs(LNAxR05)), 'g--')
	plt.plot(frxR/1e6, 20*np.log10(np.abs(LNAxR06)), 'g:')
	plt.plot(frxR/1e6, 20*np.log10(np.abs(LNAxR07)), 'r')
	plt.plot(frxR/1e6, 20*np.log10(np.abs(LNAxR08)), 'r--')
	plt.plot(frxR/1e6, 20*np.log10(np.abs(LNAxR09)), 'r:')
	plt.plot(frxR/1e6, 20*np.log10(np.abs(LNAxR10)), 'c')
	plt.ylabel('magnitude [dB]')
	plt.xlim([50, 100])
	plt.ylim([-38, -28])
	plt.grid()


	plt.subplot(2,2,3)
	plt.plot(frxR/1e6, 20*np.log10(np.abs(LNAxR01)) - 20*np.log10(np.abs(LNAxR01)), 'b')
	plt.plot(frxR/1e6, 20*np.log10(np.abs(LNAxR02)) - 20*np.log10(np.abs(LNAxR01)), 'b--')
	plt.plot(frxR/1e6, 20*np.log10(np.abs(LNAxR03)) - 20*np.log10(np.abs(LNAxR01)), 'b:')
	plt.plot(frxR/1e6, 20*np.log10(np.abs(LNAxR04)) - 20*np.log10(np.abs(LNAxR01)), 'g')
	plt.plot(frxR/1e6, 20*np.log10(np.abs(LNAxR05)) - 20*np.log10(np.abs(LNAxR01)), 'g--')
	plt.plot(frxR/1e6, 20*np.log10(np.abs(LNAxR06)) - 20*np.log10(np.abs(LNAxR01)), 'g:')
	plt.plot(frxR/1e6, 20*np.log10(np.abs(LNAxR07)) - 20*np.log10(np.abs(LNAxR01)), 'r')
	plt.plot(frxR/1e6, 20*np.log10(np.abs(LNAxR08)) - 20*np.log10(np.abs(LNAxR01)), 'r--')
	plt.plot(frxR/1e6, 20*np.log10(np.abs(LNAxR09)) - 20*np.log10(np.abs(LNAxR01)), 'r:')
	plt.plot(frxR/1e6, 20*np.log10(np.abs(LNAxR10)) - 20*np.log10(np.abs(LNAxR01)), 'c')	
	plt.ylim([-0.01, 0.1])
	plt.ylabel(r'$\Delta$ magnitude [dB]')
	plt.xlabel('frequency [MHz]')


	plt.subplot(2,2,2)
	plt.plot(d25C[:,0], (180/np.pi)*np.unwrap(np.angle(d25C[:,1]+1j*d25C[:,2])), 'k', linewidth=2)
	plt.plot(frxR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAxR01)), 'b')
	plt.plot(frxR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAxR02)), 'b--')
	plt.plot(frxR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAxR03)), 'b:')
	plt.plot(frxR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAxR04)), 'g')
	plt.plot(frxR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAxR05)), 'g--')
	plt.plot(frxR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAxR06)), 'g:')
	plt.plot(frxR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAxR07)), 'r')
	plt.plot(frxR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAxR08)), 'r--')
	plt.plot(frxR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAxR09)), 'r:')
	plt.plot(frxR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAxR10)), 'c')
	plt.ylabel('phase [deg]')
	plt.xlim([50, 100])
	plt.ylim([15, 60])
	plt.grid()
	plt.legend(['Sept 2016'+'\n'+'-35dBm', 'SET1:  1', 'SET1:  2', 'SET1:  3', 'SET1:  4', 'SET1:  5', 'SET1:  6', 'SET1:  7', 'SET1:  8', 'SET1:  9', 'SET1:  10'], loc=0, fontsize=9)

	plt.subplot(2,2,4)
	plt.plot(frxR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAxR01)) - (180/np.pi)*np.unwrap(np.angle(LNAxR01)), 'b')
	plt.plot(frxR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAxR02)) - (180/np.pi)*np.unwrap(np.angle(LNAxR01)), 'b--')
	plt.plot(frxR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAxR03)) - (180/np.pi)*np.unwrap(np.angle(LNAxR01)), 'b:')
	plt.plot(frxR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAxR04)) - (180/np.pi)*np.unwrap(np.angle(LNAxR01)), 'g')
	plt.plot(frxR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAxR05)) - (180/np.pi)*np.unwrap(np.angle(LNAxR01)), 'g--')
	plt.plot(frxR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAxR06)) - (180/np.pi)*np.unwrap(np.angle(LNAxR01)), 'g:')
	plt.plot(frxR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAxR07)) - (180/np.pi)*np.unwrap(np.angle(LNAxR01)), 'r')
	plt.plot(frxR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAxR08)) - (180/np.pi)*np.unwrap(np.angle(LNAxR01)), 'r--')
	plt.plot(frxR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAxR09)) - (180/np.pi)*np.unwrap(np.angle(LNAxR01)), 'r:')
	plt.plot(frxR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAxR10)) - (180/np.pi)*np.unwrap(np.angle(LNAxR01)), 'c')
	plt.ylim([-0.1, 1])
	plt.xlabel('frequency [MHz]')
	plt.ylabel(r'$\Delta$ phase [deg]')

	plt.legend(['SET1: 1-1', 'SET1: 2-1', 'SET1: 3-1', 'SET1: 4-1', 'SET1: 5-1', 'SET1: 6-1', 'SET1: 7-1', 'SET1: 8-1', 'SET1: 9-1', 'SET1: 10-1'], loc=0, fontsize=9)


	# Save plot
	path_plot_save = home_folder + '/DATA/EDGES/results/plots/20170303/'
	plt.savefig(path_plot_save + 'low_band_s11_repeatability1.pdf', bbox_inches='tight')
	plt.close()
	plt.close()








	plt.figure(2, figsize=[12,10])
	plt.subplot(2,2,1)
	plt.plot(d25C[:,0], 20*np.log10(np.abs(d25C[:,1]+1j*d25C[:,2])), 'k', linewidth=2)
	plt.plot(fryR/1e6, 20*np.log10(np.abs(LNAyR01)), 'b')
	plt.plot(fryR/1e6, 20*np.log10(np.abs(LNAyR02)), 'b--')
	plt.plot(fryR/1e6, 20*np.log10(np.abs(LNAyR03)), 'b:')
	plt.plot(fryR/1e6, 20*np.log10(np.abs(LNAyR04)), 'g')
	plt.plot(fryR/1e6, 20*np.log10(np.abs(LNAyR05)), 'g--')
	plt.plot(fryR/1e6, 20*np.log10(np.abs(LNAyR06)), 'g:')
	plt.plot(fryR/1e6, 20*np.log10(np.abs(LNAyR07)), 'r')
	plt.plot(fryR/1e6, 20*np.log10(np.abs(LNAyR08)), 'r--')
	plt.plot(fryR/1e6, 20*np.log10(np.abs(LNAyR09)), 'r:')
	plt.plot(fryR/1e6, 20*np.log10(np.abs(LNAyR10)), 'c')
	plt.ylabel('magnitude [dB]')
	plt.xlim([50, 100])
	plt.ylim([-38, -28])
	plt.grid()

	plt.subplot(2,2,3)
	plt.plot(fryR/1e6, 20*np.log10(np.abs(LNAyR01)) - 20*np.log10(np.abs(LNAyR01)), 'b')
	plt.plot(fryR/1e6, 20*np.log10(np.abs(LNAyR02)) - 20*np.log10(np.abs(LNAyR01)), 'b--')
	plt.plot(fryR/1e6, 20*np.log10(np.abs(LNAyR03)) - 20*np.log10(np.abs(LNAyR01)), 'b:')
	plt.plot(fryR/1e6, 20*np.log10(np.abs(LNAyR04)) - 20*np.log10(np.abs(LNAyR01)), 'g')
	plt.plot(fryR/1e6, 20*np.log10(np.abs(LNAyR05)) - 20*np.log10(np.abs(LNAyR01)), 'g--')
	plt.plot(fryR/1e6, 20*np.log10(np.abs(LNAyR06)) - 20*np.log10(np.abs(LNAyR01)), 'g:')
	plt.plot(fryR/1e6, 20*np.log10(np.abs(LNAyR07)) - 20*np.log10(np.abs(LNAyR01)), 'r')
	plt.plot(fryR/1e6, 20*np.log10(np.abs(LNAyR08)) - 20*np.log10(np.abs(LNAyR01)), 'r--')
	plt.plot(fryR/1e6, 20*np.log10(np.abs(LNAyR09)) - 20*np.log10(np.abs(LNAyR01)), 'r:')
	plt.plot(fryR/1e6, 20*np.log10(np.abs(LNAyR10)) - 20*np.log10(np.abs(LNAyR01)), 'c')	
	plt.ylim([-0.01, 0.1])
	plt.ylabel(r'$\Delta$ magnitude [dB]')
	plt.xlabel('frequency [MHz]')


	plt.subplot(2,2,2)
	plt.plot(d25C[:,0], (180/np.pi)*np.unwrap(np.angle(d25C[:,1]+1j*d25C[:,2])), 'k', linewidth=2)
	plt.plot(fryR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAyR01)), 'b')
	plt.plot(fryR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAyR02)), 'b--')
	plt.plot(fryR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAyR03)), 'b:')
	plt.plot(fryR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAyR04)), 'g')
	plt.plot(fryR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAyR05)), 'g--')
	plt.plot(fryR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAyR06)), 'g:')
	plt.plot(fryR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAyR07)), 'r')
	plt.plot(fryR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAyR08)), 'r--')
	plt.plot(fryR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAyR09)), 'r:')
	plt.plot(fryR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAyR10)), 'c')
	plt.ylabel('phase [deg]')
	plt.xlim([50, 100])
	plt.ylim([15, 60])	
	plt.grid()
	plt.legend(['Sept 2016'+'\n'+'-35dBm', 'SET2:  1', 'SET2:  2', 'SET2:  3', 'SET2:  4', 'SET2:  5', 'SET2:  6', 'SET2:  7', 'SET2:  8', 'SET2:  9', 'SET2:  10'], loc=0, fontsize=9)

	plt.subplot(2,2,4)
	plt.plot(fryR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAyR01)) - (180/np.pi)*np.unwrap(np.angle(LNAyR01)), 'b')
	plt.plot(fryR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAyR02)) - (180/np.pi)*np.unwrap(np.angle(LNAyR01)), 'b--')
	plt.plot(fryR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAyR03)) - (180/np.pi)*np.unwrap(np.angle(LNAyR01)), 'b:')
	plt.plot(fryR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAyR04)) - (180/np.pi)*np.unwrap(np.angle(LNAyR01)), 'g')
	plt.plot(fryR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAyR05)) - (180/np.pi)*np.unwrap(np.angle(LNAyR01)), 'g--')
	plt.plot(fryR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAyR06)) - (180/np.pi)*np.unwrap(np.angle(LNAyR01)), 'g:')
	plt.plot(fryR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAyR07)) - (180/np.pi)*np.unwrap(np.angle(LNAyR01)), 'r')
	plt.plot(fryR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAyR08)) - (180/np.pi)*np.unwrap(np.angle(LNAyR01)), 'r--')
	plt.plot(fryR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAyR09)) - (180/np.pi)*np.unwrap(np.angle(LNAyR01)), 'r:')
	plt.plot(fryR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAyR10)) - (180/np.pi)*np.unwrap(np.angle(LNAyR01)), 'c')
	plt.ylim([-0.1, 1])
	plt.xlabel('frequency [MHz]')
	plt.ylabel(r'$\Delta$ phase [deg]')

	plt.legend(['SET2: 1-1', 'SET2: 2-1', 'SET2: 3-1', 'SET2: 4-1', 'SET2: 5-1', 'SET2: 6-1', 'SET2: 7-1', 'SET2: 8-1', 'SET2: 9-1', 'SET2: 10-1'], loc=0, fontsize=9)

	# Save plot
	path_plot_save = home_folder + '/DATA/EDGES/results/plots/20170303/'
	plt.savefig(path_plot_save + 'low_band_s11_repeatability2.pdf', bbox_inches='tight')
	plt.close()
	plt.close()












	plt.figure(3, figsize=[12,10])
	plt.subplot(2,2,1)
	plt.plot(d25C[:,0], 20*np.log10(np.abs(d25C[:,1]+1j*d25C[:,2])), 'k', linewidth=2)
	plt.plot(frzR/1e6, 20*np.log10(np.abs(LNAzR01)), 'b')
	plt.plot(frzR/1e6, 20*np.log10(np.abs(LNAzR02)), 'b--')
	plt.plot(frzR/1e6, 20*np.log10(np.abs(LNAzR03)), 'b:')
	plt.plot(frzR/1e6, 20*np.log10(np.abs(LNAzR04)), 'g')
	plt.plot(frzR/1e6, 20*np.log10(np.abs(LNAzR05)), 'g--')
	plt.plot(frzR/1e6, 20*np.log10(np.abs(LNAzR06)), 'g:')
	plt.plot(frzR/1e6, 20*np.log10(np.abs(LNAzR07)), 'r')
	plt.plot(frzR/1e6, 20*np.log10(np.abs(LNAzR08)), 'r--')
	plt.plot(frzR/1e6, 20*np.log10(np.abs(LNAzR09)), 'r:')
	plt.plot(frzR/1e6, 20*np.log10(np.abs(LNAzR10)), 'c')
	plt.ylabel('magnitude [dB]')
	plt.xlim([50, 100])
	plt.ylim([-38, -28])
	plt.grid()

	plt.subplot(2,2,3)
	plt.plot(frzR/1e6, 20*np.log10(np.abs(LNAzR01)) - 20*np.log10(np.abs(LNAzR01)), 'b')
	plt.plot(frzR/1e6, 20*np.log10(np.abs(LNAzR02)) - 20*np.log10(np.abs(LNAzR01)), 'b--')
	plt.plot(frzR/1e6, 20*np.log10(np.abs(LNAzR03)) - 20*np.log10(np.abs(LNAzR01)), 'b:')
	plt.plot(frzR/1e6, 20*np.log10(np.abs(LNAzR04)) - 20*np.log10(np.abs(LNAzR01)), 'g')
	plt.plot(frzR/1e6, 20*np.log10(np.abs(LNAzR05)) - 20*np.log10(np.abs(LNAzR01)), 'g--')
	plt.plot(frzR/1e6, 20*np.log10(np.abs(LNAzR06)) - 20*np.log10(np.abs(LNAzR01)), 'g:')
	plt.plot(frzR/1e6, 20*np.log10(np.abs(LNAzR07)) - 20*np.log10(np.abs(LNAzR01)), 'r')
	plt.plot(frzR/1e6, 20*np.log10(np.abs(LNAzR08)) - 20*np.log10(np.abs(LNAzR01)), 'r--')
	plt.plot(frzR/1e6, 20*np.log10(np.abs(LNAzR09)) - 20*np.log10(np.abs(LNAzR01)), 'r:')
	plt.plot(frzR/1e6, 20*np.log10(np.abs(LNAzR10)) - 20*np.log10(np.abs(LNAzR01)), 'c')	
	plt.ylim([-0.01, 0.1])
	plt.ylabel(r'$\Delta$ magnitude [dB]')
	plt.xlabel('frequency [MHz]')


	plt.subplot(2,2,2)
	plt.plot(d25C[:,0], (180/np.pi)*np.unwrap(np.angle(d25C[:,1]+1j*d25C[:,2])), 'k', linewidth=2)
	plt.plot(frzR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAzR01)), 'b')
	plt.plot(frzR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAzR02)), 'b--')
	plt.plot(frzR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAzR03)), 'b:')
	plt.plot(frzR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAzR04)), 'g')
	plt.plot(frzR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAzR05)), 'g--')
	plt.plot(frzR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAzR06)), 'g:')
	plt.plot(frzR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAzR07)), 'r')
	plt.plot(frzR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAzR08)), 'r--')
	plt.plot(frzR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAzR09)), 'r:')
	plt.plot(frzR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAzR10)), 'c')
	plt.ylabel('phase [deg]')
	plt.xlim([50, 100])
	plt.ylim([15, 60])
	plt.grid()
	plt.legend(['Sept 2016'+'\n'+'-35dBm', 'SET3:  1', 'SET3:  2', 'SET3:  3', 'SET3:  4', 'SET3:  5', 'SET3:  6', 'SET3:  7', 'SET3:  8', 'SET3:  9', 'SET3:  10'], loc=0, fontsize=9)

	plt.subplot(2,2,4)
	plt.plot(frzR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAzR01)) - (180/np.pi)*np.unwrap(np.angle(LNAzR01)), 'b')
	plt.plot(frzR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAzR02)) - (180/np.pi)*np.unwrap(np.angle(LNAzR01)), 'b--')
	plt.plot(frzR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAzR03)) - (180/np.pi)*np.unwrap(np.angle(LNAzR01)), 'b:')
	plt.plot(frzR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAzR04)) - (180/np.pi)*np.unwrap(np.angle(LNAzR01)), 'g')
	plt.plot(frzR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAzR05)) - (180/np.pi)*np.unwrap(np.angle(LNAzR01)), 'g--')
	plt.plot(frzR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAzR06)) - (180/np.pi)*np.unwrap(np.angle(LNAzR01)), 'g:')
	plt.plot(frzR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAzR07)) - (180/np.pi)*np.unwrap(np.angle(LNAzR01)), 'r')
	plt.plot(frzR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAzR08)) - (180/np.pi)*np.unwrap(np.angle(LNAzR01)), 'r--')
	plt.plot(frzR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAzR09)) - (180/np.pi)*np.unwrap(np.angle(LNAzR01)), 'r:')
	plt.plot(frzR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAzR10)) - (180/np.pi)*np.unwrap(np.angle(LNAzR01)), 'c')
	plt.ylim([-0.1, 1])
	plt.xlabel('frequency [MHz]')
	plt.ylabel(r'$\Delta$ phase [deg]')

	plt.legend(['SET3: 1-1', 'SET3: 2-1', 'SET3: 3-1', 'SET3: 4-1', 'SET3: 5-1', 'SET3: 6-1', 'SET3: 7-1', 'SET3: 8-1', 'SET3: 9-1', 'SET3: 10-1'], loc=0, fontsize=9)

	# Save plot
	path_plot_save = home_folder + '/DATA/EDGES/results/plots/20170303/'
	plt.savefig(path_plot_save + 'low_band_s11_repeatability3.pdf', bbox_inches='tight')
	plt.close()
	plt.close()













	# Measurements at 15degC
	# -----------------------
	plt.figure(4, figsize=[12,10])
	plt.subplot(2,2,1)
	plt.plot(d15C[:,0], 20*np.log10(np.abs(d15C[:,1]+1j*d15C[:,2])), 'k', linewidth=2)
	plt.plot(frkR/1e6, 20*np.log10(np.abs(LNAkR01)), 'b')
	plt.plot(frkR/1e6, 20*np.log10(np.abs(LNAkR02)), 'b--')
	plt.plot(frkR/1e6, 20*np.log10(np.abs(LNAkR03)), 'b:')
	plt.plot(frkR/1e6, 20*np.log10(np.abs(LNAkR04)), 'g')
	plt.plot(frkR/1e6, 20*np.log10(np.abs(LNAkR05)), 'g--')
	plt.plot(frkR/1e6, 20*np.log10(np.abs(LNAkR06)), 'g:')
	plt.plot(frkR/1e6, 20*np.log10(np.abs(LNAkR07)), 'r')
	plt.plot(frkR/1e6, 20*np.log10(np.abs(LNAkR08)), 'r--')
	plt.plot(frkR/1e6, 20*np.log10(np.abs(LNAkR09)), 'r:')
	plt.plot(frkR/1e6, 20*np.log10(np.abs(LNAkR10)), 'c')
	plt.ylabel('magnitude [dB]')
	plt.xlim([50, 100])
	plt.ylim([-38, -28])
	plt.grid()


	plt.subplot(2,2,3)
	plt.plot(frkR/1e6, 20*np.log10(np.abs(LNAkR01)) - 20*np.log10(np.abs(LNAkR01)), 'b')
	plt.plot(frkR/1e6, 20*np.log10(np.abs(LNAkR02)) - 20*np.log10(np.abs(LNAkR01)), 'b--')
	plt.plot(frkR/1e6, 20*np.log10(np.abs(LNAkR03)) - 20*np.log10(np.abs(LNAkR01)), 'b:')
	plt.plot(frkR/1e6, 20*np.log10(np.abs(LNAkR04)) - 20*np.log10(np.abs(LNAkR01)), 'g')
	plt.plot(frkR/1e6, 20*np.log10(np.abs(LNAkR05)) - 20*np.log10(np.abs(LNAkR01)), 'g--')
	plt.plot(frkR/1e6, 20*np.log10(np.abs(LNAkR06)) - 20*np.log10(np.abs(LNAkR01)), 'g:')
	plt.plot(frkR/1e6, 20*np.log10(np.abs(LNAkR07)) - 20*np.log10(np.abs(LNAkR01)), 'r')
	plt.plot(frkR/1e6, 20*np.log10(np.abs(LNAkR08)) - 20*np.log10(np.abs(LNAkR01)), 'r--')
	plt.plot(frkR/1e6, 20*np.log10(np.abs(LNAkR09)) - 20*np.log10(np.abs(LNAkR01)), 'r:')
	plt.plot(frkR/1e6, 20*np.log10(np.abs(LNAkR10)) - 20*np.log10(np.abs(LNAkR01)), 'c')	
	plt.ylim([-0.01, 0.1])
	plt.ylabel(r'$\Delta$ magnitude [dB]')
	plt.xlabel('frequency [MHz]')


	plt.subplot(2,2,2)
	plt.plot(d15C[:,0], (180/np.pi)*np.unwrap(np.angle(d15C[:,1]+1j*d15C[:,2])), 'k', linewidth=2)
	plt.plot(frkR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAkR01)), 'b')
	plt.plot(frkR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAkR02)), 'b--')
	plt.plot(frkR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAkR03)), 'b:')
	plt.plot(frkR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAkR04)), 'g')
	plt.plot(frkR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAkR05)), 'g--')
	plt.plot(frkR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAkR06)), 'g:')
	plt.plot(frkR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAkR07)), 'r')
	plt.plot(frkR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAkR08)), 'r--')
	plt.plot(frkR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAkR09)), 'r:')
	plt.plot(frkR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAkR10)), 'c')
	plt.ylabel('phase [deg]')
	plt.xlim([50, 100])
	plt.ylim([15, 60])	
	plt.grid()
	plt.legend(['Nov 2016'+'\n'+'-35dBm', 'SET1:  1', 'SET1:  2', 'SET1:  3', 'SET1:  4', 'SET1:  5', 'SET1:  6', 'SET1:  7', 'SET1:  8', 'SET1:  9', 'SET1:  10'], loc=0, fontsize=9)

	plt.subplot(2,2,4)
	plt.plot(frkR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAkR01)) - (180/np.pi)*np.unwrap(np.angle(LNAkR01)), 'b')
	plt.plot(frkR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAkR02)) - (180/np.pi)*np.unwrap(np.angle(LNAkR01)), 'b--')
	plt.plot(frkR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAkR03)) - (180/np.pi)*np.unwrap(np.angle(LNAkR01)), 'b:')
	plt.plot(frkR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAkR04)) - (180/np.pi)*np.unwrap(np.angle(LNAkR01)), 'g')
	plt.plot(frkR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAkR05)) - (180/np.pi)*np.unwrap(np.angle(LNAkR01)), 'g--')
	plt.plot(frkR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAkR06)) - (180/np.pi)*np.unwrap(np.angle(LNAkR01)), 'g:')
	plt.plot(frkR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAkR07)) - (180/np.pi)*np.unwrap(np.angle(LNAkR01)), 'r')
	plt.plot(frkR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAkR08)) - (180/np.pi)*np.unwrap(np.angle(LNAkR01)), 'r--')
	plt.plot(frkR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAkR09)) - (180/np.pi)*np.unwrap(np.angle(LNAkR01)), 'r:')
	plt.plot(frkR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAkR10)) - (180/np.pi)*np.unwrap(np.angle(LNAkR01)), 'c')
	plt.ylim([-0.1, 1])
	plt.xlabel('frequency [MHz]')
	plt.ylabel(r'$\Delta$ phase [deg]')

	plt.legend(['SET1: 1-1', 'SET1: 2-1', 'SET1: 3-1', 'SET1: 4-1', 'SET1: 5-1', 'SET1: 6-1', 'SET1: 7-1', 'SET1: 8-1', 'SET1: 9-1', 'SET1: 10-1'], loc=0, fontsize=9)


	# Save plot
	path_plot_save = home_folder + '/DATA/EDGES/results/plots/20170303/'
	plt.savefig(path_plot_save + 'low_band_s11_repeatability4.pdf', bbox_inches='tight')
	plt.close()
	plt.close()










	# Measurements at 35degC
	# -----------------------
	plt.figure(5, figsize=[12,10])
	plt.subplot(2,2,1)
	plt.plot(d35C[:,0], 20*np.log10(np.abs(d35C[:,1]+1j*d35C[:,2])), 'k', linewidth=2)
	plt.plot(frjR/1e6, 20*np.log10(np.abs(LNAjR01)), 'b')
	plt.plot(frjR/1e6, 20*np.log10(np.abs(LNAjR02)), 'b--')
	plt.plot(frjR/1e6, 20*np.log10(np.abs(LNAjR03)), 'b:')
	plt.plot(frjR/1e6, 20*np.log10(np.abs(LNAjR04)), 'g')
	plt.plot(frjR/1e6, 20*np.log10(np.abs(LNAjR05)), 'g--')
	plt.plot(frjR/1e6, 20*np.log10(np.abs(LNAjR06)), 'g:')
	plt.plot(frjR/1e6, 20*np.log10(np.abs(LNAjR07)), 'r')
	plt.plot(frjR/1e6, 20*np.log10(np.abs(LNAjR08)), 'r--')
	plt.plot(frjR/1e6, 20*np.log10(np.abs(LNAjR09)), 'r:')
	plt.plot(frjR/1e6, 20*np.log10(np.abs(LNAjR10)), 'c')
	plt.ylabel('magnitude [dB]')
	plt.xlim([50, 100])
	plt.ylim([-38, -28])
	plt.grid()


	plt.subplot(2,2,3)
	plt.plot(frjR/1e6, 20*np.log10(np.abs(LNAjR01)) - 20*np.log10(np.abs(LNAjR01)), 'b')
	plt.plot(frjR/1e6, 20*np.log10(np.abs(LNAjR02)) - 20*np.log10(np.abs(LNAjR01)), 'b--')
	plt.plot(frjR/1e6, 20*np.log10(np.abs(LNAjR03)) - 20*np.log10(np.abs(LNAjR01)), 'b:')
	plt.plot(frjR/1e6, 20*np.log10(np.abs(LNAjR04)) - 20*np.log10(np.abs(LNAjR01)), 'g')
	plt.plot(frjR/1e6, 20*np.log10(np.abs(LNAjR05)) - 20*np.log10(np.abs(LNAjR01)), 'g--')
	plt.plot(frjR/1e6, 20*np.log10(np.abs(LNAjR06)) - 20*np.log10(np.abs(LNAjR01)), 'g:')
	plt.plot(frjR/1e6, 20*np.log10(np.abs(LNAjR07)) - 20*np.log10(np.abs(LNAjR01)), 'r')
	plt.plot(frjR/1e6, 20*np.log10(np.abs(LNAjR08)) - 20*np.log10(np.abs(LNAjR01)), 'r--')
	plt.plot(frjR/1e6, 20*np.log10(np.abs(LNAjR09)) - 20*np.log10(np.abs(LNAjR01)), 'r:')
	plt.plot(frjR/1e6, 20*np.log10(np.abs(LNAjR10)) - 20*np.log10(np.abs(LNAjR01)), 'c')	
	plt.ylim([-0.01, 0.1])
	plt.ylabel(r'$\Delta$ magnitude [dB]')
	plt.xlabel('frequency [MHz]')


	plt.subplot(2,2,2)
	plt.plot(d35C[:,0], (180/np.pi)*np.unwrap(np.angle(d35C[:,1]+1j*d35C[:,2])), 'k', linewidth=2)
	plt.plot(frjR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAjR01)), 'b')
	plt.plot(frjR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAjR02)), 'b--')
	plt.plot(frjR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAjR03)), 'b:')
	plt.plot(frjR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAjR04)), 'g')
	plt.plot(frjR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAjR05)), 'g--')
	plt.plot(frjR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAjR06)), 'g:')
	plt.plot(frjR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAjR07)), 'r')
	plt.plot(frjR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAjR08)), 'r--')
	plt.plot(frjR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAjR09)), 'r:')
	plt.plot(frjR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAjR10)), 'c')
	plt.ylabel('phase [deg]')
	plt.xlim([50, 100])
	plt.ylim([15, 60])	
	plt.grid()
	plt.legend(['Nov 2016'+'\n'+'-35dBm', 'SET1:  1', 'SET1:  2', 'SET1:  3', 'SET1:  4', 'SET1:  5', 'SET1:  6', 'SET1:  7', 'SET1:  8', 'SET1:  9', 'SET1:  10'], loc=0, fontsize=9)

	plt.subplot(2,2,4)
	plt.plot(frjR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAjR01)) - (180/np.pi)*np.unwrap(np.angle(LNAjR01)), 'b')
	plt.plot(frjR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAjR02)) - (180/np.pi)*np.unwrap(np.angle(LNAjR01)), 'b--')
	plt.plot(frjR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAjR03)) - (180/np.pi)*np.unwrap(np.angle(LNAjR01)), 'b:')
	plt.plot(frjR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAjR04)) - (180/np.pi)*np.unwrap(np.angle(LNAjR01)), 'g')
	plt.plot(frjR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAjR05)) - (180/np.pi)*np.unwrap(np.angle(LNAjR01)), 'g--')
	plt.plot(frjR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAjR06)) - (180/np.pi)*np.unwrap(np.angle(LNAjR01)), 'g:')
	plt.plot(frjR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAjR07)) - (180/np.pi)*np.unwrap(np.angle(LNAjR01)), 'r')
	plt.plot(frjR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAjR08)) - (180/np.pi)*np.unwrap(np.angle(LNAjR01)), 'r--')
	plt.plot(frjR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAjR09)) - (180/np.pi)*np.unwrap(np.angle(LNAjR01)), 'r:')
	plt.plot(frjR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAjR10)) - (180/np.pi)*np.unwrap(np.angle(LNAjR01)), 'c')
	plt.ylim([-0.1, 1])
	plt.xlabel('frequency [MHz]')
	plt.ylabel(r'$\Delta$ phase [deg]')

	plt.legend(['SET1: 1-1', 'SET1: 2-1', 'SET1: 3-1', 'SET1: 4-1', 'SET1: 5-1', 'SET1: 6-1', 'SET1: 7-1', 'SET1: 8-1', 'SET1: 9-1', 'SET1: 10-1'], loc=0, fontsize=9)



	# Save plot
	path_plot_save = home_folder + '/DATA/EDGES/results/plots/20170303/'
	plt.savefig(path_plot_save + 'low_band_s11_repeatability5.pdf', bbox_inches='tight')
	plt.close()
	plt.close()













	# Deltas
	# ---------------------------
	plt.figure(6, figsize=[20,10])

	plt.subplot(2,3,1)
	plt.plot(fryR/1e6,  20*np.log10(np.abs(LNAxR01)) - 20*np.log10(np.abs(d25C[:,1]+1j*d25C[:,2])), 'b')
	plt.plot(fryR/1e6,  20*np.log10(np.abs(LNAyR01)) - 20*np.log10(np.abs(d25C[:,1]+1j*d25C[:,2])), 'b--')
	plt.plot(fryR/1e6,  20*np.log10(np.abs(LNAzR01)) - 20*np.log10(np.abs(d25C[:,1]+1j*d25C[:,2])), 'b:')
	plt.ylim([-0.5, 0])
	plt.ylabel(r'$\Delta$ magnitude [dB]')
	plt.grid()
	plt.title('(Feb 2017, 25degC, -30dBm) - (Sept 2016, 25degC, -35dBm)', fontsize=11)

	plt.subplot(2,3,4)
	plt.plot(fryR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAxR01)) - (180/np.pi)*np.unwrap(np.angle(d25C[:,1]+1j*d25C[:,2])), 'b')
	plt.plot(fryR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAyR01)) - (180/np.pi)*np.unwrap(np.angle(d25C[:,1]+1j*d25C[:,2])), 'b--')
	plt.plot(fryR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAzR01)) - (180/np.pi)*np.unwrap(np.angle(d25C[:,1]+1j*d25C[:,2])), 'b:')
	plt.ylim([-3, 0])
	plt.ylabel(r'$\Delta$ phase [deg]')
	plt.xlabel('frequency [MHz]')
	plt.grid()



	plt.subplot(2,3,2)
	plt.plot(fryR/1e6, 20*np.log10(np.abs(LNAkR01)) - 20*np.log10(np.abs(d15C[:,1]+1j*d15C[:,2])), 'r')
	plt.ylim([-0.5, 0])
	#plt.ylabel(r'$\Delta$ magnitude [dB]')
	plt.grid()
	plt.title('(Feb 2017, 15degC, -30dBm) - (Nov 2016, 15degC, -35dBm)', fontsize=11)

	plt.subplot(2,3,5)
	plt.plot(fryR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAkR01)) - (180/np.pi)*np.unwrap(np.angle(d15C[:,1]+1j*d15C[:,2])), 'r')
	plt.ylim([-3, 0])
	#plt.ylabel(r'$\Delta$ phase [deg]')
	plt.xlabel('frequency [MHz]')
	plt.grid()



	plt.subplot(2,3,3)
	plt.plot(fryR/1e6, 20*np.log10(np.abs(LNAjR01)) - 20*np.log10(np.abs(d35C[:,1]+1j*d35C[:,2])), 'r')
	plt.ylim([-0.5, 0])
	#plt.ylabel(r'$\Delta$ magnitude [dB]')
	plt.grid()
	plt.title('(Feb 2017, 35degC, -30dBm) - (Nov 2016, 35degC, -35dBm)', fontsize=11)

	plt.subplot(2,3,6)
	plt.plot(fryR/1e6, (180/np.pi)*np.unwrap(np.angle(LNAjR01)) - (180/np.pi)*np.unwrap(np.angle(d35C[:,1]+1j*d35C[:,2])), 'r')
	plt.ylim([-3, 0])
	#plt.ylabel(r'$\Delta$ phase [deg]')
	plt.xlabel('frequency [MHz]')
	plt.grid()





	# Save plot
	# ---------------------------
	path_plot_save = home_folder + '/DATA/EDGES/results/plots/20170303/'
	plt.savefig(path_plot_save + 'low_band_s11_repeatability6.pdf', bbox_inches='tight')
	plt.close()
	plt.close()










	return 0







































































def s11_accuracy_test_at_minus30dBm_with_attenuators():


	data_path = '/DATA/EDGES/calibration/receiver_calibration/low_band2/2016_09_25C/data/s11/raw/Attenuators/'


	# S-parameters of attenuators

	# At VNA

	## Attenuator Set1, -30 dBm, VNA before restarting
	#os1p30v1, fs = rc.s1p_read(home_folder + data_path + '30dBm_set1/Open.s1p')
	#ss1p30v1, fs = rc.s1p_read(home_folder + data_path + '30dBm_set1/Short.s1p')
	#ms1p30v1, fs = rc.s1p_read(home_folder + data_path + '30dBm_set1/Match.s1p')

	#a3s1p30v1r1, fs = rc.s1p_read(home_folder + data_path + '30dBm_set1/3dB_1st.s1p')
	#a3s1p30v1r2, fs = rc.s1p_read(home_folder + data_path + '30dBm_set1/3dB_2nd.s1p')
	#a3s1p30v1r3, fs = rc.s1p_read(home_folder + data_path + '30dBm_set1/3dB_3rd.s1p')

	#a6s1p30v1r1, fs = rc.s1p_read(home_folder + data_path + '30dBm_set1/6dB_1st.s1p')
	#a6s1p30v1r2, fs = rc.s1p_read(home_folder + data_path + '30dBm_set1/6dB_2nd.s1p')
	#a6s1p30v1r3, fs = rc.s1p_read(home_folder + data_path + '30dBm_set1/6dB_3rd.s1p')

	#a10s1p30v1r1, fs = rc.s1p_read(home_folder + data_path + '30dBm_set1/10dB_1st.s1p')
	#a10s1p30v1r2, fs = rc.s1p_read(home_folder + data_path + '30dBm_set1/10dB_2nd.s1p')
	#a10s1p30v1r3, fs = rc.s1p_read(home_folder + data_path + '30dBm_set1/10dB_3rd.s1p')

	#a15s1p30v1r1, fs = rc.s1p_read(home_folder + data_path + '30dBm_set1/15dB_1st.s1p')
	#a15s1p30v1r2, fs = rc.s1p_read(home_folder + data_path + '30dBm_set1/15dB_2nd.s1p')
	#a15s1p30v1r3, fs = rc.s1p_read(home_folder + data_path + '30dBm_set1/15dB_3rd.s1p')









	# 0 dBm, VNA restarting
	op0, fs = rc.s1p_read(home_folder + data_path + '0dBm/Open.s1p')
	sp0, fs = rc.s1p_read(home_folder + data_path + '0dBm/Short.s1p')
	mp0, fs = rc.s1p_read(home_folder + data_path + '0dBm/Match.s1p')

	a3s1p0r1, fs = rc.s1p_read(home_folder + data_path + '0dBm/3dB_1st.s1p')
	a3s1p0r2, fs = rc.s1p_read(home_folder + data_path + '0dBm/3dB_2nd.s1p')

	a6s1p0r1, fs = rc.s1p_read(home_folder + data_path + '0dBm/6dB_1st.s1p')
	a6s1p0r2, fs = rc.s1p_read(home_folder + data_path + '0dBm/6dB_2nd.s1p')

	a10s1p0r1, fs = rc.s1p_read(home_folder + data_path + '0dBm/10dB_1st.s1p')
	a10s1p0r2, fs = rc.s1p_read(home_folder + data_path + '0dBm/10dB_2nd.s1p')

	a15s1p0r1, fs = rc.s1p_read(home_folder + data_path + '0dBm/15dB_1st.s1p')
	a15s1p0r2, fs = rc.s1p_read(home_folder + data_path + '0dBm/15dB_2nd.s1p')

	a3s2p0r1, fs = rc.s1p_read(home_folder + data_path + '0dBm/3dB_copy_1st.s1p')
	a3s2p0r2, fs = rc.s1p_read(home_folder + data_path + '0dBm/3dB_copy_2nd.s1p')

	a6s2p0r1, fs = rc.s1p_read(home_folder + data_path + '0dBm/6dB_copy_1st.s1p')
	a6s2p0r2, fs = rc.s1p_read(home_folder + data_path + '0dBm/6dB_copy_2nd.s1p')

	a10s2p0r1, fs = rc.s1p_read(home_folder + data_path + '0dBm/10dB_copy_1st.s1p')
	a10s2p0r2, fs = rc.s1p_read(home_folder + data_path + '0dBm/10dB_copy_2nd.s1p')

	a15s2p0r1, fs = rc.s1p_read(home_folder + data_path + '0dBm/15dB_copy_1st.s1p')
	a15s2p0r2, fs = rc.s1p_read(home_folder + data_path + '0dBm/15dB_copy_2nd.s1p')





	# -30 dBm, VNA before restarting
	op30v1, fs = rc.s1p_read(home_folder + data_path + '30dBm_set2/Open.s1p')
	sp30v1, fs = rc.s1p_read(home_folder + data_path + '30dBm_set2/Short.s1p')
	mp30v1, fs = rc.s1p_read(home_folder + data_path + '30dBm_set2/Match.s1p')

	a3s1p30v1r1, fs = rc.s1p_read(home_folder + data_path + '30dBm_set2/3dB_1st.s1p')
	a3s1p30v1r2, fs = rc.s1p_read(home_folder + data_path + '30dBm_set2/3dB_2nd.s1p')

	a6s1p30v1r1, fs = rc.s1p_read(home_folder + data_path + '30dBm_set2/6dB_1st.s1p')
	a6s1p30v1r2, fs = rc.s1p_read(home_folder + data_path + '30dBm_set2/6dB_2nd.s1p')

	a10s1p30v1r1, fs = rc.s1p_read(home_folder + data_path + '30dBm_set2/10dB_1st.s1p')
	a10s1p30v1r2, fs = rc.s1p_read(home_folder + data_path + '30dBm_set2/10dB_2nd.s1p')

	a15s1p30v1r1, fs = rc.s1p_read(home_folder + data_path + '30dBm_set2/15dB_1st.s1p')
	a15s1p30v1r2, fs = rc.s1p_read(home_folder + data_path + '30dBm_set2/15dB_2nd.s1p')


	a3s2p30v1r1, fs = rc.s1p_read(home_folder + data_path + '30dBm_set2/3dB_copy_1st.s1p')
	a3s2p30v1r2, fs = rc.s1p_read(home_folder + data_path + '30dBm_set2/3dB_copy_2nd.s1p')

	a6s2p30v1r1, fs = rc.s1p_read(home_folder + data_path + '30dBm_set2/6dB_copy_1st.s1p')
	a6s2p30v1r2, fs = rc.s1p_read(home_folder + data_path + '30dBm_set2/6dB_copy_2nd.s1p')

	a10s2p30v1r1, fs = rc.s1p_read(home_folder + data_path + '30dBm_set2/10dB_copy_1st.s1p')
	a10s2p30v1r2, fs = rc.s1p_read(home_folder + data_path + '30dBm_set2/10dB_copy_2nd.s1p')

	a15s2p30v1r1, fs = rc.s1p_read(home_folder + data_path + '30dBm_set2/15dB_copy_1st.s1p')
	a15s2p30v1r2, fs = rc.s1p_read(home_folder + data_path + '30dBm_set2/15dB_copy_2nd.s1p')





	# -30 dBm, VNA after restarting
	op30v2, fs = rc.s1p_read(home_folder + data_path + '30dBm_restart/Open.s1p')
	sp30v2, fs = rc.s1p_read(home_folder + data_path + '30dBm_restart/Short.s1p')
	mp30v2, fs = rc.s1p_read(home_folder + data_path + '30dBm_restart/Match.s1p')

	a3s1p30v2r1, fs = rc.s1p_read(home_folder + data_path + '30dBm_restart/3dB_1st.s1p')
	a3s1p30v2r2, fs = rc.s1p_read(home_folder + data_path + '30dBm_restart/3dB_2nd.s1p')

	a6s1p30v2r1, fs = rc.s1p_read(home_folder + data_path + '30dBm_restart/6dB_1st.s1p')
	a6s1p30v2r2, fs = rc.s1p_read(home_folder + data_path + '30dBm_restart/6dB_2nd.s1p')

	a10s1p30v2r1, fs = rc.s1p_read(home_folder + data_path + '30dBm_restart/10dB_1st.s1p')
	a10s1p30v2r2, fs = rc.s1p_read(home_folder + data_path + '30dBm_restart/10dB_2nd.s1p')

	a15s1p30v2r1, fs = rc.s1p_read(home_folder + data_path + '30dBm_restart/15dB_1st.s1p')
	a15s1p30v2r2, fs = rc.s1p_read(home_folder + data_path + '30dBm_restart/15dB_2nd.s1p')


	a3s2p30v2r1, fs = rc.s1p_read(home_folder + data_path + '30dBm_restart/3dB_copy_1st.s1p')
	a3s2p30v2r2, fs = rc.s1p_read(home_folder + data_path + '30dBm_restart/3dB_copy_2nd.s1p')

	a6s2p30v2r1, fs = rc.s1p_read(home_folder + data_path + '30dBm_restart/6dB_copy_1st.s1p')
	a6s2p30v2r2, fs = rc.s1p_read(home_folder + data_path + '30dBm_restart/6dB_copy_2nd.s1p')

	a10s2p30v2r1, fs = rc.s1p_read(home_folder + data_path + '30dBm_restart/10dB_copy_1st.s1p')
	a10s2p30v2r2, fs = rc.s1p_read(home_folder + data_path + '30dBm_restart/10dB_copy_2nd.s1p')

	a15s2p30v2r1, fs = rc.s1p_read(home_folder + data_path + '30dBm_restart/15dB_copy_1st.s1p')
	a15s2p30v2r2, fs = rc.s1p_read(home_folder + data_path + '30dBm_restart/15dB_copy_2nd.s1p')













	# Models of standards
	resistance_of_match  = 50.11 # male
	resistance_of_match1 = 50.10
	resistance_of_match2 = 50.12
	oa, sa, ma           = rc.agilent_85033E(fs, resistance_of_match)
	oa, sa, ma1          = rc.agilent_85033E(fs, resistance_of_match1)
	oa, sa, ma2          = rc.agilent_85033E(fs, resistance_of_match2)



	# 0 dBm Set1
	a3s1p0r1c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op0, sp0, mp0, a3s1p0r1)
	a3s1p0r2c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op0, sp0, mp0, a3s1p0r2)

	a6s1p0r1c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op0, sp0, mp0, a6s1p0r1)
	a6s1p0r2c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op0, sp0, mp0, a6s1p0r2)

	a10s1p0r1c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op0, sp0, mp0, a10s1p0r1)
	a10s1p0r2c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op0, sp0, mp0, a10s1p0r2)	

	a15s1p0r1c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op0, sp0, mp0, a15s1p0r1)
	a15s1p0r2c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op0, sp0, mp0, a15s1p0r2)

	# uncertainties
	a3s1p0r1c1, x1, x2, x3  = rc.de_embed(oa, sa, ma1, op0, sp0, mp0, a3s1p0r1)
	a3s1p0r1c2, x1, x2, x3  = rc.de_embed(oa, sa, ma2, op0, sp0, mp0, a3s1p0r1)

	a6s1p0r1c1, x1, x2, x3  = rc.de_embed(oa, sa, ma1, op0, sp0, mp0, a6s1p0r1)
	a6s1p0r1c2, x1, x2, x3  = rc.de_embed(oa, sa, ma2, op0, sp0, mp0, a6s1p0r1)

	a10s1p0r1c1, x1, x2, x3  = rc.de_embed(oa, sa, ma1, op0, sp0, mp0, a10s1p0r1)
	a10s1p0r1c2, x1, x2, x3  = rc.de_embed(oa, sa, ma2, op0, sp0, mp0, a10s1p0r1)

	a15s1p0r1c1, x1, x2, x3  = rc.de_embed(oa, sa, ma1, op0, sp0, mp0, a15s1p0r1)
	a15s1p0r1c2, x1, x2, x3  = rc.de_embed(oa, sa, ma2, op0, sp0, mp0, a15s1p0r1)



	# 0 dBm Set2
	a3s2p0r1c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op0, sp0, mp0, a3s2p0r1)
	a3s2p0r2c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op0, sp0, mp0, a3s2p0r2)

	a6s2p0r1c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op0, sp0, mp0, a6s2p0r1)
	a6s2p0r2c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op0, sp0, mp0, a6s2p0r2)

	a10s2p0r1c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op0, sp0, mp0, a10s2p0r1)
	a10s2p0r2c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op0, sp0, mp0, a10s2p0r2)	

	a15s2p0r1c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op0, sp0, mp0, a15s2p0r1)
	a15s2p0r2c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op0, sp0, mp0, a15s2p0r2)

	# uncertainties
	a3s2p0r1c1, x1, x2, x3  = rc.de_embed(oa, sa, ma1, op0, sp0, mp0, a3s2p0r1)
	a3s2p0r1c2, x1, x2, x3  = rc.de_embed(oa, sa, ma2, op0, sp0, mp0, a3s2p0r1)

	a6s2p0r1c1, x1, x2, x3  = rc.de_embed(oa, sa, ma1, op0, sp0, mp0, a6s2p0r1)
	a6s2p0r1c2, x1, x2, x3  = rc.de_embed(oa, sa, ma2, op0, sp0, mp0, a6s2p0r1)

	a10s2p0r1c1, x1, x2, x3  = rc.de_embed(oa, sa, ma1, op0, sp0, mp0, a10s2p0r1)
	a10s2p0r1c2, x1, x2, x3  = rc.de_embed(oa, sa, ma2, op0, sp0, mp0, a10s2p0r1)

	a15s2p0r1c1, x1, x2, x3  = rc.de_embed(oa, sa, ma1, op0, sp0, mp0, a15s2p0r1)
	a15s2p0r1c2, x1, x2, x3  = rc.de_embed(oa, sa, ma2, op0, sp0, mp0, a15s2p0r1)	










	# -30 dBm Set1
	a3s1p30v1r1c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v1, sp30v1, mp30v1, a3s1p30v1r1)
	a3s1p30v1r2c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v1, sp30v1, mp30v1, a3s1p30v1r2)

	a6s1p30v1r1c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v1, sp30v1, mp30v1, a6s1p30v1r1)
	a6s1p30v1r2c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v1, sp30v1, mp30v1, a6s1p30v1r2)

	a10s1p30v1r1c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v1, sp30v1, mp30v1, a10s1p30v1r1)
	a10s1p30v1r2c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v1, sp30v1, mp30v1, a10s1p30v1r2)	

	a15s1p30v1r1c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v1, sp30v1, mp30v1, a15s1p30v1r1)
	a15s1p30v1r2c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v1, sp30v1, mp30v1, a15s1p30v1r2)

	# uncertainties
	a3s1p30v1r1c1, x1, x2, x3  = rc.de_embed(oa, sa, ma1, op30v1, sp30v1, mp30v1, a3s1p30v1r1)
	a3s1p30v1r1c2, x1, x2, x3  = rc.de_embed(oa, sa, ma2, op30v1, sp30v1, mp30v1, a3s1p30v1r1)

	a6s1p30v1r1c1, x1, x2, x3  = rc.de_embed(oa, sa, ma1, op30v1, sp30v1, mp30v1, a6s1p30v1r1)
	a6s1p30v1r1c2, x1, x2, x3  = rc.de_embed(oa, sa, ma2, op30v1, sp30v1, mp30v1, a6s1p30v1r1)

	a10s1p30v1r1c1, x1, x2, x3  = rc.de_embed(oa, sa, ma1, op30v1, sp30v1, mp30v1, a10s1p30v1r1)
	a10s1p30v1r1c2, x1, x2, x3  = rc.de_embed(oa, sa, ma2, op30v1, sp30v1, mp30v1, a10s1p30v1r1)

	a15s1p30v1r1c1, x1, x2, x3  = rc.de_embed(oa, sa, ma1, op30v1, sp30v1, mp30v1, a15s1p30v1r1)
	a15s1p30v1r1c2, x1, x2, x3  = rc.de_embed(oa, sa, ma2, op30v1, sp30v1, mp30v1, a15s1p30v1r1)	




	# -30 dBm Set2
	a3s2p30v1r1c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v1, sp30v1, mp30v1, a3s2p30v1r1)
	a3s2p30v1r2c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v1, sp30v1, mp30v1, a3s2p30v1r2)

	a6s2p30v1r1c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v1, sp30v1, mp30v1, a6s2p30v1r1)
	a6s2p30v1r2c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v1, sp30v1, mp30v1, a6s2p30v1r2)

	a10s2p30v1r1c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v1, sp30v1, mp30v1, a10s2p30v1r1)
	a10s2p30v1r2c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v1, sp30v1, mp30v1, a10s2p30v1r2)	

	a15s2p30v1r1c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v1, sp30v1, mp30v1, a15s2p30v1r1)
	a15s2p30v1r2c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v1, sp30v1, mp30v1, a15s2p30v1r2)		

	# uncertainties
	a3s2p30v1r1c1, x1, x2, x3  = rc.de_embed(oa, sa, ma1, op30v1, sp30v1, mp30v1, a3s2p30v1r1)
	a3s2p30v1r1c2, x1, x2, x3  = rc.de_embed(oa, sa, ma2, op30v1, sp30v1, mp30v1, a3s2p30v1r1)

	a6s2p30v1r1c1, x1, x2, x3  = rc.de_embed(oa, sa, ma1, op30v1, sp30v1, mp30v1, a6s2p30v1r1)
	a6s2p30v1r1c2, x1, x2, x3  = rc.de_embed(oa, sa, ma2, op30v1, sp30v1, mp30v1, a6s2p30v1r1)

	a10s2p30v1r1c1, x1, x2, x3  = rc.de_embed(oa, sa, ma1, op30v1, sp30v1, mp30v1, a10s2p30v1r1)
	a10s2p30v1r1c2, x1, x2, x3  = rc.de_embed(oa, sa, ma2, op30v1, sp30v1, mp30v1, a10s2p30v1r1)

	a15s2p30v1r1c1, x1, x2, x3  = rc.de_embed(oa, sa, ma1, op30v1, sp30v1, mp30v1, a15s2p30v1r1)
	a15s2p30v1r1c2, x1, x2, x3  = rc.de_embed(oa, sa, ma2, op30v1, sp30v1, mp30v1, a15s2p30v1r1)	








	# -30 dBm, after restart, Set1
	a3s1p30v2r1c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v2, sp30v2, mp30v2, a3s1p30v2r1)
	a3s1p30v2r2c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v2, sp30v2, mp30v2, a3s1p30v2r2)

	a6s1p30v2r1c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v2, sp30v2, mp30v2, a6s1p30v2r1)
	a6s1p30v2r2c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v2, sp30v2, mp30v2, a6s1p30v2r2)

	a10s1p30v2r1c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v2, sp30v2, mp30v2, a10s1p30v2r1)
	a10s1p30v2r2c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v2, sp30v2, mp30v2, a10s1p30v2r2)	

	a15s1p30v2r1c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v2, sp30v2, mp30v2, a15s1p30v2r1)
	a15s1p30v2r2c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v2, sp30v2, mp30v2, a15s1p30v2r2)

	# uncertainties
	a3s1p30v2r1c1, x1, x2, x3  = rc.de_embed(oa, sa, ma1, op30v2, sp30v2, mp30v2, a3s1p30v2r1)
	a3s1p30v2r1c2, x1, x2, x3  = rc.de_embed(oa, sa, ma2, op30v2, sp30v2, mp30v2, a3s1p30v2r1)

	a6s1p30v2r1c1, x1, x2, x3  = rc.de_embed(oa, sa, ma1, op30v2, sp30v2, mp30v2, a6s1p30v2r1)
	a6s1p30v2r1c2, x1, x2, x3  = rc.de_embed(oa, sa, ma2, op30v2, sp30v2, mp30v2, a6s1p30v2r1)

	a10s1p30v2r1c1, x1, x2, x3  = rc.de_embed(oa, sa, ma1, op30v2, sp30v2, mp30v2, a10s1p30v2r1)
	a10s1p30v2r1c2, x1, x2, x3  = rc.de_embed(oa, sa, ma2, op30v2, sp30v2, mp30v2, a10s1p30v2r1)

	a15s1p30v2r1c1, x1, x2, x3  = rc.de_embed(oa, sa, ma1, op30v2, sp30v2, mp30v2, a15s1p30v2r1)
	a15s1p30v2r1c2, x1, x2, x3  = rc.de_embed(oa, sa, ma2, op30v2, sp30v2, mp30v2, a15s1p30v2r1)



	# -30 dBm, after restart, Set2
	a3s2p30v2r1c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v2, sp30v2, mp30v2, a3s2p30v2r1)
	a3s2p30v2r2c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v2, sp30v2, mp30v2, a3s2p30v2r2)

	a6s2p30v2r1c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v2, sp30v2, mp30v2, a6s2p30v2r1)
	a6s2p30v2r2c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v2, sp30v2, mp30v2, a6s2p30v2r2)

	a10s2p30v2r1c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v2, sp30v2, mp30v2, a10s2p30v2r1)
	a10s2p30v2r2c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v2, sp30v2, mp30v2, a10s2p30v2r2)	

	a15s2p30v2r1c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v2, sp30v2, mp30v2, a15s2p30v2r1)
	a15s2p30v2r2c, x1, x2, x3  = rc.de_embed(oa, sa, ma, op30v2, sp30v2, mp30v2, a15s2p30v2r2)	

	# uncertainties
	a3s2p30v2r1c1, x1, x2, x3  = rc.de_embed(oa, sa, ma1, op30v2, sp30v2, mp30v2, a3s2p30v2r1)
	a3s2p30v2r1c2, x1, x2, x3  = rc.de_embed(oa, sa, ma2, op30v2, sp30v2, mp30v2, a3s2p30v2r1)

	a6s2p30v2r1c1, x1, x2, x3  = rc.de_embed(oa, sa, ma1, op30v2, sp30v2, mp30v2, a6s2p30v2r1)
	a6s2p30v2r1c2, x1, x2, x3  = rc.de_embed(oa, sa, ma2, op30v2, sp30v2, mp30v2, a6s2p30v2r1)

	a10s2p30v2r1c1, x1, x2, x3  = rc.de_embed(oa, sa, ma1, op30v2, sp30v2, mp30v2, a10s2p30v2r1)
	a10s2p30v2r1c2, x1, x2, x3  = rc.de_embed(oa, sa, ma2, op30v2, sp30v2, mp30v2, a10s2p30v2r1)

	a15s2p30v2r1c1, x1, x2, x3  = rc.de_embed(oa, sa, ma1, op30v2, sp30v2, mp30v2, a15s2p30v2r1)
	a15s2p30v2r1c2, x1, x2, x3  = rc.de_embed(oa, sa, ma2, op30v2, sp30v2, mp30v2, a15s2p30v2r1)	









	# DC resistances
	DC3  = 160.758
	DC6  = 85.86
	DC10 = 60.7333
	DC15 = 53.3140

	DC3c  = 161.67
	DC6c  = 85.395
	DC10c = 60.697
	DC15c = 53.236



	# Magnitude -----------------------
	# -----------------------------------------------------------------------------------------------------

	plt.close()
	plt.close()
	plt.close()
	plt.close()
	plt.close()



	plt.figure(1, figsize=[12,14])
	plt.subplot(4,2,1)
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3,50)))*np.ones(len(fs)), 'r', linewidth=2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(a3s1p0r1c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a3s1p0r2c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a3s1p0r1c1)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(a3s1p0r1c2)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3,50)))*np.ones(len(fs)), 'r', linewidth=2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3+0.01,50)))*np.ones(len(fs)), 'r--')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	plt.ylim([-5.594, -5.586])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)
	plt.ylabel('3-dB attn'+'\n'+'magnitude [dB]')
	#plt.legend(['from DC resistance'+'\n'+'(+/- 0.01 ohm error in attn)','rep1'+'\n'+'(+/- 0.01 ohm error in calibration match)','rep2'], ncol=4, loc=8, fontsize=10)
	plt.title('Attenuator Set 1')


	plt.subplot(4,2,3)
	plt.plot(fs/1e6, 20*np.log10(np.abs(a6s1p0r1c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a6s1p0r2c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a6s1p0r1c1)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(a6s1p0r1c2)), 'b:')	
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC6,50)))*np.ones(len(fs)), 'r', linewidth=2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC6+0.01,50)))*np.ones(len(fs)), 'r--')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC6-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	plt.ylim([-11.6, -11.56])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)		
	plt.ylabel('6-dB attn'+'\n'+'magnitude [dB]')


	plt.subplot(4,2,5)
	plt.plot(fs/1e6, 20*np.log10(np.abs(a10s1p0r1c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a10s1p0r2c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a10s1p0r1c1)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(a10s1p0r1c2)), 'b:')	
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC10,50)))*np.ones(len(fs)), 'r', linewidth=2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC10+0.01,50)))*np.ones(len(fs)), 'r--')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC10-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	plt.ylim([-20.35, -20.25])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)	
	plt.ylabel('10-dB attn'+'\n'+'magnitude [dB]')


	plt.subplot(4,2,7)
	plt.plot(fs/1e6, 20*np.log10(np.abs(a15s1p0r1c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a15s1p0r2c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a15s1p0r1c1)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(a15s1p0r1c2)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC15,50)))*np.ones(len(fs)), 'r', linewidth=2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC15+0.01,50)))*np.ones(len(fs)), 'r--')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC15-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	plt.ylim([-30.1, -29.8])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)
	plt.ylabel('15-dB attn'+'\n'+'magnitude [dB]')
	plt.xlabel('frequency [MHz]')








	plt.subplot(4,2,2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3c,50)))*np.ones(len(fs)), 'r', linewidth=2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(a3s2p0r1c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a3s2p0r2c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a3s2p0r1c1)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(a3s2p0r1c2)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3c,50)))*np.ones(len(fs)), 'r', linewidth=2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3c+0.01,50)))*np.ones(len(fs)), 'r--')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3c-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	plt.ylim([-5.566, -5.552])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)
	#plt.ylabel('3-dB attn'+'\n'+'magnitude [dB]')
	plt.legend(['from DC resistance'+'\n'+'(+/- 0.01 ohm error in attn)','rep1'+'\n'+'(+/- 0.01 ohm error in calibration match)','rep2'], loc=0, fontsize=7)
	plt.title('Attenuator Set 2')


	plt.subplot(4,2,4)
	plt.plot(fs/1e6, 20*np.log10(np.abs(a6s2p0r1c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a6s2p0r2c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a6s2p0r1c1)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(a6s2p0r1c2)), 'b:')	
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC6c,50)))*np.ones(len(fs)), 'r', linewidth=2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC6c+0.01,50)))*np.ones(len(fs)), 'r--')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC6c-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	plt.ylim([-11.68, -11.64])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)		
	#plt.ylabel('6-dB attn'+'\n'+'magnitude [dB]')


	plt.subplot(4,2,6)
	plt.plot(fs/1e6, 20*np.log10(np.abs(a10s2p0r1c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a10s2p0r2c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a10s2p0r1c1)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(a10s2p0r1c2)), 'b:')	
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC10c,50)))*np.ones(len(fs)), 'r', linewidth=2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC10c+0.01,50)))*np.ones(len(fs)), 'r--')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC10c-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	plt.ylim([-20.39, -20.27])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)	
	#plt.ylabel('10-dB attn'+'\n'+'magnitude [dB]')


	plt.subplot(4,2,8)
	plt.plot(fs/1e6, 20*np.log10(np.abs(a15s2p0r1c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a15s2p0r2c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a15s2p0r1c1)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(a15s2p0r1c2)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC15c,50)))*np.ones(len(fs)), 'r', linewidth=2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC15c+0.01,50)))*np.ones(len(fs)), 'r--')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC15c-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	plt.ylim([-30.25, -30.00])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)
	#plt.ylabel('15-dB attn'+'\n'+'magnitude [dB]')
	plt.xlabel('frequency [MHz]')





	# Save plot
	path_plot_save = home_folder + '/DATA/EDGES/results/plots/20170304/'
	plt.savefig(path_plot_save + 'VNA_accuracy_0dBm.pdf', bbox_inches='tight')
	plt.close()
	plt.close()





	# ----------------------------------------------------------------------------------------------


	plt.close()
	plt.close()
	plt.close()
	plt.close()
	plt.close()



	plt.figure(1, figsize=[12,14])
	plt.subplot(4,2,1)
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3,50)))*np.ones(len(fs)), 'r', linewidth=2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(a3s1p30v1r1c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a3s1p30v1r2c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a3s1p30v1r1c1)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(a3s1p30v1r1c2)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3,50)))*np.ones(len(fs)), 'r', linewidth=2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3+0.01,50)))*np.ones(len(fs)), 'r--')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	plt.ylim([-5.594, -5.586])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)
	plt.ylabel('3-dB attn'+'\n'+'magnitude [dB]')
	#plt.legend(['from DC resistance'+'\n'+'(+/- 0.01 ohm error in attn)','rep1'+'\n'+'(+/- 0.01 ohm error in calibration match)','rep2'], ncol=4, loc=8, fontsize=10)
	plt.title('Attenuator Set 1')


	plt.subplot(4,2,3)
	plt.plot(fs/1e6, 20*np.log10(np.abs(a6s1p30v1r1c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a6s1p30v1r2c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a6s1p30v1r1c1)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(a6s1p30v1r1c2)), 'b:')	
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC6,50)))*np.ones(len(fs)), 'r', linewidth=2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC6+0.01,50)))*np.ones(len(fs)), 'r--')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC6-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	plt.ylim([-11.6, -11.56])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)		
	plt.ylabel('6-dB attn'+'\n'+'magnitude [dB]')


	plt.subplot(4,2,5)
	plt.plot(fs/1e6, 20*np.log10(np.abs(a10s1p30v1r1c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a10s1p30v1r2c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a10s1p30v1r1c1)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(a10s1p30v1r1c2)), 'b:')	
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC10,50)))*np.ones(len(fs)), 'r', linewidth=2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC10+0.01,50)))*np.ones(len(fs)), 'r--')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC10-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	plt.ylim([-20.35, -20.25])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)	
	plt.ylabel('10-dB attn'+'\n'+'magnitude [dB]')


	plt.subplot(4,2,7)
	plt.plot(fs/1e6, 20*np.log10(np.abs(a15s1p30v1r1c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a15s1p30v1r2c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a15s1p30v1r1c1)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(a15s1p30v1r1c2)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC15,50)))*np.ones(len(fs)), 'r', linewidth=2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC15+0.01,50)))*np.ones(len(fs)), 'r--')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC15-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	plt.ylim([-30.1, -29.8])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)
	plt.ylabel('15-dB attn'+'\n'+'magnitude [dB]')
	plt.xlabel('frequency [MHz]')








	plt.subplot(4,2,2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3c,50)))*np.ones(len(fs)), 'r', linewidth=2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(a3s2p30v1r1c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a3s2p30v1r2c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a3s2p30v1r1c1)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(a3s2p30v1r1c2)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3c,50)))*np.ones(len(fs)), 'r', linewidth=2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3c+0.01,50)))*np.ones(len(fs)), 'r--')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3c-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	plt.ylim([-5.566, -5.552])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)
	#plt.ylabel('3-dB attn'+'\n'+'magnitude [dB]')
	plt.legend(['from DC resistance'+'\n'+'(+/- 0.01 ohm error in attn)','rep1'+'\n'+'(+/- 0.01 ohm error in calibration match)','rep2'], loc=0, fontsize=7)
	plt.title('Attenuator Set 2')


	plt.subplot(4,2,4)
	plt.plot(fs/1e6, 20*np.log10(np.abs(a6s2p30v1r1c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a6s2p30v1r2c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a6s2p30v1r1c1)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(a6s2p30v1r1c2)), 'b:')	
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC6c,50)))*np.ones(len(fs)), 'r', linewidth=2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC6c+0.01,50)))*np.ones(len(fs)), 'r--')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC6c-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	plt.ylim([-11.68, -11.64])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)		
	#plt.ylabel('6-dB attn'+'\n'+'magnitude [dB]')


	plt.subplot(4,2,6)
	plt.plot(fs/1e6, 20*np.log10(np.abs(a10s2p30v1r1c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a10s2p30v1r2c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a10s2p30v1r1c1)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(a10s2p30v1r1c2)), 'b:')	
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC10c,50)))*np.ones(len(fs)), 'r', linewidth=2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC10c+0.01,50)))*np.ones(len(fs)), 'r--')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC10c-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	plt.ylim([-20.39, -20.27])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)	
	#plt.ylabel('10-dB attn'+'\n'+'magnitude [dB]')


	plt.subplot(4,2,8)
	plt.plot(fs/1e6, 20*np.log10(np.abs(a15s2p30v1r1c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a15s2p30v1r2c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a15s2p30v1r1c1)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(a15s2p30v1r1c2)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC15c,50)))*np.ones(len(fs)), 'r', linewidth=2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC15c+0.01,50)))*np.ones(len(fs)), 'r--')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC15c-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	plt.ylim([-30.25, -30.00])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)
	#plt.ylabel('15-dB attn'+'\n'+'magnitude [dB]')
	plt.xlabel('frequency [MHz]')





	# Save plot
	path_plot_save = home_folder + '/DATA/EDGES/results/plots/20170304/'
	plt.savefig(path_plot_save + 'VNA_accuracy_-30dBm.pdf', bbox_inches='tight')
	plt.close()
	plt.close()














	# ----------------------------------------------------------------------------------------------


	plt.close()
	plt.close()
	plt.close()
	plt.close()
	plt.close()



	plt.figure(1, figsize=[12,14])
	plt.subplot(4,2,1)
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3,50)))*np.ones(len(fs)), 'r', linewidth=2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(a3s1p30v2r1c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a3s1p30v2r2c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a3s1p30v2r1c1)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(a3s1p30v2r1c2)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3,50)))*np.ones(len(fs)), 'r', linewidth=2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3+0.01,50)))*np.ones(len(fs)), 'r--')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	plt.ylim([-5.594, -5.586])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)
	plt.ylabel('3-dB attn'+'\n'+'magnitude [dB]')
	#plt.legend(['from DC resistance'+'\n'+'(+/- 0.01 ohm error in attn)','rep1'+'\n'+'(+/- 0.01 ohm error in calibration match)','rep2'], ncol=4, loc=8, fontsize=10)
	plt.title('Attenuator Set 1')


	plt.subplot(4,2,3)
	plt.plot(fs/1e6, 20*np.log10(np.abs(a6s1p30v2r1c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a6s1p30v2r2c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a6s1p30v2r1c1)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(a6s1p30v2r1c2)), 'b:')	
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC6,50)))*np.ones(len(fs)), 'r', linewidth=2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC6+0.01,50)))*np.ones(len(fs)), 'r--')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC6-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	plt.ylim([-11.6, -11.56])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)		
	plt.ylabel('6-dB attn'+'\n'+'magnitude [dB]')


	plt.subplot(4,2,5)
	plt.plot(fs/1e6, 20*np.log10(np.abs(a10s1p30v2r1c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a10s1p30v2r2c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a10s1p30v2r1c1)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(a10s1p30v2r1c2)), 'b:')	
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC10,50)))*np.ones(len(fs)), 'r', linewidth=2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC10+0.01,50)))*np.ones(len(fs)), 'r--')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC10-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	plt.ylim([-20.35, -20.25])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)	
	plt.ylabel('10-dB attn'+'\n'+'magnitude [dB]')


	plt.subplot(4,2,7)
	plt.plot(fs/1e6, 20*np.log10(np.abs(a15s1p30v2r1c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a15s1p30v2r2c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a15s1p30v2r1c1)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(a15s1p30v2r1c2)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC15,50)))*np.ones(len(fs)), 'r', linewidth=2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC15+0.01,50)))*np.ones(len(fs)), 'r--')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC15-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	plt.ylim([-30.1, -29.8])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)
	plt.ylabel('15-dB attn'+'\n'+'magnitude [dB]')
	plt.xlabel('frequency [MHz]')








	plt.subplot(4,2,2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3c,50)))*np.ones(len(fs)), 'r', linewidth=2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(a3s2p30v2r1c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a3s2p30v2r2c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a3s2p30v2r1c1)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(a3s2p30v2r1c2)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3c,50)))*np.ones(len(fs)), 'r', linewidth=2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3c+0.01,50)))*np.ones(len(fs)), 'r--')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3c-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	plt.ylim([-5.566, -5.552])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)
	#plt.ylabel('3-dB attn'+'\n'+'magnitude [dB]')
	plt.legend(['from DC resistance'+'\n'+'(+/- 0.01 ohm error in attn)','rep1'+'\n'+'(+/- 0.01 ohm error in calibration match)','rep2'], loc=0, fontsize=7)
	plt.title('Attenuator Set 2')


	plt.subplot(4,2,4)
	plt.plot(fs/1e6, 20*np.log10(np.abs(a6s2p30v2r1c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a6s2p30v2r2c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a6s2p30v2r1c1)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(a6s2p30v2r1c2)), 'b:')	
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC6c,50)))*np.ones(len(fs)), 'r', linewidth=2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC6c+0.01,50)))*np.ones(len(fs)), 'r--')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC6c-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	plt.ylim([-11.68, -11.64])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)		
	#plt.ylabel('6-dB attn'+'\n'+'magnitude [dB]')


	plt.subplot(4,2,6)
	plt.plot(fs/1e6, 20*np.log10(np.abs(a10s2p30v2r1c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a10s2p30v2r2c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a10s2p30v2r1c1)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(a10s2p30v2r1c2)), 'b:')	
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC10c,50)))*np.ones(len(fs)), 'r', linewidth=2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC10c+0.01,50)))*np.ones(len(fs)), 'r--')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC10c-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	plt.ylim([-20.39, -20.27])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)	
	#plt.ylabel('10-dB attn'+'\n'+'magnitude [dB]')


	plt.subplot(4,2,8)
	plt.plot(fs/1e6, 20*np.log10(np.abs(a15s2p30v2r1c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a15s2p30v2r2c)))
	plt.plot(fs/1e6, 20*np.log10(np.abs(a15s2p30v2r1c1)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(a15s2p30v2r1c2)), 'b:')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC15c,50)))*np.ones(len(fs)), 'r', linewidth=2)
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC15c+0.01,50)))*np.ones(len(fs)), 'r--')
	plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC15c-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	plt.ylim([-30.25, -30.00])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)
	#plt.ylabel('15-dB attn'+'\n'+'magnitude [dB]')
	plt.xlabel('frequency [MHz]')





	# Save plot
	path_plot_save = home_folder + '/DATA/EDGES/results/plots/20170304/'
	plt.savefig(path_plot_save + 'VNA_accuracy_-30dBm_after_restart.pdf', bbox_inches='tight')
	plt.close()
	plt.close()




















	# Phase --------------------------------------------
	# ------------------------------------------------------------------------

	plt.close()
	plt.close()
	plt.close()
	plt.close()
	plt.close()


	#plt.plot(fs/1e6, 20*np.log10(np.abs(a3s1p30v1r1c)))
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a3s1p30v1r2c)))
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a3s1p30v1r1c1)), 'b:')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a3s1p30v1r1c2)), 'b:')




	plt.figure(1, figsize=[12,14])
	plt.subplot(4,2,1)
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a3s1p0r2c))    - (180/np.pi)*np.unwrap(np.angle(a3s1p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a3s1p30v1r1c)) - (180/np.pi)*np.unwrap(np.angle(a3s1p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a3s1p30v1r2c)) - (180/np.pi)*np.unwrap(np.angle(a3s1p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a3s1p30v2r1c)) - (180/np.pi)*np.unwrap(np.angle(a3s1p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a3s1p30v2r2c)) - (180/np.pi)*np.unwrap(np.angle(a3s1p0r1c)))

	#plt.xlim([50, 200])
	plt.ylim([-0.03, 0.05])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)
	plt.ylabel('3-dB attn'+'\n'+r'$\Delta$ phase [deg]')
	plt.title('Attenuator Set 1')


	plt.subplot(4,2,3)
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a6s1p0r2c))    - (180/np.pi)*np.unwrap(np.angle(a6s1p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a6s1p30v1r1c)) - (180/np.pi)*np.unwrap(np.angle(a6s1p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a6s1p30v1r2c)) - (180/np.pi)*np.unwrap(np.angle(a6s1p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a6s1p30v2r1c)) - (180/np.pi)*np.unwrap(np.angle(a6s1p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a6s1p30v2r2c)) - (180/np.pi)*np.unwrap(np.angle(a6s1p0r1c)))	
	#plt.xlim([50, 200])
	#plt.ylim([-11.6, -11.56])
	plt.ylim([-0.04, 0.01])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)		
	plt.ylabel('6-dB attn'+'\n'+r'$\Delta$ phase [deg]')


	plt.subplot(4,2,5)
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a10s1p0r2c))    - (180/np.pi)*np.unwrap(np.angle(a10s1p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a10s1p30v1r1c)) - (180/np.pi)*np.unwrap(np.angle(a10s1p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a10s1p30v1r2c)) - (180/np.pi)*np.unwrap(np.angle(a10s1p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a10s1p30v2r1c)) - (180/np.pi)*np.unwrap(np.angle(a10s1p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a10s1p30v2r2c)) - (180/np.pi)*np.unwrap(np.angle(a10s1p0r1c)))	
	#plt.xlim([50, 200])
	#plt.ylim([-20.35, -20.25])
	plt.ylim([-0.06, 0.04])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)	
	plt.ylabel('10-dB attn'+'\n'+r'$\Delta$ phase [deg]')


	plt.subplot(4,2,7)
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a15s1p0r2c))    - (180/np.pi)*np.unwrap(np.angle(a15s1p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a15s1p30v1r1c)) - (180/np.pi)*np.unwrap(np.angle(a15s1p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a15s1p30v1r2c)) - (180/np.pi)*np.unwrap(np.angle(a15s1p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a15s1p30v2r1c)) - (180/np.pi)*np.unwrap(np.angle(a15s1p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a15s1p30v2r2c)) - (180/np.pi)*np.unwrap(np.angle(a15s1p0r1c)))	
	#plt.xlim([50, 200])
	#plt.ylim([-30.1, -29.8])
	plt.ylim([-0.1, 0.6])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)
	plt.ylabel('15-dB attn'+'\n'+r'$\Delta$ phase [deg]')
	plt.xlabel('frequency [MHz]')








	plt.subplot(4,2,2)
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a3s2p0r2c))  - (180/np.pi)*np.unwrap(np.angle(a3s2p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a3s2p30v1r1c)) - (180/np.pi)*np.unwrap(np.angle(a3s2p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a3s2p30v1r2c)) - (180/np.pi)*np.unwrap(np.angle(a3s2p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a3s2p30v2r1c)) - (180/np.pi)*np.unwrap(np.angle(a3s2p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a3s2p30v2r2c)) - (180/np.pi)*np.unwrap(np.angle(a3s2p0r1c)))
	#plt.xlim([50, 200])
	#plt.ylim([-5.566, -5.552])
	plt.ylim([-0.03, 0.05])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)
	#plt.ylabel('3-dB attn'+'\n'+'magnitude [dB]')
	#plt.legend(['from DC resistance'+'\n'+'(+/- 0.01 ohm error in attn)','rep1'+'\n'+'(+/- 0.01 ohm error in calibration match)','rep2'], loc=0, fontsize=7)
	plt.legend(['0dBm_repetition2 - 0dBm_reference','-30dBm_repetition1 - 0dBm_reference','-30dBm_repetition2 - 0dBm_reference','-30dBm_repetition3 - 0dBm_reference','-30dBm_repetition4 - 0dBm_reference'], ncol=1)
	plt.title('Attenuator Set 2')


	plt.subplot(4,2,4)
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a6s2p0r2c))  - (180/np.pi)*np.unwrap(np.angle(a6s2p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a6s2p30v1r1c)) - (180/np.pi)*np.unwrap(np.angle(a6s2p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a6s2p30v1r2c)) - (180/np.pi)*np.unwrap(np.angle(a6s2p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a6s2p30v2r1c)) - (180/np.pi)*np.unwrap(np.angle(a6s2p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a6s2p30v2r2c)) - (180/np.pi)*np.unwrap(np.angle(a6s2p0r1c)))
	#plt.xlim([50, 200])
	#plt.ylim([-11.68, -11.64])
	plt.ylim([-0.04, 0.01])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)		
	#plt.ylabel('6-dB attn'+'\n'+'magnitude [dB]')


	plt.subplot(4,2,6)
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a10s2p0r2c))  - (180/np.pi)*np.unwrap(np.angle(a10s2p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a10s2p30v1r1c)) - (180/np.pi)*np.unwrap(np.angle(a10s2p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a10s2p30v1r2c)) - (180/np.pi)*np.unwrap(np.angle(a10s2p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a10s2p30v2r1c)) - (180/np.pi)*np.unwrap(np.angle(a10s2p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a10s2p30v2r2c)) - (180/np.pi)*np.unwrap(np.angle(a10s2p0r1c)))
	#plt.xlim([50, 200])
	#plt.ylim([-20.39, -20.27])
	plt.ylim([-0.06, 0.04])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)	
	#plt.ylabel('10-dB attn'+'\n'+'magnitude [dB]')


	plt.subplot(4,2,8)
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a15s2p0r2c))    - (180/np.pi)*np.unwrap(np.angle(a15s2p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a15s2p30v1r1c)) - (180/np.pi)*np.unwrap(np.angle(a15s2p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a15s2p30v1r2c)) - (180/np.pi)*np.unwrap(np.angle(a15s2p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a15s2p30v2r1c)) - (180/np.pi)*np.unwrap(np.angle(a15s2p0r1c)))
	plt.plot(fs/1e6, (180/np.pi)*np.unwrap(np.angle(a15s2p30v2r2c)) - (180/np.pi)*np.unwrap(np.angle(a15s2p0r1c)))
	#plt.xlim([50, 200])
	#plt.ylim([-30.25, -30.00])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)
	#plt.ylabel('15-dB attn'+'\n'+'magnitude [dB]')
	plt.ylim([-0.1, 0.6])
	plt.xlabel('frequency [MHz]')





	# Save plot
	path_plot_save = home_folder + '/DATA/EDGES/results/plots/20171102/'
	plt.savefig(path_plot_save + 'VNA_accuracy_phase.pdf', bbox_inches='tight')
	plt.close()
	plt.close()













	# Real -----------------------
	# ----------------------------

	plt.close()
	plt.close()
	plt.close()
	plt.close()
	plt.close()



	plt.figure(1, figsize=[12,14])
	plt.subplot(4,2,1)
	#plt.plot(fs/1e6, np.real(a3s1p0r2c)    - np.real(a3s1p0r2c)) # 20*np.log10(np.abs(a3s1p0r2c)))
	plt.plot(fs/1e6, np.real(a3s1p30v1r1c) - np.real(a3s1p0r2c))
	plt.plot(fs/1e6, np.real(a3s1p30v1r2c) - np.real(a3s1p0r2c)) # 20*np.log10(np.abs(a3s1p0r2c)))	
	plt.plot(fs/1e6, np.real(a3s1p30v2r1c) - np.real(a3s1p0r2c))
	plt.plot(fs/1e6, np.real(a3s1p30v2r2c) - np.real(a3s1p0r2c)) # 20*np.log10(np.abs(a3s1p0r2c)))		
	plt.ylim([-0.0004, 0.0004])
	plt.grid()
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a3s1p0r1c1)), 'b:')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a3s1p0r1c2)), 'b:')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3,50)))*np.ones(len(fs)), 'r', linewidth=2)
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3+0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	#plt.ylim([-5.594, -5.586])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)
	plt.ylabel('3-dB attn'+'\n'+r'$\Delta$ real(S11)')
	#plt.legend(['from DC resistance'+'\n'+'(+/- 0.01 ohm error in attn)','rep1'+'\n'+'(+/- 0.01 ohm error in calibration match)','rep2'], ncol=4, loc=8, fontsize=10)
	plt.title('Attenuator Set 1')


	plt.subplot(4,2,3)
	#plt.plot(fs/1e6, np.real(a6s1p0r2c)    - np.real(a6s1p0r2c))
	plt.plot(fs/1e6, np.real(a6s1p30v1r1c) - np.real(a6s1p0r2c))
	plt.plot(fs/1e6, np.real(a6s1p30v1r2c) - np.real(a6s1p0r2c))
	plt.plot(fs/1e6, np.real(a6s1p30v2r1c) - np.real(a6s1p0r2c))
	plt.plot(fs/1e6, np.real(a6s1p30v2r2c) - np.real(a6s1p0r2c))
	plt.ylim([-0.0004, 0.0004])
	plt.grid()
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a6s1p0r1c)))
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a6s1p0r2c)))
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a6s1p0r1c1)), 'b:')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a6s1p0r1c2)), 'b:')	
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC6,50)))*np.ones(len(fs)), 'r', linewidth=2)
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC6+0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC6-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	#plt.ylim([-11.6, -11.56])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)		
	plt.ylabel('6-dB attn'+'\n'+r'$\Delta$ real(S11)')


	plt.subplot(4,2,5)
	#plt.plot(fs/1e6, np.real(a10s1p0r2c)    - np.real(a10s1p0r2c))
	plt.plot(fs/1e6, np.real(a10s1p30v1r1c) - np.real(a10s1p0r2c))
	plt.plot(fs/1e6, np.real(a10s1p30v1r2c) - np.real(a10s1p0r2c))
	plt.plot(fs/1e6, np.real(a10s1p30v2r1c) - np.real(a10s1p0r2c))
	plt.plot(fs/1e6, np.real(a10s1p30v2r2c) - np.real(a10s1p0r2c))
	plt.ylim([-0.0004, 0.0004])
	plt.grid()
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a10s1p0r1c)))
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a10s1p0r2c)))
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a10s1p0r1c1)), 'b:')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a10s1p0r1c2)), 'b:')	
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC10,50)))*np.ones(len(fs)), 'r', linewidth=2)
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC10+0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC10-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	#plt.ylim([-20.35, -20.25])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)	
	plt.ylabel('10-dB attn'+'\n'+r'$\Delta$ real(S11)')


	plt.subplot(4,2,7)
	#plt.plot(fs/1e6, np.real(a15s1p0r2c)    - np.real(a15s1p0r2c))
	plt.plot(fs/1e6, np.real(a15s1p30v1r1c) - np.real(a15s1p0r2c))
	plt.plot(fs/1e6, np.real(a15s1p30v1r2c) - np.real(a15s1p0r2c))
	plt.plot(fs/1e6, np.real(a15s1p30v2r1c) - np.real(a15s1p0r2c))
	plt.plot(fs/1e6, np.real(a15s1p30v2r2c) - np.real(a15s1p0r2c))
	plt.ylim([-0.0004, 0.0004])
	plt.grid()
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a15s1p0r1c)))
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a15s1p0r2c)))
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a15s1p0r1c1)), 'b:')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a15s1p0r1c2)), 'b:')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC15,50)))*np.ones(len(fs)), 'r', linewidth=2)
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC15+0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC15-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	#plt.ylim([-30.1, -29.8])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)
	plt.ylabel('15-dB attn'+'\n'+r'$\Delta$ real(S11)')
	plt.xlabel('frequency [MHz]')








	plt.subplot(4,2,2)
	#plt.plot(fs/1e6, np.real(a3s2p0r1c) - np.real(rc.impedance2gamma(DC3c,50)*np.ones(len(fs))))
	#plt.plot(fs/1e6, np.real(a3s2p0r2c) - np.real(rc.impedance2gamma(DC3c,50)*np.ones(len(fs)))) # 20*np.log10(np.abs(a3s1p0r2c)))
	plt.plot(fs/1e6, np.real(a3s2p30v1r1c) - np.real(a3s2p0r2c))
	plt.plot(fs/1e6, np.real(a3s2p30v1r2c) - np.real(a3s2p0r2c)) 
	plt.plot(fs/1e6, np.real(a3s2p30v2r1c) - np.real(a3s2p0r2c))
	plt.plot(fs/1e6, np.real(a3s2p30v2r2c) - np.real(a3s2p0r2c)) 
	plt.ylim([-0.0004, 0.0004])
	plt.grid()
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3c,50)))*np.ones(len(fs)), 'r', linewidth=2)
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a3s2p0r1c)))
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a3s2p0r2c)))
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a3s2p0r1c1)), 'b:')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a3s2p0r1c2)), 'b:')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3c,50)))*np.ones(len(fs)), 'r', linewidth=2)
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3c+0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3c-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	#plt.ylim([-5.566, -5.552])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)
	#plt.ylabel('3-dB attn'+'\n'+'magnitude [dB]')
	#plt.legend(['from DC resistance'+'\n'+'(+/- 0.01 ohm error in attn)','rep1'+'\n'+'(+/- 0.01 ohm error in calibration match)','rep2'], loc=0, fontsize=7)
	plt.title('Attenuator Set 2')


	plt.subplot(4,2,4)
	#plt.plot(fs/1e6, np.real(a6s2p0r1c) - np.real(rc.impedance2gamma(DC6c,50)*np.ones(len(fs))))
	#plt.plot(fs/1e6, np.real(a6s2p0r2c) - np.real(rc.impedance2gamma(DC6c,50)*np.ones(len(fs)))) # 20*np.log10(np.abs(a3s1p0r2c)))
	plt.plot(fs/1e6, np.real(a6s2p30v1r1c) - np.real(a6s2p0r1c))
	plt.plot(fs/1e6, np.real(a6s2p30v1r2c) - np.real(a6s2p0r1c)) 
	plt.plot(fs/1e6, np.real(a6s2p30v2r1c) - np.real(a6s2p0r1c))
	plt.plot(fs/1e6, np.real(a6s2p30v2r2c) - np.real(a6s2p0r1c)) 
	plt.ylim([-0.0004, 0.0004])
	plt.grid()	
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a6s2p0r1c)))
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a6s2p0r2c)))
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a6s2p0r1c1)), 'b:')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a6s2p0r1c2)), 'b:')	
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC6c,50)))*np.ones(len(fs)), 'r', linewidth=2)
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC6c+0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC6c-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	#plt.ylim([-11.68, -11.64])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)		
	#plt.ylabel('6-dB attn'+'\n'+'magnitude [dB]')


	plt.subplot(4,2,6)
	#plt.plot(fs/1e6, np.real(a10s2p0r1c) - np.real(rc.impedance2gamma(DC10c,50)*np.ones(len(fs))))
	#plt.plot(fs/1e6, np.real(a10s2p0r2c) - np.real(rc.impedance2gamma(DC10c,50)*np.ones(len(fs)))) # 20*np.log10(np.abs(a3s1p0r2c)))
	plt.plot(fs/1e6, np.real(a10s2p30v1r1c) - np.real(a10s2p0r1c))
	plt.plot(fs/1e6, np.real(a10s2p30v1r2c) - np.real(a10s2p0r1c)) 
	plt.plot(fs/1e6, np.real(a10s2p30v2r1c) - np.real(a10s2p0r1c))
	plt.plot(fs/1e6, np.real(a10s2p30v2r2c) - np.real(a10s2p0r1c)) 
	plt.ylim([-0.0004, 0.0004])
	plt.grid()		

	#plt.plot(fs/1e6, 20*np.log10(np.abs(a10s2p0r1c)))
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a10s2p0r2c)))
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a10s2p0r1c1)), 'b:')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a10s2p0r1c2)), 'b:')	
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC10c,50)))*np.ones(len(fs)), 'r', linewidth=2)
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC10c+0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC10c-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	#plt.ylim([-20.39, -20.27])
	#ax = plt.gca()
	ax.ticklabel_format(useOffset=False)	
	#plt.ylabel('10-dB attn'+'\n'+'magnitude [dB]')


	plt.subplot(4,2,8)
	#plt.plot(fs/1e6, np.real(a15s2p0r1c) - np.real(rc.impedance2gamma(DC15c,50)*np.ones(len(fs))))
	#plt.plot(fs/1e6, np.real(a15s2p0r2c) - np.real(rc.impedance2gamma(DC15c,50)*np.ones(len(fs)))) # 20*np.log10(np.abs(a3s1p0r2c)))
	plt.plot(fs/1e6, np.real(a15s2p30v1r1c) - np.real(a15s2p0r1c))
	plt.plot(fs/1e6, np.real(a15s2p30v1r2c) - np.real(a15s2p0r1c)) 
	plt.plot(fs/1e6, np.real(a15s2p30v2r1c) - np.real(a15s2p0r1c))
	plt.plot(fs/1e6, np.real(a15s2p30v2r2c) - np.real(a15s2p0r1c))
	plt.ylim([-0.0004, 0.0004])
	plt.grid()

	#plt.plot(fs/1e6, 20*np.log10(np.abs(a15s2p0r1c)))
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a15s2p0r2c)))
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a15s2p0r1c1)), 'b:')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a15s2p0r1c2)), 'b:')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC15c,50)))*np.ones(len(fs)), 'r', linewidth=2)
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC15c+0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC15c-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	#plt.ylim([-30.25, -30.00])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)
	#plt.ylabel('15-dB attn'+'\n'+'magnitude [dB]')
	plt.xlabel('frequency [MHz]')




	# Save plot
	path_plot_save = home_folder + '/DATA/EDGES/results/plots/20171102/'
	plt.savefig(path_plot_save + 'VNA_accuracy_real.pdf', bbox_inches='tight')
	plt.close()
	plt.close()

















	# Imag -----------------------
	# ----------------------------

	plt.close()
	plt.close()
	plt.close()
	plt.close()
	plt.close()



	plt.figure(1, figsize=[12,14])
	plt.subplot(4,2,1)
	#plt.plot(fs/1e6, np.real(a3s1p0r2c)    - np.real(a3s1p0r2c)) # 20*np.log10(np.abs(a3s1p0r2c)))
	plt.plot(fs/1e6, np.imag(a3s1p30v1r1c) - np.imag(a3s1p0r1c))
	plt.plot(fs/1e6, np.imag(a3s1p30v1r2c) - np.imag(a3s1p0r1c)) # 20*np.log10(np.abs(a3s1p0r2c)))	
	plt.plot(fs/1e6, np.imag(a3s1p30v2r1c) - np.imag(a3s1p0r1c))
	plt.plot(fs/1e6, np.imag(a3s1p30v2r2c) - np.imag(a3s1p0r1c)) # 20*np.log10(np.abs(a3s1p0r2c)))		
	plt.ylim([-0.0004, 0.0004])
	plt.grid()
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a3s1p0r1c1)), 'b:')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a3s1p0r1c2)), 'b:')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3,50)))*np.ones(len(fs)), 'r', linewidth=2)
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3+0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	#plt.ylim([-5.594, -5.586])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)
	plt.ylabel('3-dB attn'+'\n'+r'$\Delta$ imag(S11)')
	#plt.legend(['from DC resistance'+'\n'+'(+/- 0.01 ohm error in attn)','rep1'+'\n'+'(+/- 0.01 ohm error in calibration match)','rep2'], ncol=4, loc=8, fontsize=10)
	plt.title('Attenuator Set 1')


	plt.subplot(4,2,3)
	#plt.plot(fs/1e6, np.real(a6s1p0r2c)    - np.real(a6s1p0r2c))
	plt.plot(fs/1e6, np.imag(a6s1p30v1r1c) - np.imag(a6s1p0r1c))
	plt.plot(fs/1e6, np.imag(a6s1p30v1r2c) - np.imag(a6s1p0r1c))
	plt.plot(fs/1e6, np.imag(a6s1p30v2r1c) - np.imag(a6s1p0r1c))
	plt.plot(fs/1e6, np.imag(a6s1p30v2r2c) - np.imag(a6s1p0r1c))
	plt.ylim([-0.0004, 0.0004])
	plt.grid()
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a6s1p0r1c)))
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a6s1p0r2c)))
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a6s1p0r1c1)), 'b:')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a6s1p0r1c2)), 'b:')	
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC6,50)))*np.ones(len(fs)), 'r', linewidth=2)
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC6+0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC6-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	#plt.ylim([-11.6, -11.56])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)		
	plt.ylabel('6-dB attn'+'\n'+r'$\Delta$ imag(S11)')


	plt.subplot(4,2,5)
	#plt.plot(fs/1e6, np.real(a10s1p0r2c)    - np.real(a10s1p0r2c))
	plt.plot(fs/1e6, np.imag(a10s1p30v1r1c) - np.imag(a10s1p0r1c))
	plt.plot(fs/1e6, np.imag(a10s1p30v1r2c) - np.imag(a10s1p0r1c))
	plt.plot(fs/1e6, np.imag(a10s1p30v2r1c) - np.imag(a10s1p0r1c))
	plt.plot(fs/1e6, np.imag(a10s1p30v2r2c) - np.imag(a10s1p0r1c))
	plt.ylim([-0.0004, 0.0004])
	plt.grid()
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a10s1p0r1c)))
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a10s1p0r2c)))
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a10s1p0r1c1)), 'b:')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a10s1p0r1c2)), 'b:')	
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC10,50)))*np.ones(len(fs)), 'r', linewidth=2)
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC10+0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC10-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	#plt.ylim([-20.35, -20.25])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)	
	plt.ylabel('10-dB attn'+'\n'+r'$\Delta$ imag(S11)')


	plt.subplot(4,2,7)
	#plt.plot(fs/1e6, np.real(a15s1p0r2c)    - np.real(a15s1p0r2c))
	plt.plot(fs/1e6, np.imag(a15s1p30v1r1c) - np.imag(a15s1p0r2c))
	plt.plot(fs/1e6, np.imag(a15s1p30v1r2c) - np.imag(a15s1p0r2c))
	plt.plot(fs/1e6, np.imag(a15s1p30v2r1c) - np.imag(a15s1p0r2c))
	plt.plot(fs/1e6, np.imag(a15s1p30v2r2c) - np.imag(a15s1p0r2c))
	plt.ylim([-0.0004, 0.0004])
	plt.grid()
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a15s1p0r1c)))
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a15s1p0r2c)))
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a15s1p0r1c1)), 'b:')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a15s1p0r1c2)), 'b:')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC15,50)))*np.ones(len(fs)), 'r', linewidth=2)
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC15+0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC15-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	#plt.ylim([-30.1, -29.8])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)
	plt.ylabel('15-dB attn'+'\n'+r'$\Delta$ imag(S11)')
	plt.xlabel('frequency [MHz]')








	plt.subplot(4,2,2)
	#plt.plot(fs/1e6, np.real(a3s2p0r1c) - np.real(rc.impedance2gamma(DC3c,50)*np.ones(len(fs))))
	#plt.plot(fs/1e6, np.real(a3s2p0r2c) - np.real(rc.impedance2gamma(DC3c,50)*np.ones(len(fs)))) # 20*np.log10(np.abs(a3s1p0r2c)))
	plt.plot(fs/1e6, np.imag(a3s2p30v1r1c) - np.imag(a3s2p0r2c))
	plt.plot(fs/1e6, np.imag(a3s2p30v1r2c) - np.imag(a3s2p0r2c)) 
	plt.plot(fs/1e6, np.imag(a3s2p30v2r1c) - np.imag(a3s2p0r2c))
	plt.plot(fs/1e6, np.imag(a3s2p30v2r2c) - np.imag(a3s2p0r2c)) 
	plt.ylim([-0.0004, 0.0004])
	plt.grid()
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3c,50)))*np.ones(len(fs)), 'r', linewidth=2)
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a3s2p0r1c)))
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a3s2p0r2c)))
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a3s2p0r1c1)), 'b:')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a3s2p0r1c2)), 'b:')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3c,50)))*np.ones(len(fs)), 'r', linewidth=2)
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3c+0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC3c-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	#plt.ylim([-5.566, -5.552])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)
	#plt.ylabel('3-dB attn'+'\n'+'magnitude [dB]')
	#plt.legend(['from DC resistance'+'\n'+'(+/- 0.01 ohm error in attn)','rep1'+'\n'+'(+/- 0.01 ohm error in calibration match)','rep2'], loc=0, fontsize=7)
	plt.title('Attenuator Set 2')


	plt.subplot(4,2,4)
	#plt.plot(fs/1e6, np.real(a6s2p0r1c) - np.real(rc.impedance2gamma(DC6c,50)*np.ones(len(fs))))
	#plt.plot(fs/1e6, np.real(a6s2p0r2c) - np.real(rc.impedance2gamma(DC6c,50)*np.ones(len(fs)))) # 20*np.log10(np.abs(a3s1p0r2c)))
	plt.plot(fs/1e6, np.imag(a6s2p30v1r1c) - np.imag(a6s2p0r1c))
	plt.plot(fs/1e6, np.imag(a6s2p30v1r2c) - np.imag(a6s2p0r1c)) 
	plt.plot(fs/1e6, np.imag(a6s2p30v2r1c) - np.imag(a6s2p0r1c))
	plt.plot(fs/1e6, np.imag(a6s2p30v2r2c) - np.imag(a6s2p0r1c)) 
	plt.ylim([-0.0004, 0.0004])
	plt.grid()	
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a6s2p0r1c)))
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a6s2p0r2c)))
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a6s2p0r1c1)), 'b:')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a6s2p0r1c2)), 'b:')	
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC6c,50)))*np.ones(len(fs)), 'r', linewidth=2)
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC6c+0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC6c-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	#plt.ylim([-11.68, -11.64])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)		
	#plt.ylabel('6-dB attn'+'\n'+'magnitude [dB]')


	plt.subplot(4,2,6)
	#plt.plot(fs/1e6, np.real(a10s2p0r1c) - np.real(rc.impedance2gamma(DC10c,50)*np.ones(len(fs))))
	#plt.plot(fs/1e6, np.real(a10s2p0r2c) - np.real(rc.impedance2gamma(DC10c,50)*np.ones(len(fs)))) # 20*np.log10(np.abs(a3s1p0r2c)))
	plt.plot(fs/1e6, np.imag(a10s2p30v1r1c) - np.imag(a10s2p0r1c))
	plt.plot(fs/1e6, np.imag(a10s2p30v1r2c) - np.imag(a10s2p0r1c)) 
	plt.plot(fs/1e6, np.imag(a10s2p30v2r1c) - np.imag(a10s2p0r1c))
	plt.plot(fs/1e6, np.imag(a10s2p30v2r2c) - np.imag(a10s2p0r1c)) 
	plt.ylim([-0.0004, 0.0004])
	plt.grid()		

	#plt.plot(fs/1e6, 20*np.log10(np.abs(a10s2p0r1c)))
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a10s2p0r2c)))
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a10s2p0r1c1)), 'b:')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a10s2p0r1c2)), 'b:')	
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC10c,50)))*np.ones(len(fs)), 'r', linewidth=2)
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC10c+0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC10c-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	#plt.ylim([-20.39, -20.27])
	#ax = plt.gca()
	ax.ticklabel_format(useOffset=False)	
	#plt.ylabel('10-dB attn'+'\n'+'magnitude [dB]')


	plt.subplot(4,2,8)
	#plt.plot(fs/1e6, np.real(a15s2p0r1c) - np.real(rc.impedance2gamma(DC15c,50)*np.ones(len(fs))))
	#plt.plot(fs/1e6, np.real(a15s2p0r2c) - np.real(rc.impedance2gamma(DC15c,50)*np.ones(len(fs)))) # 20*np.log10(np.abs(a3s1p0r2c)))
	plt.plot(fs/1e6, np.imag(a15s2p30v1r1c) - np.imag(a15s2p0r1c))
	plt.plot(fs/1e6, np.imag(a15s2p30v1r2c) - np.imag(a15s2p0r1c)) 
	plt.plot(fs/1e6, np.imag(a15s2p30v2r1c) - np.imag(a15s2p0r1c))
	plt.plot(fs/1e6, np.imag(a15s2p30v2r2c) - np.imag(a15s2p0r1c))
	plt.ylim([-0.0004, 0.0004])
	plt.grid()

	#plt.plot(fs/1e6, 20*np.log10(np.abs(a15s2p0r1c)))
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a15s2p0r2c)))
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a15s2p0r1c1)), 'b:')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(a15s2p0r1c2)), 'b:')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC15c,50)))*np.ones(len(fs)), 'r', linewidth=2)
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC15c+0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.plot(fs/1e6, 20*np.log10(np.abs(rc.impedance2gamma(DC15c-0.01,50)))*np.ones(len(fs)), 'r--')
	#plt.xlim([50, 200])
	#plt.ylim([-30.25, -30.00])
	ax = plt.gca()
	ax.ticklabel_format(useOffset=False)
	#plt.ylabel('15-dB attn'+'\n'+'magnitude [dB]')
	plt.xlabel('frequency [MHz]')




	# Save plot
	path_plot_save = home_folder + '/DATA/EDGES/results/plots/20171102/'
	plt.savefig(path_plot_save + 'VNA_accuracy_imag.pdf', bbox_inches='tight')
	plt.close()
	plt.close()








	return 0













def high_band_s11_calibration_measurements_2017_january_25C(flow=80, fhigh=200, save='no', flag=''):


	# Data paths
	# ----------
	main_path    = home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_high_band_2017_january/LNA/S11/raw'

	path_LNA1    = main_path + '/Receiver_1st_measurement/'
	path_LNA2    = main_path + '/Receiver_2nd_reading/'
	path_LNA3    = main_path + '/Receiver_3rd_reading/'
	path_LNA4    = main_path + '/Receiver_4th_reading/'
	path_LNA_R1  = main_path + '/Receiver_1hr_readings_1/'
	path_LNA_R2  = main_path + '/Receiver_1hr_readings_2/'

	path_ambient = main_path + '/AmbientLoad/'
	path_hot     = main_path + '/HotLoad/'
	path_hot_2   = main_path + '/HotLoad_2nd_measurement/'
	path_open    = main_path + '/OpenCable/'
	path_shorted = main_path + '/ShortedCable_0ohms/'
	path_sim21   = main_path + '/SimAnt2/'
	path_sim22   = main_path + '/SimAnt2_redo/'
	path_sim2_2  = main_path + '/SimAnt2_2nd_run_Feb11/'





	# Receiver reflection coefficient
	# -------------------------------

	# FIRST REPETITION
	# ----------------
	# Reading measurements
	o,   fr1    = rc.s1p_read(path_LNA1 + 'Open.s1p')
	s,   fr1    = rc.s1p_read(path_LNA1 + 'Short.s1p')
	l,   fr1    = rc.s1p_read(path_LNA1 + 'Match.s1p')
	LNA01a, fr1 = rc.s1p_read(path_LNA1 + 'Receiver.s1p')

	# Models of standards
	resistance_of_match = 49.97 # female
	md = 1
	oa, sa, la = rc.agilent_85033E(fr1, resistance_of_match, md)

	# Correction of measurements
	LNAc1a, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA01a)

	# 90-190 MHz
	LNA1a = LNAc1a[(fr1/1e6>=flow) & (fr1/1e6<=fhigh)]
	fr1   = fr1[(fr1/1e6>=flow) & (fr1/1e6<=fhigh)]


	# Reading measurements
	o,   fr1  = rc.s1p_read(path_LNA1 + 'Open2.s1p')
	s,   fr1  = rc.s1p_read(path_LNA1 + 'Short2.s1p')
	l,   fr1  = rc.s1p_read(path_LNA1 + 'Match2.s1p')
	LNA01b, fr1 = rc.s1p_read(path_LNA1 + 'Receiver2.s1p')

	# Correction of measurements
	LNAc1b, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA01b)

	# 90-190 MHz
	LNA1b = LNAc1b[(fr1/1e6>=flow) & (fr1/1e6<=fhigh)]
	fr1   = fr1[(fr1/1e6>=flow) & (fr1/1e6<=fhigh)]	







	# SECOND REPETITION
	# ----------------
	# Reading measurements
	o,   fr2    = rc.s1p_read(path_LNA2 + 'Open.s1p')
	s,   fr2    = rc.s1p_read(path_LNA2 + 'Short.s1p')
	l,   fr2    = rc.s1p_read(path_LNA2 + 'Match.s1p')
	LNA02a, fr2 = rc.s1p_read(path_LNA2 + 'Receiver.s1p')
	LNA02b, fr2 = rc.s1p_read(path_LNA2 + 'Receiver2.s1p')

	# Correction of measurements
	LNAc2a, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA02a)
	LNAc2b, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA02b)

	# 90-190 MHz
	LNA2a = LNAc2a[(fr2/1e6>=flow) & (fr2/1e6<=fhigh)]
	LNA2b = LNAc2b[(fr2/1e6>=flow) & (fr2/1e6<=fhigh)]
	fr2   = fr2[(fr2/1e6>=flow) & (fr2/1e6<=fhigh)]







	# THIRD REPETITION
	# ----------------
	# Reading measurements
	o,   fr3    = rc.s1p_read(path_LNA3 + 'Open.s1p')
	s,   fr3    = rc.s1p_read(path_LNA3 + 'Short.s1p')
	l,   fr3    = rc.s1p_read(path_LNA3 + 'Match.s1p')
	LNA03a, fr3 = rc.s1p_read(path_LNA3 + 'Receiver.s1p')
	LNA03b, fr3 = rc.s1p_read(path_LNA3 + 'Receiver2.s1p')

	# Correction of measurements
	LNAc3a, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA03a)
	LNAc3b, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA03b)

	# 90-190 MHz
	LNA3a = LNAc3a[(fr3/1e6>=flow) & (fr3/1e6<=fhigh)]
	LNA3b = LNAc3b[(fr3/1e6>=flow) & (fr3/1e6<=fhigh)]
	fr3   = fr3[(fr3/1e6>=flow) & (fr3/1e6<=fhigh)]






	# FOURTH REPETITION
	# -----------------
	# Reading measurements
	o,   fr4    = rc.s1p_read(path_LNA4 + 'Open.s1p')
	s,   fr4    = rc.s1p_read(path_LNA4 + 'Short.s1p')
	l,   fr4    = rc.s1p_read(path_LNA4 + 'Match.s1p')
	LNA04a, fr4 = rc.s1p_read(path_LNA4 + 'Receiver.s1p')
	LNA04b, fr4 = rc.s1p_read(path_LNA4 + 'Receiver2.s1p')

	# Correction of measurements
	LNAc4a, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA04a)
	LNAc4b, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA04b)

	# 90-190 MHz
	LNA4a = LNAc4a[(fr4/1e6>=flow) & (fr4/1e6<=fhigh)]
	LNA4b = LNAc4b[(fr4/1e6>=flow) & (fr4/1e6<=fhigh)]
	fr4   = fr4[(fr4/1e6>=flow) & (fr4/1e6<=fhigh)]





	# 1hr REPETITIONS
	# -----------------
	# Reading measurements
	o,   fr     = rc.s1p_read(path_LNA_R1 + 'Open.s1p')
	s,   fr     = rc.s1p_read(path_LNA_R1 + 'Short.s1p')
	l,   fr     = rc.s1p_read(path_LNA_R1 + 'Match.s1p')
	LNA_R01, fr = rc.s1p_read(path_LNA_R1 + 'R01.s1p')
	LNA_R02, fr = rc.s1p_read(path_LNA_R1 + 'R02.s1p')
	LNA_R03, fr = rc.s1p_read(path_LNA_R1 + 'R03.s1p')
	LNA_R04, fr = rc.s1p_read(path_LNA_R1 + 'R04.s1p')
	LNA_R05, fr = rc.s1p_read(path_LNA_R1 + 'R05.s1p')
	LNA_R06, fr = rc.s1p_read(path_LNA_R1 + 'R06.s1p')
	LNA_R07, fr = rc.s1p_read(path_LNA_R1 + 'R07.s1p')
	LNA_R08, fr = rc.s1p_read(path_LNA_R1 + 'R08.s1p')
	LNA_R09, fr = rc.s1p_read(path_LNA_R1 + 'R09.s1p')
	LNA_R10, fr = rc.s1p_read(path_LNA_R1 + 'R10.s1p')
	LNA_R11, fr = rc.s1p_read(path_LNA_R1 + 'R11.s1p')


	# Correction of measurements
	LNAc_R01, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R01)
	LNAc_R02, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R02)
	LNAc_R03, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R03)
	LNAc_R04, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R04)
	LNAc_R05, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R05)
	LNAc_R06, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R06)
	LNAc_R07, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R07)
	LNAc_R08, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R08)
	LNAc_R09, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R09)
	LNAc_R10, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R10)
	LNAc_R11, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R11)


	# 90-190 MHz
	LNAxR01 = LNAc_R01[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAxR02 = LNAc_R02[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAxR03 = LNAc_R03[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAxR04 = LNAc_R04[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAxR05 = LNAc_R05[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAxR06 = LNAc_R06[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAxR07 = LNAc_R07[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAxR08 = LNAc_R08[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAxR09 = LNAc_R09[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAxR10 = LNAc_R10[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAxR11 = LNAc_R11[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	frxR    = fr[(fr/1e6>=flow) & (fr/1e6<=fhigh)]









	# 2hr REPETITIONS
	# -----------------
	# Reading measurements
	o,   fr     = rc.s1p_read(path_LNA_R2 + 'Open.s1p')
	s,   fr     = rc.s1p_read(path_LNA_R2 + 'Short.s1p')
	l,   fr     = rc.s1p_read(path_LNA_R2 + 'Match.s1p')
	LNA_R01, fr = rc.s1p_read(path_LNA_R2 + 'R01.s1p')
	LNA_R02, fr = rc.s1p_read(path_LNA_R2 + 'R02.s1p')
	LNA_R03, fr = rc.s1p_read(path_LNA_R2 + 'R03.s1p')
	LNA_R04, fr = rc.s1p_read(path_LNA_R2 + 'R04.s1p')
	LNA_R05, fr = rc.s1p_read(path_LNA_R2 + 'R05.s1p')
	LNA_R06, fr = rc.s1p_read(path_LNA_R2 + 'R06.s1p')
	LNA_R07, fr = rc.s1p_read(path_LNA_R2 + 'R07.s1p')
	LNA_R08, fr = rc.s1p_read(path_LNA_R2 + 'R08.s1p')
	LNA_R09, fr = rc.s1p_read(path_LNA_R2 + 'R09.s1p')
	LNA_R10, fr = rc.s1p_read(path_LNA_R2 + 'R10.s1p')
	LNA_R11, fr = rc.s1p_read(path_LNA_R2 + 'R11.s1p')
	LNA_R12, fr = rc.s1p_read(path_LNA_R2 + 'R12.s1p')
	LNA_R13, fr = rc.s1p_read(path_LNA_R2 + 'R13.s1p')


	# Correction of measurements
	LNAc_R01, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R01)
	LNAc_R02, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R02)
	LNAc_R03, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R03)
	LNAc_R04, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R04)
	LNAc_R05, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R05)
	LNAc_R06, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R06)
	LNAc_R07, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R07)
	LNAc_R08, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R08)
	LNAc_R09, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R09)
	LNAc_R10, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R10)
	LNAc_R11, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R11)
	LNAc_R12, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R12)
	LNAc_R13, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA_R13)


	# 90-190 MHz
	LNAyR01 = LNAc_R01[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAyR02 = LNAc_R02[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAyR03 = LNAc_R03[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAyR04 = LNAc_R04[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAyR05 = LNAc_R05[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAyR06 = LNAc_R06[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAyR07 = LNAc_R07[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAyR08 = LNAc_R08[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAyR09 = LNAc_R09[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAyR10 = LNAc_R10[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAyR11 = LNAc_R11[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAyR12 = LNAc_R12[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	LNAyR13 = LNAc_R13[(fr/1e6>=flow) & (fr/1e6<=fhigh)]
	fryR    = fr[(fr/1e6>=flow) & (fr/1e6<=fhigh)]








	# Calibration loads
	# -----------------




	# Ambient load before
	# -------------------
	o_m,  f_a1 = rc.s1p_read(path_ambient + 'Open.s1p')
	s_m,  f_a1 = rc.s1p_read(path_ambient + 'Short.s1p')
	l_m,  f_a1 = rc.s1p_read(path_ambient + 'Match.s1p')
	a1_m, f_a1 = rc.s1p_read(path_ambient + 'External.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_a1))
	s_sw = -1 * np.ones(len(f_a1))
	l_sw =  0 * np.ones(len(f_a1))


	# Correction at switch
	a1_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, a1_m)


	# Correction at receiver input
	a1_c, x1, x2, x3 = high_band_switch_correction(a1_sw_c, 25)


	a1  = a1_c[(f_a1/1e6>=flow) & (f_a1/1e6<=fhigh)]
	fa1 = f_a1[(f_a1/1e6>=flow) & (f_a1/1e6<=fhigh)]







	# Ambient load after
	# -------------------
	o_m,  f_a2 = rc.s1p_read(path_ambient + 'Open2.s1p')
	s_m,  f_a2 = rc.s1p_read(path_ambient + 'Short2.s1p')
	l_m,  f_a2 = rc.s1p_read(path_ambient + 'Match2.s1p')
	a2_m, f_a2 = rc.s1p_read(path_ambient + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_a2))
	s_sw = -1 * np.ones(len(f_a2))
	l_sw =  0 * np.ones(len(f_a2))


	# Correction at switch
	a2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, a2_m)


	# Correction at receiver input
	a2_c, x1, x2, x3 = high_band_switch_correction(a2_sw_c, 25)


	a2  = a2_c[(f_a2/1e6>=flow) & (f_a2/1e6<=fhigh)]
	fa2 = f_a2[(f_a2/1e6>=flow) & (f_a2/1e6<=fhigh)]


	# FIRST AMBIENT LOAD IS BEST













	# Hot load before
	# -------------------
	o_m,  f_h1 = rc.s1p_read(path_hot + 'Open.s1p')
	s_m,  f_h1 = rc.s1p_read(path_hot + 'Short.s1p')
	l_m,  f_h1 = rc.s1p_read(path_hot + 'Match.s1p')
	h1_m, f_h1 = rc.s1p_read(path_hot + 'External.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_h1))
	s_sw = -1 * np.ones(len(f_h1))
	l_sw =  0 * np.ones(len(f_h1))


	# Correction at switch
	h1_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, h1_m)


	# Correction at receiver input
	h1_c, x1, x2, x3 = high_band_switch_correction(h1_sw_c, 25)


	h1  = h1_c[(f_h1/1e6>=flow) & (f_h1/1e6<=fhigh)]
	fh1 = f_h1[(f_h1/1e6>=flow) & (f_h1/1e6<=fhigh)]






	# Hot load after
	# -------------------
	o_m,  f_h2 = rc.s1p_read(path_hot + 'Open2.s1p')
	s_m,  f_h2 = rc.s1p_read(path_hot + 'Short2.s1p')
	l_m,  f_h2 = rc.s1p_read(path_hot + 'Match2.s1p')
	h2_m, f_h2 = rc.s1p_read(path_hot + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_h2))
	s_sw = -1 * np.ones(len(f_h2))
	l_sw =  0 * np.ones(len(f_h2))


	# Correction at switch
	h2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, h2_m)


	# Correction at receiver input
	h2_c, x1, x2, x3 = high_band_switch_correction(h2_sw_c, 25)


	h2  = h2_c[(f_h2/1e6>=flow) & (f_h2/1e6<=fhigh)]
	fh2 = f_h2[(f_h2/1e6>=flow) & (f_h2/1e6<=fhigh)]	


	# SECOND HOT LOAD IS BEST











	# SECOND Hot load before
	# -------------------
	o_m,  f_h1 = rc.s1p_read(path_hot_2 + 'Open.s1p')
	s_m,  f_h1 = rc.s1p_read(path_hot_2 + 'Short.s1p')
	l_m,  f_h1 = rc.s1p_read(path_hot_2 + 'Match.s1p')
	h1_m, f_h1 = rc.s1p_read(path_hot_2 + 'External.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_h1))
	s_sw = -1 * np.ones(len(f_h1))
	l_sw =  0 * np.ones(len(f_h1))


	# Correction at switch
	h1_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, h1_m)


	# Correction at receiver input
	h1_c, x1, x2, x3 = high_band_switch_correction(h1_sw_c, 25)


	hr2_1 = h1_c[(f_h1/1e6>=flow) & (f_h1/1e6<=fhigh)]
	fh1   = f_h1[(f_h1/1e6>=flow) & (f_h1/1e6<=fhigh)]






	# SECOND Hot load after
	# -------------------
	o_m,  f_h2 = rc.s1p_read(path_hot_2 + 'Open2.s1p')
	s_m,  f_h2 = rc.s1p_read(path_hot_2 + 'Short2.s1p')
	l_m,  f_h2 = rc.s1p_read(path_hot_2 + 'Match2.s1p')
	h2_m, f_h2 = rc.s1p_read(path_hot_2 + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_h2))
	s_sw = -1 * np.ones(len(f_h2))
	l_sw =  0 * np.ones(len(f_h2))


	# Correction at switch
	h2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, h2_m)


	# Correction at receiver input
	h2_c, x1, x2, x3 = high_band_switch_correction(h2_sw_c, 25)


	hr2_2 = h2_c[(f_h2/1e6>=flow) & (f_h2/1e6<=fhigh)]
	fh2   = f_h2[(f_h2/1e6>=flow) & (f_h2/1e6<=fhigh)]	


	# SECOND HOT LOAD IS BEST

























	# Open Cable before
	# -------------------
	o_m,  f_o1 = rc.s1p_read(path_open + 'Open.s1p')
	s_m,  f_o1 = rc.s1p_read(path_open + 'Short.s1p')
	l_m,  f_o1 = rc.s1p_read(path_open + 'Match.s1p')
	o1_m, f_o1 = rc.s1p_read(path_open + 'External.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_o1))
	s_sw = -1 * np.ones(len(f_o1))
	l_sw =  0 * np.ones(len(f_o1))


	# Correction at switch
	o1_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, o1_m)


	# Correction at receiver input
	o1_c, x1, x2 ,x3 = high_band_switch_correction(o1_sw_c, 25)


	o1  = o1_c[(f_o1/1e6>=flow) & (f_o1/1e6<=fhigh)]
	fo1 = f_o1[(f_o1/1e6>=flow) & (f_o1/1e6<=fhigh)]






	# Open Cable after
	# -------------------
	o_m,  f_o2 = rc.s1p_read(path_open + 'Open2.s1p')
	s_m,  f_o2 = rc.s1p_read(path_open + 'Short2.s1p')
	l_m,  f_o2 = rc.s1p_read(path_open + 'Match2.s1p')
	o2_m, f_o2 = rc.s1p_read(path_open + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_o2))
	s_sw = -1 * np.ones(len(f_o2))
	l_sw =  0 * np.ones(len(f_o2))


	# Correction at switch
	o2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, o2_m)


	# Correction at receiver input
	o2_c, x1, x2, x3 = high_band_switch_correction(o2_sw_c, 25)


	o2  = o2_c[(f_o2/1e6>=flow) & (f_o2/1e6<=fhigh)]
	fo2 = f_o2[(f_o2/1e6>=flow) & (f_o2/1e6<=fhigh)]



	# SECOND OPEN CABLE IS BEST











	# Shorted Cable before
	# -------------------
	o_m,  f_s1 = rc.s1p_read(path_shorted + 'Open.s1p')
	s_m,  f_s1 = rc.s1p_read(path_shorted + 'Short.s1p')
	l_m,  f_s1 = rc.s1p_read(path_shorted + 'Match.s1p')
	s1_m, f_s1 = rc.s1p_read(path_shorted + 'External.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_s1))
	s_sw = -1 * np.ones(len(f_s1))
	l_sw =  0 * np.ones(len(f_s1))


	# Correction at switch
	s1_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, s1_m)


	# Correction at receiver input
	s1_c, x1, x2, x3 = high_band_switch_correction(s1_sw_c, 25)


	s1  = s1_c[(f_s1/1e6>=flow) & (f_s1/1e6<=fhigh)]
	fs1 = f_s1[(f_s1/1e6>=flow) & (f_s1/1e6<=fhigh)]






	# Shorted Cable after
	# -------------------
	o_m,  f_s2 = rc.s1p_read(path_shorted + 'Open2.s1p')
	s_m,  f_s2 = rc.s1p_read(path_shorted + 'Short2.s1p')
	l_m,  f_s2 = rc.s1p_read(path_shorted + 'Match2.s1p')
	s2_m, f_s2 = rc.s1p_read(path_shorted + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_s2))
	s_sw = -1 * np.ones(len(f_s2))
	l_sw =  0 * np.ones(len(f_s2))


	# Correction at switch
	s2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, s2_m)


	# Correction at receiver input
	s2_c, x1, x2, x3 = high_band_switch_correction(s2_sw_c, 25)


	s2  = s2_c[(f_s2/1e6>=flow) & (f_s2/1e6<=fhigh)]
	fs2 = f_s2[(f_s2/1e6>=flow) & (f_s2/1e6<=fhigh)]	



	# SECOND SHORTED CABLE IS BEST











	# Antenna Simulator 2 before
	# --------------------------
	o_m,  f_q21  = rc.s1p_read(path_sim21 + 'Open.s1p')
	s_m,  f_q21  = rc.s1p_read(path_sim21 + 'Short.s1p')
	l_m,  f_q21  = rc.s1p_read(path_sim21 + 'Match.s1p')
	q21_m, f_q21 = rc.s1p_read(path_sim21 + 'External.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_q21))
	s_sw = -1 * np.ones(len(f_q21))
	l_sw =  0 * np.ones(len(f_q21))


	# Correction at switch
	q21_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, q21_m)


	# Correction at receiver input
	q21_c, x1, x2, x3 = high_band_switch_correction(q21_sw_c, 25)


	q21  = q21_c[(f_q21/1e6>=flow) & (f_q21/1e6<=fhigh)]
	fq21 = f_q21[(f_q21/1e6>=flow) & (f_q21/1e6<=fhigh)]





	# Antenna Simulator 2 after
	# -------------------------
	o_m,  f_q22  = rc.s1p_read(path_sim21 + 'Open2.s1p')
	s_m,  f_q22  = rc.s1p_read(path_sim21 + 'Short2.s1p')
	l_m,  f_q22  = rc.s1p_read(path_sim21 + 'Match2.s1p')
	q22_m, f_q22 = rc.s1p_read(path_sim21 + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_q22))
	s_sw = -1 * np.ones(len(f_q22))
	l_sw =  0 * np.ones(len(f_q22))


	# Correction at switch
	q22_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, q22_m)


	# Correction at receiver input
	q22_c, x1, x2, x3 = high_band_switch_correction(q22_sw_c, 25)


	q22  = q22_c[(f_q22/1e6>=flow) & (f_q22/1e6<=fhigh)]
	fq22 = f_q22[(f_q22/1e6>=flow) & (f_q22/1e6<=fhigh)]


	# SECOND ANTSIM2 IS BEST

















	# Antenna Simulator R2 before
	# --------------------------
	o_m,  f_qR21  = rc.s1p_read(path_sim22 + 'Open.s1p')
	s_m,  f_qR21  = rc.s1p_read(path_sim22 + 'Short.s1p')
	l_m,  f_qR21  = rc.s1p_read(path_sim22 + 'Match.s1p')
	qR21_m, f_qR21 = rc.s1p_read(path_sim22 + 'External.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_qR21))
	s_sw = -1 * np.ones(len(f_qR21))
	l_sw =  0 * np.ones(len(f_qR21))


	# Correction at switch
	qR21_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, qR21_m)


	# Correction at receiver input
	qR21_c, x1, x2, x3 = high_band_switch_correction(qR21_sw_c, 25)


	qR21  = qR21_c[(f_qR21/1e6>=flow) & (f_qR21/1e6<=fhigh)]
	fqR21 = f_qR21[(f_qR21/1e6>=flow) & (f_qR21/1e6<=fhigh)]





	# Antenna Simulator R2 after
	# -------------------------
	o_m,  f_qR22  = rc.s1p_read(path_sim22 + 'Open2.s1p')
	s_m,  f_qR22  = rc.s1p_read(path_sim22 + 'Short2.s1p')
	l_m,  f_qR22  = rc.s1p_read(path_sim22 + 'Match2.s1p')
	qR22_m, f_qR22 = rc.s1p_read(path_sim22 + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_qR22))
	s_sw = -1 * np.ones(len(f_qR22))
	l_sw =  0 * np.ones(len(f_qR22))


	# Correction at switch
	qR22_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, qR22_m)


	# Correction at receiver input
	qR22_c, x1, x2, x3 = high_band_switch_correction(qR22_sw_c, 25)


	qR22  = qR22_c[(f_qR22/1e6>=flow) & (f_qR22/1e6<=fhigh)]
	fqR22 = f_qR22[(f_qR22/1e6>=flow) & (f_qR22/1e6<=fhigh)]

	# SECOND ANTSIM2 IS BEST














	# Antenna Simulator REP2 before
	# -----------------------------
	o_m,  f_qREP21  = rc.s1p_read(path_sim2_2 + 'Open.s1p')
	s_m,  f_qREP21  = rc.s1p_read(path_sim2_2 + 'Short.s1p')
	l_m,  f_qREP21  = rc.s1p_read(path_sim2_2 + 'Match.s1p')
	qREP21_m, f_qREP21 = rc.s1p_read(path_sim2_2 + 'External.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_qREP21))
	s_sw = -1 * np.ones(len(f_qREP21))
	l_sw =  0 * np.ones(len(f_qREP21))


	# Correction at switch
	qREP21_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, qREP21_m)


	# Correction at receiver input
	qREP21_c, x1, x2, x3 = high_band_switch_correction(qREP21_sw_c, 25)


	qREP21  = qREP21_c[(f_qREP21/1e6>=flow) & (f_qREP21/1e6<=fhigh)]
	fqREP21 = f_qREP21[(f_qREP21/1e6>=flow) & (f_qREP21/1e6<=fhigh)]





	# Antenna Simulator REP2 after
	# ----------------------------
	o_m,  f_qREP22  = rc.s1p_read(path_sim2_2 + 'Open2.s1p')
	s_m,  f_qREP22  = rc.s1p_read(path_sim2_2 + 'Short2.s1p')
	l_m,  f_qREP22  = rc.s1p_read(path_sim2_2 + 'Match2.s1p')
	qREP22_m, f_qREP22 = rc.s1p_read(path_sim2_2 + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_qREP22))
	s_sw = -1 * np.ones(len(f_qREP22))
	l_sw =  0 * np.ones(len(f_qREP22))


	# Correction at switch
	qREP22_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, qREP22_m)


	# Correction at receiver input
	qREP22_c, x1, x2, x3 = high_band_switch_correction(qREP22_sw_c, 25)


	qREP22  = qREP22_c[(f_qREP22/1e6>=flow) & (f_qREP22/1e6<=fhigh)]
	fqREP22 = f_qREP22[(f_qREP22/1e6>=flow) & (f_qREP22/1e6<=fhigh)]

	# SECOND ANTSIM2 IS BEST

























	# S-parameters of semi-rigid cable
	d = np.genfromtxt(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_march_2015/LNA/S11/corrected_delay/semi_rigid_s_parameters.txt')
	sr_f_raw       = d[:,0]
	sr_s11r_raw    = d[:,1]
	sr_s11i_raw    = d[:,2]
	sr_s12s21r_raw = d[:,3]
	sr_s12s21i_raw = d[:,4]
	sr_s22r_raw    = d[:,5]
	sr_s22i_raw    = d[:,6]

	sr_f       =  sr_f_raw[ (sr_f_raw >= flow)       & (sr_f_raw <= fhigh) ]
	sr_s11r    =  sr_s11r_raw[ (sr_f_raw >= flow)    & (sr_f_raw <= fhigh) ]
	sr_s11i    =  sr_s11i_raw[ (sr_f_raw >= flow)    & (sr_f_raw <= fhigh) ]
	sr_s12s21r =  sr_s12s21r_raw[ (sr_f_raw >= flow) & (sr_f_raw <= fhigh) ]
	sr_s12s21i =  sr_s12s21i_raw[ (sr_f_raw >= flow) & (sr_f_raw <= fhigh) ]
	sr_s22r    =  sr_s22r_raw[ (sr_f_raw >= flow)    & (sr_f_raw <= fhigh) ]
	sr_s22i    =  sr_s22i_raw[ (sr_f_raw >= flow)    & (sr_f_raw <= fhigh) ]



	fnew      = np.arange(flow, fhigh+0.1, 0.25)

	p         = fit_polynomial_fourier('polynomial', (sr_f-140)/60, sr_s11r, 15)
	m_s11r    = model_evaluate('polynomial', p[0], (fnew-140)/60)

	p         = fit_polynomial_fourier('polynomial', (sr_f-140)/60, sr_s11i, 15)
	m_s11i    = model_evaluate('polynomial', p[0], (fnew-140)/60)	

	p         = fit_polynomial_fourier('polynomial', (sr_f-140)/60, sr_s12s21r, 15)
	m_s12s21r = model_evaluate('polynomial', p[0], (fnew-140)/60)	

	p         = fit_polynomial_fourier('polynomial', (sr_f-140)/60, sr_s12s21i, 15)
	m_s12s21i = model_evaluate('polynomial', p[0], (fnew-140)/60)

	p         = fit_polynomial_fourier('polynomial', (sr_f-140)/60, sr_s22r, 15)
	m_s22r    = model_evaluate('polynomial', p[0], (fnew-140)/60)

	p         = fit_polynomial_fourier('polynomial', (sr_f-140)/60, sr_s22i, 15)
	m_s22i    = model_evaluate('polynomial', p[0], (fnew-140)/60)






	# -----------------------------------------------------------------------------------------
	# Output
	temp = np.array([ fr1/1e6, 
	                  np.real(LNAyR13),  np.imag(LNAyR13),
	                  np.real(a1),   np.imag(a1),   np.real(hr2_2),    np.imag(hr2_2),   # the second Hot Load measurement is a little smoother
	                  np.real(o2),   np.imag(o2),   np.real(s2),    np.imag(s2),
	                  m_s11r,        m_s11i,        m_s12s21r,      m_s12s21i,      m_s22r,       m_s22i,
	                  #np.real(q22),  np.imag(q22),  np.real(qR22),  np.imag(qR22) ])         # second round of Sim2 measurements
	                  np.real(qREP21),  np.imag(qREP21),  np.real(qREP22),  np.imag(qREP22) ])
	output_file     = temp.T



	# Saving
	if save == 'yes':	

		# Now, saving data		
		save_path       = home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_high_band_2017_january/LNA/S11/corrected/'
		temperature_LNA = '25degC'
		output_file_str = save_path + 's11_calibration_high_band_LNA' + temperature_LNA + '_' + tt.strftime('%Y-%m-%d-%H-%M-%S') + flag + '.txt'
		np.savetxt(output_file_str, output_file)

		print('File saved to: ' + output_file_str)



	return output_file












































def low_band_switch_correction_june_2016(ant_s11, f_in = np.zeros([0,1]), verification = 'no'):  


	# Loading measurements
	path_folder     = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band2/2016_06_25C/data/s11/raw/receiver_s11_characterization/'
	path_folder_vna = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band2/2016_06_25C/data/s11/raw/reference_attenuators/'


	o_sw_m, f = rc.s1p_read(path_folder + 'switch_pos1_open.s1p')
	s_sw_m, f = rc.s1p_read(path_folder + 'switch_pos2_short.s1p')
	l_sw_m, f = rc.s1p_read(path_folder + 'switch_pos3_load.s1p')

	o_ex,   f = rc.s1p_read(path_folder + 'switch_pos4_external_open_male.s1p')
	s_ex,   f = rc.s1p_read(path_folder + 'switch_pos4_external_short_male.s1p')
	l_ex,   f = rc.s1p_read(path_folder + 'switch_pos4_external_match_male.s1p')

	a6,  f = rc.s1p_read(path_folder + 'switch_pos4_external_verification_6dB_attn.s1p')
	a10, f = rc.s1p_read(path_folder + 'switch_pos4_external_verification_10dB_attn.s1p')
	a12, f = rc.s1p_read(path_folder + 'switch_pos4_external_verification_12dB_attn.s1p')




	# For verification
	o_vna, f_vna = rc.s1p_read(path_folder_vna + 'calibration_male_Open.s1p')
	s_vna, f_vna = rc.s1p_read(path_folder_vna + 'calibration_male_Short.s1p')
	l_vna, f_vna = rc.s1p_read(path_folder_vna + 'calibration_male_Load.s1p')

	a6_vna,  f_vna = rc.s1p_read(path_folder_vna + 'load_06db.s1p')
	a10_vna, f_vna = rc.s1p_read(path_folder_vna + 'load_10db.s1p')
	a12_vna, f_vna = rc.s1p_read(path_folder_vna + 'load_12db.s1p')








	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f))
	s_sw = -1 * np.ones(len(f))
	l_sw =  0 * np.ones(len(f))	




	# Correction at the switch
	o_ex_c, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m, s_sw_m, l_sw_m, o_ex)
	s_ex_c, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m, s_sw_m, l_sw_m, s_ex)
	l_ex_c, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m, s_sw_m, l_sw_m, l_ex)




	# Computation of S-parameters to the receiver input
	resistance_of_match = 50.11 # male
	md = 1
	oa, sa, la = rc.agilent_85033E(f, resistance_of_match, md)

	xx, s11, s12s21, s22 = rc.de_embed(oa, sa, la, o_ex_c, s_ex_c, l_ex_c, o_ex_c)





	# Polynomial fit of S-parameters from "f" to input frequency vector "f_in"
	# ------------------------------------------------------------------------


	# Frequency normalization
	fn = f/75e6

	if len(f_in) > 10:
		if f_in[0] > 1e5:
			fn_in = f_in/75e6
		elif f_in[-1] < 300:
			fn_in = f_in/75
	else:
		fn_in = fn	



	# Real-Imaginary parts
	real_s11    = np.real(s11)
	imag_s11    = np.imag(s11)
	real_s12s21 = np.real(s12s21)
	imag_s12s21 = np.imag(s12s21)
	real_s22    = np.real(s22)
	imag_s22    = np.imag(s22)



	# Polynomial fits
	p = np.polyfit(fn, real_s11, 7)
	fit_real_s11 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s11, 7)
	fit_imag_s11 = np.polyval(p, fn_in)


	p = np.polyfit(fn, real_s12s21, 7)
	fit_real_s12s21 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s12s21, 7)
	fit_imag_s12s21 = np.polyval(p, fn_in)


	p = np.polyfit(fn, real_s22, 7)
	fit_real_s22 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s22, 7)
	fit_imag_s22 = np.polyval(p, fn_in)


	fit_s11    = fit_real_s11    + 1j*fit_imag_s11
	fit_s12s21 = fit_real_s12s21 + 1j*fit_imag_s12s21
	fit_s22    = fit_real_s22    + 1j*fit_imag_s22



	# Corrected antenna S11
	corr_ant_s11 = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, ant_s11)





	# Verification
	if verification == 'yes':

		# Correction at the switch
		a6_sw,  xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m, s_sw_m, l_sw_m, a6)
		a10_sw, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m, s_sw_m, l_sw_m, a10)
		a12_sw, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m, s_sw_m, l_sw_m, a12)		

		a6c  = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, a6_sw)
		a10c = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, a10_sw)
		a12c = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, a12_sw)

		gamma_6dB  = np.ones(len(f)) * rc.impedance2gamma(85.267, 50)
		gamma_10dB = np.ones(len(f)) * rc.impedance2gamma(60.828, 50)

		gamma_6dB_plus   = np.ones(len(f)) * rc.impedance2gamma(85.267+0.01, 50)
		gamma_6dB_minus  = np.ones(len(f)) * rc.impedance2gamma(85.267-0.01, 50)

		gamma_10dB_plus  = np.ones(len(f)) * rc.impedance2gamma(60.828+0.01, 50)
		gamma_10dB_minus = np.ones(len(f)) * rc.impedance2gamma(60.828-0.01, 50)


		# Correction of verification measurements at VNA input
		oa_vna, sa_vna, la_vna = rc.agilent_85033E(f_vna, resistance_of_match, md)
		a6_vna_c,  xx, xx, xx = rc.de_embed(oa_vna, sa_vna, la_vna, o_vna, s_vna, l_vna, a6_vna)
		a10_vna_c, xx, xx, xx = rc.de_embed(oa_vna, sa_vna, la_vna, o_vna, s_vna, l_vna, a10_vna)
		a12_vna_c, xx, xx, xx = rc.de_embed(oa_vna, sa_vna, la_vna, o_vna, s_vna, l_vna, a12_vna)



		# Plot
		plt.close()
		plt.close()
		plt.close()
		plt.close()


		plt.subplot(2,2,1)
		plt.plot(f/1e6, 20*np.log10(np.abs(a6c)))
		plt.plot(f_vna/1e6, 20*np.log10(np.abs(a6_vna_c)))		
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB)), 'r')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB_plus)), 'r--')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB_minus)), 'r--')

		plt.xlim([40, 200])
		plt.ylim([-11.69,-11.66])
		plt.grid()
		plt.legend(['at receiver input','at VNA input','from DC resistance', '+/- 0.01 Ohms'])
		plt.ylabel('6-dB attenuator\n magnitude [dB]')

		ax = plt.gca()
		ax.ticklabel_format(useOffset=False)		



		plt.subplot(2,2,3)
		plt.plot(f/1e6, 20*np.log10(np.abs(a10c)))
		plt.plot(f_vna/1e6, 20*np.log10(np.abs(a10_vna_c)))
		plt.ylim([-20.22,-20.18])
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB)), 'r')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB_plus)), 'r--')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB_minus)), 'r--')

		plt.xlim([40, 200])
		plt.grid()
		plt.xlabel('frequency [MHz]')
		plt.ylabel('10-dB attenuator\n magnitude [dB]')

		ax = plt.gca()
		ax.ticklabel_format(useOffset=False)		



		plt.subplot(2,2,2)
		plt.plot(f/1e6, 20*np.log10(np.abs(a6c)))
		plt.plot(f_vna/1e6, 20*np.log10(np.abs(a6_vna_c)))		
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB)), 'r')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB_plus)), 'r--')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB_minus)), 'r--')
		plt.xlim([50, 100])
		plt.ylim([-11.69,-11.66])
		plt.grid()

		ax = plt.gca()
		ax.ticklabel_format(useOffset=False)		



		plt.subplot(2,2,4)
		plt.plot(f/1e6, 20*np.log10(np.abs(a10c)))
		plt.plot(f_vna/1e6, 20*np.log10(np.abs(a10_vna_c)))
		plt.ylim([-20.22,-20.18])
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB)), 'r')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB_plus)), 'r--')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB_minus)), 'r--')
		plt.xlim([50, 100])
		plt.grid()
		plt.xlabel('frequency [MHz]')		

		ax = plt.gca()
		ax.ticklabel_format(useOffset=False)		




	return (corr_ant_s11, fit_s11, fit_s12s21, fit_s22)



















def low_band_switch_correction_september_2016(ant_s11, f_in = np.zeros([0,1]), verification = 'no'):  


	"""
	This function produces the same correction as "low_band_switch_correction_june_2016", because it is the same receiver and front-end S11 switching circuitry.
	It has not changed at all between june 2016, and september 2016.

	"""


	# Loading measurements
	path_folder     = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band2/2016_09_25C/data/s11/raw/OSLA1A2A3_after_hot_load/'
	path_folder2    = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band2/2016_06_25C/data/s11/raw/receiver_s11_characterization/'
	path_folder_vna = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band2/2016_06_25C/data/s11/raw/reference_attenuators/'



	o_sw_m1, f = rc.s1p_read(path_folder + 'Open/Open_int1.s1p')
	s_sw_m1, f = rc.s1p_read(path_folder + 'Open/Short_int1.s1p')
	l_sw_m1, f = rc.s1p_read(path_folder + 'Open/Match_int1.s1p')

	o_sw_m2, f = rc.s1p_read(path_folder + 'Short/Open_int1.s1p')
	s_sw_m2, f = rc.s1p_read(path_folder + 'Short/Short_int1.s1p')
	l_sw_m2, f = rc.s1p_read(path_folder + 'Short/Match_int1.s1p')	

	o_sw_m3, f = rc.s1p_read(path_folder + 'Match/Open_int1.s1p')
	s_sw_m3, f = rc.s1p_read(path_folder + 'Match/Short_int1.s1p')
	l_sw_m3, f = rc.s1p_read(path_folder + 'Match/Match_int1.s1p')



	o_ex,   f = rc.s1p_read(path_folder + 'Open/External_Open1.s1p')
	s_ex,   f = rc.s1p_read(path_folder + 'Short/External_Short1.s1p')
	l_ex,   f = rc.s1p_read(path_folder + 'Match/External_Match1.s1p')





	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f))
	s_sw = -1 * np.ones(len(f))
	l_sw =  0 * np.ones(len(f))	




	# Correction at the switch
	o_ex_c, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m1, s_sw_m1, l_sw_m1, o_ex)
	s_ex_c, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m2, s_sw_m2, l_sw_m2, s_ex)
	l_ex_c, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m3, s_sw_m3, l_sw_m3, l_ex)




	# Computation of S-parameters to the receiver input
	resistance_of_match = 50.11 # male
	#md = 1
	oa, sa, la = rc.agilent_85033E(f, resistance_of_match)  #, md)

	xx, s11, s12s21, s22 = rc.de_embed(oa, sa, la, o_ex_c, s_ex_c, l_ex_c, o_ex_c)





	# Polynomial fit of S-parameters from "f" to input frequency vector "f_in"
	# ------------------------------------------------------------------------


	# Frequency normalization
	fn = f/75e6

	if len(f_in) > 10:
		if f_in[0] > 1e5:
			fn_in = f_in/75e6
		elif f_in[-1] < 300:
			fn_in = f_in/75
	else:
		fn_in = fn	



	# Real-Imaginary parts
	real_s11    = np.real(s11)
	imag_s11    = np.imag(s11)
	real_s12s21 = np.real(s12s21)
	imag_s12s21 = np.imag(s12s21)
	real_s22    = np.real(s22)
	imag_s22    = np.imag(s22)



	# Polynomial fits
	p = np.polyfit(fn, real_s11, 7)
	fit_real_s11 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s11, 7)
	fit_imag_s11 = np.polyval(p, fn_in)


	p = np.polyfit(fn, real_s12s21, 7)
	fit_real_s12s21 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s12s21, 7)
	fit_imag_s12s21 = np.polyval(p, fn_in)


	p = np.polyfit(fn, real_s22, 7)
	fit_real_s22 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s22, 7)
	fit_imag_s22 = np.polyval(p, fn_in)


	fit_s11    = fit_real_s11    + 1j*fit_imag_s11
	fit_s12s21 = fit_real_s12s21 + 1j*fit_imag_s12s21
	fit_s22    = fit_real_s22    + 1j*fit_imag_s22



	# Corrected antenna S11
	corr_ant_s11 = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, ant_s11)






	return (corr_ant_s11, fit_s11, fit_s12s21, fit_s22)

















































def s11_verification_box_1(DUT_s11, f_in = np.zeros([0,1]), verification = 'no'):  


	# Loading measurements
	path_folder     = home_folder + '/DATA/EDGES/receiver_calibration/calibration_june_2016/LNA/S11/raw/s11_box_characterization/'
	path_folder_vna = home_folder + '/DATA/EDGES/receiver_calibration/calibration_june_2016/LNA/S11/raw/reference_attenuators/'


	o_sw_m, f = rc.s1p_read(path_folder + 'internal_open.s1p')
	s_sw_m, f = rc.s1p_read(path_folder + 'internal_short.s1p')
	l_sw_m, f = rc.s1p_read(path_folder + 'internal_load.s1p')

	o_ex,   f = rc.s1p_read(path_folder + 'DUT_open.s1p')
	s_ex,   f = rc.s1p_read(path_folder + 'DUT_short.s1p')
	l_ex,   f = rc.s1p_read(path_folder + 'DUT_load_50.110.s1p')

	a6,  f = rc.s1p_read(path_folder + 'DUT_6dB_attn.s1p')
	a10, f = rc.s1p_read(path_folder + 'DUT_10dB_attn.s1p')
	a12, f = rc.s1p_read(path_folder + 'DUT_12dB_attn.s1p')




	# For verification
	o_vna, f_vna = rc.s1p_read(path_folder_vna + 'calibration_male_Open.s1p')
	s_vna, f_vna = rc.s1p_read(path_folder_vna + 'calibration_male_Short.s1p')
	l_vna, f_vna = rc.s1p_read(path_folder_vna + 'calibration_male_Load.s1p')

	a6_vna,  f_vna = rc.s1p_read(path_folder_vna + 'load_06db.s1p')
	a10_vna, f_vna = rc.s1p_read(path_folder_vna + 'load_10db.s1p')
	a12_vna, f_vna = rc.s1p_read(path_folder_vna + 'load_12db.s1p')








	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f))
	s_sw = -1 * np.ones(len(f))
	l_sw =  0 * np.ones(len(f))	




	# Correction at the switch
	o_ex_c, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m, s_sw_m, l_sw_m, o_ex)
	s_ex_c, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m, s_sw_m, l_sw_m, s_ex)
	l_ex_c, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m, s_sw_m, l_sw_m, l_ex)




	# Computation of S-parameters to the receiver input
	resistance_of_match = 50.11 # male
	md = 1
	oa, sa, la = rc.agilent_85033E(f, resistance_of_match, md)

	xx, s11, s12s21, s22 = rc.de_embed(oa, sa, la, o_ex_c, s_ex_c, l_ex_c, o_ex_c)





	# Polynomial fit of S-parameters from "f" to input frequency vector "f_in"
	# ------------------------------------------------------------------------


	# Frequency normalization
	fn = f/75e6

	if len(f_in) > 10:
		if f_in[0] > 1e5:
			fn_in = f_in/75e6
		elif f_in < 300:
			fn_in = f_in/75
	else:
		fn_in = fn	



	# Real-Imaginary parts
	real_s11    = np.real(s11)
	imag_s11    = np.imag(s11)
	real_s12s21 = np.real(s12s21)
	imag_s12s21 = np.imag(s12s21)
	real_s22    = np.real(s22)
	imag_s22    = np.imag(s22)



	# Polynomial fits
	p = np.polyfit(fn, real_s11, 7)
	fit_real_s11 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s11, 7)
	fit_imag_s11 = np.polyval(p, fn_in)


	p = np.polyfit(fn, real_s12s21, 7)
	fit_real_s12s21 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s12s21, 7)
	fit_imag_s12s21 = np.polyval(p, fn_in)


	p = np.polyfit(fn, real_s22, 7)
	fit_real_s22 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s22, 7)
	fit_imag_s22 = np.polyval(p, fn_in)


	fit_s11    = fit_real_s11    + 1j*fit_imag_s11
	fit_s12s21 = fit_real_s12s21 + 1j*fit_imag_s12s21
	fit_s22    = fit_real_s22    + 1j*fit_imag_s22



	# Corrected antenna S11
	corr_DUT_s11 = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, DUT_s11)





	# Verification
	if verification == 'yes':

		# Correction at the switch
		a6_sw,  xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m, s_sw_m, l_sw_m, a6)
		a10_sw, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m, s_sw_m, l_sw_m, a10)
		a12_sw, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m, s_sw_m, l_sw_m, a12)		

		a6c  = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, a6_sw)
		a10c = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, a10_sw)
		a12c = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, a12_sw)

		gamma_6dB  = np.ones(len(f)) * rc.impedance2gamma(85.267, 50)
		gamma_10dB = np.ones(len(f)) * rc.impedance2gamma(60.828, 50)

		gamma_6dB_plus   = np.ones(len(f)) * rc.impedance2gamma(85.267+0.01, 50)
		gamma_6dB_minus  = np.ones(len(f)) * rc.impedance2gamma(85.267-0.01, 50)

		gamma_10dB_plus  = np.ones(len(f)) * rc.impedance2gamma(60.828+0.01, 50)
		gamma_10dB_minus = np.ones(len(f)) * rc.impedance2gamma(60.828-0.01, 50)


		# Correction of verification measurements at VNA input
		oa_vna, sa_vna, la_vna = rc.agilent_85033E(f_vna, resistance_of_match, md)
		a6_vna_c,  xx, xx, xx = rc.de_embed(oa_vna, sa_vna, la_vna, o_vna, s_vna, l_vna, a6_vna)
		a10_vna_c, xx, xx, xx = rc.de_embed(oa_vna, sa_vna, la_vna, o_vna, s_vna, l_vna, a10_vna)
		a12_vna_c, xx, xx, xx = rc.de_embed(oa_vna, sa_vna, la_vna, o_vna, s_vna, l_vna, a12_vna)



		# Plots
		plt.close()
		plt.close()
		plt.close()
		plt.close()

		plt.close()
		plt.close()
		plt.close()
		plt.close()

		plt.close()
		plt.close()
		plt.close()
		plt.close()

		plt.close()
		plt.close()
		plt.close()
		plt.close()

		plt.close()
		plt.close()
		plt.close()
		plt.close()






		plt.figure(1)

		plt.subplot(2,3,1)
		plt.plot(f/1e6, 20*np.log10(np.abs(fit_s11)))
		plt.xlim([40, 200])
		plt.grid()
		plt.ylabel('magnitude [dB]')
		plt.title(r'$S_{11}$', fontsize=19)

		plt.subplot(2,3,2)
		plt.plot(f/1e6, 20*np.log10(np.abs(fit_s12s21)))
		plt.xlim([40, 200])
		plt.grid()
		plt.ylabel('magnitude [dB]')
		plt.title(r'$S_{12}S_{21}$', fontsize=19)

		plt.subplot(2,3,3)
		plt.plot(f/1e6, 20*np.log10(np.abs(fit_s22)))
		plt.xlim([40, 200])
		plt.grid()
		plt.ylabel('magnitude [dB]')
		plt.title(r'$S_{22}$', fontsize=19)


		plt.subplot(2,3,4)
		plt.plot(f/1e6, (180/np.pi)*np.unwrap(np.angle(fit_s11)))
		plt.xlim([40, 200])
		plt.grid()
		plt.ylabel('phase [deg]')
		plt.xlabel('frequency [MHz]')

		plt.subplot(2,3,5)
		plt.plot(f/1e6, (180/np.pi)*np.unwrap(np.angle(fit_s12s21)))
		plt.xlim([40, 200])
		plt.grid()
		plt.ylabel('phase [deg]')
		plt.xlabel('frequency [MHz]')

		plt.subplot(2,3,6)
		plt.plot(f/1e6, (180/np.pi)*np.unwrap(np.angle(fit_s22)))
		plt.xlim([40, 200])
		plt.grid()
		plt.ylabel('phase [deg]')
		plt.xlabel('frequency [MHz]')




		plt.figure(2)

		plt.subplot(2,1,1)
		plt.plot(f/1e6, 20*np.log10(np.abs(a6c)), 'm')
		plt.plot(f_vna/1e6, 20*np.log10(np.abs(a6_vna_c)), 'b')		
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB)), 'r')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB_plus)), 'r--')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB_minus)), 'r--')

		plt.xlim([40, 200])
		plt.ylim([-11.69,-11.66])
		plt.grid()
		plt.legend(['at verification box input','at VNA input','from DC resistance', '+/- 0.01 Ohms'])
		plt.ylabel('6-dB attenuator\n magnitude [dB]')

		ax = plt.gca()
		ax.ticklabel_format(useOffset=False)		



		plt.subplot(2,1,2)
		plt.plot(f/1e6, 20*np.log10(np.abs(a10c)), 'm')
		plt.plot(f_vna/1e6, 20*np.log10(np.abs(a10_vna_c)), 'b')
		plt.ylim([-20.22,-20.18])
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB)), 'r')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB_plus)), 'r--')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB_minus)), 'r--')

		plt.xlim([40, 200])
		plt.grid()
		plt.xlabel('frequency [MHz]')
		plt.ylabel('10-dB attenuator\n magnitude [dB]')

		ax = plt.gca()
		ax.ticklabel_format(useOffset=False)		








		plt.figure(3)

		plt.subplot(2,1,1)

		#interp_model = spi.interp1d(f_vna/1e6, (180/np.pi)*np.unwrap(np.angle(a6_vna_c)), kind='cubic')
		#model        = interp_model(f)			

		plt.plot(f/1e6, (180/np.pi)*np.unwrap(np.angle(a6c)) - (180/np.pi)*np.unwrap(np.angle(a6_vna_c)), 'm', linewidth=2)
		plt.plot(f/1e6, (180/np.pi)*np.unwrap(np.angle(a6_vna_c)) - (180/np.pi)*np.unwrap(np.angle(a6_vna_c)), 'b', linewidth=2)

		plt.xlim([40, 200])
		plt.ylim([-0.4, 0.4])
		plt.grid()
		plt.legend(['at verification box input','perfect agreement reference'])
		plt.ylabel('6-dB attenuator' + '\n' + r'$\Delta$ phase [deg]')

		ax = plt.gca()
		ax.ticklabel_format(useOffset=False)		



		plt.subplot(2,1,2)

		#interp_model = spi.interp1d(f_vna/1e6, (180/np.pi)*np.unwrap(np.angle(a10_vna_c)), kind='cubic')
		#model        = interp_model(f)	

		plt.plot(f/1e6, (180/np.pi)*np.unwrap(np.angle(a10c)) - (180/np.pi)*np.unwrap(np.angle(a10_vna_c)), 'm', linewidth=2)
		plt.plot(f/1e6, (180/np.pi)*np.unwrap(np.angle(a10_vna_c)) - (180/np.pi)*np.unwrap(np.angle(a10_vna_c)), 'b', linewidth=2)

		plt.xlim([40, 200])
		plt.ylim([-0.4, 0.4])
		plt.grid()
		plt.xlabel('frequency [MHz]')
		plt.ylabel('10-dB attenuator' + '\n' + r'$\Delta$ phase [deg]')

		ax = plt.gca()
		ax.ticklabel_format(useOffset=False)		





	return f/1e6, (180/np.pi)*np.unwrap(np.angle(a10c)) - (180/np.pi)*np.unwrap(np.angle(a10_vna_c))    #corr_DUT_s11, fit_s11, fit_s12s21, fit_s22











def s11_verification_box_2(long_short_cable = 'long', attenuator_dB = 6, plot = 'no'):



	# Loading measurements
	if (long_short_cable == 'long') and (attenuator_dB == 6):
		path_data = home_folder + '/DATA/EDGES/receiver_calibration/calibration_june_2016/LNA/S11/raw/long_cable_tests/long_cable_test_attenuator_6dB/'

	elif (long_short_cable == 'long') and  (attenuator_dB == 10):
		path_data = home_folder + '/DATA/EDGES/receiver_calibration/calibration_june_2016/LNA/S11/raw/long_cable_tests/long_cable_test_attenuator_10dB/'

	elif (long_short_cable == 'short') and  (attenuator_dB == 6):
		path_data = home_folder + '/DATA/EDGES/receiver_calibration/calibration_june_2016/LNA/S11/raw/long_cable_tests/short_cable_test_attenuator_6dB/'	

	elif (long_short_cable == 'short') and  (attenuator_dB == 10):
		path_data = home_folder + '/DATA/EDGES/receiver_calibration/calibration_june_2016/LNA/S11/raw/long_cable_tests/short_cable_test_attenuator_10dB/'		



	path_folder_vna = home_folder + '/DATA/EDGES/receiver_calibration/calibration_june_2016/LNA/S11/raw/reference_attenuators/'



	# Listing files to be processed
	full_list = listdir(path_data)

	l1 = []
	l2 = []
	l3 = []
	l4 = []		

	for i in range(len(full_list)):

		if "_input1_" in full_list[i]:
			l1.append(full_list[i])

		if "_input2_" in full_list[i]:
			l2.append(full_list[i])

		if "_input3_" in full_list[i]:
			l3.append(full_list[i])	

		if "_input4_" in full_list[i]:
			l4.append(full_list[i])			

	l1_sorted = []
	l2_sorted = []
	l3_sorted = []
	l4_sorted = []	

	lmin = min([len(l1), len(l2), len(l3), len(l4)])

	for j in range(lmin):
		for i in range(lmin):
			if "run_" + str(j+1).zfill(4) + '_' in l1[i]:
				l1_sorted.append(l1[i])


			if "run_" + str(j+1).zfill(4) + '_' in l2[i]:
				l2_sorted.append(l2[i])


			if "run_" + str(j+1).zfill(4) + '_' in l3[i]:
				l3_sorted.append(l3[i])


			if "run_" + str(j+1).zfill(4) + '_' in l4[i]:
				l4_sorted.append(l4[i])


	l = min([len(l1_sorted), len(l2_sorted), len(l3_sorted), len(l4_sorted)])









	# Standards assumed at the switch
	o_sw =  1 * np.ones(151)
	s_sw = -1 * np.ones(151)
	l_sw =  0 * np.ones(151)	









	oraw_array = np.zeros([l, 151]) + 0j
	sraw_array = np.zeros([l, 151]) + 0j
	lraw_array = np.zeros([l, 151]) + 0j
	araw_array = np.zeros([l, 151]) + 0j				

	dd2_all    = np.zeros([l, 151]) + 0j
	dd3_all    = np.zeros([l, 151]) + 0j


	f_s11 = 1e6*np.arange(50,201,1)
	x, s11, s12s21, s22 = s11_verification_box_1(0, f_in = f_s11, verification = 'no')
	for i in range(len(l1_sorted)): #range(100):   

		print('Correcting measurement ' + str(i+1) + ' of ' + str(len(l1_sorted)) + '.' )

		# Reading measurements from ith cycle
		oi, f = rc.s1p_read(path_data + l1_sorted[i])
		si, f = rc.s1p_read(path_data + l2_sorted[i])
		li, f = rc.s1p_read(path_data + l3_sorted[i])
		ai, f = rc.s1p_read(path_data + l4_sorted[i])


		# Appending measurements to arrays
		oraw_array[i,:] = oi
		sraw_array[i,:] = si
		lraw_array[i,:] = li
		araw_array[i,:] = ai


		dd2, x1, x2, x3 = rc.de_embed(o_sw, s_sw, l_sw, oi, si, li, ai)
		dd2_all[i,:] = dd2


		dd3 = rc.gamma_de_embed(s11, s12s21, s22, dd2)
		dd3_all[i,:] = dd3






	# Verification
	gamma_6dB        = np.ones(len(f)) * rc.impedance2gamma(85.267, 50)
	gamma_6dB_plus   = np.ones(len(f)) * rc.impedance2gamma(85.267+0.01, 50)
	gamma_6dB_minus  = np.ones(len(f)) * rc.impedance2gamma(85.267-0.01, 50)

	gamma_10dB       = np.ones(len(f)) * rc.impedance2gamma(60.828, 50)
	gamma_10dB_plus  = np.ones(len(f)) * rc.impedance2gamma(60.828+0.01, 50)
	gamma_10dB_minus = np.ones(len(f)) * rc.impedance2gamma(60.828-0.01, 50)







	# Plot	
	if plot == 'yes':

		plt.close()
		plt.close()
		plt.close()
		plt.close()


		dd3_all_no_outliers = dd3_all[20*np.log10(np.abs(dd3_all[:,0]))<-11.66,:]

		plt.subplot(2,1,1)
		plt.plot(f/1e6, 20*np.log10(np.abs(dd3_all_no_outliers[0,:])), 'g')
		plt.plot(f/1e6, np.mean(20*np.log10(np.abs(dd3_all_no_outliers)), axis=0), 'k', linewidth = 2)
		plt.plot(f/1e6, 20*np.log10(np.abs(dd3_all_no_outliers)).T, 'g')
		plt.plot(f/1e6, np.mean(20*np.log10(np.abs(dd3_all_no_outliers)), axis=0), 'k', linewidth = 2)
		if attenuator_dB == 6:
			plt.ylim([-11.75,-11.65])
			plt.ylabel('6-dB attenuator\n magnitude [dB]')

		elif attenuator_dB == 10:
			plt.ylim([-20.40,-20.10])
			plt.ylabel('10-dB attenuator\n magnitude [dB]')

		plt.legend(['thousands of single traces','average of traces'], loc=0)
		plt.xlim([50, 200])	
		plt.grid()

		ax = plt.gca()
		ax.ticklabel_format(useOffset=False)	






		plt.subplot(2,1,2)		
		plt.plot(f/1e6, np.mean(20*np.log10(np.abs(dd3_all_no_outliers)), axis=0), 'k', linewidth = 2)

		if attenuator_dB == 6:
			plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB)), 'r')
			plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB_plus)), 'r--')
			plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB_minus)), 'r--')		
			plt.ylim([-11.72,-11.67])
			plt.ylabel('6-dB attenuator\n magnitude [dB]')

		elif attenuator_dB == 10:
			plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB)), 'r')
			plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB_plus)), 'r--')
			plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB_minus)), 'r--')			
			plt.ylim([-20.27,-20.18])
			plt.ylabel('10-dB attenuator\n magnitude [dB]')

		plt.legend(['average of traces', 'from DC resistance', '+/- 0.01 Ohms'], loc=0)
		plt.xlabel('frequency [MHz]')	
		plt.xlim([50, 200])
		plt.grid()


		ax = plt.gca()
		ax.ticklabel_format(useOffset=False)		



	return dd3_all, f/1e6













def model_rejection_anastasia_jordan_hyper(f, d, w, model_type='anastasia', fit_type='EDGES_polynomial', flow=90, fhigh=190, nterm_fg=5, binning='no', rfi_removal='no'):
	"""
	model_type: 
	#f, d1, d2, w  = alan_data_averages()

	"""

	if model_type == 'anastasia':
		nmodels = 195
	elif model_type == 'jordan':
		nmodels = 391	



	f0, r0, w0, e0, RMS0 = model_rejection(f, d, w, test_model='no', fit_type=fit_type, flow=90, fhigh=190, nterm_fg=5, binning=binning, rfi_removal=rfi_removal)

	rb_all        = np.zeros((nmodels+1, len(f0)))
	RMS_all       = np.zeros(nmodels+1)
	model_EoR_all = np.zeros((nmodels+1, len(f0)))

	rb_all[0,:]   = r0
	RMS_all[0]    = RMS0







	#for i in [108]:
	for i in range(nmodels):
		print(i)		
		fb, rb, wb, eb, RMS  = model_rejection(f, d, w, test_model='yes', model_type=model_type, anastasia_model_number=i, jordan_model_number=i, fit_type=fit_type, flow=flow, fhigh=fhigh, nterm_fg=nterm_fg, binning=binning, rfi_removal=rfi_removal)

		rb_all[i+1,:]        = rb
		RMS_all[i+1]         = RMS
		model_EoR_all[i+1,:] = eb




	# Degrees of freedom
	degrees_of_freedom = len(r0[w0>0]) - nterm_fg - 1


	# Model for uncertainty Standard Deviation assuming no global signal
	p             = np.polyfit(f0[w0>0]/150, np.abs(r0[w0>0]), 1)
	sigma_model_0 = np.polyval(p, f0/150)	
	chi_sq_0      = np.sum((r0[w0>0]/sigma_model_0[w0>0])**2)
	sigma_model = sigma_model_0 * np.sqrt((chi_sq_0/degrees_of_freedom))


		# Old method, using the average variance 
		# Variance for residuals with no global signal 
		#variance           = np.sum(rb_all[0, wb>0]**2) / len(rb_all[0, wb>0])

		# Chi-Square Goodness of fit for all models
		#chi_sq             = np.sum(rb_all[:, wb>0]**2, axis=1) / variance


	# Chi-Square Goodness of fit for all models
	chi_sq = np.sum((rb_all[:, wb>0]/sigma_model[wb>0])**2, axis=1)



	# Probability for each model to be consistent with the data
	prob = 100*(1-stats.chi2.cdf(chi_sq, degrees_of_freedom))	


	return fb, rb_all, wb, RMS_all, prob, chi_sq, degrees_of_freedom, model_EoR_all, sigma_model



















def calibration_processing_low_band_2016_25degC(flow, fhigh, save='no'):
	"""
	Last modification: August 17, 2016.

	This function produces model parameters for spectra and S11 calibration data corresponding to the low-band 2016 receiver.

	Definition:
	out = calibration_processing_low_band_2016_25degC(flow, fhigh, save='no')

	Input parameters:
	flow: low-frequency limit of the calibration modeling, in MHz
	fhigh: high-frequency limit of the calibration modeling, in MHz
	save: flag for saving parameters. Use save='yes' for saving

	Output parameters:
	out: parameters of spectra and S11 models

	Usage:
	out = calibration_processing_low_band_2016_25degC(50, 100, save='no')
	"""	




	# Paths

	# Paths for source data
	path_spectra    = home_folder + '/DATA/EDGES/spectra/level1/calibration_june_2016/300_350/'
	path_resistance = home_folder + '/DATA/EDGES/receiver_calibration/calibration_june_2016/LNA/resistance/'
	path_s11        = home_folder + '/DATA/EDGES/receiver_calibration/calibration_june_2016/LNA/S11/corrected/'

	# Paths for output parameters
	path_par_temp    = home_folder + '/DATA/EDGES/receiver_calibration/calibration_june_2016/LNA/models/25degC/temp/'
	path_par_spectra = home_folder + '/DATA/EDGES/receiver_calibration/calibration_june_2016/LNA/models/25degC/spectra/'
	path_par_s11     = home_folder + '/DATA/EDGES/receiver_calibration/calibration_june_2016/LNA/models/25degC/s11/'

	# Path for average data
	path_data        = home_folder + '/DATA/EDGES/receiver_calibration/calibration_june_2016/LNA/models/25degC/data/'	








	# Ambient
	file_ambient1 = path_spectra + 'level1_ambient_load_2016_178_00_300_350.mat'
	file_ambient2 = path_spectra + 'level1_ambient_load_2016_179_00_300_350.mat'
	file_ambient3 = path_spectra + 'level1_ambient_load_2016_180_00_300_350.mat'
	spec_ambient  = [file_ambient1, file_ambient2, file_ambient3]
	res_ambient   = path_resistance + 'ambient_load_2016_178_00.txt'



	# Hot
	file_hot1 = path_spectra + 'level1_hot_load_2016_180_01_300_350.mat'
	file_hot2 = path_spectra + 'level1_hot_load_2016_181_00_300_350.mat'
	file_hot3 = path_spectra + 'level1_hot_load_2016_182_00_300_350.mat'
	spec_hot  = [file_hot1, file_hot2, file_hot3]
	res_hot   = path_resistance + 'hot_load_2016_180_01.txt'





	# Open
	file_open1 = path_spectra + 'level1_open_cable_2016_176_04_300_350.mat'
	spec_open  = [file_open1]
	res_open   = path_resistance + 'open_cable_2016_176_04.txt'




	# Short
	file_shorted1 = path_spectra + 'level1_shorted_cable_2016_176_20_300_350.mat'
	file_shorted2 = path_spectra + 'level1_shorted_cable_2016_177_00_300_350.mat'
	spec_shorted  = [file_shorted1, file_shorted2]
	res_shorted   = path_resistance + 'shorted_cable_2016_176_20_to_177_00.txt'










	# Simulator1
	file_sim11 = path_spectra + 'level1_simulator1_2016_182_23_300_350.mat'
	file_sim12 = path_spectra + 'level1_simulator1_2016_183_00_300_350.mat'
	file_sim13 = path_spectra + 'level1_simulator1_2016_184_00_300_350.mat'
	file_sim14 = path_spectra + 'level1_simulator1_2016_185_00_300_350.mat'
	file_sim15 = path_spectra + 'level1_simulator1_2016_186_00_300_350.mat'
	file_sim16 = path_spectra + 'level1_simulator1_2016_187_00_300_350.mat'
	spec_sim1  = [file_sim11, file_sim12, file_sim13, file_sim14, file_sim15, file_sim16]
	res_sim1   = path_resistance + 'simulator1_2016_182_23.txt'



	# Simulator2
	file_sim21 = path_spectra + 'level1_simulator2_2016_187_22_300_350.mat'
	file_sim22 = path_spectra + 'level1_simulator2_2016_188_00_300_350.mat'
	file_sim23 = path_spectra + 'level1_simulator2_2016_189_00_300_350.mat'
	file_sim24 = path_spectra + 'level1_simulator2_2016_190_00_300_350.mat'
	file_sim25 = path_spectra + 'level1_simulator2_2016_191_00_300_350.mat'
	file_sim26 = path_spectra + 'level1_simulator2_2016_192_00_300_350.mat'
	spec_sim2  = [file_sim21, file_sim22, file_sim23, file_sim24, file_sim25, file_sim26]
	res_sim2   = path_resistance + 'simulator2_2016_187_22.txt'




	# Noise source + attenuator + cablebox
	file_nsac1  = path_spectra + 'level1_Alans_board_and_cablebox_2016_207_22_300_350.mat'
	file_nsac2  = path_spectra + 'level1_Alans_board_and_cablebox_2016_208_00_300_350.mat'
	file_nsac3  = path_spectra + 'level1_Alans_board_and_cablebox_2016_209_00_300_350.mat'
	file_nsac4  = path_spectra + 'level1_Alans_board_and_cablebox_2016_210_00_300_350.mat'
	file_nsac5  = path_spectra + 'level1_Alans_board_and_cablebox_2016_211_00_300_350.mat'
	file_nsac6  = path_spectra + 'level1_Alans_board_and_cablebox_2016_212_00_300_350.mat'
	file_nsac7  = path_spectra + 'level1_Alans_board_and_cablebox_2016_213_00_300_350.mat'
	file_nsac8  = path_spectra + 'level1_Alans_board_and_cablebox_2016_214_00_300_350.mat'
	file_nsac9  = path_spectra + 'level1_Alans_board_and_cablebox_2016_215_00_300_350.mat'
	file_nsac10 = path_spectra + 'level1_Alans_board_and_cablebox_2016_216_00_300_350.mat'
	spec_nsac  = [file_nsac1, file_nsac2, file_nsac3, file_nsac4, file_nsac5, file_nsac6, file_nsac7, file_nsac8, file_nsac9, file_nsac10]




	# Noise source + attenuator
	file_nsa1 = path_spectra + 'level1_Alans_board_2016_202_22_300_350.mat'
	file_nsa2 = path_spectra + 'level1_Alans_board_2016_203_00_300_350.mat'
	file_nsa3 = path_spectra + 'level1_Alans_board_2016_204_00_300_350.mat'
	file_nsa4 = path_spectra + 'level1_Alans_board_2016_205_00_300_350.mat'
	file_nsa5 = path_spectra + 'level1_Alans_board_2016_206_00_300_350.mat'
	file_nsa6 = path_spectra + 'level1_Alans_board_2016_207_00_300_350.mat'
	spec_nsa  = [file_nsa1, file_nsa2, file_nsa3, file_nsa4, file_nsa5, file_nsa6]




	# Average calibration spectra / physical temperature
	# Percentage of initial data to leave out
	percent = 5 # 5%

	ssa,    phys_temp_ambient  = average_calibration_spectrum(spec_ambient, res_ambient, 1*percent, plot='no')
	ssh,    phys_temp_hot      = average_calibration_spectrum(spec_hot,     res_hot,     1*percent, plot='no')
	sso,    phys_temp_open     = average_calibration_spectrum(spec_open,    res_open,    1*percent, plot='no')
	sss,    phys_temp_shorted  = average_calibration_spectrum(spec_shorted, res_shorted, 1*percent, plot='no')	
	sss1,   phys_temp_sim1     = average_calibration_spectrum(spec_sim1,    res_sim1,    1*percent, plot='no')
	sss2,   phys_temp_sim2     = average_calibration_spectrum(spec_sim2,    res_sim2,    1*percent, plot='no')
	ssnsac, phys_temp_nsac     = average_calibration_spectrum(spec_nsac,    res_sim1,    1*percent, plot='no')   # resistance file not needed, wrong file used for completeness.
	ssnsa,  phys_temp_nsa      = average_calibration_spectrum(spec_nsa,     res_sim1,    1*percent, plot='no')   # resistance file not needed, wrong file used for completeness.






	# Select frequency range
	ff, ilow, ihigh = frequency_edges(flow, fhigh)
	fe    = ff[ilow:ihigh+1]
	sa    = ssa[ilow:ihigh+1]
	sh    = ssh[ilow:ihigh+1]
	so    = sso[ilow:ihigh+1]
	ss    = sss[ilow:ihigh+1]	
	ss1   = sss1[ilow:ihigh+1]
	ss2   = sss2[ilow:ihigh+1]
	snsac = ssnsac[ilow:ihigh+1]
	snsa  = ssnsa[ilow:ihigh+1]






	# Spectra modeling
	fen = (fe-75)/25


	fit_spec_ambient = fit_polynomial_fourier('fourier',    fen, sa,    7,   plot='no')
	fit_spec_hot     = fit_polynomial_fourier('fourier',    fen, sh,    7,   plot='no')
	fit_spec_open    = fit_polynomial_fourier('fourier',    fen, so,    27,  plot='no')
	fit_spec_shorted = fit_polynomial_fourier('fourier',    fen, ss,    27,  plot='no')
	fit_spec_sim1    = fit_polynomial_fourier('fourier',    fen, ss1,   15,  plot='no')
	fit_spec_sim2    = fit_polynomial_fourier('fourier',    fen, ss2,   15,  plot='no')
	fit_spec_nsac    = fit_polynomial_fourier('fourier',    fen, snsac, 15,  plot='no')
	fit_spec_nsa     = fit_polynomial_fourier('fourier',    fen, snsa,  15,  plot='no')



	model_spec_ambient = model_evaluate('fourier', fit_spec_ambient[0], fen)
	model_spec_hot     = model_evaluate('fourier', fit_spec_hot[0],     fen)
	model_spec_open    = model_evaluate('fourier', fit_spec_open[0],    fen)
	model_spec_shorted = model_evaluate('fourier', fit_spec_shorted[0], fen)
	model_spec_sim1    = model_evaluate('fourier', fit_spec_sim1[0],    fen)
	model_spec_sim2    = model_evaluate('fourier', fit_spec_sim2[0],    fen)
	model_spec_nsac    = model_evaluate('fourier', fit_spec_nsac[0],    fen)
	model_spec_nsa     = model_evaluate('fourier', fit_spec_nsa[0],     fen)








	# Loading S11 data
	s11 = np.genfromtxt(path_s11 + 's11_calibration_low_band_LNA25degC_2016-08-17-10-55-58.txt')
	#s11 = np.genfromtxt(path_s11 + 's11_calibration_low_band_LNA25degC_2016-08-23-11-17-43.txt')
	#s11 = np.genfromtxt(path_s11 + 's11_calibration_low_band_LNA25degC_2016-08-23-11-48-57.txt')

	for i in range(len(s11[:,0])):
		if (s11[i,0] <= flow) and (s11[i+1,0] > flow):
			index_low = i
		if (s11[i-1,0] < fhigh) and (s11[i,0] >= fhigh):
			index_high = i
	index_s11 = np.arange(index_low, index_high+1)




	# Frequency / complex data
	f_s11       = s11[index_s11, 0]

	s11_LNA     = s11[index_s11, 1]  + 1j*s11[index_s11, 2]

	s11_amb     = s11[index_s11, 3]  + 1j*s11[index_s11, 4]
	s11_hot     = s11[index_s11, 5]  + 1j*s11[index_s11, 6]

	s11_open    = s11[index_s11, 7]  + 1j*s11[index_s11, 8]
	s11_shorted = s11[index_s11, 9]  + 1j*s11[index_s11, 10]

	s11_sr      = s11[index_s11, 11] + 1j*s11[index_s11, 12]
	s12s21_sr   = s11[index_s11, 13] + 1j*s11[index_s11, 14]
	s22_sr      = s11[index_s11, 15] + 1j*s11[index_s11, 16]

	s11_simu1   = s11[index_s11, 17] + 1j*s11[index_s11, 18]
	s11_simu2   = s11[index_s11, 19] + 1j*s11[index_s11, 20]

	s11_nsac    = s11[index_s11, 21] + 1j*s11[index_s11, 22]
	s11_nsa     = s11[index_s11, 23] + 1j*s11[index_s11, 24]

	s11_cb      = s11[index_s11, 25] + 1j*s11[index_s11, 26]
	s12s21_cb   = s11[index_s11, 27] + 1j*s11[index_s11, 28]
	s22_cb      = s11[index_s11, 29] + 1j*s11[index_s11, 30]



	# Magnitude / Angle

	# LNA
	s11_LNA_mag     = np.abs(s11_LNA)
	s11_LNA_ang     = np.unwrap(np.angle(s11_LNA))

	# Ambient
	s11_amb_mag     = np.abs(s11_amb)
	s11_amb_ang     = np.unwrap(np.angle(s11_amb))

	# Hot
	s11_hot_mag     = np.abs(s11_hot)
	s11_hot_ang     = np.unwrap(np.angle(s11_hot))

	# Open
	s11_open_mag    = np.abs(s11_open)
	s11_open_ang    = np.unwrap(np.angle(s11_open))

	# Shorted
	s11_shorted_mag = np.abs(s11_shorted)
	s11_shorted_ang = np.unwrap(np.angle(s11_shorted))

	# sr-s11
	s11_sr_mag      = np.abs(s11_sr)
	s11_sr_ang      = np.unwrap(np.angle(s11_sr))

	# sr-s12s21
	s12s21_sr_mag   = np.abs(s12s21_sr)
	s12s21_sr_ang   = np.unwrap(np.angle(s12s21_sr))

	# sr-s22
	s22_sr_mag      = np.abs(s22_sr)
	s22_sr_ang      = np.unwrap(np.angle(s22_sr))

	# Simu1
	s11_simu1_mag   = np.abs(s11_simu1)
	s11_simu1_ang   = np.unwrap(np.angle(s11_simu1))

	# Simu2
	s11_simu2_mag   = np.abs(s11_simu2)
	s11_simu2_ang   = np.unwrap(np.angle(s11_simu2))	

	# Noise source + attenuator + cablebox
	s11_nsac_mag    = np.abs(s11_nsac)
	s11_nsac_ang    = np.unwrap(np.angle(s11_nsac))

	# Noise source + attenuator
	s11_nsa_mag     = np.abs(s11_nsa)
	s11_nsa_ang     = np.unwrap(np.angle(s11_nsa))

	# s11-cablebox
	s11_cb_mag      = np.abs(s11_cb)
	s11_cb_ang      = np.unwrap(np.angle(s11_cb))

	# s11-cablebox
	s12s21_cb_mag   = np.abs(s12s21_cb)
	s12s21_cb_ang   = np.unwrap(np.angle(s12s21_cb))	

	# s11-cablebox
	s22_cb_mag      = np.abs(s22_cb)
	s22_cb_ang      = np.unwrap(np.angle(s22_cb))	







	# Modeling S11

	f_s11n = (f_s11-75)/25

	fit_s11_LNA_mag     = fit_polynomial_fourier('polynomial', f_s11n, s11_LNA_mag,     11, plot='no')  # 
	fit_s11_LNA_ang     = fit_polynomial_fourier('polynomial', f_s11n, s11_LNA_ang,     11, plot='no')  # 

	fit_s11_amb_mag     = fit_polynomial_fourier('fourier',    f_s11n, s11_amb_mag,     27, plot='no')  # 
	fit_s11_amb_ang     = fit_polynomial_fourier('fourier',    f_s11n, s11_amb_ang,     27, plot='no')  # 

	fit_s11_hot_mag     = fit_polynomial_fourier('fourier',    f_s11n, s11_hot_mag,     27, plot='no')  #  
	fit_s11_hot_ang     = fit_polynomial_fourier('fourier',    f_s11n, s11_hot_ang,     27, plot='no')  # 

	fit_s11_open_mag    = fit_polynomial_fourier('fourier',    f_s11n, s11_open_mag,    31, plot='no')  # 27
	fit_s11_open_ang    = fit_polynomial_fourier('fourier',    f_s11n, s11_open_ang,    31, plot='no')  # 27

	fit_s11_shorted_mag = fit_polynomial_fourier('fourier',    f_s11n, s11_shorted_mag, 31, plot='no')  # 27
	fit_s11_shorted_ang = fit_polynomial_fourier('fourier',    f_s11n, s11_shorted_ang, 31, plot='no')  # 27

	fit_s11_sr_mag      = fit_polynomial_fourier('polynomial', f_s11n, s11_sr_mag,       7, plot='no')  # 
	fit_s11_sr_ang      = fit_polynomial_fourier('polynomial', f_s11n, s11_sr_ang,       7, plot='no')  # 

	fit_s12s21_sr_mag   = fit_polynomial_fourier('polynomial', f_s11n, s12s21_sr_mag,   21, plot='no')  # 
	fit_s12s21_sr_ang   = fit_polynomial_fourier('polynomial', f_s11n, s12s21_sr_ang,   21, plot='no')  # 

	fit_s22_sr_mag      = fit_polynomial_fourier('polynomial', f_s11n, s22_sr_mag,       7, plot='no')  # 
	fit_s22_sr_ang      = fit_polynomial_fourier('polynomial', f_s11n, s22_sr_ang,       7, plot='no')  # 

	fit_s11_simu1_mag   = fit_polynomial_fourier('polynomial', f_s11n, s11_simu1_mag,    9, plot='no')  # 7
	fit_s11_simu1_ang   = fit_polynomial_fourier('polynomial', f_s11n, s11_simu1_ang,    9, plot='no')  # 7

	fit_s11_simu2_mag   = fit_polynomial_fourier('polynomial', f_s11n, s11_simu2_mag,    9, plot='no')  # 7
	fit_s11_simu2_ang   = fit_polynomial_fourier('polynomial', f_s11n, s11_simu2_ang,    9, plot='no')  # 7	

	fit_s11_nsac_mag    = fit_polynomial_fourier('polynomial', f_s11n, s11_nsac_mag,     7, plot='no')
	fit_s11_nsac_ang    = fit_polynomial_fourier('polynomial', f_s11n, s11_nsac_ang,     7, plot='no')

	fit_s11_nsa_mag     = fit_polynomial_fourier('polynomial', f_s11n, s11_nsa_mag,      7, plot='no')
	fit_s11_nsa_ang     = fit_polynomial_fourier('polynomial', f_s11n, s11_nsa_ang,      7, plot='no')

	fit_s11_cb_mag      = fit_polynomial_fourier('polynomial', f_s11n, s11_cb_mag,       7, plot='no')
	fit_s11_cb_ang      = fit_polynomial_fourier('polynomial', f_s11n, s11_cb_ang,       7, plot='no')

	fit_s12s21_cb_mag   = fit_polynomial_fourier('polynomial', f_s11n, s12s21_cb_mag,    7, plot='no')
	fit_s12s21_cb_ang   = fit_polynomial_fourier('polynomial', f_s11n, s12s21_cb_ang,    7, plot='no')

	fit_s22_cb_mag      = fit_polynomial_fourier('polynomial', f_s11n, s22_cb_mag,       7, plot='no')
	fit_s22_cb_ang      = fit_polynomial_fourier('polynomial', f_s11n, s22_cb_ang,       7, plot='no')





	#plt.close()
	#plt.close()
	#plt.close()
	#plt.close()
	#plt.close()
	#plt.close()
	#plt.close()
	#plt.close()	


	#plt.figure(1)
	#plt.subplot(3,1,1)
	#plt.plot(fe, so)
	#plt.plot(fe, ss)	
	#plt.grid()
	#plt.ylabel('T [K]')

	#plt.subplot(3,1,2)
	#plt.plot(fe, so-model_spec_open)
	#plt.ylim([-0.3, 0.3])
	#plt.grid()
	#plt.ylabel('$\Delta$ T [K]')

	#plt.subplot(3,1,3)
	#plt.plot(fe, ss-model_spec_shorted, 'g')
	#plt.ylim([-0.3, 0.3])
	#plt.grid()
	#plt.xlabel('frequency [MHz]')
	#plt.ylabel('$\Delta$ T [K]')	





	#plt.figure(2)
	#plt.subplot(4,1,1)
	#plt.plot(fe, sa)	
	#plt.grid()
	#plt.ylabel('T [K]')

	#plt.subplot(4,1,2)
	#plt.plot(fe, sh)	
	#plt.grid()
	#plt.ylabel('T [K]')	

	#plt.subplot(4,1,3)
	#plt.plot(fe, sa-model_spec_ambient)
	#plt.grid()
	#plt.ylabel('$\Delta$ T [K]')

	#plt.subplot(4,1,4)
	#plt.plot(fe, sh-model_spec_hot)
	#plt.grid()
	#plt.ylabel('$\Delta$ T [K]')	



	#plt.figure(3)
	#plt.subplot(4,1,1)
	#plt.plot(fe, ss1)	
	#plt.grid()
	#plt.ylabel('T [K]')

	#plt.subplot(4,1,2)
	#plt.plot(fe, ss1-model_spec_sim1)
	#plt.grid()
	#plt.ylabel('$\Delta$ T [K]')

	#plt.subplot(4,1,3)
	#plt.plot(fe, ss2)	
	#plt.grid()
	#plt.ylabel('T [K]')

	#plt.subplot(4,1,4)
	#plt.plot(fe, ss2-model_spec_sim2)
	#plt.grid()
	#plt.ylabel('$\Delta$ T [K]')





	#plt.figure(4)
	#plt.subplot(4,1,1)
	#plt.plot(fe, snsa)	
	#plt.grid()
	#plt.ylabel('T [K]')

	#plt.subplot(4,1,2)
	#plt.plot(fe, snsa-model_spec_nsa)
	#plt.grid()
	#plt.ylabel('$\Delta$ T [K]')

	#plt.subplot(4,1,3)
	#plt.plot(fe, snsac)	
	#plt.grid()
	#plt.ylabel('T [K]')

	#plt.subplot(4,1,4)
	#plt.plot(fe, snsac-model_spec_nsac)
	#plt.grid()
	#plt.ylabel('$\Delta$ T [K]')



	#print(phys_temp_open)
	#print(phys_temp_shorted)
	#print(phys_temp_ambient)
	#print(phys_temp_hot)
	#print(phys_temp_sim1)
	#print(phys_temp_sim2)









	# Saving output parameters
	if save == 'yes':


		# Average spectra data in frequency range selected
		spectra = np.array([fe, sa, sh, so, ss, ss1, ss2, snsa, snsac]).T		

		# RMS residuals
		RMS_spectra = np.zeros((8,1))
		RMS_s11     = np.zeros((30,1))

		# Spectra
		RMS_spectra[0, 0] = fit_spec_ambient[2]
		RMS_spectra[1, 0] = fit_spec_hot[2]
		RMS_spectra[2, 0] = fit_spec_open[2]
		RMS_spectra[3, 0] = fit_spec_shorted[2]
		RMS_spectra[4, 0] = fit_spec_sim1[2]
		RMS_spectra[5, 0] = fit_spec_sim2[2]
		RMS_spectra[6, 0] = fit_spec_nsac[2]
		RMS_spectra[7, 0] = fit_spec_nsa[2]


		# S11
		RMS_s11[0, 0]  = fit_s11_LNA_mag[2]
		RMS_s11[1, 0]  = fit_s11_LNA_ang[2]
		RMS_s11[2, 0]  = fit_s11_amb_mag[2]
		RMS_s11[3, 0]  = fit_s11_amb_ang[2]
		RMS_s11[4, 0]  = fit_s11_hot_mag[2]
		RMS_s11[5, 0]  = fit_s11_hot_ang[2]
		RMS_s11[6, 0]  = fit_s11_open_mag[2]
		RMS_s11[7, 0]  = fit_s11_open_ang[2]
		RMS_s11[8, 0]  = fit_s11_shorted_mag[2]
		RMS_s11[9, 0]  = fit_s11_shorted_ang[2]
		RMS_s11[10, 0] = fit_s11_sr_mag[2]
		RMS_s11[11, 0] = fit_s11_sr_ang[2]
		RMS_s11[12, 0] = fit_s12s21_sr_mag[2]
		RMS_s11[13, 0] = fit_s12s21_sr_ang[2]
		RMS_s11[14, 0] = fit_s22_sr_mag[2]
		RMS_s11[15, 0] = fit_s22_sr_ang[2]
		RMS_s11[16, 0] = fit_s11_simu1_mag[2]
		RMS_s11[17, 0] = fit_s11_simu1_ang[2]
		RMS_s11[18, 0] = fit_s11_simu2_mag[2]
		RMS_s11[19, 0] = fit_s11_simu2_ang[2]

		RMS_s11[20, 0] = fit_s11_nsac_mag[2]
		RMS_s11[21, 0] = fit_s11_nsac_ang[2]
		RMS_s11[22, 0] = fit_s11_nsa_mag[2]
		RMS_s11[23, 0] = fit_s11_nsa_ang[2]
		RMS_s11[24, 0] = fit_s11_cb_mag[2]
		RMS_s11[25, 0] = fit_s11_cb_ang[2]
		RMS_s11[26, 0] = fit_s12s21_cb_mag[2]
		RMS_s11[27, 0] = fit_s12s21_cb_ang[2]
		RMS_s11[28, 0] = fit_s22_cb_mag[2]
		RMS_s11[29, 0] = fit_s22_cb_ang[2]



		# Formating fit parameters

		# Physical temperature
		phys_temp = np.zeros((6,1))
		phys_temp[0,0] = phys_temp_ambient
		phys_temp[1,0] = phys_temp_hot
		phys_temp[2,0] = phys_temp_open
		phys_temp[3,0] = phys_temp_shorted
		phys_temp[4,0] = phys_temp_sim1
		phys_temp[5,0] = phys_temp_sim2		


		# Spectra
		par_spec_ambient    = np.reshape(fit_spec_ambient[0],    (-1,1))
		par_spec_hot        = np.reshape(fit_spec_hot[0],        (-1,1))
		par_spec_open       = np.reshape(fit_spec_open[0],       (-1,1))
		par_spec_shorted    = np.reshape(fit_spec_shorted[0],    (-1,1))
		par_spec_sim1       = np.reshape(fit_spec_sim1[0],       (-1,1))
		par_spec_sim2       = np.reshape(fit_spec_sim2[0],       (-1,1))
		par_spec_nsac       = np.reshape(fit_spec_nsac[0],       (-1,1))
		par_spec_nsa        = np.reshape(fit_spec_nsa[0],        (-1,1))


		# S11
		par_s11_LNA_mag     = np.reshape(fit_s11_LNA_mag[0],     (-1,1))
		par_s11_LNA_ang     = np.reshape(fit_s11_LNA_ang[0],     (-1,1))
		par_s11_amb_mag     = np.reshape(fit_s11_amb_mag[0],     (-1,1))
		par_s11_amb_ang     = np.reshape(fit_s11_amb_ang[0],     (-1,1))
		par_s11_hot_mag     = np.reshape(fit_s11_hot_mag[0],     (-1,1))
		par_s11_hot_ang     = np.reshape(fit_s11_hot_ang[0],     (-1,1))
		par_s11_open_mag    = np.reshape(fit_s11_open_mag[0],    (-1,1))
		par_s11_open_ang    = np.reshape(fit_s11_open_ang[0],    (-1,1))
		par_s11_shorted_mag = np.reshape(fit_s11_shorted_mag[0], (-1,1))
		par_s11_shorted_ang = np.reshape(fit_s11_shorted_ang[0], (-1,1))

		par_s11_sr_mag      = np.reshape(fit_s11_sr_mag[0],      (-1,1))
		par_s11_sr_ang      = np.reshape(fit_s11_sr_ang[0],      (-1,1))
		par_s12s21_sr_mag   = np.reshape(fit_s12s21_sr_mag[0],   (-1,1))
		par_s12s21_sr_ang   = np.reshape(fit_s12s21_sr_ang[0],   (-1,1))
		par_s22_sr_mag      = np.reshape(fit_s22_sr_mag[0],      (-1,1))
		par_s22_sr_ang      = np.reshape(fit_s22_sr_ang[0],      (-1,1))

		par_s11_simu1_mag   = np.reshape(fit_s11_simu1_mag[0],   (-1,1))
		par_s11_simu1_ang   = np.reshape(fit_s11_simu1_ang[0],   (-1,1))
		par_s11_simu2_mag   = np.reshape(fit_s11_simu2_mag[0],   (-1,1))
		par_s11_simu2_ang   = np.reshape(fit_s11_simu2_ang[0],   (-1,1))

		par_s11_nsac_mag    = np.reshape(fit_s11_nsac_mag[0],   (-1,1))
		par_s11_nsac_ang    = np.reshape(fit_s11_nsac_ang[0],   (-1,1))
		par_s11_nsa_mag     = np.reshape(fit_s11_nsa_mag[0],    (-1,1))
		par_s11_nsa_ang     = np.reshape(fit_s11_nsa_ang[0],    (-1,1))		

		par_s11_cb_mag      = np.reshape(fit_s11_cb_mag[0],   (-1,1))
		par_s11_cb_ang      = np.reshape(fit_s11_cb_ang[0],   (-1,1))
		par_s12s21_cb_mag   = np.reshape(fit_s12s21_cb_mag[0],   (-1,1))
		par_s12s21_cb_ang   = np.reshape(fit_s12s21_cb_ang[0],   (-1,1))		
		par_s22_cb_mag      = np.reshape(fit_s22_cb_mag[0],   (-1,1))
		par_s22_cb_ang      = np.reshape(fit_s22_cb_ang[0],   (-1,1))		




		# Saving

		np.savetxt(path_data + 'average_spectra_300_350.txt', spectra)

		np.savetxt(path_par_temp    + 'physical_temperatures.txt', phys_temp)

		np.savetxt(path_par_spectra + 'par_spec_amb.txt',     par_spec_ambient)
		np.savetxt(path_par_spectra + 'par_spec_hot.txt',     par_spec_hot)
		np.savetxt(path_par_spectra + 'par_spec_open.txt',    par_spec_open)
		np.savetxt(path_par_spectra + 'par_spec_shorted.txt', par_spec_shorted)
		np.savetxt(path_par_spectra + 'par_spec_simu1.txt',   par_spec_sim1)
		np.savetxt(path_par_spectra + 'par_spec_simu2.txt',   par_spec_sim2)
		np.savetxt(path_par_spectra + 'par_spec_nsac.txt',    par_spec_nsac)
		np.savetxt(path_par_spectra + 'par_spec_nsa.txt',     par_spec_nsa)		
		np.savetxt(path_par_spectra + 'RMS_spec.txt',         RMS_spectra)

		np.savetxt(path_par_s11 + 'par_s11_LNA_mag.txt',      par_s11_LNA_mag)
		np.savetxt(path_par_s11 + 'par_s11_LNA_ang.txt',      par_s11_LNA_ang)
		np.savetxt(path_par_s11 + 'par_s11_amb_mag.txt',      par_s11_amb_mag)
		np.savetxt(path_par_s11 + 'par_s11_amb_ang.txt',      par_s11_amb_ang)
		np.savetxt(path_par_s11 + 'par_s11_hot_mag.txt',      par_s11_hot_mag)
		np.savetxt(path_par_s11 + 'par_s11_hot_ang.txt',      par_s11_hot_ang)
		np.savetxt(path_par_s11 + 'par_s11_open_mag.txt',     par_s11_open_mag)
		np.savetxt(path_par_s11 + 'par_s11_open_ang.txt',     par_s11_open_ang)
		np.savetxt(path_par_s11 + 'par_s11_shorted_mag.txt',  par_s11_shorted_mag)
		np.savetxt(path_par_s11 + 'par_s11_shorted_ang.txt',  par_s11_shorted_ang)

		np.savetxt(path_par_s11 + 'par_s11_sr_mag.txt',       par_s11_sr_mag)
		np.savetxt(path_par_s11 + 'par_s11_sr_ang.txt',       par_s11_sr_ang)
		np.savetxt(path_par_s11 + 'par_s12s21_sr_mag.txt',    par_s12s21_sr_mag)
		np.savetxt(path_par_s11 + 'par_s12s21_sr_ang.txt',    par_s12s21_sr_ang)
		np.savetxt(path_par_s11 + 'par_s22_sr_mag.txt',       par_s22_sr_mag)
		np.savetxt(path_par_s11 + 'par_s22_sr_ang.txt',       par_s22_sr_ang)

		np.savetxt(path_par_s11 + 'par_s11_simu1_mag.txt',    par_s11_simu1_mag)
		np.savetxt(path_par_s11 + 'par_s11_simu1_ang.txt',    par_s11_simu1_ang)
		np.savetxt(path_par_s11 + 'par_s11_simu2_mag.txt',    par_s11_simu2_mag)
		np.savetxt(path_par_s11 + 'par_s11_simu2_ang.txt',    par_s11_simu2_ang)

		np.savetxt(path_par_s11 + 'par_s11_nsac_mag.txt',     par_s11_nsac_mag)
		np.savetxt(path_par_s11 + 'par_s11_nsac_ang.txt',     par_s11_nsac_ang)
		np.savetxt(path_par_s11 + 'par_s11_nsa_mag.txt',      par_s11_nsa_mag)
		np.savetxt(path_par_s11 + 'par_s11_nsa_ang.txt',      par_s11_nsa_ang)

		np.savetxt(path_par_s11 + 'par_s11_cb_mag.txt',       par_s11_cb_mag)
		np.savetxt(path_par_s11 + 'par_s11_cb_ang.txt',       par_s11_cb_ang)
		np.savetxt(path_par_s11 + 'par_s12s21_cb_mag.txt',    par_s12s21_cb_mag)
		np.savetxt(path_par_s11 + 'par_s12s21_cb_ang.txt',    par_s12s21_cb_ang)
		np.savetxt(path_par_s11 + 'par_s22_cb_mag.txt',       par_s22_cb_mag)
		np.savetxt(path_par_s11 + 'par_s22_cb_ang.txt',       par_s22_cb_ang)		




		np.savetxt(path_par_s11 + 'RMS_s11.txt',       	      RMS_s11)


	# End
	print('Files processed.')



	return 1






























def calibration_processing_low_band_june_2016_25Credo(flow, fhigh, save='no'):
	"""
	Last modification: August 25, 2016.

	This function produces model parameters for spectra and S11 calibration data corresponding to the low-band 2016 receiver.

	Definition:
	out = calibration_processing_low_band_2016_25dCredo(flow, fhigh, save='no')

	Input parameters:
	flow: low-frequency limit of the calibration modeling, in MHz
	fhigh: high-frequency limit of the calibration modeling, in MHz
	save: flag for saving parameters. Use save='yes' for saving

	Output parameters:
	out: parameters of spectra and S11 models

	Usage:
	out = calibration_processing_low_band_2016_25Credo(50, 100, save='no')
	"""	




	# Paths

	# Paths for source data
	path_spectra    = home_folder + '/DATA/EDGES/spectra/level1/calibration_june_2016/300_350/'
	path_resistance = home_folder + '/DATA/EDGES/receiver_calibration/calibration_june_2016/LNA/resistance/'
	path_s11        = home_folder + '/DATA/EDGES/receiver_calibration/calibration_june_2016/LNA/S11/corrected/'

	# Paths for output parameters
	path_par_temp    = home_folder + '/DATA/EDGES/receiver_calibration/calibration_june_2016/LNA/models/25degC/temp/'
	path_par_spectra = home_folder + '/DATA/EDGES/receiver_calibration/calibration_june_2016/LNA/models/25degC/spectra/'
	path_par_s11     = home_folder + '/DATA/EDGES/receiver_calibration/calibration_june_2016/LNA/models/25degC/s11/'

	# Path for average data
	path_data        = home_folder + '/DATA/EDGES/receiver_calibration/calibration_june_2016/LNA/models/25degC/data/'	








	# Ambient
	file_ambient1 = path_spectra + 'level1_ambient_2016_236_20_300_350.mat'
	file_ambient2 = path_spectra + 'level1_ambient_2016_237_00_300_350.mat'
	spec_ambient  = [file_ambient1, file_ambient2]
	res_ambient   = path_resistance + 'ambient_load_2016_236_20.txt'


	# Hot
	file_hot1 = path_spectra + 'level1_hot_2016_237_02_300_350.mat'
	spec_hot  = [file_hot1]
	res_hot   = path_resistance + 'hot_load_2016_237_02.txt'





	# Open
	file_open1 = path_spectra + 'level1_open_cable_2016_232_05_300_350.mat'
	spec_open  = [file_open1]
	res_open   = path_resistance + 'open_cable_2016_232_05.txt'


	# Short
	file_shorted1 = path_spectra + 'level1_shorted_cable2_2016_235_23_300_350.mat'
	file_shorted2 = path_spectra + 'level1_shorted_cable2_2016_236_00_300_350.mat'
	spec_shorted  = [file_shorted1, file_shorted2]
	res_shorted   = path_resistance + 'shorted_cable_2016_235_23.txt'





	# Simulator1
	file_sim11 = path_spectra + 'level1_terminated_cable_2016_232_18_300_350.mat'
	file_sim12 = path_spectra + 'level1_terminated_cable_2016_233_00_300_350.mat'
	spec_sim1  = [file_sim11, file_sim12]
	res_sim1   = path_resistance + 'terminated_cable_2016_232_18.txt'


	# Simulator2
	file_sim21 = path_spectra + 'level1_Sim2_2016_233_05_300_350.mat'
	file_sim22 = path_spectra + 'level1_Sim2_2016_234_00_300_350.mat'
	file_sim23 = path_spectra + 'level1_Sim2_2016_235_00_300_350.mat'
	spec_sim2  = [file_sim21, file_sim22, file_sim23]
	res_sim2   = path_resistance + 'simulator2_2016_233_05.txt'









	# Average calibration spectra / physical temperature
	# Percentage of initial data to leave out
	percent = 5 # 5%

	ssa,    phys_temp_ambient  = average_calibration_spectrum(spec_ambient, res_ambient, 1*percent, plot='no')
	ssh,    phys_temp_hot      = average_calibration_spectrum(spec_hot,     res_hot,     6*percent, plot='no')
	sso,    phys_temp_open     = average_calibration_spectrum(spec_open,    res_open,    1*percent, plot='no')
	sss,    phys_temp_shorted  = average_calibration_spectrum(spec_shorted, res_shorted, 1*percent, plot='no')	
	sss1,   phys_temp_sim1     = average_calibration_spectrum(spec_sim1,    res_sim1,    1*percent, plot='no')
	sss2,   phys_temp_sim2     = average_calibration_spectrum(spec_sim2,    res_sim2,    1*percent, plot='no')






	# Select frequency range
	ff, ilow, ihigh = frequency_edges(flow, fhigh)
	fe    = ff[ilow:ihigh+1]
	sa    = ssa[ilow:ihigh+1]
	sh    = ssh[ilow:ihigh+1]
	so    = sso[ilow:ihigh+1]
	ss    = sss[ilow:ihigh+1]	
	ss1   = sss1[ilow:ihigh+1]
	ss2   = sss2[ilow:ihigh+1]






	# Spectra modeling
	fen = (fe-75)/25


	fit_spec_ambient = fit_polynomial_fourier('fourier',    fen, sa,    7,   plot='no')
	fit_spec_hot     = fit_polynomial_fourier('fourier',    fen, sh,    7,   plot='no')
	fit_spec_open    = fit_polynomial_fourier('fourier',    fen, so,    27,  plot='no')
	fit_spec_shorted = fit_polynomial_fourier('fourier',    fen, ss,    27,  plot='no')
	fit_spec_sim1    = fit_polynomial_fourier('fourier',    fen, ss1,   15,  plot='no')
	fit_spec_sim2    = fit_polynomial_fourier('fourier',    fen, ss2,   15,  plot='no')



	model_spec_ambient = model_evaluate('fourier', fit_spec_ambient[0], fen)
	model_spec_hot     = model_evaluate('fourier', fit_spec_hot[0],     fen)
	model_spec_open    = model_evaluate('fourier', fit_spec_open[0],    fen)
	model_spec_shorted = model_evaluate('fourier', fit_spec_shorted[0], fen)
	model_spec_sim1    = model_evaluate('fourier', fit_spec_sim1[0],    fen)
	model_spec_sim2    = model_evaluate('fourier', fit_spec_sim2[0],    fen)








	# Loading S11 data
	#s11 = np.genfromtxt(path_s11 + 's11_calibration_low_band_LNA25degC_2016-08-25-00-32-52.txt')
	#s11 = np.genfromtxt(path_s11 + 's11_calibration_low_band_LNA25degC_2016-08-25-00-38-58_LNA2.txt')
	#s11 = np.genfromtxt(path_s11 + 's11_calibration_low_band_LNA25degC_2016-08-25-00-40-19_LNA3.txt')
	#s11 = np.genfromtxt(path_s11 + 's11_calibration_low_band_LNA25degC_2016-08-25-21-12-29_LNA4.txt')
	#s11 = np.genfromtxt(path_s11 + 's11_calibration_low_band_LNA25degC_2016-08-25-21-13-16_LNA5.txt')

	#s11 = np.genfromtxt(path_s11 + 's11_calibration_low_band_LNA25degC_2016-08-25-19-44-44_open_cable_2.txt')
	#s11 = np.genfromtxt(path_s11 + 's11_calibration_low_band_LNA25degC_2016-08-25-20-02-52_shorted_cable_2.txt')

	#s11 = np.genfromtxt(path_s11 + 's11_calibration_low_band_LNA25degC_2016-08-25-20-13-19_sim2_2.txt')

	s11 = np.genfromtxt(path_s11 + 's11_calibration_low_band_LNA25degC_2016-08-25-20-17-13_25Credo_best.txt')

	for i in range(len(s11[:,0])):
		if (s11[i,0] <= flow) and (s11[i+1,0] > flow):
			index_low = i
		if (s11[i-1,0] < fhigh) and (s11[i,0] >= fhigh):
			index_high = i
	index_s11 = np.arange(index_low, index_high+1)




	# Frequency / complex data
	f_s11       = s11[index_s11, 0]

	s11_LNA     = s11[index_s11, 1]  + 1j*s11[index_s11, 2]

	s11_amb     = s11[index_s11, 3]  + 1j*s11[index_s11, 4]
	s11_hot     = s11[index_s11, 5]  + 1j*s11[index_s11, 6]

	s11_open    = s11[index_s11, 7]  + 1j*s11[index_s11, 8]
	s11_shorted = s11[index_s11, 9]  + 1j*s11[index_s11, 10]

	s11_sr      = s11[index_s11, 11] + 1j*s11[index_s11, 12]
	s12s21_sr   = s11[index_s11, 13] + 1j*s11[index_s11, 14]
	s22_sr      = s11[index_s11, 15] + 1j*s11[index_s11, 16]

	s11_simu1   = s11[index_s11, 17] + 1j*s11[index_s11, 18]
	s11_simu2   = s11[index_s11, 19] + 1j*s11[index_s11, 20]




	# Magnitude / Angle

	# LNA
	s11_LNA_mag     = np.abs(s11_LNA)
	s11_LNA_ang     = np.unwrap(np.angle(s11_LNA))

	# Ambient
	s11_amb_mag     = np.abs(s11_amb)
	s11_amb_ang     = np.unwrap(np.angle(s11_amb))

	# Hot
	s11_hot_mag     = np.abs(s11_hot)
	s11_hot_ang     = np.unwrap(np.angle(s11_hot))

	# Open
	s11_open_mag    = np.abs(s11_open)
	s11_open_ang    = np.unwrap(np.angle(s11_open))

	# Shorted
	s11_shorted_mag = np.abs(s11_shorted)
	s11_shorted_ang = np.unwrap(np.angle(s11_shorted))

	# sr-s11
	s11_sr_mag      = np.abs(s11_sr)
	s11_sr_ang      = np.unwrap(np.angle(s11_sr))

	# sr-s12s21
	s12s21_sr_mag   = np.abs(s12s21_sr)
	s12s21_sr_ang   = np.unwrap(np.angle(s12s21_sr))

	# sr-s22
	s22_sr_mag      = np.abs(s22_sr)
	s22_sr_ang      = np.unwrap(np.angle(s22_sr))

	# Simu1
	s11_simu1_mag   = np.abs(s11_simu1)
	s11_simu1_ang   = np.unwrap(np.angle(s11_simu1))

	# Simu2
	s11_simu2_mag   = np.abs(s11_simu2)
	s11_simu2_ang   = np.unwrap(np.angle(s11_simu2))	





	# Modeling S11

	f_s11n = (f_s11-75)/25

	fit_s11_LNA_mag     = fit_polynomial_fourier('polynomial', f_s11n, s11_LNA_mag,     11, plot='no')  # 
	fit_s11_LNA_ang     = fit_polynomial_fourier('polynomial', f_s11n, s11_LNA_ang,     11, plot='no')  # 

	fit_s11_amb_mag     = fit_polynomial_fourier('fourier',    f_s11n, s11_amb_mag,     27, plot='no')  # 
	fit_s11_amb_ang     = fit_polynomial_fourier('fourier',    f_s11n, s11_amb_ang,     27, plot='no')  # 

	fit_s11_hot_mag     = fit_polynomial_fourier('fourier',    f_s11n, s11_hot_mag,     27, plot='no')  #  
	fit_s11_hot_ang     = fit_polynomial_fourier('fourier',    f_s11n, s11_hot_ang,     27, plot='no')  # 

	fit_s11_open_mag    = fit_polynomial_fourier('fourier',    f_s11n, s11_open_mag,    27, plot='no')  # 27
	fit_s11_open_ang    = fit_polynomial_fourier('fourier',    f_s11n, s11_open_ang,    27, plot='no')  # 27

	fit_s11_shorted_mag = fit_polynomial_fourier('fourier',    f_s11n, s11_shorted_mag, 27, plot='no')  # 27
	fit_s11_shorted_ang = fit_polynomial_fourier('fourier',    f_s11n, s11_shorted_ang, 27, plot='no')  # 27

	fit_s11_sr_mag      = fit_polynomial_fourier('polynomial', f_s11n, s11_sr_mag,       7, plot='no')  # 
	fit_s11_sr_ang      = fit_polynomial_fourier('polynomial', f_s11n, s11_sr_ang,       7, plot='no')  # 

	fit_s12s21_sr_mag   = fit_polynomial_fourier('polynomial', f_s11n, s12s21_sr_mag,   21, plot='no')  # 
	fit_s12s21_sr_ang   = fit_polynomial_fourier('polynomial', f_s11n, s12s21_sr_ang,   21, plot='no')  # 

	fit_s22_sr_mag      = fit_polynomial_fourier('polynomial', f_s11n, s22_sr_mag,       7, plot='no')  # 
	fit_s22_sr_ang      = fit_polynomial_fourier('polynomial', f_s11n, s22_sr_ang,       7, plot='no')  # 

	fit_s11_simu1_mag   = fit_polynomial_fourier('polynomial', f_s11n, s11_simu1_mag,   35, plot='no')  # 7
	fit_s11_simu1_ang   = fit_polynomial_fourier('polynomial', f_s11n, s11_simu1_ang,   35, plot='no')  # 7

	fit_s11_simu2_mag   = fit_polynomial_fourier('polynomial', f_s11n, s11_simu2_mag,    11, plot='no')  # 7
	fit_s11_simu2_ang   = fit_polynomial_fourier('polynomial', f_s11n, s11_simu2_ang,    11, plot='no')  # 7	










	# Saving output parameters
	if save == 'yes':


		# Average spectra data in frequency range selected
		spectra = np.array([fe, sa, sh, so, ss, ss1, ss2]).T		

		# RMS residuals
		RMS_spectra = np.zeros((6,1))
		RMS_s11     = np.zeros((20,1))

		# Spectra
		RMS_spectra[0, 0] = fit_spec_ambient[2]
		RMS_spectra[1, 0] = fit_spec_hot[2]
		RMS_spectra[2, 0] = fit_spec_open[2]
		RMS_spectra[3, 0] = fit_spec_shorted[2]
		RMS_spectra[4, 0] = fit_spec_sim1[2]
		RMS_spectra[5, 0] = fit_spec_sim2[2]


		# S11
		RMS_s11[0, 0]  = fit_s11_LNA_mag[2]
		RMS_s11[1, 0]  = fit_s11_LNA_ang[2]
		RMS_s11[2, 0]  = fit_s11_amb_mag[2]
		RMS_s11[3, 0]  = fit_s11_amb_ang[2]
		RMS_s11[4, 0]  = fit_s11_hot_mag[2]
		RMS_s11[5, 0]  = fit_s11_hot_ang[2]
		RMS_s11[6, 0]  = fit_s11_open_mag[2]
		RMS_s11[7, 0]  = fit_s11_open_ang[2]
		RMS_s11[8, 0]  = fit_s11_shorted_mag[2]
		RMS_s11[9, 0]  = fit_s11_shorted_ang[2]
		RMS_s11[10, 0] = fit_s11_sr_mag[2]
		RMS_s11[11, 0] = fit_s11_sr_ang[2]
		RMS_s11[12, 0] = fit_s12s21_sr_mag[2]
		RMS_s11[13, 0] = fit_s12s21_sr_ang[2]
		RMS_s11[14, 0] = fit_s22_sr_mag[2]
		RMS_s11[15, 0] = fit_s22_sr_ang[2]
		RMS_s11[16, 0] = fit_s11_simu1_mag[2]
		RMS_s11[17, 0] = fit_s11_simu1_ang[2]
		RMS_s11[18, 0] = fit_s11_simu2_mag[2]
		RMS_s11[19, 0] = fit_s11_simu2_ang[2]



		# Formating fit parameters

		# Physical temperature
		phys_temp = np.zeros((6,1))
		phys_temp[0,0] = phys_temp_ambient
		phys_temp[1,0] = phys_temp_hot
		phys_temp[2,0] = phys_temp_open
		phys_temp[3,0] = phys_temp_shorted
		phys_temp[4,0] = phys_temp_sim1
		phys_temp[5,0] = phys_temp_sim2		


		# Spectra
		par_spec_ambient    = np.reshape(fit_spec_ambient[0],    (-1,1))
		par_spec_hot        = np.reshape(fit_spec_hot[0],        (-1,1))
		par_spec_open       = np.reshape(fit_spec_open[0],       (-1,1))
		par_spec_shorted    = np.reshape(fit_spec_shorted[0],    (-1,1))
		par_spec_sim1       = np.reshape(fit_spec_sim1[0],       (-1,1))
		par_spec_sim2       = np.reshape(fit_spec_sim2[0],       (-1,1))


		# S11
		par_s11_LNA_mag     = np.reshape(fit_s11_LNA_mag[0],     (-1,1))
		par_s11_LNA_ang     = np.reshape(fit_s11_LNA_ang[0],     (-1,1))
		par_s11_amb_mag     = np.reshape(fit_s11_amb_mag[0],     (-1,1))
		par_s11_amb_ang     = np.reshape(fit_s11_amb_ang[0],     (-1,1))
		par_s11_hot_mag     = np.reshape(fit_s11_hot_mag[0],     (-1,1))
		par_s11_hot_ang     = np.reshape(fit_s11_hot_ang[0],     (-1,1))
		par_s11_open_mag    = np.reshape(fit_s11_open_mag[0],    (-1,1))
		par_s11_open_ang    = np.reshape(fit_s11_open_ang[0],    (-1,1))
		par_s11_shorted_mag = np.reshape(fit_s11_shorted_mag[0], (-1,1))
		par_s11_shorted_ang = np.reshape(fit_s11_shorted_ang[0], (-1,1))

		par_s11_sr_mag      = np.reshape(fit_s11_sr_mag[0],      (-1,1))
		par_s11_sr_ang      = np.reshape(fit_s11_sr_ang[0],      (-1,1))
		par_s12s21_sr_mag   = np.reshape(fit_s12s21_sr_mag[0],   (-1,1))
		par_s12s21_sr_ang   = np.reshape(fit_s12s21_sr_ang[0],   (-1,1))
		par_s22_sr_mag      = np.reshape(fit_s22_sr_mag[0],      (-1,1))
		par_s22_sr_ang      = np.reshape(fit_s22_sr_ang[0],      (-1,1))

		par_s11_simu1_mag   = np.reshape(fit_s11_simu1_mag[0],   (-1,1))
		par_s11_simu1_ang   = np.reshape(fit_s11_simu1_ang[0],   (-1,1))
		par_s11_simu2_mag   = np.reshape(fit_s11_simu2_mag[0],   (-1,1))
		par_s11_simu2_ang   = np.reshape(fit_s11_simu2_ang[0],   (-1,1))




		# Saving

		np.savetxt(path_data + 'average_spectra_300_350.txt', spectra)

		np.savetxt(path_par_temp    + 'physical_temperatures.txt', phys_temp)

		np.savetxt(path_par_spectra + 'par_spec_amb.txt',     par_spec_ambient)
		np.savetxt(path_par_spectra + 'par_spec_hot.txt',     par_spec_hot)
		np.savetxt(path_par_spectra + 'par_spec_open.txt',    par_spec_open)
		np.savetxt(path_par_spectra + 'par_spec_shorted.txt', par_spec_shorted)
		np.savetxt(path_par_spectra + 'par_spec_simu1.txt',   par_spec_sim1)
		np.savetxt(path_par_spectra + 'par_spec_simu2.txt',   par_spec_sim2)		
		np.savetxt(path_par_spectra + 'RMS_spec.txt',         RMS_spectra)

		np.savetxt(path_par_s11 + 'par_s11_LNA_mag.txt',      par_s11_LNA_mag)
		np.savetxt(path_par_s11 + 'par_s11_LNA_ang.txt',      par_s11_LNA_ang)
		np.savetxt(path_par_s11 + 'par_s11_amb_mag.txt',      par_s11_amb_mag)
		np.savetxt(path_par_s11 + 'par_s11_amb_ang.txt',      par_s11_amb_ang)
		np.savetxt(path_par_s11 + 'par_s11_hot_mag.txt',      par_s11_hot_mag)
		np.savetxt(path_par_s11 + 'par_s11_hot_ang.txt',      par_s11_hot_ang)
		np.savetxt(path_par_s11 + 'par_s11_open_mag.txt',     par_s11_open_mag)
		np.savetxt(path_par_s11 + 'par_s11_open_ang.txt',     par_s11_open_ang)
		np.savetxt(path_par_s11 + 'par_s11_shorted_mag.txt',  par_s11_shorted_mag)
		np.savetxt(path_par_s11 + 'par_s11_shorted_ang.txt',  par_s11_shorted_ang)

		np.savetxt(path_par_s11 + 'par_s11_sr_mag.txt',       par_s11_sr_mag)
		np.savetxt(path_par_s11 + 'par_s11_sr_ang.txt',       par_s11_sr_ang)
		np.savetxt(path_par_s11 + 'par_s12s21_sr_mag.txt',    par_s12s21_sr_mag)
		np.savetxt(path_par_s11 + 'par_s12s21_sr_ang.txt',    par_s12s21_sr_ang)
		np.savetxt(path_par_s11 + 'par_s22_sr_mag.txt',       par_s22_sr_mag)
		np.savetxt(path_par_s11 + 'par_s22_sr_ang.txt',       par_s22_sr_ang)

		np.savetxt(path_par_s11 + 'par_s11_simu1_mag.txt',    par_s11_simu1_mag)
		np.savetxt(path_par_s11 + 'par_s11_simu1_ang.txt',    par_s11_simu1_ang)
		np.savetxt(path_par_s11 + 'par_s11_simu2_mag.txt',    par_s11_simu2_mag)
		np.savetxt(path_par_s11 + 'par_s11_simu2_ang.txt',    par_s11_simu2_ang)



		np.savetxt(path_par_s11 + 'RMS_s11.txt',       	      RMS_s11)


	# End
	print('Files processed.')



	return 1

















def calibration_processing_low_band2_2016_09_25C(flow, fhigh, save='no', save_folder=0):


	"""
	Modification: March, 2017.

	"""	



	# Main folder
	main_folder     = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band2/2016_09_25C/'


	# Paths for source data
	path_spectra    = main_folder + 'data/spectra/300_350/'
	path_resistance = main_folder + 'data/resistance/corrected/'
	path_s11        = main_folder + 'data/s11/corrected/'


	# Creating output folders
	if save == 'yes':

		if not exists(main_folder + 'results/' + save_folder + '/temp/'):
			makedirs(main_folder + 'results/' + save_folder + '/temp/')

		if not exists(main_folder + 'results/' + save_folder + '/spectra/'):
			makedirs(main_folder + 'results/' + save_folder + '/spectra/')

		if not exists(main_folder + 'results/' + save_folder + '/s11/'):
			makedirs(main_folder + 'results/' + save_folder + '/s11/')

		if not exists(main_folder + 'results/' + save_folder + '/data/'):
			makedirs(main_folder + 'results/' + save_folder + '/data/')

		if not exists(main_folder + 'results/' + save_folder + '/calibration_files/'):
			makedirs(main_folder + 'results/' + save_folder + '/calibration_files/')			

		if not exists(main_folder + 'results/' + save_folder + '/plots/'):
			makedirs(main_folder + 'results/' + save_folder + '/plots/')


		# Output folders
		path_par_temp    = main_folder + 'results/' + save_folder + '/temp/'
		path_par_spectra = main_folder + 'results/' + save_folder + '/spectra/'
		path_par_s11     = main_folder + 'results/' + save_folder + '/s11/'
		path_data        = main_folder + 'results/' + save_folder + '/data/'






	# Ambient
	file_ambient1 = path_spectra + 'level1_ambient_load_2016_266_18_300_350.mat'
	file_ambient2 = path_spectra + 'level1_ambient_load_2016_267_00_300_350.mat'
	file_ambient3 = path_spectra + 'level1_ambient_load_2016_268_00_300_350.mat'	
	file_ambient4 = path_spectra + 'level1_ambient_load_2016_269_00_300_350.mat'	
	spec_ambient  = [file_ambient1, file_ambient2, file_ambient3, file_ambient4]
	res_ambient   = path_resistance + 'ambient_load.txt'



	# Hot
	file_hot1 = path_spectra + 'level1_hot_load_2016_269_20_300_350.mat'	
	file_hot2 = path_spectra + 'level1_hot_load_2016_270_00_300_350.mat'
	file_hot3 = path_spectra + 'level1_hot_load_2016_271_00_300_350.mat'
	file_hot4 = path_spectra + 'level1_hot_load_2016_272_00_300_350.mat'
	spec_hot  = [file_hot1, file_hot2, file_hot3, file_hot4]
	res_hot   = path_resistance + 'hot_load.txt'



	# Open Cable
	file_open1 = path_spectra + 'level1_open_cable_2016_275_01_300_350.mat'
	file_open2 = path_spectra + 'level1_open_cable_2016_276_00_300_350.mat'
	file_open3 = path_spectra + 'level1_open_cable_2016_277_00_300_350.mat'
	spec_open  = [file_open1, file_open2, file_open3]
	res_open   = path_resistance + 'open_cable.txt'



	# Shorted Cable
	file_shorted1 = path_spectra + 'level1_shorted_cable_2016_273_00_300_350.mat'
	file_shorted2 = path_spectra + 'level1_shorted_cable_2016_274_00_300_350.mat'
	file_shorted3 = path_spectra + 'level1_shorted_cable_2016_275_00_300_350.mat'
	spec_shorted  = [file_shorted1, file_shorted2, file_shorted3]
	res_shorted   = path_resistance + 'shorted_cable.txt'



	# Antenna Simulator 1
	file_sim11  = path_spectra + 'level1_ant_sim1_2016_277_02_300_350.mat'	
	file_sim12  = path_spectra + 'level1_ant_sim1_2016_278_00_300_350.mat'
	file_sim13  = path_spectra + 'level1_ant_sim1_2016_279_00_300_350.mat'	
	file_sim14  = path_spectra + 'level1_ant_sim1_2016_280_00_300_350.mat'
	file_sim15  = path_spectra + 'level1_ant_sim1_2016_281_00_300_350.mat'
	spec_sim1   = [file_sim11, file_sim12, file_sim13, file_sim14, file_sim15]
	res_sim1    = path_resistance + 'antenna_simulator1.txt'



	# Antenna Simulator 2
	file_sim21  = path_spectra + 'level1_ant_sim2_2016_281_02_300_350.mat'	
	file_sim22  = path_spectra + 'level1_ant_sim2_2016_282_00_300_350.mat'
	file_sim23  = path_spectra + 'level1_ant_sim2_2016_283_00_300_350.mat'	
	file_sim24  = path_spectra + 'level1_ant_sim2_2016_284_00_300_350.mat'
	file_sim25  = path_spectra + 'level1_ant_sim2_2016_285_00_300_350.mat'	
	spec_sim2   = [file_sim21, file_sim22, file_sim23, file_sim24, file_sim25]
	res_sim2    = path_resistance + 'antenna_simulator2.txt'	



	# Open Input
	file_open_input1 = path_spectra + 'level1_Open_spectra_with_Sim2_attached_2016_306_21_300_350.mat'
	file_open_input2 = path_spectra + 'level1_Open_spectra_with_Sim2_attached_2016_307_00_300_350.mat'
	spec_open_input  = [file_open_input1, file_open_input2]







	# Average calibration spectra / physical temperature
	# Percentage of initial data to leave out
	percent = 5 # 5%
	ssa,    phys_temp_ambient    = average_calibration_spectrum(spec_ambient,    res_ambient, 1*percent, plot='no')
	ssh,    phys_temp_hot        = average_calibration_spectrum(spec_hot,        res_hot,     6*percent, plot='no')
	sso,    phys_temp_open       = average_calibration_spectrum(spec_open,       res_open,    1*percent, plot='no')
	sss,    phys_temp_shorted    = average_calibration_spectrum(spec_shorted,    res_shorted, 1*percent, plot='no')
	sss1,   phys_temp_sim1       = average_calibration_spectrum(spec_sim1,       res_sim1,    1*percent, plot='no')
	sss2,   phys_temp_sim2       = average_calibration_spectrum(spec_sim2,       res_sim2,    1*percent, plot='no')
	ssoi,   phys_temp_open_input = average_calibration_spectrum(spec_open_input, res_sim2,    1*percent, plot='no')














	# Select frequency range
	ff, ilow, ihigh = frequency_edges(flow, fhigh)
	fe    = ff[ilow:ihigh+1]
	sa    = ssa[ilow:ihigh+1]
	sh    = ssh[ilow:ihigh+1]
	so    = sso[ilow:ihigh+1]
	ss    = sss[ilow:ihigh+1]	
	ss1   = sss1[ilow:ihigh+1]
	ss2   = sss2[ilow:ihigh+1]
	soi   = ssoi[ilow:ihigh+1]







	# Spectra modeling
	fen = (fe-75)/25


	fit_spec_ambient    = fit_polynomial_fourier('fourier',    fen, sa,     7,  plot='no')
	fit_spec_hot        = fit_polynomial_fourier('fourier',    fen, sh,     7,  plot='no')
	fit_spec_open       = fit_polynomial_fourier('fourier',    fen, so,    27,  plot='no')
	fit_spec_shorted    = fit_polynomial_fourier('fourier',    fen, ss,    27,  plot='no')
	fit_spec_sim1       = fit_polynomial_fourier('fourier',    fen, ss1,   15,  plot='no')
	fit_spec_sim2       = fit_polynomial_fourier('fourier',    fen, ss2,   15,  plot='no')
	fit_spec_open_input = fit_polynomial_fourier('fourier',    fen, soi,    7,  plot='no')


	model_spec_ambient    = model_evaluate('fourier', fit_spec_ambient[0],    fen)
	model_spec_hot        = model_evaluate('fourier', fit_spec_hot[0],        fen)
	model_spec_open       = model_evaluate('fourier', fit_spec_open[0],       fen)
	model_spec_shorted    = model_evaluate('fourier', fit_spec_shorted[0],    fen)
	model_spec_sim1       = model_evaluate('fourier', fit_spec_sim1[0],       fen)
	model_spec_sim2       = model_evaluate('fourier', fit_spec_sim2[0],       fen)
	model_spec_open_input = model_evaluate('fourier', fit_spec_open_input[0], fen)







	# Loading S11 data (both files produce same results)
	#s11 = np.genfromtxt(path_s11 + 's11_calibration_low_band_LNA25degC_2016-10-31-13-02-58.txt')    # Best file !!!!
	#s11 = np.genfromtxt(path_s11 + 's11_calibration_low_band_LNA25degC_2016-10-31-17-50-22.txt')	
	s11 = np.genfromtxt(path_s11 + 's11_calibration_low_band_LNA25degC_2017-03-02-02-53-40_S11recv2017.txt') 


	for i in range(len(s11[:,0])-1):
		if (s11[i,0] <= flow) and (s11[i+1,0] > flow):
			index_low = i
		if (s11[i,0] < fhigh) and (s11[i+1,0] >= fhigh):
			index_high = i+1
	index_s11 = np.arange(index_low, index_high+1)





	# Frequency / complex data
	f_s11       = s11[index_s11, 0]

	s11_LNA     = s11[index_s11, 1]  + 1j*s11[index_s11, 2]

	s11_amb     = s11[index_s11, 3]  + 1j*s11[index_s11, 4]
	s11_hot     = s11[index_s11, 5]  + 1j*s11[index_s11, 6]

	s11_open    = s11[index_s11, 7]  + 1j*s11[index_s11, 8]
	s11_shorted = s11[index_s11, 9]  + 1j*s11[index_s11, 10]

	s11_sr      = s11[index_s11, 11] + 1j*s11[index_s11, 12]
	s12s21_sr   = s11[index_s11, 13] + 1j*s11[index_s11, 14]
	s22_sr      = s11[index_s11, 15] + 1j*s11[index_s11, 16]

	s11_simu1   = s11[index_s11, 17] + 1j*s11[index_s11, 18]
	s11_simu2   = s11[index_s11, 19] + 1j*s11[index_s11, 20]




	# Magnitude / Angle

	# LNA
	s11_LNA_mag     = np.abs(s11_LNA)
	s11_LNA_ang     = np.unwrap(np.angle(s11_LNA))

	# Ambient
	s11_amb_mag     = np.abs(s11_amb)
	s11_amb_ang     = np.unwrap(np.angle(s11_amb))

	# Hot
	s11_hot_mag     = np.abs(s11_hot)
	s11_hot_ang     = np.unwrap(np.angle(s11_hot))

	# Open
	s11_open_mag    = np.abs(s11_open)
	s11_open_ang    = np.unwrap(np.angle(s11_open))

	# Shorted
	s11_shorted_mag = np.abs(s11_shorted)
	s11_shorted_ang = np.unwrap(np.angle(s11_shorted))

	# sr-s11
	s11_sr_mag      = np.abs(s11_sr)
	s11_sr_ang      = np.unwrap(np.angle(s11_sr))

	# sr-s12s21
	s12s21_sr_mag   = np.abs(s12s21_sr)
	s12s21_sr_ang   = np.unwrap(np.angle(s12s21_sr))

	# sr-s22
	s22_sr_mag      = np.abs(s22_sr)
	s22_sr_ang      = np.unwrap(np.angle(s22_sr))

	# Simu1
	s11_simu1_mag   = np.abs(s11_simu1)
	s11_simu1_ang   = np.unwrap(np.angle(s11_simu1))

	# Simu2
	s11_simu2_mag   = np.abs(s11_simu2)
	s11_simu2_ang   = np.unwrap(np.angle(s11_simu2))	





	# Modeling S11

	f_s11n = (f_s11-75)/25

	fit_s11_LNA_mag     = fit_polynomial_fourier('polynomial', f_s11n, s11_LNA_mag,     11, plot='no')  # 
	fit_s11_LNA_ang     = fit_polynomial_fourier('polynomial', f_s11n, s11_LNA_ang,     11, plot='no')  # 

	fit_s11_amb_mag     = fit_polynomial_fourier('fourier',    f_s11n, s11_amb_mag,     27, plot='no')  # 
	fit_s11_amb_ang     = fit_polynomial_fourier('fourier',    f_s11n, s11_amb_ang,     27, plot='no')  # 

	fit_s11_hot_mag     = fit_polynomial_fourier('fourier',    f_s11n, s11_hot_mag,     27, plot='no')  #  
	fit_s11_hot_ang     = fit_polynomial_fourier('fourier',    f_s11n, s11_hot_ang,     27, plot='no')  # 

	fit_s11_open_mag    = fit_polynomial_fourier('fourier',    f_s11n, s11_open_mag,    27, plot='no')  # 27
	fit_s11_open_ang    = fit_polynomial_fourier('fourier',    f_s11n, s11_open_ang,    27, plot='no')  # 27

	fit_s11_shorted_mag = fit_polynomial_fourier('fourier',    f_s11n, s11_shorted_mag, 27, plot='no')  # 27
	fit_s11_shorted_ang = fit_polynomial_fourier('fourier',    f_s11n, s11_shorted_ang, 27, plot='no')  # 27

	fit_s11_sr_mag      = fit_polynomial_fourier('polynomial', f_s11n, s11_sr_mag,       7, plot='no')  # 
	fit_s11_sr_ang      = fit_polynomial_fourier('polynomial', f_s11n, s11_sr_ang,       7, plot='no')  # 

	fit_s12s21_sr_mag   = fit_polynomial_fourier('polynomial', f_s11n, s12s21_sr_mag,   21, plot='no')  # 
	fit_s12s21_sr_ang   = fit_polynomial_fourier('polynomial', f_s11n, s12s21_sr_ang,   21, plot='no')  # 

	fit_s22_sr_mag      = fit_polynomial_fourier('polynomial', f_s11n, s22_sr_mag,       7, plot='no')  # 
	fit_s22_sr_ang      = fit_polynomial_fourier('polynomial', f_s11n, s22_sr_ang,       7, plot='no')  # 

	fit_s11_simu1_mag   = fit_polynomial_fourier('polynomial', f_s11n, s11_simu1_mag,   35, plot='no')  # 7
	fit_s11_simu1_ang   = fit_polynomial_fourier('polynomial', f_s11n, s11_simu1_ang,   35, plot='no')  # 7

	fit_s11_simu2_mag   = fit_polynomial_fourier('polynomial', f_s11n, s11_simu2_mag,    11, plot='no')  # 7
	fit_s11_simu2_ang   = fit_polynomial_fourier('polynomial', f_s11n, s11_simu2_ang,    11, plot='no')  # 7	










	# Saving output parameters
	if save == 'yes':


		# Average spectra data in frequency range selected
		spectra = np.array([fe, sa, sh, so, ss, ss1, ss2, soi]).T		

		# RMS residuals
		RMS_spectra = np.zeros((7,1))
		RMS_s11     = np.zeros((20,1))

		# Spectra
		RMS_spectra[0, 0] = fit_spec_ambient[2]
		RMS_spectra[1, 0] = fit_spec_hot[2]
		RMS_spectra[2, 0] = fit_spec_open[2]
		RMS_spectra[3, 0] = fit_spec_shorted[2]
		RMS_spectra[4, 0] = fit_spec_sim1[2]
		RMS_spectra[5, 0] = fit_spec_sim2[2]
		RMS_spectra[6, 0] = fit_spec_open_input[2]


		# S11
		RMS_s11[0, 0]  = fit_s11_LNA_mag[2]
		RMS_s11[1, 0]  = fit_s11_LNA_ang[2]
		RMS_s11[2, 0]  = fit_s11_amb_mag[2]
		RMS_s11[3, 0]  = fit_s11_amb_ang[2]
		RMS_s11[4, 0]  = fit_s11_hot_mag[2]
		RMS_s11[5, 0]  = fit_s11_hot_ang[2]
		RMS_s11[6, 0]  = fit_s11_open_mag[2]
		RMS_s11[7, 0]  = fit_s11_open_ang[2]
		RMS_s11[8, 0]  = fit_s11_shorted_mag[2]
		RMS_s11[9, 0]  = fit_s11_shorted_ang[2]
		RMS_s11[10, 0] = fit_s11_sr_mag[2]
		RMS_s11[11, 0] = fit_s11_sr_ang[2]
		RMS_s11[12, 0] = fit_s12s21_sr_mag[2]
		RMS_s11[13, 0] = fit_s12s21_sr_ang[2]
		RMS_s11[14, 0] = fit_s22_sr_mag[2]
		RMS_s11[15, 0] = fit_s22_sr_ang[2]
		RMS_s11[16, 0] = fit_s11_simu1_mag[2]
		RMS_s11[17, 0] = fit_s11_simu1_ang[2]
		RMS_s11[18, 0] = fit_s11_simu2_mag[2]
		RMS_s11[19, 0] = fit_s11_simu2_ang[2]



		# Formating fit parameters

		# Physical temperature
		phys_temp = np.zeros((6,1))
		phys_temp[0,0] = phys_temp_ambient
		phys_temp[1,0] = phys_temp_hot
		phys_temp[2,0] = phys_temp_open
		phys_temp[3,0] = phys_temp_shorted
		phys_temp[4,0] = phys_temp_sim1
		phys_temp[5,0] = phys_temp_sim2		


		# Spectra
		par_spec_ambient    = np.reshape(fit_spec_ambient[0],    (-1,1))
		par_spec_hot        = np.reshape(fit_spec_hot[0],        (-1,1))
		par_spec_open       = np.reshape(fit_spec_open[0],       (-1,1))
		par_spec_shorted    = np.reshape(fit_spec_shorted[0],    (-1,1))
		par_spec_sim1       = np.reshape(fit_spec_sim1[0],       (-1,1))
		par_spec_sim2       = np.reshape(fit_spec_sim2[0],       (-1,1))
		par_spec_open_input = np.reshape(fit_spec_open_input[0], (-1,1))


		# S11
		par_s11_LNA_mag     = np.reshape(fit_s11_LNA_mag[0],     (-1,1))
		par_s11_LNA_ang     = np.reshape(fit_s11_LNA_ang[0],     (-1,1))
		par_s11_amb_mag     = np.reshape(fit_s11_amb_mag[0],     (-1,1))
		par_s11_amb_ang     = np.reshape(fit_s11_amb_ang[0],     (-1,1))
		par_s11_hot_mag     = np.reshape(fit_s11_hot_mag[0],     (-1,1))
		par_s11_hot_ang     = np.reshape(fit_s11_hot_ang[0],     (-1,1))
		par_s11_open_mag    = np.reshape(fit_s11_open_mag[0],    (-1,1))
		par_s11_open_ang    = np.reshape(fit_s11_open_ang[0],    (-1,1))
		par_s11_shorted_mag = np.reshape(fit_s11_shorted_mag[0], (-1,1))
		par_s11_shorted_ang = np.reshape(fit_s11_shorted_ang[0], (-1,1))

		par_s11_sr_mag      = np.reshape(fit_s11_sr_mag[0],      (-1,1))
		par_s11_sr_ang      = np.reshape(fit_s11_sr_ang[0],      (-1,1))
		par_s12s21_sr_mag   = np.reshape(fit_s12s21_sr_mag[0],   (-1,1))
		par_s12s21_sr_ang   = np.reshape(fit_s12s21_sr_ang[0],   (-1,1))
		par_s22_sr_mag      = np.reshape(fit_s22_sr_mag[0],      (-1,1))
		par_s22_sr_ang      = np.reshape(fit_s22_sr_ang[0],      (-1,1))

		par_s11_simu1_mag   = np.reshape(fit_s11_simu1_mag[0],   (-1,1))
		par_s11_simu1_ang   = np.reshape(fit_s11_simu1_ang[0],   (-1,1))
		par_s11_simu2_mag   = np.reshape(fit_s11_simu2_mag[0],   (-1,1))
		par_s11_simu2_ang   = np.reshape(fit_s11_simu2_ang[0],   (-1,1))




		# Saving

		np.savetxt(path_data + 'average_spectra_300_350.txt', spectra)

		np.savetxt(path_par_temp    + 'physical_temperatures.txt', phys_temp)

		np.savetxt(path_par_spectra + 'par_spec_amb.txt',     par_spec_ambient)
		np.savetxt(path_par_spectra + 'par_spec_hot.txt',     par_spec_hot)
		np.savetxt(path_par_spectra + 'par_spec_open.txt',    par_spec_open)
		np.savetxt(path_par_spectra + 'par_spec_shorted.txt', par_spec_shorted)
		np.savetxt(path_par_spectra + 'par_spec_simu1.txt',   par_spec_sim1)
		np.savetxt(path_par_spectra + 'par_spec_simu2.txt',   par_spec_sim2)
		np.savetxt(path_par_spectra + 'par_spec_open_input.txt',    par_spec_open_input)
		np.savetxt(path_par_spectra + 'RMS_spec.txt',         RMS_spectra)

		np.savetxt(path_par_s11 + 'par_s11_LNA_mag.txt',      par_s11_LNA_mag)
		np.savetxt(path_par_s11 + 'par_s11_LNA_ang.txt',      par_s11_LNA_ang)
		np.savetxt(path_par_s11 + 'par_s11_amb_mag.txt',      par_s11_amb_mag)
		np.savetxt(path_par_s11 + 'par_s11_amb_ang.txt',      par_s11_amb_ang)
		np.savetxt(path_par_s11 + 'par_s11_hot_mag.txt',      par_s11_hot_mag)
		np.savetxt(path_par_s11 + 'par_s11_hot_ang.txt',      par_s11_hot_ang)
		np.savetxt(path_par_s11 + 'par_s11_open_mag.txt',     par_s11_open_mag)
		np.savetxt(path_par_s11 + 'par_s11_open_ang.txt',     par_s11_open_ang)
		np.savetxt(path_par_s11 + 'par_s11_shorted_mag.txt',  par_s11_shorted_mag)
		np.savetxt(path_par_s11 + 'par_s11_shorted_ang.txt',  par_s11_shorted_ang)

		np.savetxt(path_par_s11 + 'par_s11_sr_mag.txt',       par_s11_sr_mag)
		np.savetxt(path_par_s11 + 'par_s11_sr_ang.txt',       par_s11_sr_ang)
		np.savetxt(path_par_s11 + 'par_s12s21_sr_mag.txt',    par_s12s21_sr_mag)
		np.savetxt(path_par_s11 + 'par_s12s21_sr_ang.txt',    par_s12s21_sr_ang)
		np.savetxt(path_par_s11 + 'par_s22_sr_mag.txt',       par_s22_sr_mag)
		np.savetxt(path_par_s11 + 'par_s22_sr_ang.txt',       par_s22_sr_ang)

		np.savetxt(path_par_s11 + 'par_s11_simu1_mag.txt',    par_s11_simu1_mag)
		np.savetxt(path_par_s11 + 'par_s11_simu1_ang.txt',    par_s11_simu1_ang)
		np.savetxt(path_par_s11 + 'par_s11_simu2_mag.txt',    par_s11_simu2_mag)
		np.savetxt(path_par_s11 + 'par_s11_simu2_ang.txt',    par_s11_simu2_ang)


		np.savetxt(path_par_s11 + 'RMS_s11.txt',       	      RMS_s11)


	# End
	print('Files processed.')


	return 1


































def calibration_processing_low_band2_2016_11_15C(flow, fhigh, save='no', save_folder=0):


	"""
	Modification: March, 2017.

	"""	




	# Main folder
	main_folder     = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band2/2016_11_15C/'


	# Paths for source data
	path_spectra    = main_folder + 'data/spectra/300_350/'
	path_resistance = main_folder + 'data/resistance/corrected/'
	path_s11        = main_folder + 'data/s11/corrected/'


	# Creating output folders
	if save == 'yes':

		if not exists(main_folder + 'results/' + save_folder + '/temp/'):
			makedirs(main_folder + 'results/' + save_folder + '/temp/')

		if not exists(main_folder + 'results/' + save_folder + '/spectra/'):
			makedirs(main_folder + 'results/' + save_folder + '/spectra/')

		if not exists(main_folder + 'results/' + save_folder + '/s11/'):
			makedirs(main_folder + 'results/' + save_folder + '/s11/')

		if not exists(main_folder + 'results/' + save_folder + '/data/'):
			makedirs(main_folder + 'results/' + save_folder + '/data/')

		if not exists(main_folder + 'results/' + save_folder + '/calibration_files/'):
			makedirs(main_folder + 'results/' + save_folder + '/calibration_files/')			

		if not exists(main_folder + 'results/' + save_folder + '/plots/'):
			makedirs(main_folder + 'results/' + save_folder + '/plots/')


		# Output folders
		path_par_temp    = main_folder + 'results/' + save_folder + '/temp/'
		path_par_spectra = main_folder + 'results/' + save_folder + '/spectra/'
		path_par_s11     = main_folder + 'results/' + save_folder + '/s11/'
		path_data        = main_folder + 'results/' + save_folder + '/data/'














	# Ambient
	file_ambient1 = path_spectra + 'level1_AmbientLoad_2016_338_22_300_350.mat'
	file_ambient2 = path_spectra + 'level1_AmbientLoad_2016_339_00_300_350.mat'
	file_ambient3 = path_spectra + 'level1_AmbientLoad_2016_340_00_300_350.mat'	
	file_ambient4 = path_spectra + 'level1_AmbientLoad_2016_341_00_300_350.mat'	
	spec_ambient  = [file_ambient1, file_ambient2, file_ambient3, file_ambient4]
	res_ambient   = path_resistance + 'AmbientLoad.txt'



	# Hot
	file_hot1 = path_spectra + 'level1_HotLoad_2016_335_21_300_350.mat'	
	file_hot2 = path_spectra + 'level1_HotLoad_2016_336_00_300_350.mat'
	file_hot3 = path_spectra + 'level1_HotLoad_2016_337_00_300_350.mat'
	file_hot4 = path_spectra + 'level1_HotLoad_2016_338_00_300_350.mat'
	spec_hot  = [file_hot1, file_hot2, file_hot3, file_hot4]
	res_hot   = path_resistance + 'HotLoad.txt'



	# Open Cable
	file_open1 = path_spectra + 'level1_OpenCable_2016_342_23_300_350.mat'
	file_open2 = path_spectra + 'level1_OpenCable_2016_343_00_300_350.mat'
	spec_open  = [file_open1, file_open2]
	res_open   = path_resistance + 'OpenCable.txt'



	# Shorted Cable
	file_shorted1 = path_spectra + 'level1_ShortedCable_2016_341_22_300_350.mat'
	file_shorted2 = path_spectra + 'level1_ShortedCable_2016_342_00_300_350.mat'
	spec_shorted  = [file_shorted1, file_shorted2]
	res_shorted   = path_resistance + 'ShortedCable.txt'



	# Antenna Simulator 1
	file_sim11  = path_spectra + 'level1_SimAnt1_2016_327_19_300_350.mat'	
	file_sim12  = path_spectra + 'level1_SimAnt1_2016_328_00_300_350.mat'
	file_sim13  = path_spectra + 'level1_SimAnt1_2016_329_00_300_350.mat'	
	file_sim14  = path_spectra + 'level1_SimAnt1_2016_330_00_300_350.mat'
	file_sim15  = path_spectra + 'level1_SimAnt1_2016_331_00_300_350.mat'
	spec_sim1   = [file_sim11, file_sim12, file_sim13, file_sim14, file_sim15]
	res_sim1    = path_resistance + 'SimAnt1.txt'



	# Antenna Simulator 2
	file_sim21  = path_spectra + 'level1_SimAnt2_2016_331_19_300_350.mat'	
	file_sim22  = path_spectra + 'level1_SimAnt2_2016_332_00_300_350.mat'
	file_sim23  = path_spectra + 'level1_SimAnt2_2016_333_00_300_350.mat'	
	file_sim24  = path_spectra + 'level1_SimAnt2_2016_334_00_300_350.mat'
	file_sim25  = path_spectra + 'level1_SimAnt2_2016_335_00_300_350.mat'	
	spec_sim2   = [file_sim21, file_sim22, file_sim23, file_sim24, file_sim25]
	res_sim2    = path_resistance + 'SimAnt2.txt'	



	# Antenna Simulator 2, ROUND 2
	file_sim21  = path_spectra + 'level1_SimAnt2_Round2_2016_343_23_300_350.mat'	
	file_sim22  = path_spectra + 'level1_SimAnt2_Round2_2016_344_00_300_350.mat'
	file_sim23  = path_spectra + 'level1_SimAnt2_Round2_2016_345_00_300_350.mat'	
	file_sim24  = path_spectra + 'level1_SimAnt2_Round2_2016_346_00_300_350.mat'
	file_sim25  = path_spectra + 'level1_SimAnt2_Round2_2016_347_00_300_350.mat'	
	spec_sim2r2 = [file_sim21, file_sim22, file_sim23, file_sim24, file_sim25]
	res_sim2r2  = path_resistance + 'SimAnt2_Round2.txt'		



	# Open Input
	file_open_input1 = path_spectra + 'level1_Open_spectra_with_Sim2_attached_15C_2016_347_21_300_350.mat'
	file_open_input2 = path_spectra + 'level1_Open_spectra_with_Sim2_attached_15C_2016_348_00_300_350.mat'
	spec_open_input  = [file_open_input1, file_open_input2]









	# Average calibration spectra / physical temperature
	# Percentage of initial data to leave out
	percent = 5 # 5%
	ssa,    phys_temp_ambient  = average_calibration_spectrum(spec_ambient, res_ambient, 1*percent, plot='no')
	ssh,    phys_temp_hot      = average_calibration_spectrum(spec_hot,     res_hot,     4*percent, plot='no')
	sso,    phys_temp_open     = average_calibration_spectrum(spec_open,    res_open,    1*percent, plot='no')
	sss,    phys_temp_shorted  = average_calibration_spectrum(spec_shorted, res_shorted, 1*percent, plot='no')
	sss1,   phys_temp_sim1     = average_calibration_spectrum(spec_sim1,    res_sim1,    1*percent, plot='no')
	sss2,   phys_temp_sim2     = average_calibration_spectrum(spec_sim2,    res_sim2,    1*percent, plot='no')
	ssoi,   phys_temp_open_input = average_calibration_spectrum(spec_open_input,    res_sim2,    1*percent, plot='no')
	sss2r2, phys_temp_sim2r2   = average_calibration_spectrum(spec_sim2r2,  res_sim2r2,  1*percent, plot='no')













	# Select frequency range
	ff, ilow, ihigh = frequency_edges(flow, fhigh)
	fe    = ff[ilow:ihigh+1]
	sa    = ssa[ilow:ihigh+1]
	sh    = ssh[ilow:ihigh+1]
	so    = sso[ilow:ihigh+1]
	ss    = sss[ilow:ihigh+1]	
	ss1   = sss1[ilow:ihigh+1]
	ss2   = sss2[ilow:ihigh+1]
	soi   = ssoi[ilow:ihigh+1]
	ss2r2 = sss2r2[ilow:ihigh+1]







	# Spectra modeling
	fen = (fe-75)/25


	fit_spec_ambient    = fit_polynomial_fourier('fourier',    fen, sa,     7,  plot='no')
	fit_spec_hot        = fit_polynomial_fourier('fourier',    fen, sh,     7,  plot='no')
	fit_spec_open       = fit_polynomial_fourier('fourier',    fen, so,    27,  plot='no')
	fit_spec_shorted    = fit_polynomial_fourier('fourier',    fen, ss,    27,  plot='no')
	fit_spec_sim1       = fit_polynomial_fourier('fourier',    fen, ss1,   15,  plot='no')
	fit_spec_sim2       = fit_polynomial_fourier('fourier',    fen, ss2,   15,  plot='no')
	fit_spec_open_input = fit_polynomial_fourier('fourier',    fen, soi,    7,  plot='no')
	fit_spec_sim2r2     = fit_polynomial_fourier('fourier',    fen, ss2r2, 15,  plot='no')



	model_spec_ambient    = model_evaluate('fourier', fit_spec_ambient[0],    fen)
	model_spec_hot        = model_evaluate('fourier', fit_spec_hot[0],        fen)
	model_spec_open       = model_evaluate('fourier', fit_spec_open[0],       fen)
	model_spec_shorted    = model_evaluate('fourier', fit_spec_shorted[0],    fen)
	model_spec_sim1       = model_evaluate('fourier', fit_spec_sim1[0],       fen)
	model_spec_sim2       = model_evaluate('fourier', fit_spec_sim2[0],       fen)
	model_spec_open_input = model_evaluate('fourier', fit_spec_open_input[0], fen)
	model_spec_sim2r2     = model_evaluate('fourier', fit_spec_sim2r2[0],     fen)








	# Loading S11 data (both files produce same results)
	#s11 = np.genfromtxt(path_s11 + 's11_calibration_low_band_LNA15degC_2016-12-14-23-01-53.txt')
	s11 = np.genfromtxt(path_s11 + 's11_calibration_low_band_LNA15degC_2017-03-02-05-48-33_S11recv2017.txt')

	for i in range(len(s11[:,0])-1):
		if (s11[i,0] <= flow) and (s11[i+1,0] > flow):
			index_low = i
		if (s11[i,0] < fhigh) and (s11[i+1,0] >= fhigh):
			index_high = i+1
	index_s11 = np.arange(index_low, index_high+1)





	# Frequency / complex data
	f_s11       = s11[index_s11, 0]

	s11_LNA     = s11[index_s11, 1]  + 1j*s11[index_s11, 2]

	s11_amb     = s11[index_s11, 3]  + 1j*s11[index_s11, 4]
	s11_hot     = s11[index_s11, 5]  + 1j*s11[index_s11, 6]

	s11_open    = s11[index_s11, 7]  + 1j*s11[index_s11, 8]
	s11_shorted = s11[index_s11, 9]  + 1j*s11[index_s11, 10]

	s11_sr      = s11[index_s11, 11] + 1j*s11[index_s11, 12]
	s12s21_sr   = s11[index_s11, 13] + 1j*s11[index_s11, 14]
	s22_sr      = s11[index_s11, 15] + 1j*s11[index_s11, 16]

	s11_simu1   = s11[index_s11, 17] + 1j*s11[index_s11, 18]
	s11_simu2   = s11[index_s11, 19] + 1j*s11[index_s11, 20]

	s11_simu2r2 = s11[index_s11, 21] + 1j*s11[index_s11, 22]	




	# Magnitude / Angle

	# LNA
	s11_LNA_mag     = np.abs(s11_LNA)
	s11_LNA_ang     = np.unwrap(np.angle(s11_LNA))

	# Ambient
	s11_amb_mag     = np.abs(s11_amb)
	s11_amb_ang     = np.unwrap(np.angle(s11_amb))

	# Hot
	s11_hot_mag     = np.abs(s11_hot)
	s11_hot_ang     = np.unwrap(np.angle(s11_hot))

	# Open
	s11_open_mag    = np.abs(s11_open)
	s11_open_ang    = np.unwrap(np.angle(s11_open))

	# Shorted
	s11_shorted_mag = np.abs(s11_shorted)
	s11_shorted_ang = np.unwrap(np.angle(s11_shorted))

	# sr-s11
	s11_sr_mag      = np.abs(s11_sr)
	s11_sr_ang      = np.unwrap(np.angle(s11_sr))

	# sr-s12s21
	s12s21_sr_mag   = np.abs(s12s21_sr)
	s12s21_sr_ang   = np.unwrap(np.angle(s12s21_sr))

	# sr-s22
	s22_sr_mag      = np.abs(s22_sr)
	s22_sr_ang      = np.unwrap(np.angle(s22_sr))

	# Simu1
	s11_simu1_mag   = np.abs(s11_simu1)
	s11_simu1_ang   = np.unwrap(np.angle(s11_simu1))

	# Simu2
	s11_simu2_mag   = np.abs(s11_simu2)
	s11_simu2_ang   = np.unwrap(np.angle(s11_simu2))	

	# Simu2, Round 2
	s11_simu2r2_mag   = np.abs(s11_simu2r2)
	s11_simu2r2_ang   = np.unwrap(np.angle(s11_simu2r2))	










	# Modeling S11

	f_s11n = (f_s11-75)/25

	fit_s11_LNA_mag     = fit_polynomial_fourier('polynomial', f_s11n, s11_LNA_mag,     11, plot='no')  # 
	fit_s11_LNA_ang     = fit_polynomial_fourier('polynomial', f_s11n, s11_LNA_ang,     11, plot='no')  # 

	fit_s11_amb_mag     = fit_polynomial_fourier('fourier',    f_s11n, s11_amb_mag,     27, plot='no')  # 
	fit_s11_amb_ang     = fit_polynomial_fourier('fourier',    f_s11n, s11_amb_ang,     27, plot='no')  # 

	fit_s11_hot_mag     = fit_polynomial_fourier('fourier',    f_s11n, s11_hot_mag,     27, plot='no')  #  
	fit_s11_hot_ang     = fit_polynomial_fourier('fourier',    f_s11n, s11_hot_ang,     27, plot='no')  # 

	fit_s11_open_mag    = fit_polynomial_fourier('fourier',    f_s11n, s11_open_mag,    27, plot='no')  # 27
	fit_s11_open_ang    = fit_polynomial_fourier('fourier',    f_s11n, s11_open_ang,    27, plot='no')  # 27

	fit_s11_shorted_mag = fit_polynomial_fourier('fourier',    f_s11n, s11_shorted_mag, 27, plot='no')  # 27
	fit_s11_shorted_ang = fit_polynomial_fourier('fourier',    f_s11n, s11_shorted_ang, 27, plot='no')  # 27

	fit_s11_sr_mag      = fit_polynomial_fourier('polynomial', f_s11n, s11_sr_mag,       7, plot='no')  # 
	fit_s11_sr_ang      = fit_polynomial_fourier('polynomial', f_s11n, s11_sr_ang,       7, plot='no')  # 

	fit_s12s21_sr_mag   = fit_polynomial_fourier('polynomial', f_s11n, s12s21_sr_mag,   21, plot='no')  # 
	fit_s12s21_sr_ang   = fit_polynomial_fourier('polynomial', f_s11n, s12s21_sr_ang,   21, plot='no')  # 

	fit_s22_sr_mag      = fit_polynomial_fourier('polynomial', f_s11n, s22_sr_mag,       7, plot='no')  # 
	fit_s22_sr_ang      = fit_polynomial_fourier('polynomial', f_s11n, s22_sr_ang,       7, plot='no')  # 

	fit_s11_simu1_mag   = fit_polynomial_fourier('polynomial', f_s11n, s11_simu1_mag,   35, plot='no')  # 7
	fit_s11_simu1_ang   = fit_polynomial_fourier('polynomial', f_s11n, s11_simu1_ang,   35, plot='no')  # 7

	fit_s11_simu2_mag   = fit_polynomial_fourier('polynomial', f_s11n, s11_simu2_mag,    11, plot='no')  # 7
	fit_s11_simu2_ang   = fit_polynomial_fourier('polynomial', f_s11n, s11_simu2_ang,    11, plot='no')  # 7

	fit_s11_simu2r2_mag   = fit_polynomial_fourier('polynomial', f_s11n, s11_simu2r2_mag,  11, plot='no')
	fit_s11_simu2r2_ang   = fit_polynomial_fourier('polynomial', f_s11n, s11_simu2r2_ang,  11, plot='no')		










	# Saving output parameters
	if save == 'yes':


		# Average spectra data in frequency range selected
		spectra = np.array([fe, sa, sh, so, ss, ss1, ss2, soi, ss2r2]).T		

		# RMS residuals
		RMS_spectra = np.zeros((8,1))
		RMS_s11     = np.zeros((22,1))

		# Spectra
		RMS_spectra[0, 0] = fit_spec_ambient[2]
		RMS_spectra[1, 0] = fit_spec_hot[2]
		RMS_spectra[2, 0] = fit_spec_open[2]
		RMS_spectra[3, 0] = fit_spec_shorted[2]
		RMS_spectra[4, 0] = fit_spec_sim1[2]
		RMS_spectra[5, 0] = fit_spec_sim2[2]
		RMS_spectra[6, 0] = fit_spec_open_input[2]
		RMS_spectra[7, 0] = fit_spec_sim2r2[2]


		# S11
		RMS_s11[0, 0]  = fit_s11_LNA_mag[2]
		RMS_s11[1, 0]  = fit_s11_LNA_ang[2]
		RMS_s11[2, 0]  = fit_s11_amb_mag[2]
		RMS_s11[3, 0]  = fit_s11_amb_ang[2]
		RMS_s11[4, 0]  = fit_s11_hot_mag[2]
		RMS_s11[5, 0]  = fit_s11_hot_ang[2]
		RMS_s11[6, 0]  = fit_s11_open_mag[2]
		RMS_s11[7, 0]  = fit_s11_open_ang[2]
		RMS_s11[8, 0]  = fit_s11_shorted_mag[2]
		RMS_s11[9, 0]  = fit_s11_shorted_ang[2]
		RMS_s11[10, 0] = fit_s11_sr_mag[2]
		RMS_s11[11, 0] = fit_s11_sr_ang[2]
		RMS_s11[12, 0] = fit_s12s21_sr_mag[2]
		RMS_s11[13, 0] = fit_s12s21_sr_ang[2]
		RMS_s11[14, 0] = fit_s22_sr_mag[2]
		RMS_s11[15, 0] = fit_s22_sr_ang[2]
		RMS_s11[16, 0] = fit_s11_simu1_mag[2]
		RMS_s11[17, 0] = fit_s11_simu1_ang[2]
		RMS_s11[18, 0] = fit_s11_simu2_mag[2]
		RMS_s11[19, 0] = fit_s11_simu2_ang[2]
		RMS_s11[20, 0] = fit_s11_simu2r2_mag[2]
		RMS_s11[21, 0] = fit_s11_simu2r2_ang[2]		



		# Formating fit parameters

		# Physical temperature
		phys_temp = np.zeros((8,1))
		phys_temp[0,0] = phys_temp_ambient
		phys_temp[1,0] = phys_temp_hot
		phys_temp[2,0] = phys_temp_open
		phys_temp[3,0] = phys_temp_shorted
		phys_temp[4,0] = phys_temp_sim1
		phys_temp[5,0] = phys_temp_sim2
		phys_temp[6,0] = phys_temp_sim2r2


		# Spectra
		par_spec_ambient    = np.reshape(fit_spec_ambient[0],    (-1,1))
		par_spec_hot        = np.reshape(fit_spec_hot[0],        (-1,1))
		par_spec_open       = np.reshape(fit_spec_open[0],       (-1,1))
		par_spec_shorted    = np.reshape(fit_spec_shorted[0],    (-1,1))
		par_spec_sim1       = np.reshape(fit_spec_sim1[0],       (-1,1))
		par_spec_sim2       = np.reshape(fit_spec_sim2[0],       (-1,1))
		par_spec_open_input = np.reshape(fit_spec_open_input[0], (-1,1))
		par_spec_sim2r2     = np.reshape(fit_spec_sim2r2[0],     (-1,1))



		# S11
		par_s11_LNA_mag     = np.reshape(fit_s11_LNA_mag[0],     (-1,1))
		par_s11_LNA_ang     = np.reshape(fit_s11_LNA_ang[0],     (-1,1))
		par_s11_amb_mag     = np.reshape(fit_s11_amb_mag[0],     (-1,1))
		par_s11_amb_ang     = np.reshape(fit_s11_amb_ang[0],     (-1,1))
		par_s11_hot_mag     = np.reshape(fit_s11_hot_mag[0],     (-1,1))
		par_s11_hot_ang     = np.reshape(fit_s11_hot_ang[0],     (-1,1))
		par_s11_open_mag    = np.reshape(fit_s11_open_mag[0],    (-1,1))
		par_s11_open_ang    = np.reshape(fit_s11_open_ang[0],    (-1,1))
		par_s11_shorted_mag = np.reshape(fit_s11_shorted_mag[0], (-1,1))
		par_s11_shorted_ang = np.reshape(fit_s11_shorted_ang[0], (-1,1))

		par_s11_sr_mag      = np.reshape(fit_s11_sr_mag[0],      (-1,1))
		par_s11_sr_ang      = np.reshape(fit_s11_sr_ang[0],      (-1,1))
		par_s12s21_sr_mag   = np.reshape(fit_s12s21_sr_mag[0],   (-1,1))
		par_s12s21_sr_ang   = np.reshape(fit_s12s21_sr_ang[0],   (-1,1))
		par_s22_sr_mag      = np.reshape(fit_s22_sr_mag[0],      (-1,1))
		par_s22_sr_ang      = np.reshape(fit_s22_sr_ang[0],      (-1,1))

		par_s11_simu1_mag   = np.reshape(fit_s11_simu1_mag[0],   (-1,1))
		par_s11_simu1_ang   = np.reshape(fit_s11_simu1_ang[0],   (-1,1))
		par_s11_simu2_mag   = np.reshape(fit_s11_simu2_mag[0],   (-1,1))
		par_s11_simu2_ang   = np.reshape(fit_s11_simu2_ang[0],   (-1,1))
		par_s11_simu2r2_mag = np.reshape(fit_s11_simu2r2_mag[0], (-1,1))
		par_s11_simu2r2_ang = np.reshape(fit_s11_simu2r2_ang[0], (-1,1))



		# Saving

		np.savetxt(path_data + 'average_spectra_300_350.txt', spectra)

		np.savetxt(path_par_temp    + 'physical_temperatures.txt', phys_temp)

		np.savetxt(path_par_spectra + 'par_spec_amb.txt',     par_spec_ambient)
		np.savetxt(path_par_spectra + 'par_spec_hot.txt',     par_spec_hot)
		np.savetxt(path_par_spectra + 'par_spec_open.txt',    par_spec_open)
		np.savetxt(path_par_spectra + 'par_spec_shorted.txt', par_spec_shorted)
		np.savetxt(path_par_spectra + 'par_spec_simu1.txt',   par_spec_sim1)
		np.savetxt(path_par_spectra + 'par_spec_simu2.txt',   par_spec_sim2)
		np.savetxt(path_par_spectra + 'par_spec_open_input.txt',    par_spec_open_input)
		np.savetxt(path_par_spectra + 'par_spec_simu2r2.txt', par_spec_sim2r2)
		np.savetxt(path_par_spectra + 'RMS_spec.txt',         RMS_spectra)

		np.savetxt(path_par_s11 + 'par_s11_LNA_mag.txt',      par_s11_LNA_mag)
		np.savetxt(path_par_s11 + 'par_s11_LNA_ang.txt',      par_s11_LNA_ang)
		np.savetxt(path_par_s11 + 'par_s11_amb_mag.txt',      par_s11_amb_mag)
		np.savetxt(path_par_s11 + 'par_s11_amb_ang.txt',      par_s11_amb_ang)
		np.savetxt(path_par_s11 + 'par_s11_hot_mag.txt',      par_s11_hot_mag)
		np.savetxt(path_par_s11 + 'par_s11_hot_ang.txt',      par_s11_hot_ang)
		np.savetxt(path_par_s11 + 'par_s11_open_mag.txt',     par_s11_open_mag)
		np.savetxt(path_par_s11 + 'par_s11_open_ang.txt',     par_s11_open_ang)
		np.savetxt(path_par_s11 + 'par_s11_shorted_mag.txt',  par_s11_shorted_mag)
		np.savetxt(path_par_s11 + 'par_s11_shorted_ang.txt',  par_s11_shorted_ang)

		np.savetxt(path_par_s11 + 'par_s11_sr_mag.txt',       par_s11_sr_mag)
		np.savetxt(path_par_s11 + 'par_s11_sr_ang.txt',       par_s11_sr_ang)
		np.savetxt(path_par_s11 + 'par_s12s21_sr_mag.txt',    par_s12s21_sr_mag)
		np.savetxt(path_par_s11 + 'par_s12s21_sr_ang.txt',    par_s12s21_sr_ang)
		np.savetxt(path_par_s11 + 'par_s22_sr_mag.txt',       par_s22_sr_mag)
		np.savetxt(path_par_s11 + 'par_s22_sr_ang.txt',       par_s22_sr_ang)

		np.savetxt(path_par_s11 + 'par_s11_simu1_mag.txt',    par_s11_simu1_mag)
		np.savetxt(path_par_s11 + 'par_s11_simu1_ang.txt',    par_s11_simu1_ang)
		np.savetxt(path_par_s11 + 'par_s11_simu2_mag.txt',    par_s11_simu2_mag)
		np.savetxt(path_par_s11 + 'par_s11_simu2_ang.txt',    par_s11_simu2_ang)
		np.savetxt(path_par_s11 + 'par_s11_simu2r2_mag.txt',  par_s11_simu2r2_mag)
		np.savetxt(path_par_s11 + 'par_s11_simu2r2_ang.txt',  par_s11_simu2r2_ang)		



		np.savetxt(path_par_s11 + 'RMS_s11.txt',       	      RMS_s11)


	# End
	print('Files processed.')


	return 1






























def calibration_processing_low_band2_2016_11_35C(flow, fhigh, save='no', save_folder=0):


	"""
	Modification: March 03, 2017.

	"""	




	# Main folder
	main_folder     = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band2/2016_11_35C/'


	# Paths for source data
	path_spectra    = main_folder + 'data/spectra/300_350/'
	path_resistance = main_folder + 'data/resistance/corrected/'
	path_s11        = main_folder + 'data/s11/corrected/'


	# Creating output folders
	if save == 'yes':

		if not exists(main_folder + 'results/' + save_folder + '/temp/'):
			makedirs(main_folder + 'results/' + save_folder + '/temp/')

		if not exists(main_folder + 'results/' + save_folder + '/spectra/'):
			makedirs(main_folder + 'results/' + save_folder + '/spectra/')

		if not exists(main_folder + 'results/' + save_folder + '/s11/'):
			makedirs(main_folder + 'results/' + save_folder + '/s11/')

		if not exists(main_folder + 'results/' + save_folder + '/data/'):
			makedirs(main_folder + 'results/' + save_folder + '/data/')

		if not exists(main_folder + 'results/' + save_folder + '/calibration_files/'):
			makedirs(main_folder + 'results/' + save_folder + '/calibration_files/')			

		if not exists(main_folder + 'results/' + save_folder + '/plots/'):
			makedirs(main_folder + 'results/' + save_folder + '/plots/')


		# Output folders
		path_par_temp    = main_folder + 'results/' + save_folder + '/temp/'
		path_par_spectra = main_folder + 'results/' + save_folder + '/spectra/'
		path_par_s11     = main_folder + 'results/' + save_folder + '/s11/'
		path_data        = main_folder + 'results/' + save_folder + '/data/'




	# Ambient
	file_ambient1 = path_spectra + 'level1_AmbientLoad_2016_316_22_300_350.mat'
	file_ambient2 = path_spectra + 'level1_AmbientLoad_2016_317_00_300_350.mat'
	file_ambient3 = path_spectra + 'level1_AmbientLoad_2016_318_00_300_350.mat'	
	file_ambient4 = path_spectra + 'level1_AmbientLoad_2016_319_00_300_350.mat'	
	spec_ambient  = [file_ambient1, file_ambient2, file_ambient3, file_ambient4]
	res_ambient   = path_resistance + 'AmbientLoad.txt'



	# Hot
	file_hot1 = path_spectra + 'level1_HotLoad_2016_319_23_300_350.mat'	
	file_hot2 = path_spectra + 'level1_HotLoad_2016_320_00_300_350.mat'
	file_hot3 = path_spectra + 'level1_HotLoad_2016_321_00_300_350.mat'
	file_hot4 = path_spectra + 'level1_HotLoad_2016_322_00_300_350.mat'
	spec_hot  = [file_hot1, file_hot2, file_hot3, file_hot4]
	res_hot   = path_resistance + 'HotLoad.txt'



	# Open Cable
	file_open1 = path_spectra + 'level1_CableOpen_2016_322_22_300_350.mat'
	file_open2 = path_spectra + 'level1_CableOpen_2016_323_00_300_350.mat'
	spec_open  = [file_open1, file_open2]
	res_open   = path_resistance + 'CableOpen.txt'



	# Shorted Cable
	file_shorted1 = path_spectra + 'level1_CableShorted_2016_323_23_300_350.mat'
	file_shorted2 = path_spectra + 'level1_CableShorted_2016_324_00_300_350.mat'
	spec_shorted  = [file_shorted1, file_shorted2]
	res_shorted   = path_resistance + 'CableShorted.txt'



	# Antenna Simulator 1
	file_sim11  = path_spectra + 'level1_Sim1_2016_312_22_300_350.mat'	
	file_sim12  = path_spectra + 'level1_Sim1_2016_313_00_300_350.mat'
	file_sim13  = path_spectra + 'level1_Sim1_2016_314_00_300_350.mat'	
	file_sim14  = path_spectra + 'level1_Sim1_2016_315_00_300_350.mat'
	file_sim15  = path_spectra + 'level1_Sim1_2016_316_00_300_350.mat'
	spec_sim1   = [file_sim11, file_sim12, file_sim13, file_sim14, file_sim15]
	res_sim1    = path_resistance + 'Sim1.txt'



	# Antenna Simulator 2
	file_sim21  = path_spectra + 'level1_Sim2_2016_308_22_300_350.mat'	
	file_sim22  = path_spectra + 'level1_Sim2_2016_309_00_300_350.mat'
	file_sim23  = path_spectra + 'level1_Sim2_2016_310_00_300_350.mat'	
	file_sim24  = path_spectra + 'level1_Sim2_2016_311_00_300_350.mat'
	file_sim25  = path_spectra + 'level1_Sim2_2016_312_00_300_350.mat'	
	spec_sim2   = [file_sim21, file_sim22, file_sim23, file_sim24, file_sim25]
	res_sim2    = path_resistance + 'Sim2.txt'	



	# Open Input
	file_open_input1 = path_spectra + 'level1_Open_spectra_with_Sim2_attached_35C_2016_307_21_300_350.mat'
	file_open_input2 = path_spectra + 'level1_Open_spectra_with_Sim2_attached_35C_2016_308_00_300_350.mat'
	spec_open_input  = [file_open_input1, file_open_input2]









	# Average calibration spectra / physical temperature
	# Percentage of initial data to leave out
	percent = 8 # 5%
	ssa,    phys_temp_ambient    = average_calibration_spectrum(spec_ambient,    res_ambient, 1*percent, plot='no')
	ssh,    phys_temp_hot        = average_calibration_spectrum(spec_hot,        res_hot,     3*percent, plot='no')
	sso,    phys_temp_open       = average_calibration_spectrum(spec_open,       res_open,    1*percent, plot='no')
	sss,    phys_temp_shorted    = average_calibration_spectrum(spec_shorted,    res_shorted, 1*percent, plot='no')
	sss1,   phys_temp_sim1       = average_calibration_spectrum(spec_sim1,       res_sim1,    1*percent, plot='no')
	sss2,   phys_temp_sim2       = average_calibration_spectrum(spec_sim2,       res_sim2,    1*percent, plot='no')
	ssoi,   phys_temp_open_input = average_calibration_spectrum(spec_open_input, res_sim2,    1*percent, plot='no')












	# Select frequency range
	ff, ilow, ihigh = frequency_edges(flow, fhigh)
	fe    = ff[ilow:ihigh+1]
	sa    = ssa[ilow:ihigh+1]
	sh    = ssh[ilow:ihigh+1]
	so    = sso[ilow:ihigh+1]
	ss    = sss[ilow:ihigh+1]	
	ss1   = sss1[ilow:ihigh+1]
	ss2   = sss2[ilow:ihigh+1]
	soi   = ssoi[ilow:ihigh+1]






	# Spectra modeling
	fen = (fe-75)/25


	fit_spec_ambient    = fit_polynomial_fourier('fourier',    fen, sa,     7,  plot='no')
	fit_spec_hot        = fit_polynomial_fourier('fourier',    fen, sh,     7,  plot='no')
	fit_spec_open       = fit_polynomial_fourier('fourier',    fen, so,    27,  plot='no')
	fit_spec_shorted    = fit_polynomial_fourier('fourier',    fen, ss,    27,  plot='no')
	fit_spec_sim1       = fit_polynomial_fourier('fourier',    fen, ss1,   15,  plot='no')
	fit_spec_sim2       = fit_polynomial_fourier('fourier',    fen, ss2,   15,  plot='no')
	fit_spec_open_input = fit_polynomial_fourier('fourier',    fen, soi,    7,  plot='no')


	model_spec_ambient    = model_evaluate('fourier', fit_spec_ambient[0],    fen)
	model_spec_hot        = model_evaluate('fourier', fit_spec_hot[0],        fen)
	model_spec_open       = model_evaluate('fourier', fit_spec_open[0],       fen)
	model_spec_shorted    = model_evaluate('fourier', fit_spec_shorted[0],    fen)
	model_spec_sim1       = model_evaluate('fourier', fit_spec_sim1[0],       fen)
	model_spec_sim2       = model_evaluate('fourier', fit_spec_sim2[0],       fen)
	model_spec_open_input = model_evaluate('fourier', fit_spec_open_input[0], fen)







	# Loading S11 data (both files produce same results)
	#s11 = np.genfromtxt(path_s11 + 's11_calibration_low_band_LNA35degC_2016-12-14-23-35-37.txt')
	s11 = np.genfromtxt(path_s11 + 's11_calibration_low_band_LNA35degC_2017-03-03-20-52-01_S11recv2017.txt')

	for i in range(len(s11[:,0])-1):
		if (s11[i,0] <= flow) and (s11[i+1,0] > flow):
			index_low = i
		if (s11[i,0] < fhigh) and (s11[i+1,0] >= fhigh):
			index_high = i+1
	index_s11 = np.arange(index_low, index_high+1)





	# Frequency / complex data
	f_s11       = s11[index_s11, 0]

	s11_LNA     = s11[index_s11, 1]  + 1j*s11[index_s11, 2]

	s11_amb     = s11[index_s11, 3]  + 1j*s11[index_s11, 4]
	s11_hot     = s11[index_s11, 5]  + 1j*s11[index_s11, 6]

	s11_open    = s11[index_s11, 7]  + 1j*s11[index_s11, 8]
	s11_shorted = s11[index_s11, 9]  + 1j*s11[index_s11, 10]

	s11_sr      = s11[index_s11, 11] + 1j*s11[index_s11, 12]
	s12s21_sr   = s11[index_s11, 13] + 1j*s11[index_s11, 14]
	s22_sr      = s11[index_s11, 15] + 1j*s11[index_s11, 16]

	s11_simu1   = s11[index_s11, 17] + 1j*s11[index_s11, 18]
	s11_simu2   = s11[index_s11, 19] + 1j*s11[index_s11, 20]	




	# Magnitude / Angle

	# LNA
	s11_LNA_mag     = np.abs(s11_LNA)
	s11_LNA_ang     = np.unwrap(np.angle(s11_LNA))

	# Ambient
	s11_amb_mag     = np.abs(s11_amb)
	s11_amb_ang     = np.unwrap(np.angle(s11_amb))

	# Hot
	s11_hot_mag     = np.abs(s11_hot)
	s11_hot_ang     = np.unwrap(np.angle(s11_hot))

	# Open
	s11_open_mag    = np.abs(s11_open)
	s11_open_ang    = np.unwrap(np.angle(s11_open))

	# Shorted
	s11_shorted_mag = np.abs(s11_shorted)
	s11_shorted_ang = np.unwrap(np.angle(s11_shorted))

	# sr-s11
	s11_sr_mag      = np.abs(s11_sr)
	s11_sr_ang      = np.unwrap(np.angle(s11_sr))

	# sr-s12s21
	s12s21_sr_mag   = np.abs(s12s21_sr)
	s12s21_sr_ang   = np.unwrap(np.angle(s12s21_sr))

	# sr-s22
	s22_sr_mag      = np.abs(s22_sr)
	s22_sr_ang      = np.unwrap(np.angle(s22_sr))

	# Simu1
	s11_simu1_mag   = np.abs(s11_simu1)
	s11_simu1_ang   = np.unwrap(np.angle(s11_simu1))

	# Simu2
	s11_simu2_mag   = np.abs(s11_simu2)
	s11_simu2_ang   = np.unwrap(np.angle(s11_simu2))	










	# Modeling S11

	f_s11n = (f_s11-75)/25

	fit_s11_LNA_mag     = fit_polynomial_fourier('polynomial', f_s11n, s11_LNA_mag,     11, plot='no')  # 
	fit_s11_LNA_ang     = fit_polynomial_fourier('polynomial', f_s11n, s11_LNA_ang,     11, plot='no')  # 

	fit_s11_amb_mag     = fit_polynomial_fourier('fourier',    f_s11n, s11_amb_mag,     27, plot='no')  # 
	fit_s11_amb_ang     = fit_polynomial_fourier('fourier',    f_s11n, s11_amb_ang,     27, plot='no')  # 

	fit_s11_hot_mag     = fit_polynomial_fourier('fourier',    f_s11n, s11_hot_mag,     27, plot='no')  #  
	fit_s11_hot_ang     = fit_polynomial_fourier('fourier',    f_s11n, s11_hot_ang,     27, plot='no')  # 

	fit_s11_open_mag    = fit_polynomial_fourier('fourier',    f_s11n, s11_open_mag,    27, plot='no')  # 27
	fit_s11_open_ang    = fit_polynomial_fourier('fourier',    f_s11n, s11_open_ang,    27, plot='no')  # 27

	fit_s11_shorted_mag = fit_polynomial_fourier('fourier',    f_s11n, s11_shorted_mag, 27, plot='no')  # 27
	fit_s11_shorted_ang = fit_polynomial_fourier('fourier',    f_s11n, s11_shorted_ang, 27, plot='no')  # 27

	fit_s11_sr_mag      = fit_polynomial_fourier('polynomial', f_s11n, s11_sr_mag,       7, plot='no')  # 
	fit_s11_sr_ang      = fit_polynomial_fourier('polynomial', f_s11n, s11_sr_ang,       7, plot='no')  # 

	fit_s12s21_sr_mag   = fit_polynomial_fourier('polynomial', f_s11n, s12s21_sr_mag,   21, plot='no')  # 
	fit_s12s21_sr_ang   = fit_polynomial_fourier('polynomial', f_s11n, s12s21_sr_ang,   21, plot='no')  # 

	fit_s22_sr_mag      = fit_polynomial_fourier('polynomial', f_s11n, s22_sr_mag,       7, plot='no')  # 
	fit_s22_sr_ang      = fit_polynomial_fourier('polynomial', f_s11n, s22_sr_ang,       7, plot='no')  # 

	fit_s11_simu1_mag   = fit_polynomial_fourier('polynomial', f_s11n, s11_simu1_mag,   35, plot='no')  # 7
	fit_s11_simu1_ang   = fit_polynomial_fourier('polynomial', f_s11n, s11_simu1_ang,   35, plot='no')  # 7

	fit_s11_simu2_mag   = fit_polynomial_fourier('polynomial', f_s11n, s11_simu2_mag,    11, plot='no')  # 7
	fit_s11_simu2_ang   = fit_polynomial_fourier('polynomial', f_s11n, s11_simu2_ang,    11, plot='no')  # 7	










	# Saving output parameters
	if save == 'yes':


		# Average spectra data in frequency range selected
		spectra = np.array([fe, sa, sh, so, ss, ss1, ss2, soi]).T		

		# RMS residuals
		RMS_spectra = np.zeros((7,1))
		RMS_s11     = np.zeros((20,1))

		# Spectra
		RMS_spectra[0, 0] = fit_spec_ambient[2]
		RMS_spectra[1, 0] = fit_spec_hot[2]
		RMS_spectra[2, 0] = fit_spec_open[2]
		RMS_spectra[3, 0] = fit_spec_shorted[2]
		RMS_spectra[4, 0] = fit_spec_sim1[2]
		RMS_spectra[5, 0] = fit_spec_sim2[2]
		RMS_spectra[6, 0] = fit_spec_open_input[2]


		# S11
		RMS_s11[0, 0]  = fit_s11_LNA_mag[2]
		RMS_s11[1, 0]  = fit_s11_LNA_ang[2]
		RMS_s11[2, 0]  = fit_s11_amb_mag[2]
		RMS_s11[3, 0]  = fit_s11_amb_ang[2]
		RMS_s11[4, 0]  = fit_s11_hot_mag[2]
		RMS_s11[5, 0]  = fit_s11_hot_ang[2]
		RMS_s11[6, 0]  = fit_s11_open_mag[2]
		RMS_s11[7, 0]  = fit_s11_open_ang[2]
		RMS_s11[8, 0]  = fit_s11_shorted_mag[2]
		RMS_s11[9, 0]  = fit_s11_shorted_ang[2]
		RMS_s11[10, 0] = fit_s11_sr_mag[2]
		RMS_s11[11, 0] = fit_s11_sr_ang[2]
		RMS_s11[12, 0] = fit_s12s21_sr_mag[2]
		RMS_s11[13, 0] = fit_s12s21_sr_ang[2]
		RMS_s11[14, 0] = fit_s22_sr_mag[2]
		RMS_s11[15, 0] = fit_s22_sr_ang[2]
		RMS_s11[16, 0] = fit_s11_simu1_mag[2]
		RMS_s11[17, 0] = fit_s11_simu1_ang[2]
		RMS_s11[18, 0] = fit_s11_simu2_mag[2]
		RMS_s11[19, 0] = fit_s11_simu2_ang[2]	



		# Formating fit parameters

		# Physical temperature
		phys_temp = np.zeros((6,1))
		phys_temp[0,0] = phys_temp_ambient
		phys_temp[1,0] = phys_temp_hot
		phys_temp[2,0] = phys_temp_open
		phys_temp[3,0] = phys_temp_shorted
		phys_temp[4,0] = phys_temp_sim1
		phys_temp[5,0] = phys_temp_sim2


		# Spectra
		par_spec_ambient    = np.reshape(fit_spec_ambient[0],    (-1,1))
		par_spec_hot        = np.reshape(fit_spec_hot[0],        (-1,1))
		par_spec_open       = np.reshape(fit_spec_open[0],       (-1,1))
		par_spec_shorted    = np.reshape(fit_spec_shorted[0],    (-1,1))
		par_spec_sim1       = np.reshape(fit_spec_sim1[0],       (-1,1))
		par_spec_sim2       = np.reshape(fit_spec_sim2[0],       (-1,1))
		par_spec_open_input = np.reshape(fit_spec_open_input[0], (-1,1))


		# S11
		par_s11_LNA_mag     = np.reshape(fit_s11_LNA_mag[0],     (-1,1))
		par_s11_LNA_ang     = np.reshape(fit_s11_LNA_ang[0],     (-1,1))
		par_s11_amb_mag     = np.reshape(fit_s11_amb_mag[0],     (-1,1))
		par_s11_amb_ang     = np.reshape(fit_s11_amb_ang[0],     (-1,1))
		par_s11_hot_mag     = np.reshape(fit_s11_hot_mag[0],     (-1,1))
		par_s11_hot_ang     = np.reshape(fit_s11_hot_ang[0],     (-1,1))
		par_s11_open_mag    = np.reshape(fit_s11_open_mag[0],    (-1,1))
		par_s11_open_ang    = np.reshape(fit_s11_open_ang[0],    (-1,1))
		par_s11_shorted_mag = np.reshape(fit_s11_shorted_mag[0], (-1,1))
		par_s11_shorted_ang = np.reshape(fit_s11_shorted_ang[0], (-1,1))

		par_s11_sr_mag      = np.reshape(fit_s11_sr_mag[0],      (-1,1))
		par_s11_sr_ang      = np.reshape(fit_s11_sr_ang[0],      (-1,1))
		par_s12s21_sr_mag   = np.reshape(fit_s12s21_sr_mag[0],   (-1,1))
		par_s12s21_sr_ang   = np.reshape(fit_s12s21_sr_ang[0],   (-1,1))
		par_s22_sr_mag      = np.reshape(fit_s22_sr_mag[0],      (-1,1))
		par_s22_sr_ang      = np.reshape(fit_s22_sr_ang[0],      (-1,1))

		par_s11_simu1_mag   = np.reshape(fit_s11_simu1_mag[0],   (-1,1))
		par_s11_simu1_ang   = np.reshape(fit_s11_simu1_ang[0],   (-1,1))
		par_s11_simu2_mag   = np.reshape(fit_s11_simu2_mag[0],   (-1,1))
		par_s11_simu2_ang   = np.reshape(fit_s11_simu2_ang[0],   (-1,1))



		# Saving

		np.savetxt(path_data + 'average_spectra_300_350.txt', spectra)

		np.savetxt(path_par_temp    + 'physical_temperatures.txt', phys_temp)

		np.savetxt(path_par_spectra + 'par_spec_amb.txt',     par_spec_ambient)
		np.savetxt(path_par_spectra + 'par_spec_hot.txt',     par_spec_hot)
		np.savetxt(path_par_spectra + 'par_spec_open.txt',    par_spec_open)
		np.savetxt(path_par_spectra + 'par_spec_shorted.txt', par_spec_shorted)
		np.savetxt(path_par_spectra + 'par_spec_simu1.txt',   par_spec_sim1)
		np.savetxt(path_par_spectra + 'par_spec_simu2.txt',   par_spec_sim2)
		np.savetxt(path_par_spectra + 'par_spec_open_input.txt',    par_spec_open_input)
		np.savetxt(path_par_spectra + 'RMS_spec.txt',         RMS_spectra)

		np.savetxt(path_par_s11 + 'par_s11_LNA_mag.txt',      par_s11_LNA_mag)
		np.savetxt(path_par_s11 + 'par_s11_LNA_ang.txt',      par_s11_LNA_ang)
		np.savetxt(path_par_s11 + 'par_s11_amb_mag.txt',      par_s11_amb_mag)
		np.savetxt(path_par_s11 + 'par_s11_amb_ang.txt',      par_s11_amb_ang)
		np.savetxt(path_par_s11 + 'par_s11_hot_mag.txt',      par_s11_hot_mag)
		np.savetxt(path_par_s11 + 'par_s11_hot_ang.txt',      par_s11_hot_ang)
		np.savetxt(path_par_s11 + 'par_s11_open_mag.txt',     par_s11_open_mag)
		np.savetxt(path_par_s11 + 'par_s11_open_ang.txt',     par_s11_open_ang)
		np.savetxt(path_par_s11 + 'par_s11_shorted_mag.txt',  par_s11_shorted_mag)
		np.savetxt(path_par_s11 + 'par_s11_shorted_ang.txt',  par_s11_shorted_ang)

		np.savetxt(path_par_s11 + 'par_s11_sr_mag.txt',       par_s11_sr_mag)
		np.savetxt(path_par_s11 + 'par_s11_sr_ang.txt',       par_s11_sr_ang)
		np.savetxt(path_par_s11 + 'par_s12s21_sr_mag.txt',    par_s12s21_sr_mag)
		np.savetxt(path_par_s11 + 'par_s12s21_sr_ang.txt',    par_s12s21_sr_ang)
		np.savetxt(path_par_s11 + 'par_s22_sr_mag.txt',       par_s22_sr_mag)
		np.savetxt(path_par_s11 + 'par_s22_sr_ang.txt',       par_s22_sr_ang)

		np.savetxt(path_par_s11 + 'par_s11_simu1_mag.txt',    par_s11_simu1_mag)
		np.savetxt(path_par_s11 + 'par_s11_simu1_ang.txt',    par_s11_simu1_ang)
		np.savetxt(path_par_s11 + 'par_s11_simu2_mag.txt',    par_s11_simu2_mag)
		np.savetxt(path_par_s11 + 'par_s11_simu2_ang.txt',    par_s11_simu2_ang)	


		np.savetxt(path_par_s11 + 'RMS_s11.txt',       	      RMS_s11)


	# End
	print('Files processed.')


	return 1

















































def modeling_antenna_s11_delay_fit(nterms):

	# Paths
	path_data = home_folder + '/DATA/EDGES/s11/high_band/corrected/'	



	d = np.genfromtxt(path_data + '2015_262_19_14/average_2015_262_19_14.txt')

	# Data arrays
	f    = d[40:140,0]/1e6  # 90-190 MHz
	fn   = (f-140)/60
	rs11 = d[40:140,1]
	is11 = d[40:140,2]

	s11 = rs11 + 1j*is11

	mag       = np.abs(s11)
	ang       = (180/np.pi)*np.unwrap(np.angle(s11))

	par_ang   = np.polyfit(f*1e6, ang, 1)
	model_ang = np.polyval(par_ang, f*1e6)


	new_rs11 = mag*np.cos((np.pi/180)*(ang-model_ang))
	new_is11 = mag*np.sin((np.pi/180)*(ang-model_ang))
	new_s11  = new_rs11 + 1j*new_is11

	new_mag  = np.abs(new_s11)
	new_ang  = (180/np.pi)*np.unwrap(np.angle(new_s11))



	#par_mag   = np.polyfit(fn, mag, nterms-1)
	#model_mag = np.polyval(par_mag, fn)

	#



	plt.close()
	plt.close()
	plt.subplot(2,1,1)
	plt.plot(f, 20*np.log10(mag)-20*np.log10(new_mag))
	plt.grid()

	plt.subplot(2,1,2)
	plt.plot(f, (ang-new_ang))
	plt.grid()



	return 1









def high_band_saving_MC_calibration_quantities(cterms, wterms, nMC, save_flag):

	"""
	Examples:
	cterms    = 7
	wterms    = 7
	nMC       = 10000
	save_flag = 'set1'

	"""




	# Setting up the simulations

	MC_temp               = np.zeros(6)
	MC_spectra_noise      = np.zeros(6)
	MC_s11_syst           = np.zeros(20)
	MC_s11_noise          = np.zeros(20)

	MC_temp[0:4]          = 1
	MC_spectra_noise[0:4] = 1	
	MC_s11_syst[0:10]     = 1
	MC_s11_syst[12]       = 1

	f, il, ih = frequency_edges(90, 190)
	fe = f[il:ih+1]




	# Producing the MC results
	rl_MC  = np.zeros((nMC, len(fe))) + 0j
	sca_MC = np.zeros((nMC, len(fe)))
	off_MC = np.zeros((nMC, len(fe)))
	TU_MC  = np.zeros((nMC, len(fe)))
	TC_MC  = np.zeros((nMC, len(fe)))
	TS_MC  = np.zeros((nMC, len(fe)))

	for i in range(nMC):		
		print('Iteration: ' + str(i))
		rl, sca, off, TU, TC, TS  =  models_LNA('high_band_2015', 25, fe, cterms=cterms, wterms=wterms, spectra_data_model='model', receiver_reflection='actual', MC_spectra_noise=MC_spectra_noise, MC_s11_noise=MC_s11_noise, MC_s11_syst=MC_s11_syst, systematic_s11='uncorrelated', MC_temp=MC_temp)
		rl_MC[i,:]  = rl
		sca_MC[i,:] = sca
		off_MC[i,:] = off
		TU_MC[i,:]  = TU
		TC_MC[i,:]  = TC
		TS_MC[i,:]  = TS





	# Save MC results	
	path_save = home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_march_2015/LNA/calibration_files/MC_calibration_files/cterms' + str(cterms) + '_wterms' + str(wterms) + '/'

	np.savetxt(path_save + 'calibration_file_high_band_cterms' + str(cterms) + '_wterms' + str(wterms) + '_MC_real_rl_' + save_flag + '.txt', np.real(rl_MC), fmt='%1.8f')
	np.savetxt(path_save + 'calibration_file_high_band_cterms' + str(cterms) + '_wterms' + str(wterms) + '_MC_imag_rl_' + save_flag + '.txt', np.imag(rl_MC), fmt='%1.8f')

	np.savetxt(path_save + 'calibration_file_high_band_cterms' + str(cterms) + '_wterms' + str(wterms) + '_MC_scale_'   + save_flag + '.txt', sca_MC, fmt='%1.8f')
	np.savetxt(path_save + 'calibration_file_high_band_cterms' + str(cterms) + '_wterms' + str(wterms) + '_MC_offset_'  + save_flag + '.txt', off_MC, fmt='%1.8f')
	np.savetxt(path_save + 'calibration_file_high_band_cterms' + str(cterms) + '_wterms' + str(wterms) + '_MC_TU_'      + save_flag + '.txt', TU_MC,  fmt='%1.8f')
	np.savetxt(path_save + 'calibration_file_high_band_cterms' + str(cterms) + '_wterms' + str(wterms) + '_MC_TC_'      + save_flag + '.txt', TC_MC,  fmt='%1.8f')
	np.savetxt(path_save + 'calibration_file_high_band_cterms' + str(cterms) + '_wterms' + str(wterms) + '_MC_TS_'      + save_flag + '.txt', TS_MC,  fmt='%1.8f')


	return 0       #rl_MC, sca_MC, off_MC, TU_MC, TC_MC, TS_MC










def high_band_2015_calibration_quantities_parameters(save_flag):

	# Paths
	path_calibration  = home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_march_2015/LNA/calibration_files/'
	path_MC7_files    = home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_march_2015/LNA/calibration_files/MC_calibration_files/cterms7_wterms7/'
	path_MC6_files    = home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_march_2015/LNA/calibration_files/MC_calibration_files/cterms6_wterms6/'
	path_save         = home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_march_2015/LNA/calibration_files/parameter_files/'



	# Frequency array
	ff, il, ih = frequency_edges(90, 190)
	fe = ff[il:ih+1]
	fn = (fe-140)/60



	# Fiducial polynomial parameters at different temperatures, for cterms=wterms=7, and cterms=wterms=6
	# --------------------------------------------------------------------------------------------------
	pReS11   = np.zeros((81, 32))
	pImS11   = np.zeros((81, 32))

	pC1_c7w7 = np.zeros((81, 7))
	pC2_c7w7 = np.zeros((81, 7))
	pTU_c7w7 = np.zeros((81, 7))
	pTC_c7w7 = np.zeros((81, 7))
	pTS_c7w7 = np.zeros((81, 7))

	pC1_c6w6 = np.zeros((81, 6))
	pC2_c6w6 = np.zeros((81, 6))
	pTU_c6w6 = np.zeros((81, 6))
	pTC_c6w6 = np.zeros((81, 6))
	pTS_c6w6 = np.zeros((81, 6))	


	# Range of temperatures
	temperature = np.arange(23, 27.01, 0.05)
	for i in range(len(temperature)):

		print('Temperature: ' + str(i))
		recv_temp = temperature[i]

		# cterms = wterms = 7
		s11_LNA, sca, off, TU, TC, TS = receiver_calibration('high_band_2015', fe, receiver_temperature = recv_temp, low_band_cal_file = 1, high_band_cal_file = 1)

		pReS11[i,:]   = np.polyfit(fn, np.real(s11_LNA), 31)
		pImS11[i,:]   = np.polyfit(fn, np.imag(s11_LNA), 31)

		pC1_c7w7[i,:] = np.polyfit(fn, sca, 6)
		pC2_c7w7[i,:] = np.polyfit(fn, off, 6)
		pTU_c7w7[i,:] = np.polyfit(fn,  TU, 6)
		pTC_c7w7[i,:] = np.polyfit(fn,  TC, 6)
		pTS_c7w7[i,:] = np.polyfit(fn,  TS, 6)



		# cterms = wterms = 6
		s11_LNA, sca, off, TU, TC, TS = receiver_calibration('high_band_2015', fe, receiver_temperature = recv_temp, low_band_cal_file = 1, high_band_cal_file = 4)
		pC1_c6w6[i,:] = np.polyfit(fn, sca, 5)
		pC2_c6w6[i,:] = np.polyfit(fn, off, 5)
		pTU_c6w6[i,:] = np.polyfit(fn,  TU, 5)
		pTC_c6w6[i,:] = np.polyfit(fn,  TC, 5)
		pTS_c6w6[i,:] = np.polyfit(fn,  TS, 5)









	# Computing covariance matrices for Receiver Reflection Coefficient, with 32 terms
	# ---------------------------------------------------------------------------------

	# Initializing parameter arrays
	pReS11_MC = np.zeros((10000, 32))
	pImS11_MC = np.zeros((10000, 32))

	# ---------------------------------------------------------------------
	# ReS11
	# ---------------------------------------------------------------------
	DATA   = np.genfromtxt(path_MC7_files + 'calibration_file_high_band_cterms7_wterms7_MC_real_rl_set1.txt')
	for i in range(10000):
		print('ReS11: ' + str(i))
		pReS11_MC[i,:] = np.polyfit(fn, DATA[i,:], 31)

	# ---------------------------------------------------------------------
	# ImS11
	# ---------------------------------------------------------------------
	DATA   = np.genfromtxt(path_MC7_files + 'calibration_file_high_band_cterms7_wterms7_MC_imag_rl_set1.txt')	
	for i in range(10000):
		print('ImS11: ' + str(i))
		pImS11_MC[i,:] = np.polyfit(fn, DATA[i,:], 31)	


	# Computing covariance matrices for cterms = wterms = 7
	covReS11 = np.cov((pReS11_MC-np.mean(pReS11_MC, axis=0)).T)
	covImS11 = np.cov((pImS11_MC-np.mean(pImS11_MC, axis=0)).T)











	# Computing covariance matrices for cterms = wterms = 7
	# ---------------------------------------------------------------------	

	# Initializing parameter arrays
	pC1_MC = np.zeros((10000, 7))
	pC2_MC = np.zeros((10000, 7))
	pTU_MC = np.zeros((10000, 7))
	pTC_MC = np.zeros((10000, 7))
	pTS_MC = np.zeros((10000, 7))

	# ---------------------------------------------------------------------
	# C1 
	# ---------------------------------------------------------------------
	DATA   = np.genfromtxt(path_MC7_files + 'calibration_file_high_band_cterms7_wterms7_MC_scale_set1.txt')	
	for i in range(10000):
		print('C1: ' + str(i))
		pC1_MC[i,:] = np.polyfit(fn, DATA[i,:], 6)

	# ---------------------------------------------------------------------
	# C2
	# ---------------------------------------------------------------------
	DATA   = np.genfromtxt(path_MC7_files + 'calibration_file_high_band_cterms7_wterms7_MC_offset_set1.txt')	
	for i in range(10000):
		print('C2: ' + str(i))
		pC2_MC[i,:] = np.polyfit(fn, DATA[i,:], 6)		

	# ---------------------------------------------------------------------
	# TU
	# ---------------------------------------------------------------------
	DATA   = np.genfromtxt(path_MC7_files + 'calibration_file_high_band_cterms7_wterms7_MC_TU_set1.txt')
	for i in range(10000):
		print('TU: ' + str(i))
		pTU_MC[i,:] = np.polyfit(fn, DATA[i,:], 6)			

	# ---------------------------------------------------------------------
	# TC
	# ---------------------------------------------------------------------
	DATA   = np.genfromtxt(path_MC7_files + 'calibration_file_high_band_cterms7_wterms7_MC_TC_set1.txt')
	for i in range(10000):
		print('TC: ' + str(i))
		pTC_MC[i,:] = np.polyfit(fn, DATA[i,:], 6)	

	# ---------------------------------------------------------------------
	# TS
	# ---------------------------------------------------------------------
	DATA   = np.genfromtxt(path_MC7_files + 'calibration_file_high_band_cterms7_wterms7_MC_TS_set1.txt')
	for i in range(10000):
		print('TS: ' + str(i))
		pTS_MC[i,:] = np.polyfit(fn, DATA[i,:], 6)		


	# Computing covariance matrices for cterms = wterms = 7
	covC1_c7w7 = np.cov((pC1_MC-np.mean(pC1_MC, axis=0)).T)
	covC2_c7w7 = np.cov((pC2_MC-np.mean(pC2_MC, axis=0)).T)
	covTU_c7w7 = np.cov((pTU_MC-np.mean(pTU_MC, axis=0)).T)
	covTC_c7w7 = np.cov((pTC_MC-np.mean(pTC_MC, axis=0)).T)
	covTS_c7w7 = np.cov((pTS_MC-np.mean(pTS_MC, axis=0)).T)













	# Computing covariance matrices for cterms = wterms = 6
	# ---------------------------------------------------------------------	

	# Initializing parameter arrays
	pC1_MC = np.zeros((10000, 6))
	pC2_MC = np.zeros((10000, 6))
	pTU_MC = np.zeros((10000, 6))
	pTC_MC = np.zeros((10000, 6))
	pTS_MC = np.zeros((10000, 6))

	# ---------------------------------------------------------------------
	# C1 
	# ---------------------------------------------------------------------
	DATA   = np.genfromtxt(path_MC6_files + 'calibration_file_high_band_cterms6_wterms6_MC_scale_set1.txt')	
	for i in range(10000):
		print('C1: ' + str(i))
		pC1_MC[i,:] = np.polyfit(fn, DATA[i,:], 5)

	# ---------------------------------------------------------------------
	# C2
	# ---------------------------------------------------------------------
	DATA   = np.genfromtxt(path_MC6_files + 'calibration_file_high_band_cterms6_wterms6_MC_offset_set1.txt')	
	for i in range(10000):
		print('C2: ' + str(i))
		pC2_MC[i,:] = np.polyfit(fn, DATA[i,:], 5)		

	# ---------------------------------------------------------------------
	# TU
	# ---------------------------------------------------------------------
	DATA   = np.genfromtxt(path_MC6_files + 'calibration_file_high_band_cterms6_wterms6_MC_TU_set1.txt')
	for i in range(10000):
		print('TU: ' + str(i))
		pTU_MC[i,:] = np.polyfit(fn, DATA[i,:], 5)			

	# ---------------------------------------------------------------------
	# TC
	# ---------------------------------------------------------------------
	DATA   = np.genfromtxt(path_MC6_files + 'calibration_file_high_band_cterms6_wterms6_MC_TC_set1.txt')
	for i in range(10000):
		print('TC: ' + str(i))
		pTC_MC[i,:] = np.polyfit(fn, DATA[i,:], 5)	

	# ---------------------------------------------------------------------
	# TS
	# ---------------------------------------------------------------------
	DATA   = np.genfromtxt(path_MC6_files + 'calibration_file_high_band_cterms6_wterms6_MC_TS_set1.txt')
	for i in range(10000):
		print('TS: ' + str(i))
		pTS_MC[i,:] = np.polyfit(fn, DATA[i,:], 5)		


	# Computing covariance matrices for cterms = wterms = 6
	covC1_c6w6 = np.cov((pC1_MC-np.mean(pC1_MC, axis=0)).T)
	covC2_c6w6 = np.cov((pC2_MC-np.mean(pC2_MC, axis=0)).T)
	covTU_c6w6 = np.cov((pTU_MC-np.mean(pTU_MC, axis=0)).T)
	covTC_c6w6 = np.cov((pTC_MC-np.mean(pTC_MC, axis=0)).T)
	covTS_c6w6 = np.cov((pTS_MC-np.mean(pTS_MC, axis=0)).T)






	# Save
	# ---------------------------------------------------------------------
	save_file = path_save + 'parameter_file' + save_flag + '.hdf5'	

	with h5py.File(save_file, 'w') as hf:

		hf.create_dataset('temperature',      data = temperature)

		hf.create_dataset('par_temp_ReS11',   data = pReS11)
		hf.create_dataset('par_temp_ImS11',   data = pImS11)		

		hf.create_dataset('par_temp_C1_c7w7', data = pC1_c7w7)
		hf.create_dataset('par_temp_C2_c7w7', data = pC2_c7w7)
		hf.create_dataset('par_temp_TU_c7w7', data = pTU_c7w7)
		hf.create_dataset('par_temp_TC_c7w7', data = pTC_c7w7)
		hf.create_dataset('par_temp_TS_c7w7', data = pTS_c7w7)

		hf.create_dataset('par_temp_C1_c6w6', data = pC1_c6w6)
		hf.create_dataset('par_temp_C2_c6w6', data = pC2_c6w6)
		hf.create_dataset('par_temp_TU_c6w6', data = pTU_c6w6)
		hf.create_dataset('par_temp_TC_c6w6', data = pTC_c6w6)
		hf.create_dataset('par_temp_TS_c6w6', data = pTS_c6w6)



		hf.create_dataset('cov_ReS11',   data = covReS11)
		hf.create_dataset('cov_ImS11',   data = covImS11)		

		hf.create_dataset('cov_C1_c7w7', data = covC1_c7w7)
		hf.create_dataset('cov_C2_c7w7', data = covC2_c7w7)
		hf.create_dataset('cov_TU_c7w7', data = covTU_c7w7)
		hf.create_dataset('cov_TC_c7w7', data = covTC_c7w7)
		hf.create_dataset('cov_TS_c7w7', data = covTS_c7w7)		

		hf.create_dataset('cov_C1_c6w6', data = covC1_c6w6)
		hf.create_dataset('cov_C2_c6w6', data = covC2_c6w6)
		hf.create_dataset('cov_TU_c6w6', data = covTU_c6w6)
		hf.create_dataset('cov_TC_c6w6', data = covTC_c6w6)
		hf.create_dataset('cov_TS_c6w6', data = covTS_c6w6)			


	return 0








def low_band2_2017_calibration_quantities_parameters(save_flag):
	
	"""
	
	June 18, 2018
	
	"""
	
	
	# Paths
	path_save         = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band2/model_2016_11_15C_25C_35C/parameter_files/'
	
	
	# Frequency array
	ff, il, ih = frequency_edges(50, 100)
	fe = ff[il:ih+1]
	fn = (fe-75)/25


	# Range of temperatures
	# ---------------------
	temperature = np.arange(20, 30.01, 0.05)
	lt = len(temperature)


	# Fiducial polynomial parameters at different temperatures, for cterms=wterms=7
	# -----------------------------------------------------------------------------
	
	N_s11_LNA = 7
	N_recv    = 7
		
	pReS11   = np.zeros((lt, N_s11_LNA))
	pImS11   = np.zeros((lt, N_s11_LNA))

	pC1 = np.zeros((lt, N_recv))
	pC2 = np.zeros((lt, N_recv))
	pTU = np.zeros((lt, N_recv))
	pTC = np.zeros((lt, N_recv))
	pTS = np.zeros((lt, N_recv))
	
	
	
	
	for i in range(lt):

		recv_temp = temperature[i]
		print('Temperature: ' + str(i) + ' is ' + str(recv_temp))
		
				

		# cterms = wterms = 7
		s11_LNA, sca, off, TU, TC, TS = receiver_calibration('low_band2_2017', fe, receiver_temperature = recv_temp, low_band_cal_file = 1)

		pReS11[i,:]   = np.polyfit(fn, np.real(s11_LNA), N_s11_LNA-1)
		pImS11[i,:]   = np.polyfit(fn, np.imag(s11_LNA), N_s11_LNA-1)
		
		pC1[i,:] = np.polyfit(fn, sca, N_recv-1)
		pC2[i,:] = np.polyfit(fn, off, N_recv-1)
		pTU[i,:] = np.polyfit(fn, TU,  N_recv-1)
		pTC[i,:] = np.polyfit(fn, TC,  N_recv-1)
		pTS[i,:] = np.polyfit(fn, TS,  N_recv-1)
		
		
		
		
		#model = np.polyval(pTS[i,:], fn)
		#rms   = np.std(TS - model)
		#print(rms)



	# Save
	# ------------------------------------------------------------
	save_file = path_save + 'parameter_file' + save_flag + '.hdf5'	

	with h5py.File(save_file, 'w') as hf:

		hf.create_dataset('temperature',    data = temperature)

		hf.create_dataset('par_temp_ReS11', data = pReS11)
		hf.create_dataset('par_temp_ImS11', data = pImS11)		

		hf.create_dataset('par_temp_C1',    data = pC1)
		hf.create_dataset('par_temp_C2',    data = pC2)
		hf.create_dataset('par_temp_TU',    data = pTU)
		hf.create_dataset('par_temp_TC',    data = pTC)
		hf.create_dataset('par_temp_TS',    data = pTS)
		
		
	return pReS11, pImS11, pC1, pC2, pTU, pTC, pTS
















def receiver_calibration_fast(band, fe, receiver_temperature=25, cwterms=7, MC='no'):

	"""
	Nov 28, 2016
	Use this function to calibrate HIGH-BAND data instead of the "traditional" but slower function "receiver_calibration"

	receiver_temperature: value measured by monitoring thermistor
	cwterms: common value of cterms=wterms=7 (default), or cterms=wterms=6 
	MC: 'yes' produces a simultaneous MC realization of the Receiver S11 and five calibration quantities

	"""


	if band == 'high_band_2015':
		
		path_file = home_folder + '/DATA/EDGES/calibration/receiver_calibration/high_band1/model_2015_03_25C_35C/parameter_files/parameter_file_20161127.hdf5'

	
		# Loading parameters and covariance matrices for receiver calibration
		with h5py.File(path_file,'r') as hf:
			#print([key for key in hf.keys()])
	
			# Temperature array
			hf_temp    = hf.get('temperature')
			temp       = np.array(hf_temp)
	
	
	
			# Receiver reflection coefficient
			hf_pReS11   = hf.get('par_temp_ReS11')
			hf_pImS11   = hf.get('par_temp_ImS11')
	
			pReS11      = np.array(hf_pReS11)
			pImS11      = np.array(hf_pImS11)		
	
			hf_covReS11 = hf.get('cov_ReS11')
			hf_covImS11 = hf.get('cov_ImS11')
	
			covReS11    = np.array(hf_covReS11)
			covImS11    = np.array(hf_covImS11)		
	
	
	
	
			# Receiver calibration quantities
			if cwterms == 7:
				hf_pC1 = hf.get('par_temp_C1_c7w7')
				hf_pC2 = hf.get('par_temp_C2_c7w7')
				hf_pTU = hf.get('par_temp_TU_c7w7')
				hf_pTC = hf.get('par_temp_TC_c7w7')
				hf_pTS = hf.get('par_temp_TS_c7w7')
	
				hf_covC1 = hf.get('cov_C1_c7w7')
				hf_covC2 = hf.get('cov_C2_c7w7')
				hf_covTU = hf.get('cov_TU_c7w7')
				hf_covTC = hf.get('cov_TC_c7w7')
				hf_covTS = hf.get('cov_TS_c7w7')
	
	
			elif cwterms == 6:
				hf_pC1 = hf.get('par_temp_C1_c6w6')
				hf_pC2 = hf.get('par_temp_C2_c6w6')
				hf_pTU = hf.get('par_temp_TU_c6w6')
				hf_pTC = hf.get('par_temp_TC_c6w6')
				hf_pTS = hf.get('par_temp_TS_c6w6')		
	
				hf_covC1 = hf.get('cov_C1_c6w6')
				hf_covC2 = hf.get('cov_C2_c6w6')
				hf_covTU = hf.get('cov_TU_c6w6')
				hf_covTC = hf.get('cov_TC_c6w6')
				hf_covTS = hf.get('cov_TS_c6w6')
	
			pC1   = np.array(hf_pC1)
			pC2   = np.array(hf_pC2)
			pTU   = np.array(hf_pTU)
			pTC   = np.array(hf_pTC)
			pTS   = np.array(hf_pTS)
	
			covC1 = np.array(hf_covC1)
			covC2 = np.array(hf_covC2)
			covTU = np.array(hf_covTU)
			covTC = np.array(hf_covTC)
			covTS = np.array(hf_covTS)
	
	
	
	
	
	
	
	
	
		# Index in the temperature table
		itemp = np.arange(0, len(temp), 1)
		xx    = np.abs(temp - receiver_temperature)
		ixx   = np.argsort(xx)
		ii    = ixx[0]
	

		# Normalized frequency
		fn = (fe-140)/60
	
	
		# Evaluating polynomials
		if MC == 'yes':
	
			# Producing MC set of parameters
			pReS11_MC = np.random.multivariate_normal(pReS11[ii,:], covReS11)
			pImS11_MC = np.random.multivariate_normal(pImS11[ii,:], covImS11)
	
			pC1_MC = np.random.multivariate_normal(pC1[ii,:], covC1)
			pC2_MC = np.random.multivariate_normal(pC2[ii,:], covC2)
			pTU_MC = np.random.multivariate_normal(pTU[ii,:], covTU)
			pTC_MC = np.random.multivariate_normal(pTC[ii,:], covTC)
			pTS_MC = np.random.multivariate_normal(pTS[ii,:], covTS)
	
	
			# Evaluating MC polynomials
			ReS11 = np.polyval(pReS11_MC, fn)
			ImS11 = np.polyval(pImS11_MC, fn)
			S11 = ReS11 + 1j*ImS11
	
			C1 = np.polyval(pC1_MC, fn)
			C2 = np.polyval(pC2_MC, fn)
			TU = np.polyval(pTU_MC, fn)
			TC = np.polyval(pTC_MC, fn)
			TS = np.polyval(pTS_MC, fn)
	
	
	
		elif MC == 'no':
	
			# Evaluating nominal polynomials
			ReS11 = np.polyval(pReS11[ii,:], fn)
			ImS11 = np.polyval(pImS11[ii,:], fn)
			S11 = ReS11 + 1j*ImS11
	
			C1 = np.polyval(pC1[ii,:], fn)
			C2 = np.polyval(pC2[ii,:], fn)
			TU = np.polyval(pTU[ii,:], fn)
			TC = np.polyval(pTC[ii,:], fn)
			TS = np.polyval(pTS[ii,:], fn)		










	if band == 'low_band2_2017':
		
		path_file = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band2/model_2016_11_15C_25C_35C/parameter_files/parameter_file_20180618.hdf5'

	
		# Loading parameters and covariance matrices for receiver calibration
		with h5py.File(path_file,'r') as hf:
			#print([key for key in hf.keys()])
	
	
			# Temperature array
			hf_temp    = hf.get('temperature')
			temp       = np.array(hf_temp)
	
		
			# Receiver reflection coefficient
			hf_pReS11   = hf.get('par_temp_ReS11')
			hf_pImS11   = hf.get('par_temp_ImS11')
			hf_pC1      = hf.get('par_temp_C1')
			hf_pC2      = hf.get('par_temp_C2')
			hf_pTU      = hf.get('par_temp_TU')
			hf_pTC      = hf.get('par_temp_TC')
			hf_pTS      = hf.get('par_temp_TS')			
	
			pReS11      = np.array(hf_pReS11)
			pImS11      = np.array(hf_pImS11)		
			pC1         = np.array(hf_pC1)
			pC2         = np.array(hf_pC2)
			pTU         = np.array(hf_pTU)
			pTC         = np.array(hf_pTC)
			pTS         = np.array(hf_pTS)

	
	
	
	
	
	
		# Index in the temperature table
		itemp = np.arange(0, len(temp), 1)
		xx    = np.abs(temp - receiver_temperature)
		ixx   = np.argsort(xx)
		ii    = ixx[0]


		# Normalized frequency
		fn = (fe-75)/25
	

		# Evaluating nominal polynomials
		ReS11 = np.polyval(pReS11[ii,:], fn)
		ImS11 = np.polyval(pImS11[ii,:], fn)
		S11 = ReS11 + 1j*ImS11

		C1 = np.polyval(pC1[ii,:], fn)
		C2 = np.polyval(pC2[ii,:], fn)
		TU = np.polyval(pTU[ii,:], fn)
		TC = np.polyval(pTC[ii,:], fn)
		TS = np.polyval(pTS[ii,:], fn)		
	
		
		
		

	return S11, C1, C2, TU, TC, TS



























def antenna_beam_factor_interpolation(band, lst_hires, fnew, case_beam_factor=1, high_band_antenna_type='blade', MC_beam_factor='no', MC_array=np.zeros(10)):

	"""
	band:             'high_band_2015'
	lst_hires:        array of LSTs
	fnew:             array frequency
	case_beam_fator:  1 through 11, and 21 through 26
	MC_beam_factor:   'yes' / 'no'
	MC_array:         MC_array = np.random.normal(0,1,10)   # mean=0, std=1 

	"""



	# Loading data
	if (band == 'high_band_2015'):

		file_path = '/DATA/EDGES/calibration/beam_factors/high_band/high_band_results/'


		if high_band_antenna_type == 'blade':
			
			bf_old_01 = np.genfromtxt(home_folder + file_path + 'high_band_blade_FEKO_case_01_data.txt')
			bf_old_02 = np.genfromtxt(home_folder + file_path + 'high_band_blade_FEKO_case_02_data.txt')
			bf_old_03 = np.genfromtxt(home_folder + file_path + 'high_band_blade_FEKO_case_03_data.txt')	
			bf_old_04 = np.genfromtxt(home_folder + file_path + 'high_band_blade_FEKO_case_04_data.txt')
			bf_old_05 = np.genfromtxt(home_folder + file_path + 'high_band_blade_FEKO_case_05_data.txt')
			bf_old_06 = np.genfromtxt(home_folder + file_path + 'high_band_blade_FEKO_case_06_data.txt')
			bf_old_07 = np.genfromtxt(home_folder + file_path + 'high_band_blade_FEKO_case_07_data.txt')
			bf_old_08 = np.genfromtxt(home_folder + file_path + 'high_band_blade_FEKO_case_08_data.txt')
			bf_old_09 = np.genfromtxt(home_folder + file_path + 'high_band_blade_FEKO_case_09_data.txt')
			bf_old_10 = np.genfromtxt(home_folder + file_path + 'high_band_blade_FEKO_case_10_data.txt')
			bf_old_11 = np.genfromtxt(home_folder + file_path + 'high_band_blade_FEKO_case_11_data.txt')
	
			bf_old_21 = np.genfromtxt(home_folder + file_path + 'high_band_blade_FEKO_case_21_data.txt')
			bf_old_22 = np.genfromtxt(home_folder + file_path + 'high_band_blade_FEKO_case_22_data.txt')
			bf_old_23 = np.genfromtxt(home_folder + file_path + 'high_band_blade_FEKO_case_23_data.txt')
			bf_old_24 = np.genfromtxt(home_folder + file_path + 'high_band_blade_FEKO_case_24_data.txt')
			bf_old_25 = np.genfromtxt(home_folder + file_path + 'high_band_blade_FEKO_case_25_data.txt')
			bf_old_26 = np.genfromtxt(home_folder + file_path + 'high_band_blade_FEKO_case_26_data.txt')
	
			freq     = np.genfromtxt(home_folder + file_path + 'high_band_blade_FEKO_case_01_freq.txt')
			lst_old  = np.genfromtxt(home_folder + file_path + 'high_band_blade_FEKO_case_01_LST.txt')
	
	
	
			if case_beam_factor == 1:	# nominal	
				bf_old = bf_old_01
	
			if case_beam_factor == 2:	# panel separation
				bf_old = bf_old_02
	
			if case_beam_factor == 3:	# panel length
				bf_old = bf_old_03
	
			if case_beam_factor == 4:	# panel width
				bf_old = bf_old_04
	
			if case_beam_factor == 5:	# soil conductivity
				bf_old = bf_old_05			
	
			if case_beam_factor == 6:	# soil conductivity
				bf_old = bf_old_06
	
			if case_beam_factor == 7:	# soil relative permittivity
				bf_old = bf_old_07
	
			if case_beam_factor == 8:	# soil relative permittivity
				bf_old = bf_old_08
	
			if case_beam_factor == 9:	# panel height
				bf_old = bf_old_09
	
			if case_beam_factor == 10:	# ground plane length
				bf_old = bf_old_10
	
			if case_beam_factor == 11:	# ground plane width
				bf_old = bf_old_11			
	
	
			if case_beam_factor == 21:	# normalization at 90 MHz
				bf_old = bf_old_21
	
			if case_beam_factor == 22:	# normalization at 190 MHz
				bf_old = bf_old_22
	
			if case_beam_factor == 23:	# rotation angle
				bf_old = bf_old_23
	
			if case_beam_factor == 24:	# rotation angle
				bf_old = bf_old_24
	
			if case_beam_factor == 25:	# sky model (GSM2008)
				bf_old = bf_old_25			
	
			if case_beam_factor == 26:	# sky model (GSM2016)
				bf_old = bf_old_26			
	
	
	
	
	
			# Monte Carlo perturbations
			if MC_beam_factor == 'yes':
	
				# Individual 1-sigma perturbations
				D02 = (bf_old_02 - bf_old_01)   # panel separation  (1 sigma 1 mm)
				D03 = (bf_old_03 - bf_old_01)/2 # panel length      (1 sigma 1.5 mm)
				D04 = (bf_old_04 - bf_old_01)/2 # panel width       (1 sigma 1.5 mm)  
				D05 = (bf_old_05 - bf_old_01)/4 # soil conductivity (1 sigma represents doubling the nominal conductivity)
				#D06 = (bf_old_06 - bf_old_01)/2
				D07 = (bf_old_07 - bf_old_01) * (3.5/(10-3.5)) # soil relative permittivity (1 sigma represents doubling the nominal r.p.)
				#D08 = (bf_old_08 - bf_old_01)/2
				D09 = (bf_old_09 - bf_old_01)/2 # panel height        (1 sigma 1.5 mm)
				D10 = (bf_old_10 - bf_old_01)/2 # ground plane length (1 sigma 5 cm)
				D11 = (bf_old_11 - bf_old_01)/2 # ground plane width  (1 sigma 5 cm)
	
				#D21 = (bf_old_21 - bf_old_01)/2
				#D22 = (bf_old_22 - bf_old_01)/2
				D23 = (bf_old_23 - bf_old_01)/2 # rotation angle      (1 sigma 0.5 deg)
				#D24 = (bf_old_24 - bf_old_01)/2
				#D25 = (bf_old_25 - bf_old_01)/2
				D26 = (bf_old_26 - bf_old_01)/2 # sky model           (1 sigma is 0.5*(gsm2016 - (G-H)))
	
	
				# Perturbations combined randomly in quadrature (MC_array is an input parameter)
				DD = (MC_array[0]*D02) + (MC_array[1]*D03) + (MC_array[2]*D04) + (MC_array[3]*D05) + (MC_array[4]*D07) + (MC_array[5]*D09) + (MC_array[6]*D10) + (MC_array[7]*D11) + (MC_array[8]*D23) + (MC_array[9]*D26)
	
	
				# Applying perturbation to nominal beam factor
				bf_old  = bf_old + DD





		# Fourpoint antenna convolution with sky model
		elif high_band_antenna_type == 'fourpoint':
			
			bf_old  = np.genfromtxt(home_folder + file_path + 'high_band_fourpoint_FEKO_80_200MHz_data.txt')
			freq    = np.genfromtxt(home_folder + file_path + 'high_band_fourpoint_FEKO_80_200MHz_freq.txt')
			lst_old = np.genfromtxt(home_folder + file_path + 'high_band_fourpoint_FEKO_80_200MHz_LST.txt')
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			




	if (band == 'low_band_2015'):

		file_path = '/DATA/EDGES/calibration/beam_factors/low_band1/'

		# Low-Band 1, NIVEDITA, Extended Ground Plane
		if case_beam_factor == 0:
			bf_old  = np.genfromtxt(home_folder + file_path + 'low_band_blade_haslam_FEKO_40-100MHz_minus7deg_reffreq_76MHz_NIVEDITA_extended_ground_plane_data.txt')
			freq    = np.genfromtxt(home_folder + file_path + 'low_band_blade_haslam_FEKO_40-100MHz_minus7deg_reffreq_76MHz_NIVEDITA_extended_ground_plane_freq.txt')
			lst_old = np.genfromtxt(home_folder + file_path + 'low_band_blade_haslam_FEKO_40-100MHz_minus7deg_reffreq_76MHz_NIVEDITA_extended_ground_plane_LST.txt')

			print('Beam: Nivedita EXTENDED ground plane.  Sky map: Haslam')


		# Low-Band 1, NIVEDITA, Original Small Ground Plane
		if case_beam_factor == 4:
			bf_old  = np.genfromtxt(home_folder + file_path + 'low_band_blade_haslam_FEKO_40-100MHz_minus7deg_reffreq_76MHz_NIVEDITA_small_10mx10m_ground_plane_data.txt')
			freq    = np.genfromtxt(home_folder + file_path + 'low_band_blade_haslam_FEKO_40-100MHz_minus7deg_reffreq_76MHz_NIVEDITA_small_10mx10m_ground_plane_freq.txt')
			lst_old = np.genfromtxt(home_folder + file_path + 'low_band_blade_haslam_FEKO_40-100MHz_minus7deg_reffreq_76MHz_NIVEDITA_small_10mx10m_ground_plane_LST.txt')

			print('Beam: Nivedita ORIGINAL ground plane.  Sky map: Haslam')



		# Low-Band 1, Original Small Ground Plane
		if case_beam_factor == 1:
			bf_old  = np.genfromtxt(home_folder + file_path + 'low_band_blade_FEKO_40-100MHz_minus7deg_reffreq_76MHz_small_10mx10m_ground_plane_data.txt')
			freq    = np.genfromtxt(home_folder + file_path + 'low_band_blade_FEKO_40-100MHz_minus7deg_reffreq_76MHz_small_10mx10m_ground_plane_freq.txt')
			lst_old = np.genfromtxt(home_folder + file_path + 'low_band_blade_FEKO_40-100MHz_minus7deg_reffreq_76MHz_small_10mx10m_ground_plane_LST.txt')

		# Low-Band 1, Extended Ground Plane
		if case_beam_factor == 2:
			bf_old  = np.genfromtxt(home_folder + file_path + 'low_band_blade_FEKO_40-120MHz_minus7deg_reffreq_76MHz_data.txt')
			freq    = np.genfromtxt(home_folder + file_path + 'low_band_blade_FEKO_40-120MHz_minus7deg_reffreq_76MHz_freq.txt')
			lst_old = np.genfromtxt(home_folder + file_path + 'low_band_blade_FEKO_40-120MHz_minus7deg_reffreq_76MHz_LST.txt')

		if case_beam_factor == 22:

			file_path = '/DATA/EDGES/calibration/beam_factors/low_band1/'

			print('Haslam scaled')

			bf_old  = np.genfromtxt(home_folder + file_path + 'low_band_blade_haslam_FEKO_40-120MHz_minus7deg_reffreq_76MHz_data.txt')
			freq    = np.genfromtxt(home_folder + file_path + 'low_band_blade_haslam_FEKO_40-120MHz_minus7deg_reffreq_76MHz_freq.txt')
			lst_old = np.genfromtxt(home_folder + file_path + 'low_band_blade_haslam_FEKO_40-120MHz_minus7deg_reffreq_76MHz_LST.txt')







	if (band == 'low_band2_2017'):

		file_path = '/DATA/EDGES/calibration/beam_factors/low_band2/'

		# Low-Band 2, Original NS Rotation
		if case_beam_factor == 1:
			bf_old  = np.genfromtxt(home_folder + file_path + 'low_band_blade_haslam_FEKO_40-100MHz_minus2deg_reffreq_76MHz_NIVEDITA_data.txt')
			freq    = np.genfromtxt(home_folder + file_path + 'low_band_blade_haslam_FEKO_40-100MHz_minus2deg_reffreq_76MHz_NIVEDITA_freq.txt')
			lst_old = np.genfromtxt(home_folder + file_path + 'low_band_blade_haslam_FEKO_40-100MHz_minus2deg_reffreq_76MHz_NIVEDITA_LST.txt')		


		# Low-Band 2, EW Rotation
		if case_beam_factor == 2:
			bf_old  = np.genfromtxt(home_folder + file_path + 'low_band_blade_haslam_FEKO_40-100MHz_plus87deg_reffreq_76MHz_NIVEDITA_data.txt')
			freq    = np.genfromtxt(home_folder + file_path + 'low_band_blade_haslam_FEKO_40-100MHz_plus87deg_reffreq_76MHz_NIVEDITA_freq.txt')
			lst_old = np.genfromtxt(home_folder + file_path + 'low_band_blade_haslam_FEKO_40-100MHz_plus87deg_reffreq_76MHz_NIVEDITA_LST.txt')
			




	# Wrap beam factor and LST for 24-hr interpolation 
	bf   = np.vstack((bf_old[-1,:], bf_old, bf_old[0,:]))
	lst0 = np.append(lst_old[-1]-24, lst_old)
	lst  = np.append(lst0, lst_old[0]+24)

	# Arranging original arrays in preparation for interpolation
	freq_array        = np.tile(freq, len(lst))
	lst_array         = np.repeat(lst, len(freq))
	bf_array          = bf.reshape(1,-1)[0]
	freq_lst_original = np.array([freq_array, lst_array]).T

	# Producing high-resolution array of LSTs (frequencies are the same as the original)
	freq_hires       = np.copy(freq)
	freq_hires_array = np.tile(freq_hires, len(lst_hires))
	lst_hires_array  = np.repeat(lst_hires, len(freq_hires)) 
	freq_lst_hires   = np.array([freq_hires_array, lst_hires_array]).T

	# Interpolating beam factor to high LST resolution
	bf_hires_array = spi.griddata(freq_lst_original, bf_array, freq_lst_hires, method='cubic')	
	bf_2D          = bf_hires_array.reshape(len(lst_hires), len(freq_hires))

	# Interpolating beam factor to high frequency resolution
	for i in range(len(bf_2D[:,0])):
		par       = np.polyfit(freq_hires, bf_2D[i,:], 11)
		bf_single = np.polyval(par, fnew)

		if i == 0:
			bf_2D_hires = np.copy(bf_single)
		elif i > 0:
			bf_2D_hires = np.vstack((bf_2D_hires, bf_single))


	return bf_2D_hires   #beam_factor_model  #, freq_hires, bf_lst_average












def level3_v2_to_level4():

	path_file           = home_folder + '/DATA/EDGES/spectra/level3/high_band/v2/high_band_v2_blade_LST_23.76_3.76.hdf5'
	f, t_2D, m_2D, w_2D = level3_read_v2(path_file)

	t_all   = np.zeros((len(np.unique(m_2D[:,1])), len(t_2D[0,:])))
	w_all   = np.zeros((len(np.unique(m_2D[:,1])), len(t_2D[0,:])))
	#r_all = np.zeros((len(np.unique(m_2D[:,1])), len(t_2D[0,:])))
	wea_all = np.zeros((len(np.unique(m_2D[:,1])), 6))
	r_all   = np.zeros((len(np.unique(m_2D[:,1])), len(t_2D[0,:])))


	tb_all  = np.zeros((len(np.unique(m_2D[:,1])), 250))   # binning between 90.2 and 189.8 MHz    (these are the center frequencies of the first and last bins)
	wb_all  = np.zeros((len(np.unique(m_2D[:,1])), 250))
	rb_all  = np.zeros((len(np.unique(m_2D[:,1])), 250))	
	rb2_all = np.zeros((len(np.unique(m_2D[:,1])), 250))	

	index_orig  = np.arange(len(m_2D[:,0]))
	flag_index  = 0



	for k in [2015, 2016]:
		for j in range(10): #range(366):     # 

			index_all = index_orig[(m_2D[:,0]== k)&(m_2D[:,1]== j)]

			if len(index_all) > 1:

				print(flag_index)

				# Selecting data corresponding to a given Year / Day
				t_sel = t_2D[index_all, :]
				w_sel = w_2D[index_all, :]
				m_sel = m_2D[index_all, :]


				# Averaging traces
				tav0, wav0 = spectral_averaging(t_sel, w_sel)


				# Median Year, Day, AmbTemp, AmbHum, RecTemp1, RecTemp2
				wea      = np.median(m_sel[:,[0,1,9,10,11,12]], axis=0).reshape(1,-1)


				# RFI flagging
				tav1, wav1 = FM_excision_raw_frequency(f, tav0, wav0)
				tav, wav   = RFI_cleaning_std(f, tav1, wav1, n_sigma = 3.5, df_MHz = 20, npar = 4)


				# Store data if enough data available (weights greater than zero), no NaNs, and no indeterminate divisions
				if (np.sum(wav) > 0) and (np.sum(np.isnan(tav)) == 0) and (np.sum(np.isinf(tav)) == 0):

					t_all[flag_index, :]   = tav
					w_all[flag_index, :]   = wav
					wea_all[flag_index, :] = wea

					pp    = fit_polynomial_fourier('EDGES_polynomial', f/150, tav, 5, Weights = wav)
					model = model_evaluate('EDGES_polynomial', pp[0], f/150)
					rav   = tav - model

					r_all[flag_index, :]   = rav

					fb, rb2, wb2 = spectral_binning_fixed_frequency(90.2, 189.8, 0.4, f, rav, wav)
					rb2_all[flag_index, :] = rb2





					fb, tb, wb = spectral_binning_fixed_frequency(90.2, 189.8, 0.4, f, tav, wav)

					pp    = fit_polynomial_fourier('EDGES_polynomial', fb/150, tb, 5, Weights = wb)
					model = model_evaluate('EDGES_polynomial', pp[0], fb/150)
					rb    = tb - model




					tb_all[flag_index, :] = tb
					wb_all[flag_index, :] = wb
					rb_all[flag_index, :] = rb








				flag_index = flag_index + 1



	return f, t_all, w_all, wea_all, r_all, tb_all, wb_all, rb_all, rb2_all














def data_analysis_daily_spectra_filter(band, datelist):


	# Dates to REMOVE
	if band == 'high_band_2015':
		rejected = ['2015_210', '2015_219', '2015_220', '2015_229', '2015_239', '2015_272', '2015_276', '2015_277', '2015_281', '2015_290', '2015_294', '2015_295', '2015_297', '2015_300', '2015_301', '2015_302', '2015_320', '2015_331', '2015_335', '2015_342', '2015_349', '2015_358', '2016_005', '2016_008', '2016_017', '2016_030', '2016_034', '2016_048', '2016_052', '2016_068', '2016_177', '2016_179', '2016_180', '2016_189', '2016_224']



	if band == 'low_band_2015':
		rejected = ['2016_283', '2016_284', '2016_285', '2016_286', '2016_289', '2016_330', '2017_089', '2017_090', '2017_091']



	if band == 'low_band2_2017':
		rejected = ['2017_089', '2017_090', '2017_091', '2017_103']




	# Removing rejected days
	flag = 0
	for i in range(len(datelist)):

		rej = 0
		for j in range(len(rejected)):
			if (datelist[i][0:8] == rejected[j]):
				rej = 1

		if rej == 0:
			if flag == 0:
				datelist_new = [datelist[i]]
				flag = 1

			elif flag > 0:
				datelist_new.append(datelist[i])



	return datelist_new





















def data_analysis_residuals_array(fin, tin_all, win_all, flow=90, fhigh=190, model_type='EDGES_polynomial', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes'):

	"""

	This function computes the binned residuals for a set of spectra organized in a 2D array, where each row is a spectrum.
	fin: input frequency in MHz
	tin_all, win_all: input 2D arrays.
	flow, fhigh: frequency limits.

	"""



	# Selecting data within desired frequency range
	fx = fin[(fin>=flow) & (fin<=fhigh)]
	tx = tin_all[:,(fin>=flow) & (fin<=fhigh)]
	wx = win_all[:,(fin>=flow) & (fin<=fhigh)]



	# Computing residuals, frequency binning, and RFI cleaning
	for i in range(len(tx[:,0])):
		print('Computing residuals: ' + str(i) + ' of ' + str(len(tx[:,0])))


		# Fitting and removing model to compute residuals	
		p     = fit_polynomial_fourier(model_type, fx/fnorm, tx[i,:], nfg, Weights=wx[i,:])
		model = model_evaluate(model_type, p[0], fx/fnorm)



		# Output at raw resolution
		fo = fx 
		ro = tx[i,:] - model
		wo = wx[i,:]



		# Binning
		if binning == 'yes':
			#fb, rb, wb   = spectral_binning_fixed_frequency(flow, fhigh, fbin, fx, rr, wx[i,:])
			fo, ro, wo   = spectral_binning_number_of_samples(fo, ro, wo, nsamples=nsamples)


		# RFI flagging
		if rfi_flagging == 'yes':			
			ro, wo = RFI_cleaning_std(fo, ro, wo, n_sigma=2.5, df_MHz=20, npar=4)


		# WEIGHTED RMS over whole range
		rms = np.sqrt(  np.sum(wo*(ro**2)) / np.sum(wo)  )          # rms          = np.std(ro[wo>0])


		# WEIGHTED RMS above 110 MHz
		rk      = ro[fo>=110]
		wk      = wo[fo>=110]
		rms_110 = np.sqrt(  np.sum(wk*(rk**2)) / np.sum(wk)  )      # rms_110      = np.std(rk[wk>0])


		# Accumulating results
		if i == 0:
			ro_all      = np.copy(ro)
			wo_all      = np.copy(wo)
			rms_all     = np.copy(rms)
			rms_110_all = np.copy(rms_110)

		elif i > 0:
			ro_all      = np.vstack((ro_all, ro))
			wo_all      = np.vstack((wo_all, wo))
			rms_all     = np.append(rms_all, rms)
			rms_110_all = np.append(rms_110_all, rms_110)

	return fo, ro_all, wo_all, rms_all, rms_110_all






















def results_season_spectra(band, file_number, fin, tc_all, wc_all, wea_all, LST, flow=90, fhigh=190, fbin=0.4, model_type='EDGES_polynomial', fnorm=140, nfg=3, plot_flag=''):


	plt.close()
	plt.close()
	plt.close()
	plt.close()
	plt.close()
	plt.close()




	# Removing bad days
	tx_all, wx_all, we_all = data_analysis_daily_spectra_filter(band, file_number, tc_all, wc_all, wea_all)




	# Identifying LST range                
	for k in range(len(tx_all[:,0])):
		LST_sel = LST[(LST[:,0] == we_all[k,0]) & (LST[:,1] == we_all[k,1]), 3]

		if len(LST_sel[LST_sel > 12]) > 0:

			LST_sel_1 = LST_sel[LST_sel > 12] - 24

			if len(LST_sel[LST_sel < 12]) > 0:
				LST_sel_0 = LST_sel[LST_sel < 12]
				LST_max = np.max(LST_sel_0)

			else:
				LST_max = np.max(LST_sel_1)

			LST_min = np.min(LST_sel_1)

		else:
			LST_max = np.max(LST_sel)
			LST_min = np.min(LST_sel)

		if k == 0:
			LST_min_all = np.copy(LST_min)
			LST_max_all = np.copy(LST_max)

		else:
			LST_min_all = np.append(LST_min_all, LST_min)
			LST_max_all = np.append(LST_max_all, LST_max)






	# Producing arrays (weather, LST, tsky) with dates, including those with no data
	days2015 = np.arange(we_all[0,1], 366, 1)
	year2015 = 2015 * np.ones(len(days2015))
	days2016 = np.arange(1, we_all[-1,1]+1, 1)
	year2016 = 2016 * np.ones(len(days2016))

	days  = np.append(days2015, days2016)
	years = np.append(year2015, year2016)
	dates_complete = np.hstack((years.reshape(-1,1), days.reshape(-1,1)))

	weather_complete = np.NaN * np.ones((len(years), 4))
	tsky_complete    = np.NaN * np.ones((len(years), len(tx_all[0,:])))
	LST_complete     = np.NaN * np.ones((len(years), 2))

	for j in range(len(dates_complete[:,0])):
		for i in range(len(we_all[:,0])):

			if (we_all[i,0] == dates_complete[j,0]) and (we_all[i,1] == dates_complete[j,1]):
				weather_complete[j,:]      = we_all[i,2::]

				tx_all_nan                 = np.copy(tx_all[i,:])
				tx_all_nan[wx_all[i,:]==0] = np.nan
				tsky_complete[j,:]         = tx_all_nan
				LST_complete[j,0]          = LST_min_all[i]
				LST_complete[j,1]          = LST_max_all[i]


	avtsky, avwsky   = spectral_averaging(tx_all, wx_all)













	# ######################################################
	# Summary plot
	size_x = 14
	size_y = 10.5
	fig    = plt.figure(num=1, figsize=(size_x, size_y))

	ii = np.arange(0,len(days),20)
	for i in range(len(ii)):

		kk = str(int(dates_complete[ii[i],0])) + '-' + str(int(dates_complete[ii[i],1]))
		if i == 0:
			ii_label = [kk]

		elif i > 0:
			ii_label.append(kk)


	ax = fig.add_axes([0.05, 0.83, 0.87, 0.15])
	line1 = ax.plot(np.arange(0.5, len(days)+0.5), weather_complete[:,0], label='amb. temp.') # ambient temperature
	ax.set_xticks(ii)
	ax.set_xticklabels('')
	ax.set_yticks([10,20,30])
	ax.set_xlim([0, len(days)-0])
	ax.set_ylim([0,40])
	ax.set_ylabel(r'temp. [$^{\circ}$C]')

	ax2 = ax.twinx()
	line2 = ax2.plot(np.arange(0.5, len(days)+0.5), weather_complete[:,1], 'r', label='amb. humidity') # ambient humidity
	ax2.set_yticks([20,40,60,80])
	ax2.set_xlim([0, len(days)-0])
	ax2.set_ylim([0,100])
	ax2.set_ylabel('humidity [%]')

	lines  = line1+line2
	labels = [l.get_label() for l in lines]
	ax.legend(lines, labels, loc=0, ncol=2, fontsize=10)




	ax = fig.add_axes([0.05, 0.68, 0.87, 0.15])
	ax.plot(np.arange(0.5, len(days)+0.5), weather_complete[:,3]) # receiver control
	ax.plot(np.arange(0.5, len(days)+0.5), weather_complete[:,2]) # receiver monitor
	ax.set_xticks(ii)
	ax.set_xticklabels('')
	ax.set_xlim([0, len(days)-0])

	MMIN = np.floor(np.min(weather_complete[np.isnan(weather_complete[:,2])==0,2]))
	MMAX = np.ceil(np.max(weather_complete[np.isnan(weather_complete[:,2])==0,2])) + 1

	if MMIN < 20:
		MMIN = 20		

	if MMAX > 27:
		MMAX = 27

	ax.set_ylim([MMIN, MMAX])
	ax.set_yticks(np.arange(MMIN+1, MMAX, 1))
	#ax.set_yticks(np.arange(np.floor(np.min(weather_complete[:,2]))+1, np.ceil(np.max(weather_complete[:,2])) + 1, 1))
	ax.set_ylabel(r'temp. [$^{\circ}$C]')
	ax.legend(['receiver control temp.','receiver monitor temp.'], loc=0, ncol=2, fontsize=10)




	ax = fig.add_axes([0.05, 0.53, 0.87, 0.15])
	for i in range(len(days)):
		if np.isnan(LST_complete[i,0]) == 0:
			ax.plot([i+0.5,i+0.5], [LST_complete[i,0], LST_complete[i,1]], 'm', linewidth=3)

	ax.set_xticks(ii)
	ax.set_xticklabels('')	
	ax.set_xlim([0, len(days)-0])
	ax.set_ylim([np.floor(np.min(LST_min_all))-0.3, np.ceil(np.max(LST_max_all))+0.3])
	ax.set_yticks(np.arange(np.floor(np.min(LST_min_all)), np.ceil(np.max(LST_max_all))+1, 1))
	ax.set_ylabel('LST [hr]')




	ax = fig.add_axes([0.05, 0.13, 0.87, 0.4])
	im = ax.imshow((tsky_complete - avtsky).T, interpolation='none', aspect='auto', extent=[0, len(days), 190, 90], vmin=-15, vmax=15)
	ax.set_xticks(ii)
	ax.set_xticklabels(ii_label, rotation=45)
	ax.set_xlim([0, len(days)-0])
	ax.set_yticks(np.arange(100, 190, 20))
	ax.set_xlabel('date')
	ax.set_ylabel('frequency [MHz]')

	cbaxes = fig.add_axes([0.93, 0.13+0.05, 0.016, 0.3])
	cb = plt.colorbar(im, cax=cbaxes)
	cb.set_label(r'$T_{\rm{sky}}-\langle T_{\rm{sky}} \rangle$ [K]', fontsize=15)



	plt.savefig(home_folder + '/Desktop/summary_' + band + '_all_days' + plot_flag + '.pdf', bbox_inches='tight')
	plt.close()


































	# #########################################################
	# Computing residuals
	fb, rb_all, wb_all, rms_all, rms_110_all = data_analysis_residuals_array(fin, tx_all, wx_all, flow=90, fhigh=190, model_type='Physical_model', fnorm=140, nfg=5, fbin=0.4)



	# Plotting residuals
	o = plot_spectra_residuals(fb, rb_all, wb_all, 'season', we_all[:,1], K=1, flow_lim=80, fhigh_lim=220, xticks_low=80, xticks_high=220, xticks_delta=20, rms_text_freq=195, fontsize=10, size_x_column=7, size_y=20, NSC=35, y_label='day of year', plot_name='daily_residuals_' + band + '_all_days' + plot_flag )




















	# ########################################################################
	size_x = 8.5
	size_y = 10
	K      = 1 #1/5
	NS     = len(rb_all[:,0])
	Nav    = np.floor(NS/16)

	rms_text_freq = 195
	fontsize=10

	xticks_low   = 80
	xticks_high  = 220
	xticks_delta = 20

	flow_lim  =  80
	fhigh_lim = 220





	fig = plt.figure(num=3, figsize=(size_x, size_y))


	ax = fig.add_axes([0.15, 0.05, 0.8, 0.78])
	date_start = np.zeros((Nav,2))
	date_end   = np.zeros((Nav,2))
	for i in range(int(Nav)):
		print('chao: ' + str(i))
		i1 = i*16
		i2 = (i+1)*16

		if i < (Nav-1):
			avt, avw = spectral_averaging(tx[i1:i2, :], wx[i1:i2, :])
			date_start[i,:] = we_all[i1,0:2]
			date_end[i,:]   = we_all[i2-1,0:2]


		elif i == (Nav-1):
			avt, avw = spectral_averaging(tx[i1::, :], wx[i1::, :])
			date_start[i,:] = we_all[i1,0:2]
			date_end[i,:]   = we_all[-1,0:2]                        



		p            = fit_polynomial_fourier(model_type, fx/fnorm, avt, nfg, Weights=avw)
		model        = model_evaluate(model_type, p[0], fx/fnorm)
		avr          = avt - model
		fb, rb, wb   = spectral_binning_fixed_frequency(flow, fhigh, fbin, fx, avr, avw)
		rb_nr, wb_nr = RFI_cleaning_std(fb, rb, wb, n_sigma = 2.5, df_MHz = 20, npar = 4)

		if i == 0:
			rb_all = np.copy(rb_nr)
			wb_all = np.copy(wb_nr)

		elif i > 0:
			rb_all = np.vstack((rb_all, rb_nr))
			wb_all = np.vstack((wb_all, wb_nr))



		ax.plot(fb[wb_nr>0], -rb_nr[wb_nr>0] + K*i)
		ax.text(rms_text_freq, K*i, str(int(round(np.std(1000*rb_nr[wb_nr>0]))))+' mK', fontsize=fontsize, fontweight='bold')



	ax.set_xlim([flow_lim, fhigh+(fhigh_lim-fhigh)/2])
	ax.set_ylim([-K, K*(Nav+1)])
	ax.set_xlabel('frequency [MHz]')
	ax.set_ylabel(str(int(1000*K)) + ' mK per division')
	ax.invert_yaxis()
	ax.set_xticks(np.arange(xticks_low, xticks_high+1, xticks_delta))
	ax.set_yticks(K*np.arange(0,Nav, 1))



	for i in range(int(Nav)):
		print('jejejejeje')
		if i == 0:
			yt = [str(int(date_start[i,0])) + '-' + str(int(date_start[i,1])) + '\n' + str(int(date_end[i,0])) + '-' + str(int(date_end[i,1]))]
		elif i > 0:
			yt.append(str(int(date_start[i,0])) + '-' + str(int(date_start[i,1])) + '\n' + str(int(date_end[i,0])) + '-' + str(int(date_end[i,1])))                      
	ax.set_yticklabels(yt)
	plt.grid()



	ax = fig.add_axes([0.15, 0.83, 0.8, 0.16])
	avt, avw     = spectral_averaging(tx, wx)

	p            = fit_polynomial_fourier(model_type, fx/fnorm, avt, nfg, Weights=avw)
	model        = model_evaluate(model_type, p[0], fx/fnorm)       
	avr          = avt - model
	fb, rb, wb   = spectral_binning_fixed_frequency(flow, fhigh, fbin, fx, avr, avw)
	rb_nr, wb_nr = RFI_cleaning_std(fb, rb, wb, n_sigma = 2.5, df_MHz = 20, npar = 4)


	ax.plot(fb[wb_nr>0], 1000*rb_nr[wb_nr>0])
	ax.text(rms_text_freq, 0, str(int(round(np.std(1000*rb_nr[wb_nr>0]))))+' mK', fontsize=fontsize, fontweight='bold')

	ax.set_xlim([flow_lim, fhigh+(fhigh_lim-fhigh)/2])
	ax.set_xticks(np.arange(xticks_low, xticks_high+1, xticks_delta))
	ax.set_xticklabels('')
	ax.set_xlabel('')

	ax.set_ylim([-1000*K, 1000*K])
	ax.set_yticks(1000*np.arange(-(K)+(K/4),(K),K/4))
	ax.set_ylabel('T [mK] \n all data averaged')

	plt.grid()

	plt.savefig(home_folder + '/Desktop/total_average_' + band + '_all_days' + plot_flag + '.pdf', bbox_inches='tight')
	plt.close()        






	return 0 #weather_complete   #0 #fb, wb_all_out, we_all

























def probing_anastasia_model(f, d, w, nterms_fg=5, case=1):




	if case == 1:

		# Initialization
		T21_K_ref  = 1
		n_models   = 195
		p_rec  = np.zeros(n_models)
		dp_rec = np.zeros(n_models)
		r = np.zeros((n_models, len(f)))


		# Probe all models
		for j in range(n_models):

			print(j)
			p          = fit_polynomial_fourier('EDGES_polynomial_plus_anastasia', f, d, nterms_fg, Weights=w, anastasia_model_number=j)
			p_rec[j]   = p[0][nterms_fg]
			dp_rec[j]  = np.sqrt(np.diag(p[3]))[nterms_fg]


			model  = model_evaluate('EDGES_polynomial_plus_anastasia', p[0], f, anastasia_model_number=j)
			r[j,:] = d - model   


		# 2D detection/rejection array
		dr = (p_rec - T21_K_ref)/dp_rec


		# Plotting
		plt.figure(1)

		plt.subplot(2,1,1)
		plt.errorbar(np.arange(0,len(p_rec)), p_rec, dp_rec)
		#plt.ylim([-2, 2])
		plt.grid()
		plt.ylabel('estimated amplitude')

		plt.subplot(2,1,2)
		plt.plot(np.arange(0,len(p_rec)), dr)
		#plt.ylim([-2, 2])
		plt.grid()
		plt.xlabel('model number')
		plt.ylabel(r'detection / rejection significance [$\sigma$]')






	if case == 2:

		# Initialization
		n_models   = 195
		r = np.zeros((n_models, len(f)))


		# Probe all models
		for j in range(n_models):

			print(j)

			ma     = model_eor_anastasia(j, f, interpolation_kind='linear')
			p      = fit_polynomial_fourier('EDGES_polynomial', f, d-ma, nterms_fg, Weights=w)
			model  = model_evaluate('EDGES_polynomial', p[0], f)
			r[j,:] = d-ma - model



	return r








def data_selection_single_day_v3(band, date, LST_1, LST_2, sun_el_max = -10, moon_el_max=90, amb_hum_max = 90, min_receiver_temp=23, max_receiver_temp=27):

	"""
	band = 'high_band', or 'low_band'. Not 'high_band_2015'.

	This is the only version. There is no v1 or v2.

	"""

	if band == 'high_band_2015':
		band = 'high_band'

	elif band == 'low_band_2015':
		band = 'low_band_50_120MHz'

	elif band == 'low_band2_2017':
		band = 'low_band2'

	# Loading data
	path_data = home_folder + '/DATA/EDGES/spectra/level2/' + band + '/v2/'


	# Generating index of data within range of LST
	filename    = path_data + date + '.hdf5'
	f, t, m, w  = level2read_v2(filename)


	index       = np.arange(len(m[:,0]))
	index_LST_1 = index[m[:,3]  >= LST_1]
	index_LST_2 = index[m[:,3]  <  LST_2]


	# Applying cuts for Sun elevation, ambient humidity, and receiver temperature
	index_SUN  = index[m[:,6]   <= sun_el_max]
	index_MOON = index[m[:,8]   <= moon_el_max]
	index_HUM  = index[m[:,10]  <= amb_hum_max]
	index_Trec = index[(m[:,11] >= min_receiver_temp) & (m[:,11] <= max_receiver_temp)]   # restricting receiver temperature Trec from thermistor 2 (S11 switch)


	# Combined index
	if LST_1 < LST_2:
		index1    = np.intersect1d(index_LST_1, index_LST_2)

	elif LST_1 > LST_2:
		index1    = np.union1d(index_LST_1, index_LST_2)

	index2    = np.intersect1d(index_SUN, index_MOON)
	index3    = np.intersect1d(index2, index_HUM)
	index4    = np.intersect1d(index3, index_Trec)
	index_all = np.intersect1d(index1, index4)

	print('NUMBER OF TRACES: ' + str(len(index_all)))


	# If there are traces available
	if len(index_all) > 1:

		# Select traces
		t_sel2   = t[index_all, :]
		w_sel2   = w[index_all, :]
		m_sel2   = m[index_all, :]


		# RFI-cleaning set of single-traces
		#t_sel2, w_sel2, t_sets, w_sets = RFI_cleaning_traces(f, t_sel, w_sel, 16)

	else:
		t_sel2  = 0
		w_sel2  = 0
		m_sel2  = 0


	return f, t_sel2, w_sel2, m_sel2






















def results_daily_spectra(fin, tc_all, wc_all, wea_all, LST, delta_LST, flow=90, fhigh=190, fbin=0.4, model_type='EDGES_polynomial', fnorm=140, nfg=3):


	plt.close()
	plt.close()
	plt.close()
	plt.close()


	LST_steps     = np.arange(LST[0, 3], LST[-1, 3], delta_LST)
	if LST_steps[-1] < LST[-1, 3]:
		LST_steps = np.append(LST_steps, LST[-1, 3])

	flag = 0
	for i in range(len(LST_steps)-1):

		print(i)


		t_sel   = tc_all[(LST[:,3] >= LST_steps[i]) & (LST[:,3] <= LST_steps[i+1]),:]
		w_sel   = wc_all[(LST[:,3] >= LST_steps[i]) & (LST[:,3] <= LST_steps[i+1]),:]
		wea_sel = wea_all[(LST[:,3] >= LST_steps[i]) & (LST[:,3] <= LST_steps[i+1]),:]


		avt0, avw0 = spectral_averaging(t_sel, w_sel)


		# Continue if enough data available (weights greater than zero), no NaNs, and no indeterminate divisions 
		if (np.sum(avw0) > 0) and (np.sum(np.isnan(avt0)) == 0) and (np.sum(np.isinf(avt0)) == 0):

			# RFI-cleaning the average traces
			avt1, avw1 = RFI_excision_raw_frequency(fin, avt0, avw0)
			avt, avw   = RFI_cleaning_std(fin, avt1, avw1, n_sigma = 3.5, df_MHz = 20, npar = 4)


			# Selecting data within desired frequency range
			fx = fin[(fin>=flow) & (fin<=fhigh)]
			tx = avt[(fin>=flow) & (fin<=fhigh)]
			wx = avw[(fin>=flow) & (fin<=fhigh)]

			# Computing residuals
			p            = fit_polynomial_fourier(model_type, fx/fnorm, tx, nfg, Weights=wx)
			model        = model_evaluate(model_type, p[0], fx/fnorm)
			rr           = tx - model
			fb, rb, wb   = spectral_binning_fixed_frequency(flow, fhigh, fbin, fx, rr, wx)
			rb_nr, wb_nr = RFI_cleaning_std(fb, rb, wb, n_sigma = 2.5, df_MHz = 20, npar = 4)




			# Storing data
			if flag == 0:
				avt_all = np.copy(avt).reshape(1,-1)
				avw_all = np.copy(avw).reshape(1,-1)
				rb_all  = np.copy(rb_nr)
				wb_all  = np.copy(wb_nr)
				flag    = 1


			elif flag > 0:
				avt_all = np.append(avt_all, avt.reshape(1,-1), axis=0)
				avw_all = np.append(avw_all, avw.reshape(1,-1), axis=0)
				rb_all  = np.vstack((rb_all, rb_nr))
				wb_all  = np.vstack((wb_all, wb_nr))










	return fb, rb_all, wb_all, LST_steps









def plot_spectra_residuals(fb, rb_all, wb_all, season_or_daily, LST_or_day, K=1, rms_offset=0, flow_lim=50, fhigh_lim=200, xticks_low=50, xticks_high=200, xticks_delta=10, rms_text_freq=195, fontsize=10, size_x_column=5, size_y=20, NSC=35, y_label='hola [hr]', plot_name='hola'):

	# LST_or_day: in case of day, use: wea[:,1] or something like that

	# ###############################################################
	# Plotting binned daily residual spectra
	#size_y = 20               # y-size of figure
	NS     = len(rb_all[:,0]) # number of spectra
	#NSC    = 35               # number of spectra per column
	NC     = np.ceil(NS/NSC)  # number of columns
	size_x = NC*size_x_column             # x-size of figure

	#rms_text_freq = 192
	#xticks_low    = 120
	#xticks_high   = 190
	#xticks_delta  = 10
	#fontsize      = 10

	#flow_lim      = 120
	#fhigh_lim     = 210


	#if band == 'high_band':
		#K = 0.5

	#elif band == 'low_band':
		#K = 2		

	plt.close()
	plt.close()
	plt.close()

	fig = plt.figure(num=1, figsize=(size_x, size_y))

	ax = fig.add_subplot(1,NC,1)
	if NS > NSC:
		NS2 = NSC
	else:
		NS2 = NS


	# First column of residuals
	for i in np.arange(0,NS2):

		rrr = np.copy(rb_all[i,:])
		rrr[wb_all[i,:]==0] = np.nan
		# rb_all[i,wb_all[i,:]>0],  [wb_all[i,:]>0]

		if (i % 2 == 0):
			ax.plot(fb, -rrr + K*i, 'b')
		else:
			ax.plot(fb, -rrr + K*i, 'r')

		ax.text(rms_text_freq, K*i+0.0, str(int(round(np.std(1000*rb_all[i,wb_all[i,:]>0])))+rms_offset)+' mK', fontsize=fontsize, fontweight='bold')
	plt.xlim([flow_lim, fhigh_lim])
	plt.ylim([-K*1, K*NSC])
	plt.xlabel('frequency [MHz]')
	ax.invert_yaxis()
	ax.set_xticks(np.arange(xticks_low, xticks_high+1, xticks_delta))	
	ax.set_yticks(K*np.arange(0,NSC,1))

	if season_or_daily == 'season':
		date_list = [int(l) for l in LST_or_day[0:NSC].tolist()]
		ax.set_yticklabels(date_list)		
		#plt.ylabel('day of year')
		plt.ylabel(y_label)

	elif season_or_daily == 'daily':
		date_list = [round(l,2) for l in LST_or_day[0:NSC].tolist()]
		ax.set_yticklabels(date_list)				
		#plt.ylabel('LST [hr]')
		plt.ylabel(y_label)


	# Additional columns
	for j in range(15):

		if NS > (j+1)*NSC:
			if NS > (j+2)*NSC:
				NS2 = (j+2)*NSC
			else:
				NS2 = NS		

			ax = fig.add_subplot(1,NC,(j+2))
			for i in np.arange((j+1)*NSC,NS2):

				rrr = np.copy(rb_all[i,:])
				rrr[wb_all[i,:]==0] = np.nan

				if (i % 2 == 0):
					ax.plot(fb, -rrr + K*i, 'b')
				else:
					ax.plot(fb, -rrr + K*i, 'r')	

				ax.text(rms_text_freq, K*i+0.0, str(int(round(np.std(1000*rb_all[i,wb_all[i,:]>0])))+rms_offset)+' mK', fontsize=fontsize, fontweight='bold')
			plt.xlim([flow_lim, fhigh_lim])
			plt.ylim([K*((j+1)*NSC-1), K*((j+2)*NSC)])
			plt.xlabel('frequency [MHz]')
			ax.invert_yaxis()
			ax.set_xticks(np.arange(xticks_low, xticks_high+1, xticks_delta))
			ax.set_yticks(K*np.arange((j+1)*NSC, (j+2)*NSC, 1))

			if season_or_daily == 'season':
				date_list = [int(l) for l in LST_or_day[((j+1)*NSC):((j+2)*NSC)].tolist()]
				ax.set_yticklabels(date_list)

			elif season_or_daily == 'daily':
				date_list = [round(l,2) for l in LST_or_day[((j+1)*NSC):((j+2)*NSC)].tolist()]
				ax.set_yticklabels(date_list)

	plt.savefig(home_folder + '/Desktop/' + plot_name + '.pdf', bbox_inches='tight')
	plt.close()

	return 0









def low_band_september_2016_noise_source():

	# Load spectra
	file1 = home_folder + '/DATA/EDGES/spectra/level1/calibration_september_2016/300_350/level1_Alans_Noise_Source_no_attenuator_2016_293_00_300_350.mat'
	file2 = home_folder + '/DATA/EDGES/spectra/level1/calibration_september_2016/300_350/level1_Alans_Noise_Source_no_attenuator_2016_294_00_300_350.mat'
	file3 = home_folder + '/DATA/EDGES/spectra/level1/calibration_september_2016/300_350/level1_Alans_Noise_Source_no_attenuator_2016_295_00_300_350.mat'

	ta1, xxx = level1_MAT(file1, plot='no')
	ta2, xxx = level1_MAT(file2, plot='no')
	ta3, xxx = level1_MAT(file3, plot='no')

	ta0 = np.concatenate((ta1, ta2, ta3), axis=0)










	# Frequency
	ff, il, ih = frequency_edges(50,100)
	fe = ff[il:(ih+1)]


	# Select frequency range
	ta_unc = ta0[:, il:(ih+1)]


	# Receiver calibration quantities
	s11_LNA, sca, off, TU, TC, TS = receiver_calibration('low_band_2016', fe, receiver_temperature=25, low_band_cal_file=1)



	# Calibrated antenna temperature with losses
	s11_ant = ecc # CHANGE THIS TO A REFLECTION COEFFICIENT INTEPROLATED TO THE SPECTRA FREQUENCY RESOLUTION
	ta_cal  = calibrated_antenna_temperature(ta_unc, s11_ant, s11_LNA, sca, off, TU, TC, TS)	



	## Removing loss
	#Tant_cal = (Tant_cal_with_loss - Tambient*(1-combined_gain))/combined_gain	


	return fe, ta_cal, fs, ecc

























def data_analysis_spectrum_high_to_low_resolution(fx, tx_rfi, wx_rfi, flow=89, fhigh=191, fnorm=140, nfg=5, pre_rfi_flagging='yes', post_rfi_flagging='yes'):

	# RFI flagging at raw resolution
	if pre_rfi_flagging == 'yes':
		tx, wx = RFI_cleaning_std(fx, tx_rfi, wx_rfi, n_sigma=4, df_MHz=20, npar=4)

	# Fit model
	model_type='EDGES_polynomial'
	nfg=nfg

	# Fitting model at raw resolution
	p  = fit_polynomial_fourier(model_type, fx/fnorm, tx, nfg, Weights=wx)

	# Computing and binning residuals
	fb, rb, wb, rms, rms_110 = data_analysis_residuals_array(fx, tx.reshape(1,-1), wx.reshape(1,-1), flow=flow, fhigh=fhigh, model_type=model_type, fnorm=fnorm, nfg=nfg, binning='yes', nsamples=64, rfi_flagging=post_rfi_flagging)	

	# Evaluating model at binned frequency
	mb = model_evaluate(model_type, p[0], fb/fnorm)

	# Output low-resolution array
	tb = mb+rb

	return fb, tb, wb




















def data_analysis_phenomenological_detection_rejection(band, data_or_file='data', filecase=1, fin=0, tin=0, win=0, foreground_model='EDGES_polynomial', nterms_fg=5, signal_model='tanh', T21_K_ref_list=[0.028], real_simulated='real', flow=90, fhigh=190, z_alpha=0, sim_time_factor=1, sim_with_gaussian='no', save='no', save_flag='_flag'):

	# data_or_file: it selects to process input data (fin, tin, win) or file from filecase
	# T21_K_ref_list=[-0.3, -0.1]


	if (data_or_file == 'file') & (band == 'high_band'):

		if filecase == 1:
			data = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/spectra/high_band_average_20161129_nominal.txt')

		elif filecase == 2:
			data = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/spectra/high_band_average_20161129_ants11_1.txt')	# all 212

		elif filecase == 3:
			data = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/spectra/high_band_average_20161129_ants11_2.txt')	# all 262

		elif filecase == 4:
			data = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/spectra/high_band_average_20161129_ants11_3.txt')	# average

		elif filecase == 5:
			data = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/spectra/high_band_average_20161129_gndloss_1.txt')	# value to Alan

		elif filecase == 6:
			data = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/spectra/high_band_average_20161129_recv_1.txt')	# 7 to 6 cwterms

		elif filecase == 7:
			data = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/spectra/high_band_average_20161129_recv_2.txt')	# RCV temp at 25degC

		elif filecase == 8:
			data = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/spectra/high_band_average_20161129_recv_3.txt')	# RCV MC

		elif filecase == 9:
			data = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/spectra/high_band_average_20161129_recv_4.txt')	# RCV MC

		elif filecase == 12:
			data = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/spectra/high_band_average_20161130_beam_02.txt')	# beam case 2

		elif filecase == 13:
			data = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/spectra/high_band_average_20161130_beam_03.txt')	# beam case 2

		elif filecase == 14:
			data = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/spectra/high_band_average_20161130_beam_04.txt')	# beam case 2

		elif filecase == 15:
			data = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/spectra/high_band_average_20161130_beam_05.txt')	# beam case 2

		elif filecase == 16:
			data = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/spectra/high_band_average_20161130_beam_06.txt')	# beam case 2

		elif filecase == 17:
			data = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/spectra/high_band_average_20161130_beam_07.txt')	# beam case 2

		elif filecase == 18:
			data = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/spectra/high_band_average_20161130_beam_08.txt')	# beam case 2

		elif filecase == 19:
			data = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/spectra/high_band_average_20161130_beam_09.txt')	# beam case 2

		elif filecase == 20:
			data = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/spectra/high_band_average_20161130_beam_10.txt')	# beam case 2

		elif filecase == 21:
			data = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/spectra/high_band_average_20161130_beam_11.txt')	# beam case 2

		elif filecase == 31:
			data = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/spectra/high_band_average_20161130_beam_21.txt')	# beam case 2

		elif filecase == 32:
			data = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/spectra/high_band_average_20161130_beam_22.txt')	# beam case 2

		elif filecase == 33:
			data = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/spectra/high_band_average_20161130_beam_23.txt')	# beam case 2

		elif filecase == 34:
			data = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/spectra/high_band_average_20161130_beam_24.txt')	# beam case 2

		elif filecase == 35:
			data = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/spectra/high_band_average_20161130_beam_25.txt')	# beam case 2

		elif filecase == 36:
			data = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/spectra/high_band_average_20161130_beam_26.txt')	# beam case 2		


		# Loading data
		ff = data[:,0]
		tt = data[:,1]
		ww = data[:,2]



	# Processing input data instead of files
	if (data_or_file == 'data'):
		ff = np.copy(fin)
		tt = np.copy(tin)
		ww = np.copy(win)



	# Selecting data in desired range
	f = ff[(ff >= flow) & (ff <= fhigh)]
	t = tt[(ff >= flow) & (ff <= fhigh)]
	w = ww[(ff >= flow) & (ff <= fhigh)]		


	# Producing simulated data
	if real_simulated == 'simulated':

		p          = fit_polynomial_fourier(foreground_model, f, t, nterms_fg, Weights=w)
		t_nn       = p[1]

		dt = 60*60*0.4 * sim_time_factor  # 1.8     # 3.6
		df = 390*1e3
		n  = np.random.normal(0, t_nn/np.sqrt(dt*df))   # realistic noise similar to real High-Band data
		t  = t_nn + n
		w  = np.ones(len(t))


		if sim_with_gaussian == 'g1':
			g1, xx, xxx = model_eor(f, T21 = -0.15, model_type='gaussian_redshift', zr=7, dz=3)
			t = t + g1

		if sim_with_gaussian == 'g2':
			g2, xx, xxx = model_eor(f, T21 = -0.15, model_type='gaussian_redshift', zr=9, dz=3)
			t = t + g2

		if sim_with_gaussian == 'g3':
			g3, xx, xxx = model_eor(f, T21 = -0.15, model_type='gaussian_redshift', zr=11, dz=3)
			t = t + g3		




	# Redshift range
	zlow   = frequency2redshift(np.max(f))
	zhigh  = frequency2redshift(np.min(f))



	# Tanh EoR model
	if signal_model == 'tanh':

		# Selecting full signal model
		if foreground_model == 'EDGES_polynomial':
			MT = 'EDGES_polynomial_plus_tanh'

		if foreground_model == 'Physical_model':
			MT = 'Physical_model_plus_tanh'

		# Reference amplitude of Gaussian
		T21_K_ref = np.array(T21_K_ref_list)

		# Detection-Rejection domain (z - dz)
		z      = np.arange(zlow, zhigh, 0.02) # 0.1
		dz     = np.arange(0.02, 2.01, 0.02) # 0.1			




	# Negative Gaussian in Redshift
	if signal_model == 'gaussian_redshift':

		# Selecting full signal model
		if foreground_model == 'EDGES_polynomial':
			MT = 'EDGES_polynomial_plus_gaussian_redshift'

		if foreground_model == 'Physical_model':
			MT = 'Physical_model_plus_gaussian_redshift'

		# Reference amplitude of Gaussian
		#T21_K_ref = np.arange(-0.4, -0.045, 0.01)
		T21_K_ref      = np.array(T21_K_ref_list)

		# Detection-Rejection domain (z - dz)
		z      = np.arange(zlow, zhigh, 0.02) # 0.1
		dz     = np.arange(0.2, 8.01, 0.04) # 0.1			



	# Estimate and Uncertainty for 21-cm amplitude
	p_rec  = np.zeros((len(dz), len(z)))
	dp_rec = np.zeros((len(dz), len(z)))


	# Residuals and weighted RMS
	res    = np.zeros(( len(dz), len(z), len(f) ))
	wRMS   = np.zeros((len(dz), len(z)))


	# Temperature at redshift z=6
	T6     = np.zeros((len(dz), len(z), len(T21_K_ref)))


	# Residuals for NO signal
	p0     = fit_polynomial_fourier(foreground_model, f, t, nterms_fg, Weights=w)
	r0     = t - p0[1]   # data minus model
	wRMS0  = p0[2]


	# Sweeping Detection - Rejection domain
	for j in range(len(z)):
		for i in range(len(dz)):


			# Print combination of z - dz
			print((z[j], dz[i]))


			# Fitting model
			p = fit_polynomial_fourier(MT, f, t, nterms_fg, Weights=w, zr=z[j], dz=dz[i], z_alpha=z_alpha)


			# Saving parameter estimate and uncertainty
			p_rec[i,j]  = p[0][nterms_fg]
			dp_rec[i,j] = np.sqrt(np.diag(p[3]))[nterms_fg]


			# Saving residuals
			res[i,j,:] = t - p[1]   # data minus models


			# Saving weighted RMS
			wRMS[i,j] = p[2]


			# Computing and saving brightness temperature at z=6
			zref = 6
			tt, xx, yy = model_eor(redshift2frequency(np.array([14, 10, zref])), T21=1, model_type=signal_model, zr=z[j], dz=dz[i], z_alpha=z_alpha, dz_accuracy_skewed_gaussian=(dz[1]-dz[0])/4)
			for k in range(len(T21_K_ref)):	
				T6[i,j,k] = T21_K_ref[k] * tt[-1]   # tt[-1] is redshift "zref"




	# Produce 1-sigma line from 2D uncertainty array
	dz_line = np.zeros((len(z), len(T21_K_ref)))
	for j in range(len(z)):
		for i in range(len(dz)-1):
			for k in range(len(T21_K_ref)):
				if (dp_rec[i,j] <= np.abs(T21_K_ref[k])/2) and (dp_rec[i+1,j] >= np.abs(T21_K_ref[k])/2):
					dz_line[j,k] = dz[i]



	# 2D detection/rejection array
	dr = np.zeros((len(dz), len(z), len(T21_K_ref)))
	for k in range(len(T21_K_ref)):
		dr[:,:,k] = (p_rec - T21_K_ref[k])/dp_rec



	# Produce line of 95% rejection
	dr_line = np.copy(dz_line)
	for j in range(len(z)):
		for k in range(len(T21_K_ref)):


			if T21_K_ref[k] > 0:

				if dr[0,j,k] >= -2:
					dr_line[j,k] = dz[0]

				elif dr[0,j,k]<= -2:
					for i in range(len(dz)-1):			
						if (dp_rec[i,j] <= np.abs(T21_K_ref[k])/2) and ((dr[i,j,k] <= -2) and (dr[i+1,j,k] >= -2)):					
							dr_line[j,k] = dz[i]



			if T21_K_ref[k] < 0:

				if dr[0,j,k] <= 2:
					dr_line[j,k] = dz[0]

				elif dr[0,j,k]>= 2:
					for i in range(len(dz)-1):			
						if (dp_rec[i,j] <= np.abs(T21_K_ref[k])/2) and ((dr[i,j,k] >= 2) and (dr[i+1,j,k] <= 2)):
							dr_line[j,k] = dz[i]






	# Save output quantities

	if save == 'yes':

		if (data_or_file == 'file') & (real_simulated == 'real'):
			save_file = home_folder + '/DATA/EDGES/results/' + band + '/model_rejection/phenomenological/' + band + '_filecase' + str(datacase) + '_' + str(flow) + '-' + str(fhigh) + 'MHz_' + foreground_model + '_' + str(nterms_fg) + 'terms_' + signal_model + '_skewness_' + str(z_alpha) + '.hdf5'


		if (data_or_file == 'data') & (real_simulated == 'real'):
			save_file = home_folder + '/DATA/EDGES/results/' + band + '/model_rejection/phenomenological/' + band + save_flag + '.hdf5'



		elif real_simulated == 'simulated':
			save_file = home_folder + '/DATA/EDGES/results/' + band + '/model_rejection/phenomenological/' + band + '_simulated_' + str(flow) + '-' + str(fhigh) + 'MHz_' + foreground_model + '_' + str(nterms_fg) + 'terms_' + signal_model + '_skewness_' + str(z_alpha) + '.hdf5'

		with h5py.File(save_file, 'w') as hf:
			hf.create_dataset('f',        data = f)
			hf.create_dataset('res0',     data = r0)
			hf.create_dataset('wRMS0',    data = wRMS0)
			hf.create_dataset('z',        data = z)
			hf.create_dataset('dz',       data = dz)	
			hf.create_dataset('res',      data = res)
			hf.create_dataset('wRMS',     data = wRMS)
			hf.create_dataset('T6',       data = T6)        # takes too long to run for a skewed Gaussian.
			hf.create_dataset('p_rec',    data = p_rec)
			hf.create_dataset('dp_rec',   data = dp_rec)
			hf.create_dataset('dr',       data = dr)
			hf.create_dataset('dz_line',  data = dz_line)
			hf.create_dataset('dr_line',  data = dr_line)


	return f, r0, wRMS0, z, dz, res, wRMS, T6, p_rec, dp_rec, dr, dz_line, dr_line    




















def data_analysis_high_band_data_averages():


	RECV_TEMP = 'actual'	


	## Centered at LST = 21.76
	#FN = 31

	#fin, tc_all, wc_all, wea_all, LST_all, bt = eg.data_analysis_calibration('high_band_2015', 'season', save='no', season_file_number=FN, receiver_temperature=RECV_TEMP)
	#tx_all, wx_all, we_all, bx                = eg.data_analysis_daily_spectra_filter('high_band_2015', FN, tc_all, wc_all, wea_all, bt)

	##fb, rb, wb, rms, rms_110 = eg.data_analysis_residuals_array(fin, tx_all, wx_all, flow=90, fhigh=190, model_type='Physical_model', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')
	##o = eg.plot_spectra_residuals(fb, rb, wb, 'season', we_all[:,1], K=1, flow_lim=80, fhigh_lim=220, xticks_low=80, xticks_high=220, xticks_delta=20, rms_text_freq=195, fontsize=10, size_x_column=7, size_y=20, NSC=35, y_label='day of year', plot_name='LST22.76')

	#index        = np.arange(len(we_all[:,0]))
	#in1          = index[(we_all[:,0] == 2015) & (we_all[:,1] == 206)]
	#in2          = index[(we_all[:,0] == 2015) & (we_all[:,1] == 324)] + 1

	#avt22, avw22                              = eg.spectral_averaging(tx_all[in1:in2,:], wx_all[in1:in2,:])
	#fb, rb_nr_22, wb_nr_22, rms22, rms_110_22 = eg.data_analysis_residuals_array(fin, avt22.reshape((1,-1)), avw22.reshape((1,-1)), flow=90, fhigh=190, model_type='Physical_model', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')		







	## Centered at LST = 22.76
	#FN = 32

	#fin, tc_all, wc_all, wea_all, LST_all, bt = eg.data_analysis_calibration('high_band_2015', 'season', save='no', season_file_number=FN, receiver_temperature=RECV_TEMP)
	#tx_all, wx_all, we_all, bx                = eg.data_analysis_daily_spectra_filter('high_band_2015', FN, tc_all, wc_all, wea_all, bt)

	##fb, rb, wb, rms, rms_110 = eg.data_analysis_residuals_array(fin, tx_all, wx_all, flow=90, fhigh=190, model_type='Physical_model', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')
	##o = eg.plot_spectra_residuals(fb, rb, wb, 'season', we_all[:,1], K=1, flow_lim=80, fhigh_lim=220, xticks_low=80, xticks_high=220, xticks_delta=20, rms_text_freq=195, fontsize=10, size_x_column=7, size_y=20, NSC=35, y_label='day of year', plot_name='LST22.76')

	#index        = np.arange(len(we_all[:,0]))
	#in1          = index[(we_all[:,0] == 2015) & (we_all[:,1] == 206)]
	#in2          = index[(we_all[:,0] == 2015) & (we_all[:,1] == 324)] + 1

	#avt22, avw22                              = eg.spectral_averaging(tx_all[in1:in2,:], wx_all[in1:in2,:])
	#fb, rb_nr_22, wb_nr_22, rms22, rms_110_22 = eg.data_analysis_residuals_array(fin, avt22.reshape((1,-1)), avw22.reshape((1,-1)), flow=90, fhigh=190, model_type='Physical_model', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')		






	## Centered at LST = 23.76
	#FN = 33

	#fin, tc_all, wc_all, wea_all, LST_all, bt = eg.data_analysis_calibration('high_band_2015', 'season', save='no', season_file_number=FN, receiver_temperature=RECV_TEMP)
	#tx_all, wx_all, we_all, bx                = eg.data_analysis_daily_spectra_filter('high_band_2015', FN, tc_all, wc_all, wea_all, bt)

	##fb, rb, wb, rms, rms_110 = eg.data_analysis_residuals_array(fin, tx_all, wx_all, flow=90, fhigh=190, model_type='Physical_model', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')
	##o = eg.plot_spectra_residuals(fb, rb, wb, 'season', we_all[:,1], K=1, flow_lim=80, fhigh_lim=220, xticks_low=80, xticks_high=220, xticks_delta=20, rms_text_freq=195, fontsize=10, size_x_column=7, size_y=20, NSC=35, y_label='day of year', plot_name='LST23.76')

	#index        = np.arange(len(we_all[:,0]))
	#in1          = index[(we_all[:,0] == 2015) & (we_all[:,1] == 206)]
	#in2          = index[(we_all[:,0] == 2015) & (we_all[:,1] == 334)] + 1

	#avt23, avw23                            = eg.spectral_averaging(tx_all[in1:in2,:], wx_all[in1:in2,:])
	#fb, rb_nr_23, wb_nr_23, rms23, rms_110_23 = eg.data_analysis_residuals_array(fin, avt23.reshape((1,-1)), avw23.reshape((1,-1)), flow=90, fhigh=190, model_type='Physical_model', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')	





	# Centered at LST = 0.76
	FN = 10

	fin, tc_all, wc_all, wea_all, LST_all, bt = data_analysis_calibration('high_band_2015', 'season', save='no', season_file_number=FN, receiver_temperature=RECV_TEMP)
	tx_all, wx_all, we_all, bx                = data_analysis_daily_spectra_filter('high_band_2015', FN, tc_all, wc_all, wea_all, bt)

	#fb, rb, wb, rms, rms_110 = eg.data_analysis_residuals_array(fin, tx_all, wx_all, flow=90, fhigh=190, model_type='Physical_model', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')
	#o = eg.plot_spectra_residuals(fb, rb, wb, 'season', we_all[:,1], K=1, flow_lim=80, fhigh_lim=220, xticks_low=80, xticks_high=220, xticks_delta=20, rms_text_freq=195, fontsize=10, size_x_column=7, size_y=20, NSC=35, y_label='day of year', plot_name='LST0.76')


	# Selection for 90-190 MHz
	index           = np.arange(len(we_all[:,0]))
	in1             = index[(we_all[:,0] == 2015) & (we_all[:,1] == 208)]
	in2             = index[(we_all[:,0] == 2015) & (we_all[:,1] == 289)] + 1	

	avt0_A, avw0_A  = spectral_averaging(tx_all[in1:in2,:], wx_all[in1:in2,:])
	#fb, rb_nr_0, wb_nr_0, rms0, rms_110_0 = eg.data_analysis_residuals_array(fin, avt0.reshape((1,-1)), avw0.reshape((1,-1)), flow=90, fhigh=190, model_type='Physical_model', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')


	# Selectino for 115-190 MHz
	index           = np.arange(len(we_all[:,0]))
	in1             = index[(we_all[:,0] == 2015) & (we_all[:,1] == 208)]
	in2             = index[(we_all[:,0] == 2015) & (we_all[:,1] == 349)] + 1

	avt0_B, avw0_B  = spectral_averaging(tx_all[in1:in2,:], wx_all[in1:in2,:])
	#fb, rb_nr_0, wb_nr_0, rms0, rms_110_0 = eg.data_analysis_residuals_array(fin, avt0.reshape((1,-1)), avw0.reshape((1,-1)), flow=90, fhigh=190, model_type='Physical_model', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')














	# Centered at LST = 1.76
	FN = 11

	fin, tc_all, wc_all, wea_all, LST_all, bt = data_analysis_calibration('high_band_2015', 'season', save='no', season_file_number=FN, receiver_temperature=RECV_TEMP)
	tx_all, wx_all, we_all, bx                = data_analysis_daily_spectra_filter('high_band_2015', FN, tc_all, wc_all, wea_all, bt)

	#fb, rb, wb, rms, rms_110 = eg.data_analysis_residuals_array(fin, tx_all, wx_all, flow=90, fhigh=190, model_type='Physical_model', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')
	#o = eg.plot_spectra_residuals(fb, rb, wb, 'season', we_all[:,1], K=1, flow_lim=80, fhigh_lim=220, xticks_low=80, xticks_high=220, xticks_delta=20, rms_text_freq=195, fontsize=10, size_x_column=7, size_y=20, NSC=35, y_label='day of year', plot_name='LST1.76')

	index           = np.arange(len(we_all[:,0]))
	in1             = index[(we_all[:,0] == 2015) & (we_all[:,1] == 207)]
	in2             = index[(we_all[:,0] == 2015) & (we_all[:,1] == 301)] + 1

	avt1_A, avw1_A  = spectral_averaging(tx_all[in1:in2,:], wx_all[in1:in2,:])
	#fb, rb_nr_1, wb_nr_1, rms1, rms_110_1 = eg.data_analysis_residuals_array(fin, avt1.reshape((1,-1)), avw1.reshape((1,-1)), flow=90, fhigh=190, model_type='Physical_model', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')


	index           = np.arange(len(we_all[:,0]))
	in1             = index[(we_all[:,0] == 2015) & (we_all[:,1] == 207)]
	in2             = index[(we_all[:,0] == 2015) & (we_all[:,1] == 362)] + 1

	avt1_B, avw1_B  = spectral_averaging(tx_all[in1:in2,:], wx_all[in1:in2,:])
	#fb, rb_nr_1, wb_nr_1, rms1, rms_110_1 = eg.data_analysis_residuals_array(fin, avt1.reshape((1,-1)), avw1.reshape((1,-1)), flow=90, fhigh=190, model_type='Physical_model', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')















	# Centered at LST = 2.76
	FN = 12
	fin, tc_all, wc_all, wea_all, LST_all, bt = data_analysis_calibration('high_band_2015', 'season', save='no', season_file_number=FN, receiver_temperature=RECV_TEMP)
	tx_all, wx_all, we_all, bx                = data_analysis_daily_spectra_filter('high_band_2015', FN, tc_all, wc_all, wea_all, bt)

	#fb, rb, wb, rms, rms_110 = eg.data_analysis_residuals_array(fin, tx_all, wx_all, flow=90, fhigh=190, model_type='Physical_model', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')
	#o = eg.plot_spectra_residuals(fb, rb, wb, 'season', we_all[:,1], K=1, flow_lim=80, fhigh_lim=220, xticks_low=80, xticks_high=220, xticks_delta=20, rms_text_freq=195, fontsize=10, size_x_column=7, size_y=20, NSC=35, y_label='day of year', plot_name='LST2.76')	

	index          = np.arange(len(we_all[:,0]))
	in1            = index[(we_all[:,0] == 2015) & (we_all[:,1] == 215)]
	in2            = index[(we_all[:,0] == 2015) & (we_all[:,1] == 342)] + 1

	avt2_A, avw2_A = spectral_averaging(tx_all[in1:in2,:], wx_all[in1:in2,:])
	#fb, rb_nr_2, wb_nr_2, rms2, rms_110_2 = eg.data_analysis_residuals_array(fin, avt2.reshape((1,-1)), avw2.reshape((1,-1)), flow=90, fhigh=190, model_type='Physical_model', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')


	index          = np.arange(len(we_all[:,0]))
	in1            = index[(we_all[:,0] == 2015) & (we_all[:,1] == 207)]
	in2            = index[(we_all[:,0] == 2016) & (we_all[:,1] == 13)] + 1

	avt2_B, avw2_B = spectral_averaging(tx_all[in1:in2,:], wx_all[in1:in2,:])
	#fb, rb_nr_2, wb_nr_2, rms2, rms_110_2 = eg.data_analysis_residuals_array(fin, avt2.reshape((1,-1)), avw2.reshape((1,-1)), flow=90, fhigh=190, model_type='Physical_model', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')








	# Centered at LST = 3.76
	FN = 13
	fin, tc_all, wc_all, wea_all, LST_all, bt = data_analysis_calibration('high_band_2015', 'season', save='no', season_file_number=FN, receiver_temperature=RECV_TEMP)
	tx_all, wx_all, we_all, bx                = data_analysis_daily_spectra_filter('high_band_2015', FN, tc_all, wc_all, wea_all, bt)

	#fb, rb, wb, rms, rms_110 = eg.data_analysis_residuals_array(fin, tx_all, wx_all, flow=90, fhigh=190, model_type='Physical_model', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')
	#o = eg.plot_spectra_residuals(fb, rb, wb, 'season', we_all[:,1], K=1, flow_lim=80, fhigh_lim=220, xticks_low=80, xticks_high=220, xticks_delta=20, rms_text_freq=195, fontsize=10, size_x_column=7, size_y=20, NSC=35, y_label='day of year', plot_name='LST3.76')

	index          = np.arange(len(we_all[:,0]))
	in1            = index[(we_all[:,0] == 2015) & (we_all[:,1] == 225)]
	in2            = index[(we_all[:,0] == 2015) & (we_all[:,1] == 311)] + 1

	avt3_A, avw3_A = spectral_averaging(tx_all[in1:in2,:], wx_all[in1:in2,:])
	#fb, rb_nr_3, wb_nr_3, rms3, rms_110_3 = eg.data_analysis_residuals_array(fin, avt3.reshape((1,-1)), avw3.reshape((1,-1)), flow=90, fhigh=190, model_type='Physical_model', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')


	index          = np.arange(len(we_all[:,0]))
	in1            = index[(we_all[:,0] == 2015) & (we_all[:,1] == 225)]
	in2            = index[(we_all[:,0] == 2016) & (we_all[:,1] == 29)] + 1

	avt3_B, avw3_B = spectral_averaging(tx_all[in1:in2,:], wx_all[in1:in2,:])
	#fb, rb_nr_3, wb_nr_3, rms3, rms_110_3 = eg.data_analysis_residuals_array(fin, avt3.reshape((1,-1)), avw3.reshape((1,-1)), flow=90, fhigh=190, model_type='Physical_model', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')






	# Centered at LST = 4.76
	FN = 14
	fin, tc_all, wc_all, wea_all, LST_all, bt = data_analysis_calibration('high_band_2015', 'season', save='no', season_file_number=FN, receiver_temperature=RECV_TEMP)
	tx_all, wx_all, we_all, bx                = data_analysis_daily_spectra_filter('high_band_2015', FN, tc_all, wc_all, wea_all, bt)

	#fb, rb, wb, rms, rms_110 = eg.data_analysis_residuals_array(fin, tx_all, wx_all, flow=90, fhigh=190, model_type='Physical_model', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')
	#o = eg.plot_spectra_residuals(fb, rb, wb, 'season', we_all[:,1], K=1, flow_lim=80, fhigh_lim=220, xticks_low=80, xticks_high=220, xticks_delta=20, rms_text_freq=195, fontsize=10, size_x_column=7, size_y=20, NSC=35, y_label='day of year', plot_name='LST4.76')	

	index        = np.arange(len(we_all[:,0]))
	in1          = index[(we_all[:,0] == 2015) & (we_all[:,1] == 245)]
	in2          = index[(we_all[:,0] == 2015) & (we_all[:,1] == 312)] + 1	

	avt4_A, avw4_A = spectral_averaging(tx_all[in1:in2,:], wx_all[in1:in2,:])
	#fb, rb_nr_4, wb_nr_4, rms4, rms_110_4 = eg.data_analysis_residuals_array(fin, avt4.reshape((1,-1)), avw4.reshape((1,-1)), flow=90, fhigh=190, model_type='Physical_model', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')


	index        = np.arange(len(we_all[:,0]))
	in1          = index[(we_all[:,0] == 2015) & (we_all[:,1] == 245)]
	in2          = index[(we_all[:,0] == 2016) & (we_all[:,1] == 48)] + 1

	avt4_B, avw4_B = spectral_averaging(tx_all[in1:in2,:], wx_all[in1:in2,:])
	#fb, rb_nr_4, wb_nr_4, rms4, rms_110_4 = eg.data_analysis_residuals_array(fin, avt4.reshape((1,-1)), avw4.reshape((1,-1)), flow=90, fhigh=190, model_type='Physical_model', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')






	# Centered at LST = 5.76
	FN = 15
	fin, tc_all, wc_all, wea_all, LST_all, bt = data_analysis_calibration('high_band_2015', 'season', save='no', season_file_number=FN, receiver_temperature=RECV_TEMP)
	tx_all, wx_all, we_all, bx                = data_analysis_daily_spectra_filter('high_band_2015', FN, tc_all, wc_all, wea_all, bt)

	#fb, rb, wb, rms, rms_110 = eg.data_analysis_residuals_array(fin, tx_all, wx_all, flow=90, fhigh=190, model_type='Physical_model', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')
	#o = eg.plot_spectra_residuals(fb, rb, wb, 'season', we_all[:,1], K=1, flow_lim=80, fhigh_lim=220, xticks_low=80, xticks_high=220, xticks_delta=20, rms_text_freq=195, fontsize=10, size_x_column=7, size_y=20, NSC=35, y_label='day of year', plot_name='LST5.76')

	index        = np.arange(len(we_all[:,0]))
	in1          = index[(we_all[:,0] == 2015) & (we_all[:,1] == 270)]
	in2          = index[(we_all[:,0] == 2015) & (we_all[:,1] == 330)] + 1

	avt5_A, avw5_A = spectral_averaging(tx_all[in1:in2,:], wx_all[in1:in2,:])
	#fb, rb_nr_5, wb_nr_5, rms5, rms_110_5 = eg.data_analysis_residuals_array(fin, avt5.reshape((1,-1)), avw5.reshape((1,-1)), flow=90, fhigh=190, model_type='Physical_model', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')



	index        = np.arange(len(we_all[:,0]))
	in1          = index[(we_all[:,0] == 2015) & (we_all[:,1] == 270)]
	in2          = index[(we_all[:,0] == 2016) & (we_all[:,1] == 69)] + 1

	avt5_B, avw5_B = spectral_averaging(tx_all[in1:in2,:], wx_all[in1:in2,:])
	#fb, rb_nr_5, wb_nr_5, rms5, rms_110_5 = eg.data_analysis_residuals_array(fin, avt5.reshape((1,-1)), avw5.reshape((1,-1)), flow=90, fhigh=190, model_type='Physical_model', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')






	# Centered at LST = 6.76
	FN = 16
	fin, tc_all, wc_all, wea_all, LST_all, bt = data_analysis_calibration('high_band_2015', 'season', save='no', season_file_number=FN, receiver_temperature=RECV_TEMP)
	tx_all, wx_all, we_all, bx                = data_analysis_daily_spectra_filter('high_band_2015', FN, tc_all, wc_all, wea_all, bt)

	#fb, rb, wb, rms, rms_110 = eg.data_analysis_residuals_array(fin, tx_all, wx_all, flow=90, fhigh=190, model_type='Physical_model', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')
	#o = eg.plot_spectra_residuals(fb, rb, wb, 'season', we_all[:,1], K=1, flow_lim=80, fhigh_lim=220, xticks_low=80, xticks_high=220, xticks_delta=20, rms_text_freq=195, fontsize=10, size_x_column=7, size_y=20, NSC=35, y_label='day of year', plot_name='LST6.76')	

	index          = np.arange(len(we_all[:,0]))
	in1            = index[(we_all[:,0] == 2015) & (we_all[:,1] == 288)]
	in2            = index[(we_all[:,0] == 2015) & (we_all[:,1] == 330)] + 1	

	avt6_A, avw6_A = spectral_averaging(tx_all[in1:in2,:], wx_all[in1:in2,:])
	#fb, rb_nr_6, wb_nr_6, rms6, rms_110_6 = eg.data_analysis_residuals_array(fin, avt6.reshape((1,-1)), avw6.reshape((1,-1)), flow=90, fhigh=190, model_type='Physical_model', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')



	index          = np.arange(len(we_all[:,0]))
	in1            = index[(we_all[:,0] == 2015) & (we_all[:,1] == 288)]
	in2            = index[(we_all[:,0] == 2016) & (we_all[:,1] == 90)] + 1

	avt6_B, avw6_B = spectral_averaging(tx_all[in1:in2,:], wx_all[in1:in2,:])
	#fb, rb_nr_6, wb_nr_6, rms6, rms_110_6 = eg.data_analysis_residuals_array(fin, avt6.reshape((1,-1)), avw6.reshape((1,-1)), flow=90, fhigh=190, model_type='Physical_model', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')





	# --------------------------------
	# Total Average


	# Concatenating LST averages
	avt_A_tot = np.vstack((avt0_A, avt1_A, avt2_A, avt3_A, avt4_A, avt5_A, avt6_A))
	avw_A_tot = np.vstack((avw0_A, avw1_A, avw2_A, avw3_A, avw4_A, avw5_A, avw6_A))

	avt_B_tot = np.vstack((avt0_B, avt1_B, avt2_B, avt3_B, avt4_B, avt5_B, avt6_B))
	avw_B_tot = np.vstack((avw0_B, avw1_B, avw2_B, avw3_B, avw4_B, avw5_B, avw6_B))	


	# Time averages
	avt_A, avw_A = spectral_averaging(avt_A_tot, avw_A_tot)
	avt_B, avw_B = spectral_averaging(avt_B_tot, avw_B_tot)






	# -------------------------------
	# Binning spectrum
	fbA, tbA, wbA = spectrum_high_to_low_resolution(fin, avt_A, avw_A, pre_rfi_flagging='yes', post_rfi_flagging='yes')
	fbB, tbB, wbB = spectrum_high_to_low_resolution(fin, avt_B, avw_B, pre_rfi_flagging='yes', post_rfi_flagging='yes')



	# -------------------------------
	# Saving
	data_A = np.hstack((fbA.reshape(-1,1), tbA.reshape(-1,1), wbA.reshape(-1,1)))
	data_B = np.hstack((fbB.reshape(-1,1), tbB.reshape(-1,1), wbB.reshape(-1,1)))
	#np.savetxt(home_folder + '/DATA/EDGES/results/high_band/spectra/high_band_average' + save_flag + '.txt', data_A)






	#gaussian, xHI, z = eg.model_eor(fin, T21=1, model_type='gaussian', zr=9.6, dz=1.5)
	#fb_x1, rb_nr_x1, wb_nr_x1, rms_x1, XX = eg.data_analysis_residuals_array(fin, avt.reshape((1,-1)), avw.reshape((1,-1)), flow=90, fhigh=190, model_type='Physical_model', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')
	#fb_x2, rb_nr_x2, wb_nr_x2, rms_x2, XX = eg.data_analysis_residuals_array(fin, avt.reshape((1,-1)), avw.reshape((1,-1)), flow=115, fhigh=190, model_type='Physical_model', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')


	#fb_y1, rb_nr_y1, wb_nr_y1, rms_y1, XX = eg.data_analysis_residuals_array(fin, avt.reshape((1,-1)), avw.reshape((1,-1)), flow=90, fhigh=190, model_type='EDGES_polynomial', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')	
	#fb_y2, rb_nr_y2, wb_nr_y2, rms_y2, XX = eg.data_analysis_residuals_array(fin, avt.reshape((1,-1)), avw.reshape((1,-1)), flow=115, fhigh=190, model_type='EDGES_polynomial', fnorm=140, nfg=5, binning='yes', nsamples=64, rfi_flagging='yes')



	#if save_plot == 'yes':
		## ------------------------------------------------------------------------------------
		#plt.figure(1, figsize=(9,11))

		#K = 0.2

		#plt.plot(fb[wb_nr_22>0], rb_nr_22[wb_nr_22>0] + K*2, linewidth=2)
		#plt.plot(fb[wb_nr_23>0], rb_nr_23[wb_nr_23>0] + K*1, linewidth=2)
		#plt.plot(fb[wb_nr_0>0], rb_nr_0[wb_nr_0>0] - K*0, linewidth=2)	
		#plt.plot(fb[wb_nr_1>0], rb_nr_1[wb_nr_1>0] - K*1, linewidth=2)
		#plt.plot(fb[wb_nr_2>0], rb_nr_2[wb_nr_2>0] - K*2, linewidth=2)
		#plt.plot(fb[wb_nr_3>0], rb_nr_3[wb_nr_3>0] - K*3, linewidth=2)
		#plt.plot(fb[wb_nr_4>0], rb_nr_4[wb_nr_4>0] - K*4, linewidth=2)
		#plt.plot(fb[wb_nr_5>0], rb_nr_5[wb_nr_5>0] - K*5, linewidth=2)
		#plt.plot(fb[wb_nr_6>0], rb_nr_6[wb_nr_6>0] - K*6, linewidth=2)

		#plt.yticks([-K*6, -K*5, -K*4, -K*3, -K*2, -K*1, -K*0, K*1, K*2], ['13', '12', '11', '10', '9', '8', '7', '6', '5'])
		#plt.ylim([-K*7, K*3])

		#plt.text(195,  K*2, str(1000*np.round(rms22,3))+' mK')
		#plt.text(195,  K*1, str(1000*np.round(rms23,3))+' mK')
		#plt.text(195, -K*0, str(1000*np.round(rms0,3))+' mK')
		#plt.text(195, -K*1, str(1000*np.round(rms1,3))+' mK')
		#plt.text(195, -K*2, str(1000*np.round(rms2,3))+' mK')
		#plt.text(195, -K*3, str(1000*np.round(rms3,3))+' mK')
		#plt.text(195, -K*4, str(1000*np.round(rms4,3))+' mK')
		#plt.text(195, -K*5, str(1000*np.round(rms5,3))+' mK')
		#plt.text(195, -K*6, str(1000*np.round(rms6,3))+' mK')

		#plt.xlim([80,210])
		#plt.grid()

		#plt.xlabel('frequency [MHz]')
		#plt.ylabel('GHA [200 mK per division]')

		#plt.savefig(home_folder + '/DATA/EDGES/results/high_band/best_GHA_averages'+ plot_name +'.pdf', bbox_inches='tight')
		#plt.close()		




		#plt.figure(1, figsize=(9,4))

		#plt.plot(fb_x1[wb_nr_x1>0], rb_nr_x1[wb_nr_x1>0]-0*0.1, linewidth=2)
		#plt.plot(fb_x2[wb_nr_x2>0], rb_nr_x2[wb_nr_x2>0]-1*0.1, linewidth=2)
		#plt.plot(fb_y1[wb_nr_y1>0], rb_nr_y1[wb_nr_y1>0]-2*0.1, linewidth=2)
		#plt.plot(fb_y2[wb_nr_y2>0], rb_nr_y2[wb_nr_y2>0]-3*0.1, linewidth=2)
		#plt.yticks([-0.3, -0.2, -0.1, 0], ['','','',''])
		#plt.ylim([-0.4, 0.1])

		#plt.text(195,    0, str(1000*np.round(rms_x1,3))+' mK')
		#plt.text(195, -0.1, str(1000*np.round(rms_x2,3))+' mK')
		#plt.text(195, -0.2, str(1000*np.round(rms_y1,3))+' mK')
		#plt.text(195, -0.3, str(1000*np.round(rms_y2,3))+' mK')


		#plt.xlim([80,210])
		#plt.grid()

		#plt.xlabel('frequency [MHz]')
		#plt.ylabel('[100 mK per division]')

		#plt.savefig(home_folder + '/DATA/EDGES/results/high_band/best_total_average'+ plot_name +'.pdf', bbox_inches='tight')
		#plt.close()



	#data = np.hstack((fin.reshape(-1,1), avt.reshape(-1,1), avw.reshape(-1,1)))	
	#np.savetxt(home_folder + '/DATA/EDGES/results/high_band/high_band_average.txt', data)

	return data_A, data_B













def data_analysis_calibration(band, date_list_case, LST_1, LST_2, save='no', flag_save='', sun_el_max=-10, moon_el_max=90, amb_hum_max=90, min_receiver_temp=23.4, max_receiver_temp=27.4, ant_s11=262, fgl=1, glt='value', glp=0.5, fal=1, fbcl=1, MC_gl='no', MC_al='no', MC_bcl=[0,0,0,0,0,0,0,0], MC_beam_factor='no', receiver_temperature='actual', cwterms=7, MC_receiver='no', MC_recv_temp='no', MC_s11_ant_mag='no', MC_s11_ant_ang='no', MC_ant_recv='season', low_band_cal_file=1, beam_correction='yes'):


	# Configuration
	# -------------

	# Data selection
	# --------------
	#sun_el_max         = -10    # maximum sun elevation
	#moon_el_max        = 90     # maximum moon elevation
	#amb_hum_max        = 90     # maximum ambient humidity
	#min_receiver_temp  = 23.4   # limits of receiver temperature (23degC - 27degC), PLUS correction of 0.4degC for systematic thermistor offset
	#max_receiver_temp  = 27.4   # limits of receiver temperature (23degC - 27degC), PLUS correction of 0.4degC for systematic thermistor offset


	## Combined gain
	## -------------
	#ant_s11  = 262         # antenna S11 to use    # 'average'
	#fgl      = 1	       # flag ground loss
	#glt      = 'value'     # ground loss type
	#glp      = 0.5         # ground loss percentage
	#fal      = 1           # flag antenna pannel loss
	#fbcl     = 1           # flag balun connector loss 
	#MC_gl    = 'no'        # MC ground loss
	#MC_al    = 'no'        # MC antenna loss
	#MC_bcl   = [0,0,0,0,0,0,0,0]    # MC balun connector loss	


	## Beam factor
	## -----------
	#case_beam_factor  = 1      # choice of chromaticity factor ()
	#MC_bf             = 'no'   # MC chromaticity factor 


	## Receiver calibration
	## --------------------
	#receiver_temperature  = 'actual'   # receiver temperature
	#cwterms               = 7          # number of terms in receiver calibration quantities
	#MC_receiver           = 'no'       # MC in receiver calibration quantities
	#MC_s11_ant_mag        = 'no'       # MC in magnitude of antenna S11
	#MC_s11_ant_ang        = 'no'       # MC in phase of antenna S11


	# List of files to process
	# ------------------------
	datelist_raw = data_analysis_date_list(band, 'blade', case=date_list_case) # list of daily measurements
	datelist_old = data_analysis_daily_spectra_filter(band, datelist_raw)   # selection of daily measurements.
	datelist     = np.copy(datelist_old)                                       # further selection of daily measurements




	# Array of beam perturbations if beam MC is activated
	# This combined perturbation remains constant for the whole data set
	# ------------------------------------------------------------------
	if MC_beam_factor == 'yes':
		MC_beam_factor_array = np.random.normal(0, 1, 10)		
	elif MC_beam_factor == 'no':
		MC_beam_factor_array = np.zeros(10)



	# Process selected daily files
	# ----------------------------
	flag_j = 0
	for j in range(len(datelist)):   # range(5): #

		print('--------------------------------------------------------------------------------------------------------------- ' + datelist[j])

		# Load daily data
		# ---------------
		fin, t_2D, w_2D, m_2D = data_selection_single_day_v3(band, datelist[j], LST_1, LST_2, sun_el_max=sun_el_max, moon_el_max=moon_el_max, amb_hum_max=amb_hum_max, min_receiver_temp=min_receiver_temp, max_receiver_temp=max_receiver_temp)


		# Continue if there are data available
		# ------------------------------------
		if np.sum(t_2D) > 0:

			# RFI cleaning based on the average of the day
			# --------------------------------------------
			avt0, avw0 = spectral_averaging(t_2D, w_2D)                                            # computing daily average
			avt1, avw1 = RFI_excision_raw_frequency(fin, avt0, avw0)                               # RFI filter A
			avt, avw   = RFI_cleaning_std(fin, avt1, avw1, n_sigma = 3.5, df_MHz = 20, npar = 4)   # RFI filter B


			# Combined gain (loss), computed only once, at the beginning, same for all days
			# -----------------------------------------------------------------------------
			if flag_j == 0:
				cg = combined_gain(band, fin, antenna_s11_day=ant_s11, flag_ground_loss=fgl, ground_loss_type=glt, ground_loss_percent=glp, flag_antenna_loss=fal, flag_balun_connector_loss=fbcl, MC_ground_loss=MC_gl, MC_antenna_loss=MC_al, MC_balun_connector_loss=MC_bcl)			


			# Chromaticity factor, recomputed for every day because the LSTs are different 
			# ----------------------------------------------------------------------------
			if beam_correction == 'yes':
				cf = antenna_beam_factor_interpolation(band, m_2D[:,3], fin, case_beam_factor=1, MC_beam_factor=MC_beam_factor, MC_array=MC_beam_factor_array)


			# Aplying season-wide, perturbed values of antenna S11 and receiver parameters
			# For the antenna, this also produces the nominal S11 when the MC_mag and MC_ang flags are off
			# --------------------------------------------------------------------------------------------
			if (band == 'high_band_2015'):
				if (MC_ant_recv == 'season') and (flag_j == 0):

					# Antenna S11, MC applied once per day, assuming it remains constant within the day (mainly night)
					# ----------------------------------------------------------------------------------------------					
					s11_ant = models_antenna_s11(band, 'blade', fin, antenna_s11_day=ant_s11, model_type='polynomial', MC_mag=MC_s11_ant_mag, MC_ang=MC_s11_ant_ang, sigma_mag=0.0001, sigma_ang_deg=0.1)


					# Perturbations to the receiver calibration quantities, consistent with the lab measurement uncertainties from Monsalve et al. (2017).
					#-------------------------------------------------------------------------------------------------------------------------------------
					# These perturbations are applied on a daily basis.
					# These perturbations are larger than those from errors in receiver temperature correction applied on 39-sec scales.
					# Still, an option is available to account for uncertainty in receiver temperature on 39-sec scales, below.

					# Reference quantities at 25degC
					s11_LNA_25, sca_25, off_25, TU_25, TC_25, TS_25 = receiver_calibration_fast(band, fin, receiver_temperature = 25, cwterms=cwterms, MC='no')

					# "Perturbed" quantities
					s11_LNA_25MC, sca_25MC, off_25MC, TU_25MC, TC_25MC, TS_25MC = receiver_calibration_fast(band, fin, receiver_temperature = 25, cwterms=cwterms, MC=MC_receiver)

					# When MC_receiver is activated, these perturbations are applied on a daily basis. If MC_receiver is not activated, these "deltas", or perturbations, are zero.
					D_s11_LNA = s11_LNA_25MC - s11_LNA_25
					D_sca     = sca_25MC     - sca_25
					D_off     = off_25MC     - off_25
					D_TU      = TU_25MC      - TU_25
					D_TC      = TC_25MC      - TC_25
					D_TS      = TS_25MC      - TS_25			











			# Process spectra of each day
			# ---------------------------
			flag_i = 0
			for i in range(len(t_2D[:,0])):

				if band == 'high_band_2015':
					# Calibration of 39-s spectrum
					# ----------------------------
					# ----------------------------


					# Aplying daily, perturbed values of antenna S11 and receiver parameters
					# -----------------------------------------------------------------------
					if (MC_ant_recv == 'daily') and (flag_i == 0):

						# Antenna S11, MC applied once per day, assuming it remains constant within the day (mainly night)
						# ----------------------------------------------------------------------------------------------					
						s11_ant = models_antenna_s11(band, 'blade', fin, antenna_s11_day=ant_s11, model_type='polynomial', MC_mag=MC_s11_ant_mag, MC_ang=MC_s11_ant_ang, sigma_mag=0.0001, sigma_ang_deg=0.1)


						# Perturbations to the receiver calibration quantities, consistent with the lab measurement uncertainties from Monsalve et al. (2017).
						#-------------------------------------------------------------------------------------------------------------------------------------
						# These perturbations are applied on a daily basis.
						# These perturbations are larger than those from errors in receiver temperature correction applied on 39-sec scales.
						# Still, an option is available to account for uncertainty in receiver temperature on 39-sec scales, below.

						# Reference quantities at 25degC
						s11_LNA_25, sca_25, off_25, TU_25, TC_25, TS_25 = receiver_calibration_fast(band, fin, receiver_temperature = 25, cwterms=cwterms, MC='no')

						# "Perturbed" quantities
						s11_LNA_25MC, sca_25MC, off_25MC, TU_25MC, TC_25MC, TS_25MC = receiver_calibration_fast(band, fin, receiver_temperature = 25, cwterms=cwterms, MC=MC_receiver)

						# When MC_receiver is activated, these perturbations are applied on a daily basis. If MC_receiver is not activated, these "deltas", or perturbations, are zero.
						D_s11_LNA = s11_LNA_25MC - s11_LNA_25
						D_sca     = sca_25MC     - sca_25
						D_off     = off_25MC     - off_25
						D_TU      = TU_25MC      - TU_25
						D_TC      = TC_25MC      - TC_25
						D_TS      = TS_25MC      - TS_25					



					# Receiver temperature correction
					# -----------------------------
					if receiver_temperature == '25':
						RecTemp_base = 25
					elif receiver_temperature == 'actual':
						RecTemp_base = m_2D[i,-2]-0.4    # Correction of 0.4 degC is necessary



					# Adding MC perturbations to receiver temperature
					# -----------------------------------------------
					if MC_recv_temp == 'yes':
						RecTemp = RecTemp_base + 0.1*np.random.normal()  # Assigning a 1-sigma of 100 mK to the receiver temperature uncertainty, applied on 39-sec scales
					elif MC_recv_temp == 'no': 
						RecTemp = RecTemp_base



					# Receiver calibration quantities
					# -------------------------------
					s11_LNA_0, sca_0, off_0, TU_0, TC_0, TS_0 = receiver_calibration_fast(band, fin, receiver_temperature = RecTemp, cwterms=cwterms, MC='no')
					s11_LNA = s11_LNA_0 + D_s11_LNA
					sca     = sca_0     + D_sca
					off     = off_0     + D_off
					TU      = TU_0      + D_TU
					TC      = TC_0      + D_TC
					TS      = TS_0      + D_TS





				elif (band == 'low_band_2015') or (band == 'low_band2_2017'):
					# Antenna S11
					# -----------
					s11_ant = models_antenna_s11(band, 'blade', fin, antenna_s11_day = ant_s11, model_type='polynomial', MC_mag=MC_s11_ant_mag, MC_ang=MC_s11_ant_ang, sigma_mag=0.0001, sigma_ang_deg=0.1)

					# Receiver temperature correction
					# -----------------------------
					if receiver_temperature == '25':
						RecTemp_base = 25
					elif receiver_temperature == 'actual':		
						RecTemp_base = m_2D[i,-2]-0.4    # Correction of 0.4 degC is necessary
					RecTemp = RecTemp_base

					# Receiver calibration quantities
					# -------------------------------					
					s11_LNA, sca, off, TU, TC, TS = receiver_calibration(band, fin, receiver_temperature=RecTemp, low_band_cal_file=low_band_cal_file)



				# Calibrated antenna temperature with losses and beam chromaticity
				# ----------------------------------------------------------------
				tc_with_loss_and_beam = calibrated_antenna_temperature(t_2D[i,:], s11_ant, s11_LNA, sca, off, TU, TC, TS)


				# Removing loss
				# -------------
				Tambient = 273.15+m_2D[i,9]
				tc_with_beam = (tc_with_loss_and_beam - Tambient*(1-cg))/cg


				# Removing beam chromaticity
				# --------------------------
				if beam_correction == 'yes':
					tc = tc_with_beam/cf[i,:]
				elif beam_correction == 'no':
					tc = np.copy(tc_with_beam)


				#tc = data_calibration(band, RecTemp, t_2D[i,:], fin, 'blade', Tambient=273.15+m_2D[i,9], antenna_s11_day=ant_s11, combined_gain=cg, beam_factor=cf[i,:], cwterms=cwterms, MC_receiver=MC_receiver, MC_s11_ant_mag=MC_s11_ant_mag, MC_s11_ant_ang=MC_s11_ant_ang)  #   # 300


				# Zero-level data with RFI
				# ------------------------
				wc = np.copy(w_2D[i,:])  # original weights for individual spectra
				wc[avw==0] = 0           # applying additional flagging based on daily average
				tc[wc==0] = 0            # zeroing temperature of flagged channels


				# Store spectra
				# -------------
				if flag_i == 0:
					tc_daily = np.copy(tc)
					wc_daily = np.copy(wc)
					flag_i = 1

				elif flag_i > 0:
					tc_daily = np.vstack((tc_daily, tc))
					wc_daily = np.vstack((wc_daily, wc))


			# Averaging data from each day
			# ----------------------------
			av_tc_daily, av_wc_daily = spectral_averaging(tc_daily, wc_daily)


			# Storing daily averages
			# ----------------------
			x1 = np.array([np.min(m_2D[:,9]),  np.median(m_2D[:,9]),  np.max(m_2D[:,9])])
			x2 = np.array([np.min(m_2D[:,10]), np.median(m_2D[:,10]), np.max(m_2D[:,10])])
			x3 = np.array([np.min(m_2D[:,12]), np.median(m_2D[:,12]), np.max(m_2D[:,12])])
			if band == 'high_band_2015':
				x4 = np.array([np.min(m_2D[:,11]), np.median(m_2D[:,11]), np.max(m_2D[:,11])]) - 0.4  # This thermistor measurement requires a correction by -0.4 degC.			
			else:
				x4 = np.array([np.min(m_2D[:,11]), np.median(m_2D[:,11]), np.max(m_2D[:,11])])


			if flag_j == 0:
				av_tc_all = np.copy(av_tc_daily)
				av_wc_all = np.copy(av_wc_daily)
				date_all  = np.copy(m_2D[0,0:2])
				amb_temp_all       = x1
				amb_hum_all        = x2
				recv_ctrl_temp_all = x3
				recv_meas_temp_all = x4
				flag_j = 1

			elif flag_j > 0:
				av_tc_all = np.vstack((av_tc_all, av_tc_daily))
				av_wc_all = np.vstack((av_wc_all, av_wc_daily))
				date_all  = np.vstack((date_all,  m_2D[0,0:2]))
				amb_temp_all       = np.vstack((amb_temp_all, x1))
				amb_hum_all        = np.vstack((amb_hum_all, x2))
				recv_ctrl_temp_all = np.vstack((recv_ctrl_temp_all, x3))
				recv_meas_temp_all = np.vstack((recv_meas_temp_all, x4))



	# Save
	# --------------
	if save =='yes':
		path_save = home_folder + '/DATA/EDGES/spectra/level3/' + band + '/'
		save_file = path_save + band + '_LST_' + str(LST_1) + '_' + str(LST_2) + flag_save + '.hdf5'	

		with h5py.File(save_file, 'w') as hf:
			hf.create_dataset('frequency',            data = fin)
			hf.create_dataset('antenna_temperature',  data = av_tc_all)
			hf.create_dataset('weights',              data = av_wc_all)
			hf.create_dataset('dates',                data = date_all)
			hf.create_dataset('amb_temp',             data = amb_temp_all)
			hf.create_dataset('amb_hum',              data = amb_hum_all)
			hf.create_dataset('recv_ctrl_temp',       data = recv_ctrl_temp_all)
			hf.create_dataset('recv_meas_temp',       data = recv_meas_temp_all)



	return fin, av_tc_all, av_wc_all, date_all, amb_temp_all, amb_hum_all, recv_ctrl_temp_all, recv_meas_temp_all
















def data_analysis_calibration_single_day(low_band_cal_file):

	fin, t_2D_1, w_2D_1, m_2D_1 = data_selection_single_day_v3('low_band2_2017', '2017_082_03', 0, 24, sun_el_max=90, min_receiver_temp=10, max_receiver_temp=40)
	fin, t_2D_2, w_2D_2, m_2D_2 = data_selection_single_day_v3('low_band2_2017', '2017_082_08', 0, 24, sun_el_max=90, min_receiver_temp=10, max_receiver_temp=40)	
	fin, t_2D_3, w_2D_3, m_2D_3 = data_selection_single_day_v3('low_band2_2017', '2017_083_00', 0, 24, sun_el_max=90, min_receiver_temp=10, max_receiver_temp=40)
	fin, t_2D_4, w_2D_4, m_2D_4 = data_selection_single_day_v3('low_band2_2017', '2017_084_00', 0, 24, sun_el_max=90, min_receiver_temp=10, max_receiver_temp=40)
	fin, t_2D_5, w_2D_5, m_2D_5 = data_selection_single_day_v3('low_band2_2017', '2017_085_00', 0, 24, sun_el_max=90, min_receiver_temp=10, max_receiver_temp=40)
	fin, t_2D_6, w_2D_6, m_2D_6 = data_selection_single_day_v3('low_band2_2017', '2017_086_00', 0, 24, sun_el_max=90, min_receiver_temp=10, max_receiver_temp=40)
	fin, t_2D_7, w_2D_7, m_2D_7 = data_selection_single_day_v3('low_band2_2017', '2017_086_14', 0, 24, sun_el_max=90, min_receiver_temp=10, max_receiver_temp=40)
	fin, t_2D_8, w_2D_8, m_2D_8 = data_selection_single_day_v3('low_band2_2017', '2017_087_00', 0, 24, sun_el_max=90, min_receiver_temp=10, max_receiver_temp=40)
	fin, t_2D_9, w_2D_9, m_2D_9 = data_selection_single_day_v3('low_band2_2017', '2017_087_21', 0, 24, sun_el_max=90, min_receiver_temp=10, max_receiver_temp=40)

	t_2D = np.vstack((t_2D_1, t_2D_2, t_2D_3, t_2D_4, t_2D_5, t_2D_6, t_2D_7, t_2D_8, t_2D_9))
	w_2D = np.vstack((w_2D_1, w_2D_2, w_2D_3, w_2D_4, w_2D_5, w_2D_6, w_2D_7, w_2D_8, w_2D_9))
	m_2D = np.vstack((m_2D_1, m_2D_2, m_2D_3, m_2D_4, m_2D_5, m_2D_6, m_2D_7, m_2D_8, m_2D_9))



	# Averaging just to do RFI flagging
	# --------------------------------------------
	avt0, avw0 = spectral_averaging(t_2D, w_2D)                                            # computing daily average
	avt1, avw1 = RFI_excision_raw_frequency(fin, avt0, avw0)                               # RFI filter A
	avt, avw   = RFI_cleaning_std(fin, avt1, avw1, n_sigma = 3.5, df_MHz = 20, npar = 4)   # RFI filter B


	# Combined gain (loss), computed only once, at the beginning, same for all days
	# -----------------------------------------------------------------------------
	#cg = combined_gain(band, fin, antenna_s11_day=ant_s11, flag_ground_loss=fgl, ground_loss_type=glt, ground_loss_percent=glp, flag_antenna_loss=fal, flag_balun_connector_loss=fbcl, MC_ground_loss=MC_gl, MC_antenna_loss=MC_al, MC_balun_connector_loss=MC_bcl)
	cg = 1


	# Chromaticity factor, recomputed for every day because the LSTs are different 
	# ----------------------------------------------------------------------------
	cf = antenna_beam_factor_interpolation('low_band', m_2D[:,3], fin)


	# Antenna S11
	# -----------
	s11_ant = models_antenna_s11('low_band2_2017', 'blade', fin, antenna_s11_day = 87)


	# Receiver calibration quantities
	# -------------------------------	
	s11_LNA, sca, off, TU, TC, TS = receiver_calibration('low_band2_2017', fin, receiver_temperature=25, low_band_cal_file=low_band_cal_file, high_band_cal_file=1)


	# Calibration
	# -----------
	ta = calibrated_antenna_temperature(t_2D, s11_ant, s11_LNA, sca, off, TU, TC, TS)


	# Removing loss
	# -------------
	Tambient = 300 #273.15 + m_2D[i,9]
	tc_with_beam = (ta - Tambient*(1-cg))/cg


	# Removing beam chromaticity AND Zeroing temperature of flagged channels
	# ----------------------------------------------------------------------
	print('hola')
	tc = np.zeros((len(tc_with_beam[:,0]), len(tc_with_beam[0,:])))
	for i in range(len(tc[:,0])):
		tc[i, :] = tc_with_beam[i,:]/1# cf[i,:]
		tc[i, w_2D[i,:]==0] = 0


	# Time averaging
	# --------------
	avt, avw   = spectral_averaging(tc, w_2D)
	fb, tb, wb = data_analysis_spectrum_high_to_low_resolution(fin, avt, avw, flow=49, fhigh=101, fnorm=75, pre_rfi_flagging='yes', post_rfi_flagging='yes')


	# Selection of narrower frequency window
	# --------------------------------------
	f1 = 60
	f2 = 101
	ff = fb[(fb>f1) & (fb<f2)]
	tt = tb[(fb>f1) & (fb<f2)]
	ww = wb[(fb>f1) & (fb<f2)]
	p  = fit_polynomial_fourier('EDGES_polynomial', ff, tt, 4, Weights=ww)
	rr = tt - p[1]
	rr[ww==0] = 0



	return ff, rr, ww




























def data_analysis_date_list(band, antenna, case=0):

	# Selecting band	
	if (band == 'high_band_2015') and (antenna=='fourpoint'):

		dates   = ['2015_109_11', 
		           '2015_110_00', '2015_111_00', '2015_112_00', '2015_113_00', '2015_113_09', '2015_114_00', '2015_115_00', '2015_116_00', '2015_117_00', '2015_118_00', '2015_119_00', '2015_119_13', 
		           '2015_120_00', '2015_120_14', '2015_121_00', '2015_122_00', '2015_122_05', '2015_122_08', '2015_123_00', '2015_123_08', '2015_123_15', '2015_124_00', '2015_124_13', '2015_125_00', '2015_125_05', '2015_125_08', '2015_126_00', '2015_127_00', '2015_128_00', '2015_129_00', 
		           '2015_130_00', '2015_131_00', '2015_132_00', '2015_132_04', '2015_133_00', '2015_134_00', '2015_135_00', '2015_136_00', '2015_137_00', '2015_138_00', '2015_139_00', 
		           '2015_140_00', '2015_141_00', '2015_142_00', '2015_143_00', '2015_144_00', '2015_145_00', '2015_146_00', '2015_147_00', '2015_148_00', '2015_149_00', 
		           '2015_150_00', '2015_151_00', '2015_152_00', '2015_153_00', '2015_154_00', '2015_155_00', '2015_156_00', '2015_157_00', 
		           '2015_161_18', '2015_162_00', '2015_163_00', '2015_164_00', '2015_165_00', '2015_166_00', '2015_167_00', '2015_168_00', '2015_169_00', 
		           '2015_170_00', '2015_171_00', '2015_172_00', '2015_173_00', '2015_174_00', '2015_175_00', '2015_176_00', '2015_177_00', '2015_178_00', '2015_179_00', 
		           '2015_180_00', '2015_181_00', '2015_182_00', '2015_183_00', '2015_184_00', '2015_185_00', '2015_186_00', '2015_187_00', '2015_188_00', '2015_189_00', 
		           '2015_190_00', '2015_191_00', '2015_192_00', '2015_192_18', '2015_193_00', '2015_194_00', '2015_195_00', '2015_198_00']		






	if (band == 'high_band_2015') and (antenna=='blade') and (case==0):

		dates   = ['2015_206_00', '2015_207_00', '2015_208_00', '2015_209_00',
		           '2015_210_00', '2015_210_03', '2015_211_00', '2015_211_18', '2015_212_00', '2015_215_08', '2015_216_00', '2015_217_00', '2015_218_00', '2015_219_00',
		           '2015_220_00', '2015_221_00', '2015_222_00', '2015_223_00', '2015_224_00', '2015_225_00', '2015_226_00', '2015_227_00', '2015_228_00', '2015_229_00',
		           '2015_230_00', '2015_231_00', '2015_232_00', '2015_233_00', '2015_234_00', '2015_235_00', '2015_236_00', '2015_237_00', '2015_238_00', '2015_239_00',
		           '2015_240_00', '2015_241_00', '2015_242_00', '2015_243_00', '2015_245_00',
		           '2015_250_15', '2015_251_00', '2015_251_21', '2015_252_00', '2015_253_00', '2015_254_00', '2015_255_00', '2015_256_00', '2015_257_00', '2015_258_00', '2015_259_00',
		           '2015_260_00', '2015_261_00', '2015_262_00', '2015_265_19', '2015_266_00', '2015_267_00', '2015_268_00', '2015_269_00',
		           '2015_270_00', '2015_271_00', '2015_272_00', '2015_273_00', '2015_274_00', '2015_275_00', '2015_276_00', '2015_277_00', '2015_278_00', '2015_279_00',
		           '2015_280_00', '2015_281_17', '2015_282_00', '2015_283_00', '2015_284_00', '2015_285_00', '2015_286_00', '2015_287_00', '2015_288_00', '2015_289_00',
		           '2015_290_00', '2015_291_00', '2015_292_00', '2015_293_00', '2015_294_00', '2015_295_00', '2015_296_00', '2015_297_00', '2015_298_00', '2015_299_00',
		           '2015_300_00', '2015_301_00', '2015_302_00', '2015_303_00',
		           '2015_310_18', '2015_311_00', '2015_312_00', '2015_313_00', '2015_314_00', '2015_315_00', '2015_316_00', '2015_317_00', '2015_318_00', '2015_319_00',
		           '2015_320_00', '2015_321_00', '2015_322_00',

		           '2015_323_00', '2015_324_00', '2015_325_00', '2015_326_00', '2015_327_00', '2015_328_00', '2015_329_00', '2015_330_00', '2015_331_00', '2015_332_00',
		           '2015_333_00', '2015_334_00', '2015_335_00', '2015_336_00', '2015_337_00', '2015_338_00', '2015_339_00', '2015_340_00', '2015_341_00', '2015_342_00',
		           '2015_343_00', '2015_344_00', '2015_345_00', '2015_346_00', '2015_347_00', '2015_348_00', '2015_349_00', '2015_350_00', '2015_351_00', '2015_352_00',
		           '2015_353_00', '2015_354_00', '2015_355_00', '2015_356_00', '2015_357_00', '2015_358_00', '2015_359_00', '2015_360_00', '2015_361_00', '2015_362_00',
		           '2015_363_00', '2015_364_00', '2015_365_00', '2016_001_00', '2016_002_00', '2016_003_00', '2016_004_00', '2016_005_00', '2016_006_00', '2016_007_00',
		           '2016_008_00', '2016_009_00', '2016_010_00', '2016_011_00', '2016_012_00', '2016_013_00', '2016_014_00', '2016_015_00', '2016_016_00', '2016_017_00',
		           '2016_018_00', '2016_019_00', '2016_020_00', '2016_027_20', '2016_028_00', '2016_029_00', '2016_030_00', '2016_031_00', '2016_032_00', '2016_033_00',
		           '2016_034_00', '2016_035_00', '2016_036_00', '2016_037_00', '2016_038_00', '2016_039_00', '2016_040_00', '2016_041_00', '2016_042_00', '2016_043_00',
		           '2016_044_00', '2016_045_00', '2016_046_00', '2016_047_00', '2016_048_00', '2016_049_00', '2016_050_00', '2016_051_00', '2016_052_00', '2016_053_00',
		           '2016_056_00', '2016_057_00', '2016_058_00', '2016_059_00', '2016_060_00', '2016_061_00', '2016_062_00', '2016_063_00', '2016_064_00',  # '2016_055_07', 
		           '2016_065_00', '2016_066_00', '2016_067_00', '2016_068_00', '2016_069_00', '2016_070_00', '2016_071_00', '2016_072_00', '2016_073_00', '2016_074_00',
		           '2016_075_00', '2016_076_00', '2016_077_00', '2016_078_00', '2016_079_00', '2016_080_00', '2016_081_00', '2016_082_00', '2016_083_00', '2016_084_00',
		           '2016_085_00', '2016_086_00', '2016_087_00', '2016_088_00', '2016_089_00', '2016_090_00', '2016_091_00', '2016_092_00', '2016_093_00', '2016_094_00',
		           '2016_095_00', '2016_096_00', '2016_097_00', '2016_098_00', '2016_099_00', '2016_100_00', '2016_101_00', '2016_102_00', '2016_103_00', '2016_104_00',
		           '2016_107_00', '2016_108_00', '2016_109_00', '2016_110_00', '2016_111_00', '2016_112_00', '2016_113_00', '2016_114_00', '2016_115_00', '2016_116_00',
		           '2016_117_00', '2016_118_00', '2016_123_00', '2016_124_00', '2016_125_00', '2016_126_00', '2016_127_00', '2016_128_00', '2016_129_00', '2016_130_00',
		           '2016_131_00', '2016_132_00', '2016_133_00', '2016_134_00', '2016_135_00', '2016_136_00', '2016_137_00', '2016_138_00', '2016_139_00', '2016_140_00',
		           '2016_141_00', '2016_142_00', '2016_143_00', '2016_144_00', '2016_145_00', '2016_146_00', '2016_147_00', '2016_148_00', '2016_149_00', '2016_150_00',
		           '2016_151_00', '2016_152_00', '2016_153_00', '2016_154_00', '2016_155_00', '2016_156_00', '2016_157_00', '2016_158_00', '2016_159_00', '2016_160_00',
		           '2016_161_00', '2016_162_00', '2016_163_00', '2016_164_00', '2016_165_00', '2016_166_00', '2016_167_00', '2016_168_00', '2016_169_00', '2016_170_00',
		           '2016_171_00', '2016_172_00', '2016_173_00', '2016_174_00', '2016_175_00', '2016_176_00', '2016_177_00', '2016_178_00', '2016_179_00', '2016_180_00',
		           '2016_181_00', '2016_182_00', '2016_183_00', '2016_184_00', '2016_185_00', '2016_186_00', '2016_187_00', '2016_188_00', '2016_189_00', '2016_190_00',
		           '2016_191_00', '2016_192_00', '2016_193_00', '2016_194_00', '2016_195_00', '2016_196_00', '2016_197_00', '2016_198_00', '2016_199_00', '2016_200_00',
		           '2016_201_00', '2016_202_00', '2016_203_00', '2016_204_00', '2016_205_00', '2016_206_00', '2016_207_00', '2016_208_00', '2016_209_00', '2016_210_00',
		           '2016_210_08', '2016_211_00', '2016_212_00', '2016_213_00', '2016_216_16', '2016_217_00', '2016_218_00', '2016_219_00', '2016_220_00', '2016_221_00',
		           '2016_223_18', '2016_224_00', '2016_225_00', '2016_226_00', '2016_227_00', '2016_228_00', '2016_229_00', '2016_230_00', '2016_236_09', '2016_237_00',
		           '2016_239_00', '2016_240_00', '2016_241_00', '2016_242_00', '2016_243_00', '2016_244_07', '2016_245_00', '2016_246_00', '2016_247_00', '2016_248_00',
		           '2016_248_06', '2016_249_00', '2016_250_02', '2016_251_00', '2016_252_00', '2016_253_13', '2016_254_00', '2016_254_09', '2016_255_00', '2016_256_00',
		           '2016_257_00', '2016_258_00']





	if (band == 'high_band_2015') and (antenna=='blade') and (case==1):

		dates   = ['2015_250_15', '2015_251_00', '2015_251_21', '2015_252_00', '2015_253_00', '2015_254_00', '2015_255_00', '2015_256_00', '2015_257_00', '2015_258_00', '2015_259_00',
		           '2015_260_00', '2015_261_00', '2015_262_00', '2015_265_19', '2015_266_00', '2015_267_00', '2015_268_00', '2015_269_00',
		           '2015_270_00', '2015_271_00', '2015_272_00', '2015_273_00', '2015_274_00', '2015_275_00', '2015_276_00', '2015_277_00', '2015_278_00', '2015_279_00',
		           '2015_280_00', '2015_281_17', '2015_282_00', '2015_283_00', '2015_284_00', '2015_285_00', '2015_286_00', '2015_287_00', '2015_288_00', '2015_289_00',
		           '2015_290_00', '2015_291_00', '2015_292_00', '2015_293_00', '2015_294_00', '2015_295_00', '2015_296_00', '2015_297_00', '2015_298_00', '2015_299_00']












	# All for original, 10m x 10m  ground plane, antenna orientation -7 deg East from NS (7 deg West from North) CHECK THE LAST FEW DAYS for switch intermittency problems. 
	if (band == 'low_band_2015') and (antenna=='blade') and (case==0):

		dates = ['2015_286_02', '2015_287_00', '2015_288_00', '2015_289_00', 
		         '2015_291_00', '2015_292_00', '2015_293_00', '2015_294_00', '2015_295_00', '2015_296_00', '2015_297_00', '2015_298_00',
		         '2015_300_00', '2015_301_00', '2015_302_00', '2015_303_00',
		         '2015_311_00', '2015_312_00', '2015_313_00', '2015_314_00', '2015_315_00', '2015_317_00', '2015_319_00',
		         '2015_320_00', '2015_321_00', '2015_322_00', '2015_323_00', '2015_324_00', '2015_325_00', '2015_328_00', 
		         '2015_331_00', '2015_332_00', '2015_333_00', '2015_334_00', '2015_337_00', '2015_338_00', '2015_339_00',
		         '2015_340_00', '2015_341_00', '2015_342_00', '2015_345_00', '2015_347_00', '2015_348_00', '2015_349_00',
		         '2015_350_00', '2015_351_00', '2015_352_00', '2015_353_00', '2015_354_00',
		         '2015_362_00', '2015_364_00', '2015_365_00',
		         '2016_001_00', '2016_002_00', '2016_003_00', '2016_004_00', '2016_005_00', '2016_006_00', '2016_009_00',
		         '2016_010_00', '2016_011_00', '2016_012_00', '2016_013_00', '2016_015_00', '2016_016_00', '2016_019_00',
		         '2016_020_00', '2016_028_00', '2016_029_00',
		         '2016_030_00', '2016_031_00', '2016_035_00', '2016_038_00', '2016_039_00',
		         '2016_041_00', '2016_047_00', 
		         '2016_064_00', '2016_065_00', '2016_067_00', '2016_068_00', '2016_069_00',
		         '2016_070_00', '2016_071_00', '2016_072_00', '2016_074_00', '2016_078_00', '2016_079_00',
		         '2016_080_00', '2016_081_00', '2016_082_00', '2016_084_00', '2016_087_00', '2016_088_00', '2016_089_00',
		         '2016_090_00', '2016_091_00', '2016_092_00', '2016_093_00', '2016_094_00', '2016_095_00', '2016_096_00', '2016_097_00', '2016_098_00', 	         
		         '2016_106_13', '2016_107_00', '2016_108_00', 
		         '2016_110_00', '2016_111_00', '2016_112_00', '2016_113_00', '2016_114_00', '2016_115_00',
		         '2016_135_00', '2016_136_00', '2016_137_00', '2016_138_00', '2016_139_00',
		         '2016_149_00',
		         '2016_150_00', '2016_153_00', '2016_154_00', '2016_155_00', 
		         '2016_170_00', '2016_171_00', '2016_172_00',
		         '2016_181_00', '2016_182_00', '2016_183_00', '2016_185_00', '2016_186_00']


		# Not processed due to weirdness: '2015_299_00', '2015_316_00', '2015_318_00', '2015_326_00', '2015_327_00', '2015_329_00', '2015_330_00', '2015_335_00', '2015_336_00', '2015_343_14', '2015_344_00', '2015_344_21', '2015_346_00', '2015_363_00',
		# '2016_007_00', '2016_008_00', '2016_014_00', '2016_017_00', '2016_018_00', '2016_032_00', '2016_033_00', '2016_034_00', '2016_036_00', '2016_037_00', '2016_040_00', '2016_042_00', '2016_043_00', '2016_044_00', '2016_045_00', '2016_046_00', '2016_048_00', '2016_049_00', '2016_050_00', '2016_051_00', '2016_052_00', '2016_053_00', '2016_055_21', '2016_056_00', '2016_057_00', '2016_058_00', '2016_059_00', '2016_060_00', '2016_061_00', '2016_062_00', '2016_063_00', '2016_066_00', '2016_073_00', '2016_075_00', '2016_076_00', '2016_077_00', '2016_083_00', '2016_085_00', '2016_086_00', '2016_099_00', '2016_100_00', '2016_101_00', '2016_102_00', '2016_103_00', '2016_104_00', '2016_109_00', '2016_116_00', '2016_117_00', '2016_118_00', '2016_122_16', '2016_124_00', '2016_123_00', '2016_125_00', '2016_126_00', '2016_127_00', '2016_128_00', '2016_129_00', '2016_130_00', '2016_131_00', '2016_132_00', '2016_133_00', '2016_134_00', '2016_141_00', '2016_142_00', '2016_143_00', '2016_144_00', '2016_145_00', '2016_146_00', '2016_147_00', '2016_148_00', '2016_151_00', '2016_152_00', '2016_156_00', '2016_157_00', '2016_158_00', '2016_159_00', '2016_160_00', '2016_167_00', '2016_168_00', '2016_169_00', '2016_187_00', '2016_188_00', '2016_189_00', '2016_190_00', '2016_192_00', '2016_193_00', '2016_194_00', '2016_195_00', '2016_196_00', '2016_197_00', '2016_198_00', '2016_199_00', '2016_200_00', '2016_201_00', '2016_202_00', '2016_203_00', '2016_204_00', '2016_210_14', '2016_211_00', '2016_212_00', '2016_217_00', '2016_218_00', '2016_219_00', '2016_220_00', '2016_226_19', '2016_227_00', '2016_228_00', '2016_229_00', '2016_230_00', '2016_238_00', '2016_246_07', '2016_247_00', '2016_248_00', '2016_249_00'

	# There are some files between Case 0 and Case 1, but taken during tests and extension of ground plane






	# All for extended ground plane, starting with day 2016-260, antenna orientation -7 deg East from NS (7 deg West from North) 
	if (band == 'low_band_2015') and (antenna=='blade') and (case==1):

		dates = ['2016_258_13', '2016_259_00', '2016_260_00', '2016_261_00', '2016_262_00', '2016_263_00', '2016_264_00', '2016_265_00', '2016_266_00', '2016_267_00', '2016_268_00', '2016_269_00', 
		         '2016_270_00', '2016_271_00', '2016_273_15', '2016_274_00', '2016_275_00', '2016_276_00', '2016_277_00', '2016_278_00', '2016_279_00',
		         '2016_280_00', '2016_281_00', '2016_282_00', '2016_283_00', '2016_284_00', '2016_285_00', '2016_286_00', '2016_287_00', '2016_288_00', '2016_289_00',
		         '2016_290_00', '2016_291_00', '2016_292_00', '2016_293_00', '2016_294_00', '2016_295_00', '2016_296_00', '2016_297_00', '2016_298_00', '2016_299_00',
		         '2016_302_14', '2016_303_00', '2016_304_00', '2016_305_00', '2016_314_15', '2016_315_00', '2016_316_00', '2016_317_00', '2016_318_00', '2016_319_00',
		         '2016_320_00', '2016_321_00', '2016_322_00', '2016_323_00', '2016_324_00', '2016_325_00', '2016_326_00', '2016_327_00', '2016_328_00', '2016_329_00',
		         '2016_332_00', '2016_333_00', '2016_334_00', '2016_335_00', '2016_336_00', '2016_337_00', '2016_338_00', '2016_339_00',
		         '2016_340_00', '2016_341_00', '2016_342_00', '2016_343_00', '2016_347_00', '2016_348_00', '2016_349_00',
		         '2016_350_00', '2016_351_00', '2016_352_00', '2016_353_00', '2016_354_00', '2016_355_00', '2016_356_00', '2016_357_00', '2016_357_07', '2016_358_00',
		         '2016_360_00', '2016_361_00', '2016_362_00', '2016_363_00', '2016_364_00', '2016_365_00', '2016_366_00',
		         '2017_001_15', '2017_002_00', '2017_003_00', '2017_005_00', '2017_006_00', '2017_007_00', '2017_008_00', '2017_009_00',
		         '2017_010_00', '2017_011_07', '2017_012_00', '2017_013_00', '2017_014_00', '2017_015_00', '2017_016_00', '2017_017_00', 
		         '2017_077_07', '2017_078_00', '2017_079_00',
		         '2017_080_00', '2017_081_00', '2017_082_00', '2017_082_08', '2017_083_00', '2017_084_00', '2017_085_00', '2017_086_00', '2017_087_00', '2017_087_21', '2017_088_00', '2017_089_00',
		         '2017_090_00', '2017_091_00', '2017_093_00', '2017_093_17', '2017_094_00', '2017_095_00', '2017_095_15']


		# Not processed due to too strong solar effects: '2016_330_00', '2016_331_00', '2016_344_00', '2016_345_00', '2016_346_00', '2016_356_06', '2016_359_00', '2017_092_00'










	# New calibration of Low-Band 1, 2017-05-25C, same antenna orientation -7 deg East from NS (7 deg West from North)
	if (band == 'low_band_2015') and (antenna=='blade') and (case==2):

		dates = ['2017_153_12', '2017_154_00', '2017_155_00', '2017_156_00', '2017_157_00', '2017_158_03', '2017_159_00', 
		         '2017_160_00', '2017_161_00', '2017_162_00', '2017_163_00', '2017_164_00', '2017_165_00', '2017_166_00', '2017_167_00', '2017_168_00', '2017_169_00',
		         '2017_170_00', '2017_171_00']

		#dates = ['2017_170_00']























	# Antenna of Low-Band 2 rotated to NS, at an angle of -2 degrees East of North (2 deg West of North)
	if (band == 'low_band2_2017') and (antenna == 'blade') and (case==1):

		dates = ['2017_082_03', '2017_082_08', '2017_083_00', '2017_084_00', '2017_085_00', '2017_086_00', '2017_086_14', '2017_087_00', '2017_087_21', '2017_088_00', '2017_089_00',
		         '2017_090_00', '2017_091_00', '2017_092_00', '2017_093_00', '2017_093_17', '2017_094_00', '2017_095_00', '2017_096_00', '2017_097_00', '2017_098_00', '2017_099_00', 
		         '2017_100_00', '2017_101_00', '2017_102_00', '2017_102_15', '2017_103_00', '2017_103_15', '2017_104_00', '2017_105_00', '2017_106_00', '2017_107_00', '2017_108_00', '2017_109_00',
		         '2017_110_00', '2017_111_00', '2017_112_00', '2017_113_00', '2017_114_00', '2017_115_00', '2017_116_00', '2017_117_00', '2017_117_16', '2017_118_00', '2017_119_00',
		         '2017_120_00', '2017_121_00', '2017_122_00', '2017_123_00', '2017_124_00', '2017_125_00', '2017_126_00', '2017_127_00', '2017_128_00', '2017_129_00', '2017_130_00', 
		         '2017_131_00', '2017_132_00', '2017_133_00', '2017_134_00', '2017_135_00', '2017_136_00', '2017_137_00', '2017_138_00', '2017_139_00', '2017_140_00', '2017_141_00', '2017_142_00']



	# Antenna of Low-Band 2 rotated to EW, exactly at an angle of 87 degrees East of North
	if (band == 'low_band2_2017') and (antenna == 'blade') and (case==2):

		dates = ['2017_155_00', '2017_156_00', '2017_157_01', '2017_158_03', '2017_159_00', 
		         '2017_160_00', '2017_161_00', '2017_162_00', '2017_163_00', '2017_164_00', '2017_165_00', '2017_166_00', '2017_167_00', '2017_168_00', '2017_169_00', 
		         '2017_170_00', '2017_171_00']



	# Antenna of Low-Band 2 rotated to EW, exactly at an angle of 87 degrees East of North, BUT with the shield removed !!!!
	if (band == 'low_band2_2017') and (antenna == 'blade') and (case==3):

		dates = ['2017_181_00', '2017_182_00', '2017_183_00', '2017_184_00', '2017_184_17', '2017_185_00', '2017_186_00', '2017_187_00', '2017_188_00', '2017_189_00',
		         '2017_190_00', '2017_191_00', '2017_192_00', '2017_193_00', '2017_194_00', '2017_195_00', '2017_196_00', '2017_197_00', '2017_198_00',
		         '2017_200_00', '2017_201_00', '2017_202_00', '2017_203_00', '2017_204_00', '2017_205_00', '2017_206_00', '2017_207_00', '2017_208_00', '2017_209_00',
		         '2017_210_00', '2017_211_00', '2017_212_00', '2017_213_00', '2017_214_00', '2017_215_00', '2017_216_00', '2017_217_00', '2017_218_16', '2017_219_00',
		         '2017_220_00', '2017_221_00', '2017_222_00', '2017_223_00', '2017_224_00', '2017_226_00', '2017_227_00', '2017_228_00', '2017_229_00',
		         '2017_230_00', '2017_231_00', '2017_232_00', '2017_233_00', '2017_234_00', '2017_235_00', '2017_236_00', '2017_237_00', '2017_238_00', '2017_239_00']

	return dates


































def low_band_15C_november_2016_noise_source_sparameters():


	# Reflection coefficient of noise source plus 3dB attenuator, alone
	om, fs   = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_15C_november_2016/LNA/S11/raw/Alans_Noise_Source_plus_zero_extra_dB_attenuation/Open2.s1p')  # measurement after spectra measurement is slightly better
	sm, fs   = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_15C_november_2016/LNA/S11/raw/Alans_Noise_Source_plus_zero_extra_dB_attenuation/Short2.s1p')
	lm, fs   = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_15C_november_2016/LNA/S11/raw/Alans_Noise_Source_plus_zero_extra_dB_attenuation/Match2.s1p')
	NS0m, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_15C_november_2016/LNA/S11/raw/Alans_Noise_Source_plus_zero_extra_dB_attenuation/External2.s1p')

	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(fs))
	s_sw = -1 * np.ones(len(fs))
	l_sw =  0 * np.ones(len(fs))

	# Correction at switch
	NS0x, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, om, sm, lm, NS0m)

	# Correction at receiver input
	NS0c = low_band_switch_correction_june_2016(NS0x, f_in = fs, verification = 'no')





	# Reflection coefficient of noise source plus 3dB attenuator, plus extra 3-dB attenuator
	om, fs   = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_15C_november_2016/LNA/S11/raw/Alans_Noise_Source_plus_3dB_extra_attenuation/Open2.s1p')  # measurement after spectra measurement is slightly better
	sm, fs   = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_15C_november_2016/LNA/S11/raw/Alans_Noise_Source_plus_3dB_extra_attenuation/Short2.s1p')
	lm, fs   = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_15C_november_2016/LNA/S11/raw/Alans_Noise_Source_plus_3dB_extra_attenuation/Match2.s1p')
	NS3m, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_15C_november_2016/LNA/S11/raw/Alans_Noise_Source_plus_3dB_extra_attenuation/External2.s1p')

	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(fs))
	s_sw = -1 * np.ones(len(fs))
	l_sw =  0 * np.ones(len(fs))

	# Correction at switch
	NS3x, x1, x2, x3 = rc.de_embed(o_sw, s_sw, l_sw, om, sm, lm, NS3m)

	# Correction at receiver input
	NS3c = low_band_switch_correction_june_2016(NS3x, f_in = fs, verification = 'no')





	# Reflection coefficient of noise source plus 3dB attenuator, plus extra 6-dB attenuator
	om, fs   = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_15C_november_2016/LNA/S11/raw/Alans_Noise_Source_plus_6dB_extra_attenuation/Open2.s1p')  # measurement after spectra measurement is slightly better
	sm, fs   = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_15C_november_2016/LNA/S11/raw/Alans_Noise_Source_plus_6dB_extra_attenuation/Short2.s1p')
	lm, fs   = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_15C_november_2016/LNA/S11/raw/Alans_Noise_Source_plus_6dB_extra_attenuation/Match2.s1p')
	NS6m, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_15C_november_2016/LNA/S11/raw/Alans_Noise_Source_plus_6dB_extra_attenuation/External2.s1p')

	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(fs))
	s_sw = -1 * np.ones(len(fs))
	l_sw =  0 * np.ones(len(fs))

	# Correction at switch
	NS6x, x1, x2, x3 = rc.de_embed(o_sw, s_sw, l_sw, om, sm, lm, NS6m)

	# Correction at receiver input
	NS6c = low_band_switch_correction_june_2016(NS6x, f_in = fs, verification = 'no')










	# S-parameters of attenuators

	# At VNA
	om, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_15C_november_2016/LNA/S11/raw/attenuators/Open1.s1p')
	sm, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_15C_november_2016/LNA/S11/raw/attenuators/Short1.s1p')
	mm, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_15C_november_2016/LNA/S11/raw/attenuators/Match1.s1p')

	om3, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_15C_november_2016/LNA/S11/raw/attenuators/3dB_Open1.s1p')
	sm3, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_15C_november_2016/LNA/S11/raw/attenuators/3dB_Short1.s1p')
	mm3, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_15C_november_2016/LNA/S11/raw/attenuators/3dB_Match1.s1p')

	om6, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_15C_november_2016/LNA/S11/raw/attenuators/6dB_Open1.s1p')
	sm6, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_15C_november_2016/LNA/S11/raw/attenuators/6dB_Short1.s1p')
	mm6, fs = rc.s1p_read(home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_15C_november_2016/LNA/S11/raw/attenuators/6dB_Match1.s1p')


	# Models of standards
	resistance_of_match = 50.11 # male
	oa, sa, ma = rc.agilent_85033E(fs, resistance_of_match)


	# 3-dB Attn
	om3c, x1, x2, x3  = rc.de_embed(oa, sa, ma, om, sm, mm, om3)
	sm3c, x1, x2, x3  = rc.de_embed(oa, sa, ma, om, sm, mm, sm3)
	mm3c, x1, x2, x3  = rc.de_embed(oa, sa, ma, om, sm, mm, mm3)

	xx, s11a3, s12s21a3, s22a3  = rc.de_embed(oa, sa, ma, om3c, sm3c, mm3c, om3c)


	# 6-dB Attn
	om6c, x1, x2, x3  = rc.de_embed(oa, sa, ma, om, sm, mm, om6)
	sm6c, x1, x2, x3  = rc.de_embed(oa, sa, ma, om, sm, mm, sm6)
	mm6c, x1, x2, x3  = rc.de_embed(oa, sa, ma, om, sm, mm, mm6)

	xx, s11a6, s12s21a6, s22a6  = rc.de_embed(oa, sa, ma, om6c, sm6c, mm6c, om6c)	





	# Saving data
	temp = np.array([ fs/1e6, 
	                  np.real(NS0c),    np.imag(NS0c),   # reflection coefficient, just noise source
	                  np.real(NS3c),    np.imag(NS3c),   # reflection coefficient, 3-dB attenuator in front of noise source
	                  np.real(NS6c),    np.imag(NS6c),   # reflection coefficient, 6-dB attenuator in front of noise source
	                  np.real(s11a3),     np.imag(s11a3),    # S-parameters of 3-dB attenuator 
	                  np.real(s12s21a3),  np.imag(s12s21a3), # S-parameters of 3-dB attenuator 
	                  np.real(s22a3),     np.imag(s22a3),    # S-parameters of 3-dB attenuator 
	                  np.real(s11a6),     np.imag(s11a6),    # S-parameters of 6-dB attenuator
	                  np.real(s12s21a6),  np.imag(s12s21a6), # S-parameters of 6-dB attenuator
	                  np.real(s22a6),     np.imag(s22a6)])   # S-parameters of 6-dB attenuator


	output_file = temp.T
	file_name   = home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_15C_november_2016/LNA/S11/corrected/noise_source_s-parameters.txt'
	np.savetxt(file_name, output_file)



	return 0 #fs, NS0c, NS3c, NS6c, s11a3, s12s21a3, s22a3, s11a6, s12s21a6, s22a6
























def low_band1_25C_2017_05_noise_source_sparameters():

	# Main path
	main_path = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band1/2017_05_25C/data/s11/'


	# Reflection coefficient of noise source plus 3dB attenuator, alone	
	om,  fs   = rc.s1p_read(main_path + 'raw/AlansNoiseSource_at_the_Receiver_3dB/Open02.s1p')  # measurement after spectra measurement is slightly better
	sm,  fs   = rc.s1p_read(main_path + 'raw/AlansNoiseSource_at_the_Receiver_3dB/Short02.s1p')
	lm,  fs   = rc.s1p_read(main_path + 'raw/AlansNoiseSource_at_the_Receiver_3dB/Match02.s1p')
	NSm, fs   = rc.s1p_read(main_path + 'raw/AlansNoiseSource_at_the_Receiver_3dB/NoiseSource02.s1p')

	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(fs))
	s_sw = -1 * np.ones(len(fs))
	l_sw =  0 * np.ones(len(fs))

	# Correction at switch
	NSx, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, om, sm, lm, NSm)

	# Correction at receiver input
	A = low_band1_switch_correction_2017_05_25C(NSx, f_in = fs, verification = 'no')
	NSc = A[0]


	# Reflection coefficient of noise source plus 3dB attenuator, plus cable box	
	om, fs    = rc.s1p_read(main_path + 'raw/AlansNoiseSourandCableBox_3dB/Open2.s1p')  # measurement after spectra measurement is slightly better
	sm, fs    = rc.s1p_read(main_path + 'raw/AlansNoiseSourandCableBox_3dB/Short2.s1p')
	lm, fs    = rc.s1p_read(main_path + 'raw/AlansNoiseSourandCableBox_3dB/Match2.s1p')
	NScbm, fs = rc.s1p_read(main_path + 'raw/AlansNoiseSourandCableBox_3dB/External2.s1p')

	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(fs))
	s_sw = -1 * np.ones(len(fs))
	l_sw =  0 * np.ones(len(fs))

	# Correction at switch
	NScbx, x1, x2, x3 = rc.de_embed(o_sw, s_sw, l_sw, om, sm, lm, NScbm)

	# Correction at receiver input
	B = low_band1_switch_correction_2017_05_25C(NScbx, f_in = fs, verification = 'no')
	NScbc = B[0]


	# S-parameters of cable

	# At VNA
	om, fs = rc.s1p_read(main_path + 'raw/AlansCableBox_at_the_VNA/Open1.s1p')
	sm, fs = rc.s1p_read(main_path + 'raw/AlansCableBox_at_the_VNA/Short1.s1p')
	mm, fs = rc.s1p_read(main_path + 'raw/AlansCableBox_at_the_VNA/Match1.s1p')

	# At end of cable
	omcb, fs = rc.s1p_read(main_path + 'raw/AlansCableBox_at_the_VNA/CableBoxOpen1.s1p')
	smcb, fs = rc.s1p_read(main_path + 'raw/AlansCableBox_at_the_VNA/CableBoxShort1.s1p')
	mmcb, fs = rc.s1p_read(main_path + 'raw/AlansCableBox_at_the_VNA/CableBoxMatch1.s1p')

	# Models of standards
	resistance_of_match = 50.11 # male
	oa, sa, ma = rc.agilent_85033E(fs, resistance_of_match)

	# Cable
	omcbc, x1, x2, x3  = rc.de_embed(oa, sa, ma, om, sm, mm, omcb)
	smcbc, x1, x2, x3  = rc.de_embed(oa, sa, ma, om, sm, mm, smcb)
	mmcbc, x1, x2, x3  = rc.de_embed(oa, sa, ma, om, sm, mm, mmcb)

	xx, s11cb, s12s21cb, s22cb  = rc.de_embed(oa, sa, ma, omcbc, smcbc, mmcbc, omcbc)


	# Saving data
	temp = np.array([ fs/1e6, 
	                  np.real(NSc),       np.imag(NSc),      # reflection coefficient, just noise source + 3-dB
	                  np.real(NScbc),     np.imag(NScbc),    # reflection coefficient + 3-dB, plus cable box
	                  np.real(s11cb),     np.imag(s11cb),    # S-parameters of cable box
	                  np.real(s12s21cb),  np.imag(s12s21cb), # S-parameters of cable box
	                  np.real(s22cb),     np.imag(s22cb)])   # S-parameters of cable box

	output_file = temp.T
	file_name   = main_path + 'corrected/noise_source_s-parameters.txt'
	np.savetxt(file_name, output_file, header='freq [MHz]\tre(noise_source_plus_3dB)\tim(noise_source_plus_3dB)\tre(noise_source_plus_3dB_plus_cable_box)\tim(noise_source_plus_3dB_plus_cable_box)\tre(s11_cable_box)\tim(s11_cable_box)\tre(s12s21_cable_box)\tim(s12s21_cable_box)\tre(s22_cable_box)\tim(s22_cable_box)')

	#np.savetxt(file_name, output_file, header='freq [MHz], real(noise_source_plus_3dB), imag(noise_source_plus_3dB), real(noise_source_plus_3dB_plus_cable_box),imag(noise_source_plus_3dB_plus_cable_box),\
								#real(s11_cable_box),imag(s11_cable_box),\
								#real(s12s21_cable_box),imag(s12s21_cable_box),\
								#real(s22_cable_box),imag(s22_cable_box)')	


	return output_file

































def high_band_25C_january_2017_noise_source_sparameters(flow=80, fhigh=200):



	data_path = '/DATA/EDGES/calibration/receiver_calibration/calibration_high_band_2017_january/LNA/S11/raw/'


	# Reflection coefficient of noise source plus 6dB attenuator, alone
	om, fs   = rc.s1p_read(home_folder + data_path + 'NoiseSource_at_Receiver_0dB_extra/Open2.s1p')     # measurement after spectra measurement is slightly better
	sm, fs   = rc.s1p_read(home_folder + data_path + 'NoiseSource_at_Receiver_0dB_extra/Short2.s1p')
	lm, fs   = rc.s1p_read(home_folder + data_path + 'NoiseSource_at_Receiver_0dB_extra/Match2.s1p')
	NS0m, fs = rc.s1p_read(home_folder + data_path + 'NoiseSource_at_Receiver_0dB_extra/External2.s1p')

	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(fs))
	s_sw = -1 * np.ones(len(fs))
	l_sw =  0 * np.ones(len(fs))

	# Correction at switch
	NS0x, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, om, sm, lm, NS0m)

	# Correction at receiver input
	NS0c, x1 ,x2, x3 = high_band_switch_correction(NS0x, 25)






	# Reflection coefficient of noise source plus 6dB attenuator, plus extra 3-dB attenuator
	om, fs   = rc.s1p_read(home_folder + data_path + 'NoiseSource_at_Receiver_3dB_extra/Open2.s1p')  # measurement after spectra measurement is slightly better
	sm, fs   = rc.s1p_read(home_folder + data_path + 'NoiseSource_at_Receiver_3dB_extra/Short2.s1p')
	lm, fs   = rc.s1p_read(home_folder + data_path + 'NoiseSource_at_Receiver_3dB_extra/Match2.s1p')
	NS3m, fs = rc.s1p_read(home_folder + data_path + 'NoiseSource_at_Receiver_3dB_extra/External2.s1p')

	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(fs))
	s_sw = -1 * np.ones(len(fs))
	l_sw =  0 * np.ones(len(fs))

	# Correction at switch
	NS3x, x1, x2, x3 = rc.de_embed(o_sw, s_sw, l_sw, om, sm, lm, NS3m)

	# Correction at receiver input
	NS3c, x1, x2, x3 = high_band_switch_correction(NS3x, 25)






	# Reflection coefficient of noise source plus 6dB attenuator, plus extra 6-dB attenuator
	om, fs   = rc.s1p_read(home_folder + data_path + 'NoiseSource_at_Receiver_6dB_extra/Open2.s1p')  # measurement after spectra measurement is slightly better
	sm, fs   = rc.s1p_read(home_folder + data_path + 'NoiseSource_at_Receiver_6dB_extra/Short2.s1p')
	lm, fs   = rc.s1p_read(home_folder + data_path + 'NoiseSource_at_Receiver_6dB_extra/Match2.s1p')
	NS6m, fs = rc.s1p_read(home_folder + data_path + 'NoiseSource_at_Receiver_6dB_extra/External2.s1p')

	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(fs))
	s_sw = -1 * np.ones(len(fs))
	l_sw =  0 * np.ones(len(fs))

	# Correction at switch
	NS6x, x1, x2, x3 = rc.de_embed(o_sw, s_sw, l_sw, om, sm, lm, NS6m)

	# Correction at receiver input
	NS6c, x1, x2, x3 = high_band_switch_correction(NS6x, 25)








	# S-parameters of attenuators

	# At VNA
	om, fs = rc.s1p_read(home_folder + data_path + 'Attenuators/Open1.s1p')
	sm, fs = rc.s1p_read(home_folder + data_path + 'Attenuators/Short1.s1p')
	mm, fs = rc.s1p_read(home_folder + data_path + 'Attenuators/Match1.s1p')

	om3, fs = rc.s1p_read(home_folder + data_path + 'Attenuators/3dB_Open1.s1p')
	sm3, fs = rc.s1p_read(home_folder + data_path + 'Attenuators/3dB_Short1.s1p')
	mm3, fs = rc.s1p_read(home_folder + data_path + 'Attenuators/3dB_Match1.s1p')

	om6, fs = rc.s1p_read(home_folder + data_path + 'Attenuators/6dB_Open1.s1p')
	sm6, fs = rc.s1p_read(home_folder + data_path + 'Attenuators/6dB_Short1.s1p')
	mm6, fs = rc.s1p_read(home_folder + data_path + 'Attenuators/6dB_Match1.s1p')


	# Models of standards
	resistance_of_match = 50.11 # male
	oa, sa, ma          = rc.agilent_85033E(fs, resistance_of_match)


	# 3-dB Attn
	om3c, x1, x2, x3  = rc.de_embed(oa, sa, ma, om, sm, mm, om3)
	sm3c, x1, x2, x3  = rc.de_embed(oa, sa, ma, om, sm, mm, sm3)
	mm3c, x1, x2, x3  = rc.de_embed(oa, sa, ma, om, sm, mm, mm3)

	xx, s11a3, s12s21a3, s22a3  = rc.de_embed(oa, sa, ma, om3c, sm3c, mm3c, om3c)


	# 6-dB Attn
	om6c, x1, x2, x3  = rc.de_embed(oa, sa, ma, om, sm, mm, om6)
	sm6c, x1, x2, x3  = rc.de_embed(oa, sa, ma, om, sm, mm, sm6)
	mm6c, x1, x2, x3  = rc.de_embed(oa, sa, ma, om, sm, mm, mm6)

	xx, s11a6, s12s21a6, s22a6  = rc.de_embed(oa, sa, ma, om6c, sm6c, mm6c, om6c)	





	# Saving data
	temp = np.array([ fs/1e6, 
	                  np.real(NS0c),      np.imag(NS0c),   # reflection coefficient, just noise source (with internal 6-dB attenuator)
	                  np.real(NS3c),      np.imag(NS3c),   # reflection coefficient, 3-dB attenuator in front of noise source
	                  np.real(NS6c),      np.imag(NS6c),   # reflection coefficient, 6-dB attenuator in front of noise source
	                  np.real(s11a3),     np.imag(s11a3),    # S-parameters of 3-dB attenuator 
	                  np.real(s12s21a3),  np.imag(s12s21a3), # S-parameters of 3-dB attenuator 
	                  np.real(s22a3),     np.imag(s22a3),    # S-parameters of 3-dB attenuator 
	                  np.real(s11a6),     np.imag(s11a6),    # S-parameters of 6-dB attenuator
	                  np.real(s12s21a6),  np.imag(s12s21a6), # S-parameters of 6-dB attenuator
	                  np.real(s22a6),     np.imag(s22a6)])   # S-parameters of 6-dB attenuator


	output_file_all_freq = temp.T
	output_file = output_file_all_freq[(output_file_all_freq[:,0]>=flow) & (output_file_all_freq[:,0]<=fhigh),:]
	file_name   = home_folder + '/DATA/EDGES/calibration/receiver_calibration/calibration_high_band_2017_january/LNA/S11/corrected/noise_source_s-parameters.txt'
	np.savetxt(file_name, output_file)



	return output_file




















def rejection_file_read(file):

	with h5py.File(file, 'r') as hf:

		hf_f     = hf.get('f')
		f        = np.array(hf_f)

		hf_res0  = hf.get('res0')
		res0     = np.array(hf_res0)

		hf_wRMS0 = hf.get('wRMS0')
		wRMS0    = np.array(hf_wRMS0)

		hf_z     = hf.get('z')
		z        = np.array(hf_z)

		hf_dz    = hf.get('dz')
		dz       = np.array(hf_dz)

		hf_res   = hf.get('res')
		res      = np.array(hf_res)

		hf_wRMS  = hf.get('wRMS')
		wRMS     = np.array(hf_wRMS)

		hf_T6    = hf.get('T6')
		T6       = np.array(hf_T6)

		hf_p_rec   = hf.get('p_rec')
		p_rec      = np.array(hf_p_rec)

		hf_dp_rec  = hf.get('dp_rec')
		dp_rec     = np.array(hf_dp_rec)

		hf_dr      = hf.get('dr')
		dr         = np.array(hf_dr)

		hf_dz_line = hf.get('dz_line')
		dz_line    = np.array(hf_dz_line)

		hf_dr_line = hf.get('dr_line')
		dr_line    = np.array(hf_dr_line)	


	return f, res0, wRMS0, z, dz, res, wRMS, T6, p_rec, dp_rec, dr, dz_line, dr_line 




def radiometer_equation(TantK, BwMHz, IntTimeHr):

	sigma_noise_K       = TantK/np.sqrt(BwMHz*1e6 * IntTimeHr*60*60)
	noise_realization_K = sigma_noise_K * np.random.normal(np.zeros(len(TantK)))

	return sigma_noise_K, noise_realization_K











def data_analysis_sliding_window(v, t, w, Dv=[10, 20, 30, 40, 50], Nfg=[2,3,4]):


	# v = np.arange(110, 190.2, 0.4)

	# TantK_no_noise = 400*(v/140)**(-2.5)
	# BwMHz     = v[1] - v[0]
	# IntTimeHr = 4
	# sigma_noise_K, noise_realization_K = radiometer_equation(TantK_no_noise, BwMHz, IntTimeHr)
	# w = 1 / ( sigma_noise_K**2 )
	# t = TantK_no_noise + noise_realization_K



	# Reference template amplitude
	T21_K_ref = 0.028

	# Array of window durations
	indexDv   = np.zeros(len(Dv))
	for j in range(len(Dv)):
		for i in range(len(v)-1):
			if ((v[i] - v[0]) <= Dv[j]) and ((v[i+1] - v[0]) >= Dv[j]):
				indexDv[j] = i+1	

	# Number of foreground terms
	#Nfg       = np.array([2, 3, 4]) # np.array([2, 3, 4, 5]) #, 5, 6])

	# Array of EoR durations 
	dz        = np.arange(0.02, 2.01, 0.02)

	# Indices of frequency window limits
	istart_all = np.zeros(len(v))
	iend_all   = np.zeros(len(v))

	# Output arrays
	index_all = np.zeros(   (len(indexDv), 2, len(v))   )
	px_all    = np.zeros(   (len(indexDv), len(Nfg), len(v), len(dz))   )
	dpx_all   = np.zeros(   (len(indexDv), len(Nfg), len(v), len(dz))   )
	drx_all   = np.zeros(   (len(indexDv), len(Nfg), len(v), len(dz))   )	
	dz_lines  = np.zeros(   (len(indexDv), len(Nfg), len(v))   )
	dr_lines  = np.zeros(   (len(indexDv), len(Nfg), len(v))   )

	# Sweep over Window Durations
	for q in range(len(indexDv)):

		# Sweep over Number of Foreground Terms
		for k in range(len(Nfg)):

			# Sweep over frequency
			for j in range(len(v)):  # kk:    #range(20):  # #kk = np.arange(0, 20, 1)


				# Window indices
				if (j - (indexDv[q]/2)) <= 0:
					istart = 0
					iend   = indexDv[q]

				elif ((j - (indexDv[q]/2)) > 0) and ((j + (indexDv[q]/2)) < (len(v)-1)):
					istart = (j - (indexDv[q]/2))
					iend   = (j + (indexDv[q]/2))

				elif ((j - (indexDv[q]/2)) > 0) and ((j + (indexDv[q]/2)) >= (len(v)-1)):
					istart = len(v) - 1 - indexDv[q]
					iend   = len(v) - 1

				if k == 0:			
					index_all[q, 0, j] = istart
					index_all[q, 1, j] = iend



				# Data window
				vs = v[istart:iend]
				ts = t[istart:iend]
				ws = w[istart:iend]


				# Print iteration information
				print(   'Window Width: ' + str(v[indexDv[q]] - v[0]) + ' MHz, Window Limits: ' + str(v[istart]) + '--' + str(v[iend]) + ' MHz, Polynomial Terms: ' + str(Nfg[k]) + ', Frequency: ' + str(v[j])   )


				# Sweep over dz
				px  = np.zeros(len(dz))
				dpx = np.zeros(len(dz))
				drx = np.zeros(len(dz))

				for i in range(len(dz)):

					p = fit_polynomial_fourier('EDGES_polynomial_plus_tanh', vs, ts, Nfg[k], Weights=ws, zr=frequency2redshift(v[j]), dz=dz[i])

					px[i]    = p[0][Nfg[k]]
					dpx[i]   = np.sqrt(np.diag(p[3]))[Nfg[k]]
					drx[i]   = (px[i] - T21_K_ref) / dpx[i]

					px_all[q, k, j, i]  = px[i]
					dpx_all[q, k, j, i] = dpx[i]
					drx_all[q, k, j, i] = drx[i]



	# Computing and storing 95% rejection lines
	for q in range(len(indexDv)):
		for k in range(len(Nfg)):
			for j in range(len(v)):

				temp_dz_1 = 0
				temp_dz_2 = 0
				for i in range(len(dz)-1):

					if ((dpx_all[q,k,j,i] <= T21_K_ref/2) and (dpx_all[q,k,j,i+1] >= T21_K_ref/2)):
						temp_dz_1 = dz[i]

					if ((drx_all[q,k,j,i] <= -2) and (drx_all[q,k,j,i+1] >= -2)):  # ((drx_all[q,k,j,i] >= -2) and (drx_all[q,k,j,i+1] <= -2)) or
						temp_dz_2 = dz[i]

					if (np.max(drx_all[q,k,j,:]) <= -2):
						temp_dz_2 = np.max(dz)

					if (np.min(drx_all[q,k,j,:]) > -2):
						temp_dz_2 = 0





				dz_lines[q,k,j] = temp_dz_1
				dr_lines[q,k,j] = np.min([temp_dz_1, temp_dz_2])



	# plt.plot(v, v[index_all[0,1,:].astype(int)], 'r');  plt.xlabel('window center frequency [MHz]'); plt.ylabel('window limit frequencies [MHz]')

	return index_all, px_all, dpx_all, drx_all, dz_lines, dr_lines


















def data_analysis_sliding_window_chi_squared(band, v, t, w, chi_square_version='v1', cosmo_model_type='tanh', T21=0.028, gaussian_skewness=0, Dv=[10, 20, 30, 40, 50], Nfg=[2,3,4], save='no', filename='rejection_results_window_XMHz_nterms_Y'):


	# v = np.arange(90, 190.2, 0.4)

	# TantK_no_noise = 400*(v/140)**(-2.5)
	# BwMHz     = v[1] - v[0]
	# IntTimeHr = 4
	# sigma_noise_K, noise_realization_K = radiometer_equation(TantK_no_noise, BwMHz, IntTimeHr)
	# w = 1 / ( sigma_noise_K**2 )
	# t = TantK_no_noise + noise_realization_K



	# Reference template amplitude
	# T21_K_ref = 0.028

	# Array of window durations
	indexDv   = np.zeros(len(Dv))
	for j in range(len(Dv)):
		indexDv[j] = len(v)  # Initialize at maximum window width possible, this can be overwritten below for narrower windows
		for i in range(len(v)-1):
			if ((v[i] - v[0]) <= Dv[j]) and ((v[i+1] - v[0]) >= Dv[j]):
				indexDv[j] = i+1	

	# Array of EoR durations
	if cosmo_model_type == 'tanh':
		dz = np.arange(0.04, 2.01, 0.04)
	elif cosmo_model_type == 'gaussian_redshift':
		dz = np.arange(0.2, 4.01, 0.2)

	# Indices of frequency window limits
	istart_all = np.zeros(len(v))
	iend_all   = np.zeros(len(v))

	# Main output array
	line68 = np.zeros( (len(indexDv), len(Nfg), len(v)) )
	line95 = np.zeros( (len(indexDv), len(Nfg), len(v)) )


	# Sweep over Window Durations
	for q in range(len(indexDv)):

		# Number of windows across frequency 
		Nwindows = len(v) - indexDv[q] + 1


		# Sweep over Number of Foreground Terms
		for k in range(len(Nfg)):

			# Initializing auxiliary arrays
			cube_prob    = np.zeros((Nwindows, len(dz), len(v)))
			prob68       = np.zeros((Nwindows, len(v)))
			prob95       = np.zeros((Nwindows, len(v)))
			window_index = np.zeros((Nwindows, 2))

			# Initializing array of window no-signal residuals 
			if (q == 0) and (k == 0):
				residuals0 = np.zeros((Nwindows, indexDv[q]))


			# Sweep over number of windows
			for y in range(Nwindows.astype(int)):  # range(10): range(30):
				istart = y
				iend   = y + indexDv[q]

				# Data window
				vs = v[istart:iend]
				ts = t[istart:iend]
				ws = w[istart:iend]

				# Storing indices
				window_index[y, 0] = istart
				window_index[y, 1] = iend

				# Degrees of freedom
				DF = len(ts[ws>0]) - Nfg[k] - 1


				# Fitting a polynomial only to the data window, no Tanh signal
				p = fit_polynomial_fourier('EDGES_polynomial', vs, ts, Nfg[k], Weights=ws)


				# chi squared METHOD 1
				REDchi2_no_signal = p[4][0,0]


				# chi squared METHOD 2: modeling residuals
				R0                          = np.abs((ts - p[1]))
				pR0                         = fit_polynomial_fourier('polynomial', vs/200, R0, 2, Weights=ws)
				modelR0_unnormalized        = model_evaluate('polynomial', pR0[0], vs/200)				
				chi2_unnormalized_no_signal = np.sum( (((ts - p[1])/modelR0_unnormalized)[ws>0])**2 )
				normalization_constant      = DF / chi2_unnormalized_no_signal				
				modelR0_normalized          = modelR0_unnormalized / np.sqrt(normalization_constant)



				# Storing residuals (for first window size only)
				if (q == 0) and (k == 0):
					residuals0[y, :] = ts - p[1]



				# Sweep over frequency within the window
				for j in range(len(vs)):

					# Print iteration information
					print(   'Window Width: ' + str(v[indexDv[q]-1] - v[0]) + ' MHz, Window Limits: ' + str(vs[0]) + '--' + str(vs[-1]) + ' MHz, Polynomial Terms: ' + str(Nfg[k]) + ', Frequency: ' + str(vs[j]) + ', DF: ' + str(DF) )					

					# chi squared METHOD 1
					chi2    = np.zeros(len(dz))

					# chi squared METHOD 2 
					chi2_v2 = np.zeros(len(dz))				

					# Sweep in dz
					for i in range(len(dz)):

						# Compute cosmological model
						cosmo_model, xHI, z = model_eor(vs, T21=T21, model_type=cosmo_model_type, zr=frequency2redshift(vs[j]), dz=dz[i], z_alpha=gaussian_skewness)
						diff = ts - cosmo_model

						# Fit foreground model to the data minus the cosmological model
						p = fit_polynomial_fourier('EDGES_polynomial', vs, diff, Nfg[k], Weights=ws)

						# Normalized chi square, METHOD 1
						REDchi2    = p[4][0,0]
						chi2[i]    = DF * REDchi2 / REDchi2_no_signal

						# Normalized chi square, METHOD 2
						wsn        = (ws/np.sum(ws))    # normalized weights
						chi2_v2[i] = np.sum( (((diff - p[1])/modelR0_normalized)[ws>0])**2 )   # wsn




					# Probability for each model to be consistent with the data
					if chi_square_version == 'v1':
						prob = 100*(1-stats.chi2.cdf(chi2, DF))
					elif chi_square_version == 'v2':
						prob = 100*(1-stats.chi2.cdf(chi2_v2, DF))


					# Storing probabilities
					cube_prob[y, :, j+istart] = prob


					# 68% and 95% lines for all windows
					for i in range(len(dz)-1):
						if (prob[i] <= 5) and (prob[i+1] > 5):
							prob95[y, j+istart] = dz[i]

						if (prob[i] <= 32) and (prob[i+1] > 32):
							prob68[y, j+istart] = dz[i]					




			# Line of maximum 95% constraints for all windows
			line68[q, k, :] = np.max(prob68, axis=0)
			line95[q, k, :] = np.max(prob95, axis=0)


			# Additional output variables (only produced for the first window size and Nfg)
			if (q == 0) and (k == 0):
				cube_prob_out    = np.copy(cube_prob)
				prob68_out       = np.copy(prob68)
				prob95_out       = np.copy(prob95)
				window_index_out = np.copy(window_index)



	# Save	
	if save == 'yes':

		path_save = home_folder + '/DATA/EDGES/results/' + band + '/products/model_rejection/chi_square_sliding_window/'
		save_file = path_save + filename + '.hdf5'	

		with h5py.File(save_file, 'w') as hf:
			hf.create_dataset('v',                data = v)
			hf.create_dataset('Dv',               data = Dv)
			hf.create_dataset('Nfg',              data = Nfg)			
			hf.create_dataset('line68',           data = line68)
			hf.create_dataset('line95',           data = line95)
			hf.create_dataset('cube_prob',        data = cube_prob_out)
			hf.create_dataset('prob68',           data = prob68_out)
			hf.create_dataset('prob95',           data = prob95_out)
			hf.create_dataset('window_index',     data = window_index_out)
			hf.create_dataset('residuals0',       data = residuals0)


	return line68, line95, cube_prob_out, prob68_out, prob95_out, window_index_out, residuals0











def read_chi_square_sliding_window(band, filename):

	path = home_folder + '/DATA/EDGES/results/' + band + '/products/model_rejection/chi_square_sliding_window/'
	with h5py.File(path + filename,'r') as hf:

		hf_v  = hf.get('v')
		v     = np.array(hf_v)		

		hf_Dv = hf.get('Dv')
		Dv    = np.array(hf_Dv)

		hf_Nfg = hf.get('Nfg')
		Nfg    = np.array(hf_Nfg)

		hf_line68 = hf.get('line68')
		line68    = np.array(hf_line68)

		hf_line95 = hf.get('line95')
		line95    = np.array(hf_line95)

		hf_cube_prob = hf.get('cube_prob')
		cube_prob    = np.array(hf_cube_prob)

		hf_prob68 = hf.get('prob68')
		prob68    = np.array(hf_prob68)

		hf_prob95 = hf.get('prob95')
		prob95    = np.array(hf_prob95)

		hf_window_index = hf.get('window_index')
		window_index    = np.array(hf_window_index)

		hf_residuals0 = hf.get('residuals0')
		residuals0    = np.array(hf_residuals0)		

	return v, Dv, Nfg, line68, line95, cube_prob, prob68, prob95, window_index, residuals0








def read_least_squares_sliding_window(band, folder, filename):

	path = home_folder + '/DATA/EDGES/results/' + band + '/products/model_rejection/least_squares_sliding_window/' + folder + '/'
	with h5py.File(path + filename,'r') as hf:

		hf_v  = hf.get('v')
		v     = np.array(hf_v)		

		hf_t  = hf.get('t')
		t     = np.array(hf_t)

		hf_w  = hf.get('w')
		w     = np.array(hf_w)

		hf_Dv = hf.get('Dv')
		Dv    = np.array(hf_Dv)

		hf_Nfg = hf.get('Nfg')
		Nfg    = np.array(hf_Nfg)

		hf_zr   = hf.get('zr')
		zr      = np.array(hf_zr)

		hf_dz   = hf.get('dz')
		dz      = np.array(hf_dz)		

		hf_p21  = hf.get('p21')
		p21     = np.array(hf_p21)

		hf_dp21 = hf.get('dp21')
		dp21    = np.array(hf_dp21)


	return v, t, w, Dv, Nfg, zr, dz, p21, dp21











def calibration_processing_high_band_january_2017_25C(flow, fhigh, save='no'):


	"""
	Modification: February 9, 2017.

	"""	



	# Paths

	# Paths for source data
	path_spectra     = home_folder + '/DATA/EDGES/spectra/level1/calibration_high_band_2017_january/300_350/'
	path_resistance  = home_folder + '/DATA/EDGES/calibration/receiver_calibration/high_band/2017_01_25C/LNA/resistance/corrected/'
	path_s11         = home_folder + '/DATA/EDGES/calibration/receiver_calibration/high_band/2017_01_25C/LNA/S11/corrected/'

	# Paths for output parameters
	path_par_temp    = home_folder + '/DATA/EDGES/calibration/receiver_calibration/high_band/2017_01_25C/LNA/models/25degC/temp/'
	path_par_spectra = home_folder + '/DATA/EDGES/calibration/receiver_calibration/high_band/2017_01_25C/LNA/models/25degC/spectra/'
	path_par_s11     = home_folder + '/DATA/EDGES/calibration/receiver_calibration/high_band/2017_01_25C/LNA/models/25degC/s11/'

	# Path for average data
	path_data        = home_folder + '/DATA/EDGES/calibration/receiver_calibration/high_band/2017_01_25C/LNA/models/25degC/data/'	




	# Ambient
	file_ambient1 = path_spectra + 'level1_AmbientLoad_2017_024_23_300_350.mat'
	file_ambient2 = path_spectra + 'level1_AmbientLoad_2017_025_00_300_350.mat'
	file_ambient3 = path_spectra + 'level1_AmbientLoad_2017_026_00_300_350.mat'	
	spec_ambient  = [file_ambient1, file_ambient2, file_ambient3]
	res_ambient   = path_resistance + 'ambient_load.txt'



	# Hot
	file_hot1 = path_spectra + 'level1_HotLoad_2017_027_00_300_350.mat'	
	file_hot2 = path_spectra + 'level1_HotLoad_2017_028_00_300_350.mat'
	spec_hot  = [file_hot1, file_hot2]
	res_hot   = path_resistance + 'hot_load.txt'



	# Open Cable
	file_open1 = path_spectra + 'level1_OpenCable_2017_031_01_300_350.mat'
	spec_open  = [file_open1]
	res_open   = path_resistance + 'open_cable.txt'



	# Shorted Cable
	file_shorted1 = path_spectra + 'level1_ShortedCable_0ohms_2017_037_21_300_350.mat'
	file_shorted2 = path_spectra + 'level1_ShortedCable_0ohms_2017_038_00_300_350.mat'
	spec_shorted  = [file_shorted1, file_shorted2]
	res_shorted   = path_resistance + 'shorted_cable.txt'



	## Antenna Simulator 1
	#file_sim11  = path_spectra + 'level1_SimAnt1_2016_327_19_300_350.mat'	
	#file_sim12  = path_spectra + 'level1_SimAnt1_2016_328_00_300_350.mat'
	#file_sim13  = path_spectra + 'level1_SimAnt1_2016_329_00_300_350.mat'	
	#file_sim14  = path_spectra + 'level1_SimAnt1_2016_330_00_300_350.mat'
	#file_sim15  = path_spectra + 'level1_SimAnt1_2016_331_00_300_350.mat'
	#spec_sim1   = [file_sim11, file_sim12, file_sim13, file_sim14, file_sim15]
	#res_sim1    = path_resistance + 'SimAnt1.txt'



	# Antenna Simulator 2
	file_sim21  = path_spectra + 'level1_SimAnt2_2017_028_23_300_350.mat'
	file_sim22  = path_spectra + 'level1_SimAnt2_2017_029_00_300_350.mat'
	file_sim23  = path_spectra + 'level1_SimAnt2_2017_030_00_300_350.mat'		
	spec_sim2   = [file_sim21, file_sim22, file_sim23]
	res_sim2    = path_resistance + 'ant_sim2.txt'




	# Average calibration spectra / physical temperature
	# Percentage of initial data to leave out
	percent = 10 # 5%
	ssa,    phys_temp_ambient  = average_calibration_spectrum(spec_ambient, res_ambient, 1*percent, plot='no')
	ssh,    phys_temp_hot      = average_calibration_spectrum(spec_hot,     res_hot,     2*percent, plot='no')
	sso,    phys_temp_open     = average_calibration_spectrum(spec_open,    res_open,    1*percent, plot='no')
	sss,    phys_temp_shorted  = average_calibration_spectrum(spec_shorted, res_shorted, 1*percent, plot='no')
	#sss1,   phys_temp_sim1     = average_calibration_spectrum(spec_sim1,    res_sim1,    1*percent, plot='no')
	sss2,   phys_temp_sim2     = average_calibration_spectrum(spec_sim2,    res_sim2,    1*percent, plot='no')

	# there is no measurement of antenna simulator 1, so I am using the ant sim 2
	sss1           = np.copy(sss2)
	phys_temp_sim1 = np.copy(phys_temp_sim2)












	# Select frequency range
	ff, ilow, ihigh = frequency_edges(flow, fhigh)
	fe    = ff[ilow:ihigh+1]
	sa    = ssa[ilow:ihigh+1]
	sh    = ssh[ilow:ihigh+1]
	so    = sso[ilow:ihigh+1]
	ss    = sss[ilow:ihigh+1]	
	ss1   = sss1[ilow:ihigh+1]
	ss2   = sss2[ilow:ihigh+1]
	#soi   = ssoi[ilow:ihigh+1]
	#ss2r2 = sss2r2[ilow:ihigh+1]







	# Spectra modeling
	fen = (fe-140)/60


	fit_spec_ambient    = fit_polynomial_fourier('polynomial',    fen, sa,     5,  plot='no')
	fit_spec_hot        = fit_polynomial_fourier('polynomial',    fen, sh,     5,  plot='no')
	fit_spec_open       = fit_polynomial_fourier('fourier',    fen, so,    121,  plot='no')
	fit_spec_shorted    = fit_polynomial_fourier('fourier',    fen, ss,    121,  plot='no')
	#fit_spec_sim1       = fit_polynomial_fourier('fourier',    fen, ss1,   15,  plot='no')
	fit_spec_sim1       = fit_polynomial_fourier('fourier',    fen, ss1,   23,  plot='no')
	fit_spec_sim2       = fit_polynomial_fourier('fourier',    fen, ss2,   23,  plot='no')

	#fit_spec_open_input = fit_polynomial_fourier('fourier',    fen, soi,    7,  plot='no')
	#fit_spec_sim2r2     = fit_polynomial_fourier('fourier',    fen, ss2r2, 15,  plot='no')



	model_spec_ambient    = model_evaluate('polynomial', fit_spec_ambient[0],    fen)
	model_spec_hot        = model_evaluate('polynomial', fit_spec_hot[0],        fen)
	model_spec_open       = model_evaluate('fourier', fit_spec_open[0],       fen)
	model_spec_shorted    = model_evaluate('fourier', fit_spec_shorted[0],    fen)
	#model_spec_sim1       = model_evaluate('fourier', fit_spec_sim1[0],       fen)
	model_spec_sim1       = model_evaluate('fourier', fit_spec_sim1[0],       fen)
	model_spec_sim2       = model_evaluate('fourier', fit_spec_sim2[0],       fen)
	#model_spec_open_input = model_evaluate('fourier', fit_spec_open_input[0], fen)
	#model_spec_sim2r2     = model_evaluate('fourier', fit_spec_sim2r2[0],     fen)








	# Loading S11 data (both files produce same results)
	#s11 = np.genfromtxt(path_s11 + 's11_calibration_high_band_LNA25degC_2017-02-08-14-23-04_LNA1a.txt')
	s11 = np.genfromtxt(path_s11 + 's11_calibration_high_band_LNA25degC_2017-02-15-13-53-40_LNAxR01.txt')

	for i in range(len(s11[:,0])-1):
		if (s11[i,0] <= flow) and (s11[i+1,0] > flow):
			index_low = i
		if (s11[i,0] < fhigh) and (s11[i+1,0] >= fhigh):
			index_high = i+1
	index_s11 = np.arange(index_low, index_high+1)





	# Frequency / complex data
	f_s11       = s11[index_s11, 0]

	s11_LNA     = s11[index_s11, 1]  + 1j*s11[index_s11, 2]

	s11_amb     = s11[index_s11, 3]  + 1j*s11[index_s11, 4]
	s11_hot     = s11[index_s11, 5]  + 1j*s11[index_s11, 6]

	s11_open    = s11[index_s11, 7]  + 1j*s11[index_s11, 8]
	s11_shorted = s11[index_s11, 9]  + 1j*s11[index_s11, 10]

	s11_sr      = s11[index_s11, 11] + 1j*s11[index_s11, 12]
	s12s21_sr   = s11[index_s11, 13] + 1j*s11[index_s11, 14]
	s22_sr      = s11[index_s11, 15] + 1j*s11[index_s11, 16]

	#s11_simu1   = s11[index_s11, 17] + 1j*s11[index_s11, 18]
	s11_simu2   = s11[index_s11, 19] + 1j*s11[index_s11, 20]
	s11_simu1 = np.copy(s11_simu2)




	# Magnitude / Angle

	# LNA
	s11_LNA_mag     = np.abs(s11_LNA)
	s11_LNA_ang     = np.unwrap(np.angle(s11_LNA))

	# Ambient
	s11_amb_mag     = np.abs(s11_amb)
	s11_amb_ang     = np.unwrap(np.angle(s11_amb))

	# Hot
	s11_hot_mag     = np.abs(s11_hot)
	s11_hot_ang     = np.unwrap(np.angle(s11_hot))

	# Open
	s11_open_mag    = np.abs(s11_open)
	s11_open_ang    = np.unwrap(np.angle(s11_open))

	# Shorted
	s11_shorted_mag = np.abs(s11_shorted)
	s11_shorted_ang = np.unwrap(np.angle(s11_shorted))

	# sr-s11
	s11_sr_mag      = np.abs(s11_sr)
	s11_sr_ang      = np.unwrap(np.angle(s11_sr))

	# sr-s12s21
	s12s21_sr_mag   = np.abs(s12s21_sr)
	s12s21_sr_ang   = np.unwrap(np.angle(s12s21_sr))

	# sr-s22
	s22_sr_mag      = np.abs(s22_sr)
	s22_sr_ang      = np.unwrap(np.angle(s22_sr))

	# Simu1
	s11_simu1_mag   = np.abs(s11_simu1)
	s11_simu1_ang   = np.unwrap(np.angle(s11_simu1))

	# Simu2
	s11_simu2_mag   = np.abs(s11_simu2)
	s11_simu2_ang   = np.unwrap(np.angle(s11_simu2))	











	# Modeling S11

	f_s11n = (f_s11-140)/60

	fit_s11_LNA_mag     = fit_polynomial_fourier('fourier',    f_s11n, s11_LNA_mag,     27, plot='no')  # 
	fit_s11_LNA_ang     = fit_polynomial_fourier('fourier',    f_s11n, s11_LNA_ang,     27, plot='no')  # 

	fit_s11_amb_mag     = fit_polynomial_fourier('fourier',    f_s11n, s11_amb_mag,     27, plot='no')  # 
	fit_s11_amb_ang     = fit_polynomial_fourier('fourier',    f_s11n, s11_amb_ang,     27, plot='no')  # 

	fit_s11_hot_mag     = fit_polynomial_fourier('fourier',    f_s11n, s11_hot_mag,     27, plot='no')  #  
	fit_s11_hot_ang     = fit_polynomial_fourier('fourier',    f_s11n, s11_hot_ang,     27, plot='no')  # 

	fit_s11_open_mag    = fit_polynomial_fourier('fourier',    f_s11n, s11_open_mag,    27, plot='no')  # 27
	fit_s11_open_ang    = fit_polynomial_fourier('fourier',    f_s11n, s11_open_ang,    27, plot='no')  # 27

	fit_s11_shorted_mag = fit_polynomial_fourier('fourier',    f_s11n, s11_shorted_mag, 27, plot='no')  # 27
	fit_s11_shorted_ang = fit_polynomial_fourier('fourier',    f_s11n, s11_shorted_ang, 27, plot='no')  # 27

	fit_s11_sr_mag      = fit_polynomial_fourier('polynomial', f_s11n, s11_sr_mag,      15, plot='no')  # 
	fit_s11_sr_ang      = fit_polynomial_fourier('polynomial', f_s11n, s11_sr_ang,      15, plot='no')  # 

	fit_s12s21_sr_mag   = fit_polynomial_fourier('polynomial', f_s11n, s12s21_sr_mag,   15, plot='no')  # 
	fit_s12s21_sr_ang   = fit_polynomial_fourier('polynomial', f_s11n, s12s21_sr_ang,   15, plot='no')  # 

	fit_s22_sr_mag      = fit_polynomial_fourier('polynomial', f_s11n, s22_sr_mag,      15, plot='no')  # 
	fit_s22_sr_ang      = fit_polynomial_fourier('polynomial', f_s11n, s22_sr_ang,      15, plot='no')  # 

	#fit_s11_simu1_mag   = fit_polynomial_fourier('polynomial', f_s11n, s11_simu1_mag,   35, plot='no')  # 7
	#fit_s11_simu1_ang   = fit_polynomial_fourier('polynomial', f_s11n, s11_simu1_ang,   35, plot='no')  # 7

	fit_s11_simu1_mag   = fit_polynomial_fourier('fourier', f_s11n, s11_simu1_mag,      27, plot='no')  # 7
	fit_s11_simu1_ang   = fit_polynomial_fourier('fourier', f_s11n, s11_simu1_ang,      27, plot='no')  # 7	

	fit_s11_simu2_mag   = fit_polynomial_fourier('fourier', f_s11n, s11_simu2_mag,      27, plot='no')  # 7
	fit_s11_simu2_ang   = fit_polynomial_fourier('fourier', f_s11n, s11_simu2_ang,      27, plot='no')  # 7

#	fit_s11_simu2r2_mag   = fit_polynomial_fourier('fourier', f_s11n, s11_simu2r2_mag,  27, plot='no')
#	fit_s11_simu2r2_ang   = fit_polynomial_fourier('fourier', f_s11n, s11_simu2r2_ang,  27, plot='no')		










	# Saving output parameters
	if save == 'yes':


		# Average spectra data in frequency range selected
		spectra = np.array([fe, sa, sh, so, ss, ss1, ss2]).T

		# RMS residuals
		RMS_spectra = np.zeros((6,1))
		RMS_s11     = np.zeros((20,1))

		# Spectra
		RMS_spectra[0, 0] = fit_spec_ambient[2]
		RMS_spectra[1, 0] = fit_spec_hot[2]
		RMS_spectra[2, 0] = fit_spec_open[2]
		RMS_spectra[3, 0] = fit_spec_shorted[2]
		RMS_spectra[4, 0] = fit_spec_sim1[2]
		RMS_spectra[5, 0] = fit_spec_sim2[2]
		#RMS_spectra[6, 0] = fit_spec_open_input[2]
		#RMS_spectra[7, 0] = fit_spec_sim2r2[2]


		# S11
		RMS_s11[0, 0]  = fit_s11_LNA_mag[2]
		RMS_s11[1, 0]  = fit_s11_LNA_ang[2]
		RMS_s11[2, 0]  = fit_s11_amb_mag[2]
		RMS_s11[3, 0]  = fit_s11_amb_ang[2]
		RMS_s11[4, 0]  = fit_s11_hot_mag[2]
		RMS_s11[5, 0]  = fit_s11_hot_ang[2]
		RMS_s11[6, 0]  = fit_s11_open_mag[2]
		RMS_s11[7, 0]  = fit_s11_open_ang[2]
		RMS_s11[8, 0]  = fit_s11_shorted_mag[2]
		RMS_s11[9, 0]  = fit_s11_shorted_ang[2]
		RMS_s11[10, 0] = fit_s11_sr_mag[2]
		RMS_s11[11, 0] = fit_s11_sr_ang[2]
		RMS_s11[12, 0] = fit_s12s21_sr_mag[2]
		RMS_s11[13, 0] = fit_s12s21_sr_ang[2]
		RMS_s11[14, 0] = fit_s22_sr_mag[2]
		RMS_s11[15, 0] = fit_s22_sr_ang[2]
		RMS_s11[16, 0] = fit_s11_simu1_mag[2]
		RMS_s11[17, 0] = fit_s11_simu1_ang[2]
		RMS_s11[18, 0] = fit_s11_simu2_mag[2]      #
		RMS_s11[19, 0] = fit_s11_simu2_ang[2]      #
		#RMS_s11[20, 0] = fit_s11_simu2r2_mag[2]
		#RMS_s11[21, 0] = fit_s11_simu2r2_ang[2]		



		# Formating fit parameters

		# Physical temperature
		phys_temp = np.zeros((6,1))
		phys_temp[0,0] = phys_temp_ambient
		phys_temp[1,0] = phys_temp_hot
		phys_temp[2,0] = phys_temp_open
		phys_temp[3,0] = phys_temp_shorted
		phys_temp[4,0] = phys_temp_sim1
		phys_temp[5,0] = phys_temp_sim2
		#phys_temp[6,0] = phys_temp_sim2r2


		# Spectra
		par_spec_ambient    = np.reshape(fit_spec_ambient[0],    (-1,1))
		par_spec_hot        = np.reshape(fit_spec_hot[0],        (-1,1))
		par_spec_open       = np.reshape(fit_spec_open[0],       (-1,1))
		par_spec_shorted    = np.reshape(fit_spec_shorted[0],    (-1,1))
		par_spec_sim1       = np.reshape(fit_spec_sim1[0],       (-1,1))
		par_spec_sim2       = np.reshape(fit_spec_sim2[0],       (-1,1))
		#par_spec_open_input = np.reshape(fit_spec_open_input[0], (-1,1))
		#par_spec_sim2r2     = np.reshape(fit_spec_sim2r2[0],     (-1,1))



		# S11
		par_s11_LNA_mag     = np.reshape(fit_s11_LNA_mag[0],     (-1,1))
		par_s11_LNA_ang     = np.reshape(fit_s11_LNA_ang[0],     (-1,1))
		par_s11_amb_mag     = np.reshape(fit_s11_amb_mag[0],     (-1,1))
		par_s11_amb_ang     = np.reshape(fit_s11_amb_ang[0],     (-1,1))
		par_s11_hot_mag     = np.reshape(fit_s11_hot_mag[0],     (-1,1))
		par_s11_hot_ang     = np.reshape(fit_s11_hot_ang[0],     (-1,1))
		par_s11_open_mag    = np.reshape(fit_s11_open_mag[0],    (-1,1))
		par_s11_open_ang    = np.reshape(fit_s11_open_ang[0],    (-1,1))
		par_s11_shorted_mag = np.reshape(fit_s11_shorted_mag[0], (-1,1))
		par_s11_shorted_ang = np.reshape(fit_s11_shorted_ang[0], (-1,1))

		par_s11_sr_mag      = np.reshape(fit_s11_sr_mag[0],      (-1,1))
		par_s11_sr_ang      = np.reshape(fit_s11_sr_ang[0],      (-1,1))
		par_s12s21_sr_mag   = np.reshape(fit_s12s21_sr_mag[0],   (-1,1))
		par_s12s21_sr_ang   = np.reshape(fit_s12s21_sr_ang[0],   (-1,1))
		par_s22_sr_mag      = np.reshape(fit_s22_sr_mag[0],      (-1,1))
		par_s22_sr_ang      = np.reshape(fit_s22_sr_ang[0],      (-1,1))

		par_s11_simu1_mag   = np.reshape(fit_s11_simu1_mag[0],   (-1,1))
		par_s11_simu1_ang   = np.reshape(fit_s11_simu1_ang[0],   (-1,1))
		par_s11_simu2_mag   = np.reshape(fit_s11_simu2_mag[0],   (-1,1))   #
		par_s11_simu2_ang   = np.reshape(fit_s11_simu2_ang[0],   (-1,1))   #
		#par_s11_simu2r2_mag = np.reshape(fit_s11_simu2r2_mag[0], (-1,1))
		#par_s11_simu2r2_ang = np.reshape(fit_s11_simu2r2_ang[0], (-1,1))



		# Saving

		np.savetxt(path_data + 'average_spectra_300_350.txt', spectra)

		np.savetxt(path_par_temp    + 'physical_temperatures.txt', phys_temp)

		np.savetxt(path_par_spectra + 'par_spec_amb.txt',     par_spec_ambient)
		np.savetxt(path_par_spectra + 'par_spec_hot.txt',     par_spec_hot)
		np.savetxt(path_par_spectra + 'par_spec_open.txt',    par_spec_open)
		np.savetxt(path_par_spectra + 'par_spec_shorted.txt', par_spec_shorted)
		np.savetxt(path_par_spectra + 'par_spec_simu1.txt',   par_spec_sim1)
		np.savetxt(path_par_spectra + 'par_spec_simu2.txt',   par_spec_sim2)
		#np.savetxt(path_par_spectra + 'par_spec_open_input.txt',    par_spec_open_input)
		#np.savetxt(path_par_spectra + 'par_spec_simu2r2.txt', par_spec_sim2r2)
		np.savetxt(path_par_spectra + 'RMS_spec.txt',         RMS_spectra)

		np.savetxt(path_par_s11 + 'par_s11_LNA_mag.txt',      par_s11_LNA_mag)
		np.savetxt(path_par_s11 + 'par_s11_LNA_ang.txt',      par_s11_LNA_ang)
		np.savetxt(path_par_s11 + 'par_s11_amb_mag.txt',      par_s11_amb_mag)
		np.savetxt(path_par_s11 + 'par_s11_amb_ang.txt',      par_s11_amb_ang)
		np.savetxt(path_par_s11 + 'par_s11_hot_mag.txt',      par_s11_hot_mag)
		np.savetxt(path_par_s11 + 'par_s11_hot_ang.txt',      par_s11_hot_ang)
		np.savetxt(path_par_s11 + 'par_s11_open_mag.txt',     par_s11_open_mag)
		np.savetxt(path_par_s11 + 'par_s11_open_ang.txt',     par_s11_open_ang)
		np.savetxt(path_par_s11 + 'par_s11_shorted_mag.txt',  par_s11_shorted_mag)
		np.savetxt(path_par_s11 + 'par_s11_shorted_ang.txt',  par_s11_shorted_ang)

		np.savetxt(path_par_s11 + 'par_s11_sr_mag.txt',       par_s11_sr_mag)
		np.savetxt(path_par_s11 + 'par_s11_sr_ang.txt',       par_s11_sr_ang)
		np.savetxt(path_par_s11 + 'par_s12s21_sr_mag.txt',    par_s12s21_sr_mag)
		np.savetxt(path_par_s11 + 'par_s12s21_sr_ang.txt',    par_s12s21_sr_ang)
		np.savetxt(path_par_s11 + 'par_s22_sr_mag.txt',       par_s22_sr_mag)
		np.savetxt(path_par_s11 + 'par_s22_sr_ang.txt',       par_s22_sr_ang)

		np.savetxt(path_par_s11 + 'par_s11_simu1_mag.txt',    par_s11_simu1_mag)
		np.savetxt(path_par_s11 + 'par_s11_simu1_ang.txt',    par_s11_simu1_ang)
		np.savetxt(path_par_s11 + 'par_s11_simu2_mag.txt',    par_s11_simu2_mag)
		np.savetxt(path_par_s11 + 'par_s11_simu2_ang.txt',    par_s11_simu2_ang)		



		np.savetxt(path_par_s11 + 'RMS_s11.txt',       	      RMS_s11)


	# End
	print('Files processed.')


	return 1











def data_analysis_model_detection_rejection(f, t, w, model_21, model_fg='EDGES_polynomial', Nfg=5, zr=8, dz=2, z_alpha=0, anastasia_model_number=0, jordan_model_number=0, xi_min=0.9, tau_e_min=0.02, tau_e_max=0.25):

	"""
	This file superseeds the file data_analysis_phenomenological_detection_rejection()

	"""

	# Full measurement model
	if (model_21 == 'tanh') and (model_fg == 'EDGES_polynomial'):
		model = 'EDGES_polynomial_plus_tanh'


	if (model_21 == 'gaussian_redshift') and (model_fg == 'EDGES_polynomial'):
		model = 'EDGES_polynomial_plus_gaussian_redshift'


	if (model_21 == 'anastasia') and (model_fg == 'EDGES_polynomial'):
		model = 'EDGES_polynomial_plus_anastasia'


	if (model_21 == 'jordan') and (model_fg == 'EDGES_polynomial'):
		model = 'EDGES_polynomial_plus_jordan'



	# Weighted least squares
	p    = fit_polynomial_fourier(model, f, t, Nfg, Weights=w, zr=zr, dz=dz, z_alpha=z_alpha) #, anastasia_model_number=anastasia_model_number, jordan_model_number=jordan_model_number, xi_min=xi_min, tau_e_min=tau_e_min, tau_e_max=tau_e_max)
	p21  = p[0][Nfg]
	dp21 = np.sqrt(np.diag(p[3]))[Nfg]
	aux  = p[-1]


	return p21, dp21, aux





















def data_analysis_sliding_window_least_squares(band, v, t, w, model_21='tanh', resolution_zr='high_res', gaussian_max_dz=12, gaussian_skewness=0, Dv=[10, 20, 30, 40, 50], Nfg=[2,3,4], zr=0, dz=0, save='no', filename='rejection_results_tanh_window_XMHz_nterms_Y'):




	# Used for High-Band paper 

	## Array of center redshifts
	#if resolution_zr == 'high_res':
		#dzr = 0.03
	#elif resolution_zr == 'low_res':
		#dzr = 0.2

	#zr = np.arange(6.48, 14.8, dzr)



	## Array of durations
	#if model_21   == 'tanh': 
		#dz = np.arange(0.04, 1.41, 0.04)

	#elif model_21 == 'gaussian_redshift':
		#dz = np.arange(0.2, gaussian_max_dz + 0.01, 0.2)



	# Durations of windows in terms of number of frequency channels
	indexDv   = np.zeros(len(Dv))
	for j in range(len(Dv)):
		indexDv[j] = len(v)  # Initialize at maximum window width possible, this can be overwritten below for narrower windows
		for i in range(len(v)-1):
			if ((v[i] - v[0]) <= Dv[j]) and ((v[i+1] - v[0]) >= Dv[j]):
				indexDv[j] = i+1	

	max_Nwindows = int(len(v) - np.min(indexDv) + 1)
	p21_all      = np.zeros((len(indexDv), len(Nfg), max_Nwindows, len(zr), len(dz)))
	dp21_all     = np.zeros((len(indexDv), len(Nfg), max_Nwindows, len(zr), len(dz)))

	# Sweep over window durations
	for q in range(len(indexDv)):

		print('--------------------------------------------')

		# Number of windows across frequency 
		Nwindows = len(v) - indexDv[q] + 1

		# Sweep over number of foreground terms
		for k in range(len(Nfg)):

			print('--------------------------------------------')

			# Sweep over windows
			for y in range(int(Nwindows)): # .astype(int)

				print('Window size: ' + str(q+1) + ' of ' + str(len(indexDv)) + '. Polynomial terms: ' + str(k+1) + ' of ' + str(len(Nfg)) + '. Window number: ' + str(y+1) + ' of ' + str(int(Nwindows)))

				istart = int(y)
				iend   = int(y) + int(indexDv[q])

				# Data window
				vs = v[istart:iend]
				ts = t[istart:iend]
				ws = w[istart:iend]

				# Redshift window
				zs = frequency2redshift(vs)

				# Sweep in zr
				dzr = zr[1] - zr[0]
				for j in range(len(zr)):

					# Check if zr is within window limits
					if (zr[j] > (np.min(zs)-dzr)) and (zr[j] < (np.max(zs)+dzr)):

						# Sweep in dz
						for i in range(len(dz)):

							p21, dp21, aux    = data_analysis_model_detection_rejection(vs, ts, ws, model_21, model_fg='EDGES_polynomial', Nfg=Nfg[k], zr=zr[j], dz=dz[i], z_alpha=gaussian_skewness)
							p21_all[q, k, y, j, i]       = p21
							dp21_all[q, k, y, j, i]      = dp21



	# Save	
	if save == 'yes':

		path_save = home_folder + '/DATA/EDGES/results/' + band + '/products/model_rejection/least_squares_sliding_window/'
		save_file = path_save + filename + '.hdf5'

		with h5py.File(save_file, 'w') as hf:
			hf.create_dataset('v',          data = v)
			hf.create_dataset('t',          data = t)
			hf.create_dataset('w',          data = w)
			hf.create_dataset('Dv',         data = Dv)
			hf.create_dataset('Nfg',        data = Nfg)
			hf.create_dataset('zr',         data = zr)
			hf.create_dataset('dz',         data = dz)
			hf.create_dataset('p21',        data = p21_all)
			hf.create_dataset('dp21',       data = dp21_all)

	return zr, dz, p21_all, dp21_all


















def data_analysis_cube_to_limits(band, folder, HDF5_filename, Tref = 0.028, save='no', ww=0, fg=0, from_file='yes', zr=0, dz=0, p21=0, dp21=0):

	# Example: band = 'high_band'
	# Example, selection of window widths: ww = [6,7,8,9,10,11,12,13,14,15,16]
	# Example, selection of polynomial terms: fg = [2,3]


	# Loading file
	if from_file == 'yes':
		v, t, w, Dv, Nfg, zr, dz, p21, dp21 = read_least_squares_sliding_window(band, folder + '/full_results', HDF5_filename + '.hdf5')










	# Plotting errorbars as a function of Nfg, for zr=8.5, dz=1
	#
	# Dv[9]             = 65 MHz
	# Window_number[86] = 123.78 - 188.78 MHz
	# zr[67]            = 8.5
	# dz[24]            = 1
	# 
	# plt.errorbar([3, 4, 5], p21[9, :, 86, 67, 24], dp21[9, :, 86, 67, 24]);plt.xlim([2, 6])





	# Dimensional lengths
	len_ww = len(p21[:,0,0,0,0])
	len_fg = len(p21[0,:,0,0,0])
	len_wi = len(p21[0,0,:,0,0])
	len_zr = len(p21[0,0,0,:,0])
	len_dz = len(p21[0,0,0,0,:])

	# Initializing maps and limit line
	significance_map  = np.zeros((len_zr, len_dz))
	p21_map           = np.zeros((len_zr, len_dz))
	dp21_map          = np.ones((len_zr, len_dz))

	win_width         = np.zeros((len_zr, len_dz))
	fg_terms          = np.zeros((len_zr, len_dz))
	win_center        = np.zeros((len_zr, len_dz))

	limit_1sigma      = np.zeros(len(zr))
	limit_2sigma      = np.zeros(len(zr))

	# Consistency with zero
	CCZ = 2


	# Sweep over EoR reference redshift
	for j in range(len_zr):

		# Sweep over EoR durations
		for i in range(len_dz):




			# Sweep over window widths
			if ww == 0:
				rw = range(len_ww)
			else:
				rw = ww
			for q in rw:


				# Sweep over number of foreground terms
				if fg == 0:
					rfg = range(len_fg)
				else:
					rfg = fg
				for k in rfg:


					# Sweep over window "center"
					for y in range(len_wi):

						# Do analysis only if parameters available
						if (p21[q,k,y,j,i] != 0) and (dp21[q,k,y,j,i] != 0):

							print('hola')

							# For positive reference temperature				
							if Tref > 0:

								print(p21[q,k,y,j,i])

								# Rejection conditions
								if (np.abs(p21[q,k,y,j,i]) <= np.abs(Tref/2)) and (np.abs(p21[q,k,y,j,i]/dp21[q,k,y,j,i]) <= CCZ) and ((Tref + p21[q,k,y,j,i]) > CCZ*dp21[q,k,y,j,i]):
								#if (np.abs(p21[q,k,y,j,i]) <= np.abs(Tref/2)):
								#if (np.abs(p21[q,k,y,j,i]) <= np.abs(Tref/2)) and ((Tref + p21[q,k,y,j,i]) > np.abs(Tref/2)):





									# Rejection significance
									significance = ((Tref - p21[q,k,y,j,i])/dp21[q,k,y,j,i])

									# Accept model only if more strongly rejected than previous one
									if (significance > significance_map[j,i]):
										significance_map[j,i] = significance
										p21_map[j,i]          = p21[q,k,y,j,i]
										dp21_map[j,i]         = dp21[q,k,y,j,i]


										win_width[j,i]  = q #Dv[q]
										fg_terms[j,i]   = k #Nfg[k]
										win_center[j,i] = y



									## Accept model only if more strongly rejected than previous one
									#if (dp21[q,k,y,j,i] < dp21_map[j,i]) and (np.abs(p21[q,k,y,j,i]) <= 2*dp21[q,k,y,j,i]):
										#significance_map[j,i] = significance
										#p21_map[j,i]          = p21[q,k,y,j,i]
										#dp21_map[j,i]         = dp21[q,k,y,j,i]										



							# For negative reference temperature			
							if Tref < 0:

								# Rejection conditions
								if (np.abs(p21[q,k,y,j,i]) <= np.abs(Tref/2)) and (np.abs(p21[q,k,y,j,i]/dp21[q,k,y,j,i]) <= CCZ) and ((Tref + p21[q,k,y,j,i]) < -CCZ*dp21[q,k,y,j,i]):

									# Rejection significance
									significance = ((p21[q,k,y,j,i] - Tref)/dp21[q,k,y,j,i])

									# Accept model only if more strongly rejected than previous one
									if (significance > significance_map[j,i]):           # and (signi > -(p21[q,k,y,j,i]/dp21[q,k,y,j,i])):
										significance_map[j,i] = significance
										p21_map[j,i]          = p21[q,k,y,j,i]
										dp21_map[j,i]         = dp21[q,k,y,j,i]



	# 1 and 2-sigma significance line
	for j in range(len_zr):
		flag1 = 0
		flag2 = 0
		for i in range(len_dz-1):
			if (significance_map[j,i] >= 1) and (significance_map[j,i+1] < 1) and (flag1 == 0):
				limit_1sigma[j] = dz[i]
				flag1 = 1

			if (significance_map[j,i] >= 2) and (significance_map[j,i+1] < 2) and (flag2 == 0):
				limit_2sigma[j] = dz[i]
				flag2 = 1


	# Save as HDF5
	if save == 'yes':

		path_save = home_folder + '/DATA/EDGES/results/' + band + '/products/model_rejection/least_squares_sliding_window/' + folder + '/'
		if Tref > 0:
			name_Tref = '_p' + str(np.abs(Tref))
		if Tref < 0:
			name_Tref = '_m' + str(np.abs(Tref))


		save_file = path_save + 'limits/limits_' + HDF5_filename + name_Tref + '.hdf5'
		with h5py.File(save_file, 'w') as hf:
			hf.create_dataset('Tref',             data = Tref)
			hf.create_dataset('zr',               data = zr)
			hf.create_dataset('dz',               data = dz)
			hf.create_dataset('significance_map', data = significance_map)
			hf.create_dataset('p21_map',          data = p21_map)
			hf.create_dataset('dp21_map',         data = dp21_map)
			hf.create_dataset('limit_1sigma',     data = limit_1sigma)
			hf.create_dataset('limit_2sigma',     data = limit_2sigma)			


	return Tref, zr, dz, significance_map, p21_map, dp21_map, limit_1sigma, limit_2sigma, win_width, fg_terms, win_center












def read_least_squares_limits(band, folder, filename):

	path = home_folder + '/DATA/EDGES/results/' + band + '/products/model_rejection/least_squares_sliding_window/' + folder + '/'
	with h5py.File(path + filename,'r') as hf:

		hf_Tref = hf.get('Tref')
		Tref    = np.array(hf_Tref)

		hf_zr   = hf.get('zr')
		zr      = np.array(hf_zr)

		hf_dz   = hf.get('dz')
		dz      = np.array(hf_dz)

		hf_sm   = hf.get('significance_map')
		sm      = np.array(hf_sm)

		hf_p21  = hf.get('p21_map')
		p21     = np.array(hf_p21)

		hf_dp21 = hf.get('dp21_map')
		dp21    = np.array(hf_dp21)

		hf_1s   = hf.get('limit_1sigma')
		lim1s   = np.array(hf_1s)

		hf_2s   = hf.get('limit_2sigma')
		lim2s   = np.array(hf_2s)

	return Tref, zr, dz, sm, p21, dp21, lim1s, lim2s














def data_analysis_cold_EoR_least_squares():

	"""
	April 27, 2017

	"""

	# Average spectrum
	f, t, w, d, at, ah, rc, rm  = level3_read(home_folder + '/DATA/EDGES/spectra/level3/high_band_2015/results_paper_1/high_band_2015_LST_0.26_6.26_dates_2015_250_299_nominal.hdf5')
	avt, avw   = spectral_averaging(t, w)
	fb, tb, wb = data_analysis_spectrum_high_to_low_resolution(f, avt, avw, flow=89, fhigh=191, fnorm=140, pre_rfi_flagging='yes', post_rfi_flagging='yes')
	tb[wb==0]  = 0

	# Parameter estimation
	model_21 = 'jordan'
	model_fg = 'EDGES_polynomial'
	Nfg      = 5

	xi_min    = 0.0  # All values !!!    0.99 means xhi=1%   
	tau_e_min = 0.01 # This range encloses all values!!
	tau_e_max = 0.3  # 

	#N = 5114 # Number of models
	N = 32000 # All models !!!!
	xi_all    = np.zeros((N,len(fb)))
	model_all = np.zeros((N,len(fb)))
	te_all    = np.zeros(N)
	z0_all    = np.zeros(N)
	dz_all    = np.zeros(N)
	zC_all    = np.zeros(N)
	TC_all    = np.zeros(N)
	p21_all   = np.zeros(N)
	dp21_all  = np.zeros(N)

	for i in range(N):
		print(i)
		p21, dp21, aux = data_analysis_model_detection_rejection(fb, tb, wb, model_21, model_fg=model_fg, Nfg=Nfg, jordan_model_number=7090+i, xi_min=xi_min, tau_e_min=tau_e_min, tau_e_max=tau_e_max)

		xi_all[i,:]    = aux[0]
		model_all[i,:] = aux[1]
		te_all[i]      = aux[2]
		z0_all[i]      = aux[3]
		dz_all[i]      = aux[4]
		zC_all[i]      = aux[5]
		TC_all[i]      = aux[6]
		p21_all[i]     = p21
		dp21_all[i]    = dp21		




	# Save as HDF5
	save_file = home_folder + '/DATA/EDGES/results/high_band/products/model_rejection/least_squares_cold_EoR/results_cold_EoR_all_models_20170427.hdf5'

	with h5py.File(save_file, 'w') as hf:
		hf.create_dataset('fb',     data = fb)
		hf.create_dataset('xi_all',     data = xi_all)
		hf.create_dataset('model_all',  data = model_all)
		hf.create_dataset('te_all',     data = te_all)
		hf.create_dataset('z0_all',     data = z0_all)
		hf.create_dataset('dz_all',     data = dz_all)
		hf.create_dataset('zC_all',     data = zC_all)
		hf.create_dataset('TC_all',     data = TC_all)
		hf.create_dataset('p21_all',    data = p21_all)
		hf.create_dataset('dp21_all',   data = dp21_all)


	return fb, xi_all, model_all, te_all, z0_all, dz_all, zC_all, TC_all, p21_all, dp21_all










def read_cold_EoR_least_squares(filename):

	path = home_folder + '/DATA/EDGES/results/high_band/products/model_rejection/least_squares_cold_EoR/'
	with h5py.File(path + filename,'r') as hf:

		hf_fb     = hf.get('fb')
		fb        = np.array(hf_fb)

		hf_xi     = hf.get('xi_all')
		xi        = np.array(hf_xi)

		hf_model  = hf.get('model_all')
		model     = np.array(hf_model)

		hf_te     = hf.get('te_all')
		te        = np.array(hf_te)

		hf_z0     = hf.get('z0_all')
		z0        = np.array(hf_z0)

		hf_dz     = hf.get('dz_all')
		dz        = np.array(hf_dz)

		hf_zC     = hf.get('zC_all')
		zC        = np.array(hf_zC)

		hf_TC     = hf.get('TC_all')
		TC        = np.array(hf_TC)

		hf_p21    = hf.get('p21_all')
		p21       = np.array(hf_p21)

		hf_dp21   = hf.get('dp21_all')
		dp21      = np.array(hf_dp21)


	return fb, xi, model, te, z0, dz, zC, TC, p21, dp21




















def data_analysis_LF_models_least_squares():

	"""
	May 3, 2017

	"""

	# Average spectrum
	f, t, w, d, at, ah, rc, rm  = level3_read(home_folder + '/DATA/EDGES/spectra/level3/high_band_2015/results_paper_1/high_band_2015_LST_0.26_6.26_dates_2015_250_299_nominal.hdf5')
	avt, avw   = spectral_averaging(t, w)
	fb, tb, wb = data_analysis_spectrum_high_to_low_resolution(f, avt, avw, flow=89, fhigh=191, fnorm=140, pre_rfi_flagging='yes', post_rfi_flagging='yes')
	tb[wb==0]  = 0



	# Parameter estimation
	model_21 = 'jordan'
	model_fg = 'EDGES_polynomial'
	Nfg      = 5



	N = 6698 # All models !!!!

	#ao = (Tsnew, xinew, mnew/1000, TC[model_number-(33+358)]/1000, zC[model_number-(33+358)], Tmin[model_number-(33+358)], gamma_z[model_number-(33+358)], Z[model_number-(33+358)],
	#      cx[model_number-(33+358)], Bx[model_number-(33+358)], N[model_number-(33+358)], LW[model_number-(33+358)], LC[model_number-(33+358)])	

	Ts_all      = np.zeros((N,len(fb)))
	xi_all      = np.zeros((N,len(fb)))
	model_all   = np.zeros((N,len(fb)))

	TC_all      = np.zeros(N)
	zC_all      = np.zeros(N)
	vC_all      = np.zeros(N)

	TD_all      = np.zeros(N)
	zD_all      = np.zeros(N)
	vD_all      = np.zeros(N)

	dz_all      = np.zeros(N)
	dv_all      = np.zeros(N)

	Tmin_all    = np.zeros(N)
	gamma_z_all = np.zeros(N)
	Z_all       = np.zeros(N)
	cx_all      = np.zeros(N)
	Bx_all      = np.zeros(N)
	N_all       = np.zeros(N)
	LW_all      = np.zeros(N)
	LC_all      = np.zeros(N)

	p21_all     = np.zeros(N)
	dp21_all    = np.zeros(N)	



	for i in range(N):
		print(i)
		p21, dp21, aux = data_analysis_model_detection_rejection(fb, tb, wb, model_21, model_fg=model_fg, Nfg=Nfg, jordan_model_number=391+i)

		Ts_all[i,:]    = aux[0]	
		xi_all[i,:]    = aux[1]
		model_all[i,:] = aux[2]

		TC_all[i]      = aux[3]
		zC_all[i]      = aux[4]
		vC_all[i]      = aux[5]

		TD_all[i]      = aux[6]
		zD_all[i]      = aux[7]	
		vD_all[i]      = aux[8]

		dz_all[i]      = aux[9]
		dv_all[i]      = aux[10]

		Tmin_all[i]    = aux[11]
		gamma_z_all[i] = aux[12]
		Z_all[i]       = aux[13]
		cx_all[i]      = aux[14]
		Bx_all[i]      = aux[15]
		N_all[i]       = aux[16]
		LW_all[i]      = aux[17]
		LC_all[i]      = aux[18]		

		p21_all[i]     = p21
		dp21_all[i]    = dp21



	# Save as HDF5
	save_file = home_folder + '/DATA/EDGES/results/high_band/products/model_rejection/least_squares_LF/results_LF_all_models_20170503.hdf5'

	with h5py.File(save_file, 'w') as hf:
		hf.create_dataset('fb',     data = fb)

		hf.create_dataset('Ts_all',     data = Ts_all)
		hf.create_dataset('xi_all',     data = xi_all)
		hf.create_dataset('model_all',  data = model_all)

		hf.create_dataset('TC_all',     data = TC_all)
		hf.create_dataset('zC_all',     data = zC_all)
		hf.create_dataset('vC_all',     data = vC_all)

		hf.create_dataset('TD_all',     data = TD_all)
		hf.create_dataset('zD_all',     data = zD_all)
		hf.create_dataset('vD_all',     data = vD_all)

		hf.create_dataset('dz_all',     data = dz_all)
		hf.create_dataset('dv_all',     data = dv_all)

		hf.create_dataset('Tmin_all',     data = Tmin_all)
		hf.create_dataset('gamma_z_all',  data = gamma_z_all)
		hf.create_dataset('Z_all',        data = Z_all)
		hf.create_dataset('cx_all',       data = cx_all)
		hf.create_dataset('Bx_all',       data = Bx_all)
		hf.create_dataset('N_all',        data = N_all)
		hf.create_dataset('LW_all',       data = LW_all)
		hf.create_dataset('LC_all',       data = LC_all)

		hf.create_dataset('p21_all',    data = p21_all)
		hf.create_dataset('dp21_all',   data = dp21_all)


	return fb, Ts_all, xi_all, model_all, TC_all, zC_all, vC_all, TD_all, zD_all, vD_all, dz_all, dv_all, Tmin_all, gamma_z_all, Z_all, cx_all, Bx_all, N_all, LW_all, LC_all, p21_all, dp21_all



















def read_LF_least_squares(filename):

	"""
	Created 2017-05-03

	"""



	path = home_folder + '/DATA/EDGES/results/high_band/products/model_rejection/least_squares_LF/'
	with h5py.File(path + filename,'r') as hf:

		hf_fb     = hf.get('fb')
		fb        = np.array(hf_fb)



		hf_Ts     = hf.get('Ts_all')
		Ts        = np.array(hf_Ts)

		hf_xi     = hf.get('xi_all')
		xi        = np.array(hf_xi)

		hf_model  = hf.get('model_all')
		model     = np.array(hf_model)



		hf_TC     = hf.get('TC_all')
		TC        = np.array(hf_TC)

		hf_zC     = hf.get('zC_all')
		zC        = np.array(hf_zC)

		hf_vC     = hf.get('vC_all')
		vC        = np.array(hf_vC)



		hf_TD     = hf.get('TD_all')
		TD        = np.array(hf_TD)

		hf_zD     = hf.get('zD_all')
		zD        = np.array(hf_zD)

		hf_vD     = hf.get('vD_all')
		vD        = np.array(hf_vD)



		hf_dz     = hf.get('dz_all')
		dz        = np.array(hf_dz)

		hf_dv     = hf.get('dv_all')
		dv        = np.array(hf_dv)




		hf_Tmin    = hf.get('Tmin_all')
		Tmin       = np.array(hf_Tmin)

		hf_gamma_z    = hf.get('gamma_z_all')
		gamma_z       = np.array(hf_gamma_z)

		hf_Z     = hf.get('Z_all')
		Z        = np.array(hf_Z)

		hf_cx    = hf.get('cx_all')
		cx       = np.array(hf_cx)

		hf_Bx    = hf.get('Bx_all')
		Bx       = np.array(hf_Bx)

		hf_N     = hf.get('N_all')
		N        = np.array(hf_N)

		hf_LW    = hf.get('LW_all')
		LW       = np.array(hf_LW)

		hf_LC    = hf.get('LC_all')
		LC       = np.array(hf_LC)




		hf_p21    = hf.get('p21_all')
		p21       = np.array(hf_p21)

		hf_dp21   = hf.get('dp21_all')
		dp21      = np.array(hf_dp21)


	return fb, Ts, xi, model, TC, zC, vC, TD, zD, vD, dz, dv, Tmin, gamma_z, Z, cx, Bx, N, LW, LC, p21, dp21














def data_analysis_anastasia_least_squares():

	"""
	May 09, 2017

	"""

	# Average spectrum
	f, t, w, d, at, ah, rc, rm  = level3_read(home_folder + '/DATA/EDGES/spectra/level3/high_band_2015/results_paper_1/high_band_2015_LST_0.26_6.26_dates_2015_250_299_nominal.hdf5')
	avt, avw   = spectral_averaging(t, w)
	fb, tb, wb = data_analysis_spectrum_high_to_low_resolution(f, avt, avw, flow=89, fhigh=191, fnorm=140, pre_rfi_flagging='yes', post_rfi_flagging='yes')
	tb[wb==0]  = 0

	# Parameter estimation
	model_21 = 'anastasia'
	model_fg = 'EDGES_polynomial'
	Nfg      = 5

	N = 286 # All models !!!!
	model_all = np.zeros((N,len(fb)))
	p21_all   = np.zeros(N)
	dp21_all  = np.zeros(N)

	for i in range(N):
		print(i)
		p21, dp21, aux = data_analysis_model_detection_rejection(fb, tb, wb, model_21, model_fg=model_fg, Nfg=Nfg, anastasia_model_number=i)

		model_all[i,:] = aux[0]	
		p21_all[i]     = p21
		dp21_all[i]    = dp21		




	# Save as HDF5
	save_file = home_folder + '/DATA/EDGES/results/high_band/products/model_rejection/least_squares_anastasia/results_anastasia_all_models_20170509.hdf5'

	with h5py.File(save_file, 'w') as hf:
		hf.create_dataset('fb',         data = fb)
		hf.create_dataset('model_all',  data = model_all)
		hf.create_dataset('p21_all',    data = p21_all)
		hf.create_dataset('dp21_all',   data = dp21_all)


	return fb, model_all, p21_all, dp21_all













def read_anastasia_least_squares(filename):

	"""
	Created 2017-05-09

	"""

	path = home_folder + '/DATA/EDGES/results/high_band/products/model_rejection/least_squares_anastasia/'
	with h5py.File(path + filename,'r') as hf:

		hf_fb     = hf.get('fb')
		fb        = np.array(hf_fb)

		hf_model  = hf.get('model_all')
		model     = np.array(hf_model)

		hf_p21    = hf.get('p21_all')
		p21       = np.array(hf_p21)

		hf_dp21   = hf.get('dp21_all')
		dp21      = np.array(hf_dp21)

	return fb, model, p21, dp21






















































def model_eor_flattened_gaussian(v, model_type=1, T21=1, vr=75, dv=20, tau0=4, tilt=0):

	# Memo 220 and 226
	if model_type == 1:
		b  = -np.log(-np.log( (1 + np.exp(-tau0))/2 )/tau0)
		K1 = T21 * (1 - np.exp( -tau0 * np.exp( (-b*(v-vr)**2) / ((dv**2)/4))))
		K2 = 1 + (tilt * (v - vr) / dv)
		K3 = 1 - np.exp(-tau0)
		T  = K1 * K2 / K3

	# Memo 226
	if model_type == 2:
		K1 = np.tanh( (1/(v + dv/2) - 1/vr) / (dv/(tau0*(vr**2))) )
		K2 = np.tanh( (1/(v - dv/2) - 1/vr) / (dv/(tau0*(vr**2))) )
		T = -(T21/2) * (K1 - K2) 

	return T   # The amplitude is equal to T21, not to -T21









def plot_least_squares_map_limits(significance_map, error_bar_map, filename, extent=[14.8, 6.5, 0, 2], ylim=[0,1.5], yticks=np.arange(0, 1.5, 0.5), text_coordinates=[14.7, 1.25], sigma_cbarticks=np.arange(0, 29, 4)):

	# Assigning NaNs to zeros in map		
	for j in range(len(significance_map[:,0])):
		for i in range(len(significance_map[0,:])):
			if (significance_map[j,i] < 1):
				error_bar_map[j,i] = np.nan


	# Figure
	plt.close()
	plt.close()



	# Creating panels
	size_x = 9.0
	size_y = 7.0
	x0     = 0.18
	y0     = 0.02
	dx     = 0.78
	dy     = 0.3
	x00    = 0.02
	y00    = 0.04
	dxcb   = 0.02

	f1     = plt.figure(num=1, figsize=(size_x, size_y))

	ax1    = f1.add_axes([1*x0, 2*y0 + 1*dy, dx, dy])
	plt.text(text_coordinates[0], text_coordinates[1], '(a)', fontsize=18)	
	cax1   = f1.add_axes([1*x0+1*dx+1*x00, 1*y0 + 1*dy + 1.25*y00, dxcb, 0.8*dy])

	ax2    = f1.add_axes([1*x0, 1*y0 + 0*dy, dx, dy])
	plt.text(text_coordinates[0], text_coordinates[1], '(b)', fontsize=18)
	cax2   = f1.add_axes([1*x0+1*dx+1*x00, 1*y0 + 0.7*y00, dxcb, 0.8*dy])




	# Top panel (Rejection significance)
	# ----------------------------------
	# Custom colormap
	cmap        = plt.cm.jet
	cmaplist    = [cmap(i) for i in range(cmap.N)]
	cmaplist2   = 30*[(1,1,1,1.0)] + cmaplist
	cmap        = cmap.from_list('Custom cmap', cmaplist2, cmap.N)		
	bounds      = np.arange(0,11,1)      # Boundary of significance levels
	norm        = colors.BoundaryNorm(boundaries=bounds, ncolors=cmap.N)

	# Actual map
	im          = ax1.imshow(significance_map, interpolation='none', aspect='auto', extent=extent, cmap=cmap, norm=norm)
	ax1.set_xticklabels([])
	ax1.set_yticks(yticks)
	ax1.set_ylim(ylim)
	ax1.grid()
	ax1.set_ylabel(r'$\Delta z$', fontsize=20)

	# Colorbar
	cbar        = plt.colorbar(im, cax=cax1, ticks=np.arange(1.5, 10, 1), boundaries=bounds[1::])	# 9 significance levels
	cbar.ax.set_yticklabels([1,2,3,4,5,6,7,8,9])   # Tick labels on colorbar
	cbar.ax.set_ylabel(r'rejection significance [$\hat{\sigma}_{21}$]', fontsize=10)  # Ylabel	  

	# Top axis (frequency)
	ax12 = ax1.twiny()
	ax12.set_xlabel('frequency [MHz]',fontsize=12)
	z0 = frequency2redshift(90)
	ax12.set_xticks(np.array((np.abs(frequency2redshift(90)-z0), np.abs(frequency2redshift(110)-z0), np.abs(frequency2redshift(130)-z0), np.abs(frequency2redshift(150)-z0), np.abs(frequency2redshift(170)-z0), np.abs(frequency2redshift(190)-z0))))
	ax12.set_xticklabels(['90', '110', '130', '150', '170', '190'])



	# Bottom panel (Errorbar size)
	# ----------------------------
	im          = ax2.imshow(1000*error_bar_map, interpolation='none', aspect='auto', extent=extent, cmap = plt.cm.jet_r, vmin=sigma_cbarticks[0], vmax=sigma_cbarticks[-1])
	ax2.set_yticks(yticks)
	ax2.set_ylim(ylim)
	ax2.grid()
	ax2.set_xlabel(r'$z_r$', fontsize=20)
	ax2.set_ylabel(r'$\Delta z$', fontsize=20)	

	cbar        = plt.colorbar(im, cax=cax2, ticks=sigma_cbarticks)
	cbar.ax.set_ylabel(r'$\hat{\sigma}_{21}$ [mK]')




	## Save
	## ----
	#path_plot_save = home_folder + '/DATA/EDGES/results/plots/20170506/'
	#plt.savefig(path_plot_save + filename + '.pdf', bbox_inches='tight')
	#plt.close()
	#plt.close()


	return 0













def EoR_duration_spt2edges():

	zr_ref = 10
	dz     = np.arange(0.2,4.01,0.01)
	z      = np.arange(1,15.001,0.001)

	for k in range(len(dz)):
		tb, xhi, kk = model_eor(redshift2frequency(z), zr=zr_ref, dz=dz[k])
		xi = (1-xhi)

		for j in range(len(z)-1):
			if (xi[j] >= 0.99) and (xi[j+1] < 0.99):
				z99 = z[j]

			if (xi[j] >= 0.2) and (xi[j+1] < 0.2):
				z20 = z[j]

		diff = z20 - z99
		print('xi_20 - xi_99: ' + str(diff) + ', xi_27 - xi_73: ' + str(dz[k]))

	return 0










def EDGES_2017_EoR_rejection_results():

	"""
	May 20, 2017

	"""

	dd = read_least_squares_limits('high_band', 'results_paper_1/limits', 'limits_rejection_results_tanh_nominal_p0.028.hdf5')

	z  = dd[1]
	s1 = dd[-2]  # EDGES_2017_1sigma
	s2 = dd[-1]  # EDGES_2017_2sigma

	outT = np.array([z, s1, s2])
	out = outT.T

	np.savetxt(home_folder + '/DATA/EDGES/results/high_band/products/model_rejection/rejection_limits/tanh_EoR_limits_20170520.txt', out)

	return 0





























def low_band1_s11_calibration_measurements_2017_05_25C(flow, fhigh, save='no', flag=''):


	# Data paths
	main_path    = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band1/2017_05_25C/data/s11/raw/'

	path_LNA     = main_path + 'Receiver_after_antsim2/'
	#path_LNA     = main_path + 'Receiver_after_ambient_may_26_4pos_switch_at_0V/'
	path_ambient = main_path + 'Ambient_2nd_time/'
	path_hot     = main_path + 'Hot_Load/'
	path_open    = main_path + 'Open_Cable/'
	path_shorted = main_path + 'Short_cable/'
	path_sim1    = main_path + 'AntSim1/'
	path_sim2    = main_path + 'AntSim2_rdo/'



	# ------- Receiver S11 ------------------------

	# Reading measurements
	o,   fr0  = rc.s1p_read(path_LNA + 'Open1.s1p')
	s,   fr0  = rc.s1p_read(path_LNA + 'Short1.s1p')
	l,   fr0  = rc.s1p_read(path_LNA + 'Match1.s1p')
	LNA0, fr0 = rc.s1p_read(path_LNA + 'Receiver_1m.s1p')

	#o,   fr0  = rc.s1p_read(path_LNA + 'Open.s1p')
	#s,   fr0  = rc.s1p_read(path_LNA + 'Short.s1p')
	#l,   fr0  = rc.s1p_read(path_LNA + 'Match.s1p')
	#LNA0, fr0 = rc.s1p_read(path_LNA + 'Receiver.s1p')	


	# Models of standards
	resistance_of_match = 49.97 # female
	md = 1
	oa, sa, la = rc.agilent_85033E(fr0, resistance_of_match, md)

	# Correction of measurements
	LNAc, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA0)

	LNA = LNAc[(fr0/1e6>=flow) & (fr0/1e6<=fhigh)]   # Choosing LNA measurement (best is LNA2c, at 25degC)
	fr  = fr0[(fr0/1e6>=flow) & (fr0/1e6<=fhigh)]






	# Calibration loads
	# ---------------------------------------------------------------------------------------------------


	# Ambient load before
	# -------------------
	o_m,  f_a1 = rc.s1p_read(path_ambient + 'Open01.s1p')
	s_m,  f_a1 = rc.s1p_read(path_ambient + 'Short01.s1p')
	l_m,  f_a1 = rc.s1p_read(path_ambient + 'Match01.s1p')
	a1_m, f_a1 = rc.s1p_read(path_ambient + 'External01.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_a1))
	s_sw = -1 * np.ones(len(f_a1))
	l_sw =  0 * np.ones(len(f_a1))


	# Correction at switch
	a1_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, a1_m)


	# Correction at receiver input
	#a1_cc = low_band1_switch_correction_2017_05_25C(a1_sw_c, f_in = f_a1, verification = 'no')
	#a1_c  = a1_cc[0]

	temp_switch = 27.16
	a1_cc = low_band_switch_correction(a1_sw_c, temp_switch, f_in = f_a1)
	a1_c  = a1_cc[0]


	a1  = a1_c[(f_a1/1e6>=flow) & (f_a1/1e6<=fhigh)]
	fa1 = f_a1[(f_a1/1e6>=flow) & (f_a1/1e6<=fhigh)]







	## Ambient load after
	## -------------------
	#o_m,  f_a2 = rc.s1p_read(path_ambient + 'Open2.s1p')
	#s_m,  f_a2 = rc.s1p_read(path_ambient + 'Short2.s1p')
	#l_m,  f_a2 = rc.s1p_read(path_ambient + 'Match2.s1p')
	#a2_m, f_a2 = rc.s1p_read(path_ambient + 'External2.s1p')


	## Standards assumed at the switch
	#o_sw =  1 * np.ones(len(f_a2))
	#s_sw = -1 * np.ones(len(f_a2))
	#l_sw =  0 * np.ones(len(f_a2))


	## Correction at switch
	#a2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, a2_m)


	## Correction at receiver input
	#a2_cc = low_band1_switch_correction_2017_05_25C(a2_sw_c, f_in = f_a2, verification = 'no')
	#a2_c  = a2_cc[0]

	#a2  = a2_c[(f_a2/1e6>=flow) & (f_a2/1e6<=fhigh)]
	#fa2 = f_a2[(f_a2/1e6>=flow) & (f_a2/1e6<=fhigh)]










	# Hot load before
	# -------------------
	o_m,  f_h1 = rc.s1p_read(path_hot + 'Open1.s1p')
	s_m,  f_h1 = rc.s1p_read(path_hot + 'Short1.s1p')
	l_m,  f_h1 = rc.s1p_read(path_hot + 'Match1.s1p')
	h1_m, f_h1 = rc.s1p_read(path_hot + 'External1.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_h1))
	s_sw = -1 * np.ones(len(f_h1))
	l_sw =  0 * np.ones(len(f_h1))


	# Correction at switch
	h1_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, h1_m)


	# Correction at receiver input
	#h1_cc = low_band1_switch_correction_2017_05_25C(h1_sw_c, f_in = f_h1, verification = 'no')
	#h1_c  = h1_cc[0]

	temp_switch = 27.16
	h1_cc = low_band_switch_correction(h1_sw_c, temp_switch, f_in = f_h1)	
	h1_c  = h1_cc[0]


	h1  = h1_c[(f_h1/1e6>=flow) & (f_h1/1e6<=fhigh)]
	fh1 = f_h1[(f_h1/1e6>=flow) & (f_h1/1e6<=fhigh)]






	# Hot load after
	# -------------------
	o_m,  f_h2 = rc.s1p_read(path_hot + 'Open2.s1p')
	s_m,  f_h2 = rc.s1p_read(path_hot + 'Short2.s1p')
	l_m,  f_h2 = rc.s1p_read(path_hot + 'Match2.s1p')
	h2_m, f_h2 = rc.s1p_read(path_hot + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_h2))
	s_sw = -1 * np.ones(len(f_h2))
	l_sw =  0 * np.ones(len(f_h2))


	# Correction at switch
	h2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, h2_m)


	# Correction at receiver input
	#h2_cc = low_band1_switch_correction_2017_05_25C(h2_sw_c, f_in = f_h2, verification = 'no')
	#h2_c  = h2_cc[0]

	temp_switch = 27.16
	h2_cc = low_band_switch_correction(h2_sw_c, temp_switch, f_in = f_h2)	
	h2_c  = h2_cc[0]


	h2  = h2_c[(f_h2/1e6>=flow) & (f_h2/1e6<=fhigh)]
	fh2 = f_h2[(f_h2/1e6>=flow) & (f_h2/1e6<=fhigh)]












	# Open Cable before
	# -------------------
	o_m,  f_o1 = rc.s1p_read(path_open + 'Open1.s1p')
	s_m,  f_o1 = rc.s1p_read(path_open + 'Short1.s1p')
	l_m,  f_o1 = rc.s1p_read(path_open + 'Match1.s1p')
	o1_m, f_o1 = rc.s1p_read(path_open + 'External1.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_o1))
	s_sw = -1 * np.ones(len(f_o1))
	l_sw =  0 * np.ones(len(f_o1))


	# Correction at switch
	o1_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, o1_m)


	# Correction at receiver input
	#o1_cc = low_band1_switch_correction_2017_05_25C(o1_sw_c, f_in = f_o1, verification = 'no')
	#o1_c  = o1_cc[0]

	temp_switch = 27.16
	o1_cc = low_band_switch_correction(o1_sw_c, temp_switch, f_in = f_o1)	
	o1_c  = o1_cc[0]


	o1  = o1_c[(f_o1/1e6>=flow) & (f_o1/1e6<=fhigh)]
	fo1 = f_o1[(f_o1/1e6>=flow) & (f_o1/1e6<=fhigh)]






	# Open Cable after
	# -------------------
	o_m,  f_o2 = rc.s1p_read(path_open + 'Open2.s1p')
	s_m,  f_o2 = rc.s1p_read(path_open + 'Short2.s1p')
	l_m,  f_o2 = rc.s1p_read(path_open + 'Match2.s1p')
	o2_m, f_o2 = rc.s1p_read(path_open + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_o2))
	s_sw = -1 * np.ones(len(f_o2))
	l_sw =  0 * np.ones(len(f_o2))


	# Correction at switch
	o2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, o2_m)


	# Correction at receiver input
	#o2_cc = low_band1_switch_correction_2017_05_25C(o2_sw_c, f_in = f_o2, verification = 'no')
	#o2_c  = o2_cc[0]

	temp_switch = 27.16
	o2_cc = low_band_switch_correction(o2_sw_c, temp_switch, f_in = f_o2)	
	o2_c  = o2_cc[0]	

	o2  = o2_c[(f_o2/1e6>=flow) & (f_o2/1e6<=fhigh)]
	fo2 = f_o2[(f_o2/1e6>=flow) & (f_o2/1e6<=fhigh)]












	# Shorted Cable before
	# -------------------
	o_m,  f_s1 = rc.s1p_read(path_shorted + 'Open1.s1p')
	s_m,  f_s1 = rc.s1p_read(path_shorted + 'Short1.s1p')
	l_m,  f_s1 = rc.s1p_read(path_shorted + 'Match1.s1p')
	s1_m, f_s1 = rc.s1p_read(path_shorted + 'External1.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_s1))
	s_sw = -1 * np.ones(len(f_s1))
	l_sw =  0 * np.ones(len(f_s1))


	# Correction at switch
	s1_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, s1_m)


	# Correction at receiver input
	#s1_cc = low_band1_switch_correction_2017_05_25C(s1_sw_c, f_in = f_s1, verification = 'no')
	#s1_c  = s1_cc[0]

	temp_switch = 27.16
	s1_cc = low_band_switch_correction(s1_sw_c, temp_switch, f_in = f_s1)	
	s1_c  = s1_cc[0]	


	s1  = s1_c[(f_s1/1e6>=flow) & (f_s1/1e6<=fhigh)]
	fs1 = f_s1[(f_s1/1e6>=flow) & (f_s1/1e6<=fhigh)]







	# Shorted Cable after
	# -------------------
	o_m,  f_s2 = rc.s1p_read(path_shorted + 'Open2.s1p')
	s_m,  f_s2 = rc.s1p_read(path_shorted + 'Short2.s1p')
	l_m,  f_s2 = rc.s1p_read(path_shorted + 'Match2.s1p')
	s2_m, f_s2 = rc.s1p_read(path_shorted + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_s2))
	s_sw = -1 * np.ones(len(f_s2))
	l_sw =  0 * np.ones(len(f_s2))


	# Correction at switch
	s2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, s2_m)


	# Correction at receiver input
	#s2_cc = low_band1_switch_correction_2017_05_25C(s2_sw_c, f_in = f_s2, verification = 'no')
	#s2_c  = s2_cc[0]

	temp_switch = 27.16
	s2_cc = low_band_switch_correction(s2_sw_c, temp_switch, f_in = f_s2)	
	s2_c  = s2_cc[0]		


	s2  = s2_c[(f_s2/1e6>=flow) & (f_s2/1e6<=fhigh)]
	fs2 = f_s2[(f_s2/1e6>=flow) & (f_s2/1e6<=fhigh)]















	# Antenna Simulator 1 before
	# --------------------------
	o_m,  f_q11  = rc.s1p_read(path_sim1 + 'Open1.s1p')
	s_m,  f_q11  = rc.s1p_read(path_sim1 + 'Short1.s1p')
	l_m,  f_q11  = rc.s1p_read(path_sim1 + 'Match1.s1p')
	q11_m, f_q11 = rc.s1p_read(path_sim1 + 'External1.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_q11))
	s_sw = -1 * np.ones(len(f_q11))
	l_sw =  0 * np.ones(len(f_q11))


	# Correction at switch
	q11_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, q11_m)


	# Correction at receiver input
	#q11_cc = low_band1_switch_correction_2017_05_25C(q11_sw_c, f_in = f_q11, verification = 'no')
	#q11_c  = q11_cc[0]

	temp_switch = 27.16
	q11_cc = low_band_switch_correction(q11_sw_c, temp_switch, f_in = f_q11)	
	q11_c  = q11_cc[0]	


	q11  = q11_c[(f_q11/1e6>=flow) & (f_q11/1e6<=fhigh)]
	fq11 = f_q11[(f_q11/1e6>=flow) & (f_q11/1e6<=fhigh)]





	# Antenna Simulator 1 after
	# -------------------------
	o_m,  f_q12  = rc.s1p_read(path_sim1 + 'Open2.s1p')
	s_m,  f_q12  = rc.s1p_read(path_sim1 + 'Short2.s1p')
	l_m,  f_q12  = rc.s1p_read(path_sim1 + 'Match2.s1p')
	q12_m, f_q12 = rc.s1p_read(path_sim1 + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_q12))
	s_sw = -1 * np.ones(len(f_q12))
	l_sw =  0 * np.ones(len(f_q12))


	# Correction at switch
	q12_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, q12_m)


	# Correction at receiver input
	#q12_cc = low_band1_switch_correction_2017_05_25C(q12_sw_c, f_in = f_q12, verification = 'no')
	#q12_c  = q12_cc[0]

	temp_switch = 27.16
	q12_cc = low_band_switch_correction(q12_sw_c, temp_switch, f_in = f_q12)	
	q12_c  = q12_cc[0]	


	q12  = q12_c[(f_q12/1e6>=flow) & (f_q12/1e6<=fhigh)]
	fq12 = f_q12[(f_q12/1e6>=flow) & (f_q12/1e6<=fhigh)]










	# Antenna Simulator 2 before                # NOT GOOD, USE THE 'AFTER' MEASUREMENT
	# --------------------------
	o_m,  f_q21  = rc.s1p_read(path_sim2 + 'Open1.s1p')
	s_m,  f_q21  = rc.s1p_read(path_sim2 + 'Short1.s1p')
	l_m,  f_q21  = rc.s1p_read(path_sim2 + 'Match1.s1p')
	q21_m, f_q21 = rc.s1p_read(path_sim2 + 'External1.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_q21))
	s_sw = -1 * np.ones(len(f_q21))
	l_sw =  0 * np.ones(len(f_q21))


	# Correction at switch
	q21_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, q21_m)


	# Correction at receiver input
	#q21_cc = low_band1_switch_correction_2017_05_25C(q21_sw_c, f_in = f_q21, verification = 'no')
	#q21_c  = q21_cc[0]

	temp_switch = 27.16
	q21_cc = low_band_switch_correction(q21_sw_c, temp_switch, f_in = f_q21)	
	q21_c  = q21_cc[0]		

	q21  = q21_c[(f_q21/1e6>=flow) & (f_q21/1e6<=fhigh)]
	fq21 = f_q21[(f_q21/1e6>=flow) & (f_q21/1e6<=fhigh)]








	# Antenna Simulator 2 after
	# --------------------------
	o_m,  f_q22  = rc.s1p_read(path_sim2 + 'Open2.s1p')
	s_m,  f_q22  = rc.s1p_read(path_sim2 + 'Short2.s1p')
	l_m,  f_q22  = rc.s1p_read(path_sim2 + 'Match2.s1p')
	q22_m, f_q22 = rc.s1p_read(path_sim2 + 'External2.s1p')


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_q22))
	s_sw = -1 * np.ones(len(f_q22))
	l_sw =  0 * np.ones(len(f_q22))


	# Correction at switch
	q22_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, q22_m)


	# Correction at receiver input
	#q22_cc = low_band1_switch_correction_2017_05_25C(q22_sw_c, f_in = f_q22, verification = 'no')
	#q22_c  = q22_cc[0]

	temp_switch = 27.16
	q22_cc = low_band_switch_correction(q22_sw_c, temp_switch, f_in = f_q22)	
	q22_c  = q22_cc[0]	


	q22  = q22_c[(f_q22/1e6>=flow) & (f_q22/1e6<=fhigh)]
	fq22 = f_q22[(f_q22/1e6>=flow) & (f_q22/1e6<=fhigh)]




	# Saving
	# ---------------------------------------------
	if save == 'yes':

		# Loading S-parameters of semi-rigid cable (they are at 1 MHz)
		# --------------------------------------------------------------
		spar0      = np.genfromtxt(home_folder + '/DATA/EDGES/calibration/receiver_calibration/high_band1/2015_03_25C/data/S11/corrected_delay/semi_rigid_s_parameters.txt')
		f_sr0      = spar0[:, 0]
		spar       = spar0[(f_sr0>=flow) & (f_sr0<=fhigh), :]

		xf_sr       = spar[:, 0]
		xs11_srr    = spar[:, 1]
		xs11_sri    = spar[:, 2]
		xs12s21_srr = spar[:, 3]
		xs12s21_sri = spar[:, 4]
		xs22_srr    = spar[:, 5]
		xs22_sri    = spar[:, 6]

		# Best fit is with 5 terms over 40-120 MHz
		pp = np.polyfit(xf_sr, xs11_srr, 4);     s11r    = np.polyval(pp, fr/1e6)
		pp = np.polyfit(xf_sr, xs11_sri, 4);     s11i    = np.polyval(pp, fr/1e6)
		pp = np.polyfit(xf_sr, xs12s21_srr, 4);  s12s21r = np.polyval(pp, fr/1e6)
		pp = np.polyfit(xf_sr, xs12s21_sri, 4);  s12s21i = np.polyval(pp, fr/1e6)
		pp = np.polyfit(xf_sr, xs22_srr, 4);     s22r    = np.polyval(pp, fr/1e6)
		pp = np.polyfit(xf_sr, xs22_sri, 4);     s22i    = np.polyval(pp, fr/1e6)

		# Now, saving data
		temp = np.array([ fr/1e6, 
		                  np.real(LNA),  np.imag(LNA),
		                  np.real(a1),   np.imag(a1),   np.real(h2),    np.imag(h2),
		                  np.real(o2),   np.imag(o2),   np.real(s2),    np.imag(s2),
		                  s11r,          s11i,          s12s21r,        s12s21i,        s22r,         s22i,
		                  np.real(q12),  np.imag(q12),  np.real(q22),   np.imag(q22) ])





		output_file     = temp.T
		save_path       = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band1/2017_05_25C/data/s11/corrected/'
		temperature_LNA = '25degC'
		output_file_str = save_path + 's11_calibration_low_band_LNA' + temperature_LNA + '_' + tt.strftime('%Y-%m-%d-%H-%M-%S') + flag + '.txt'

		header = 'freq [MHz]\tre(receiver)\tim(receiver)\tre(amb)\tim(amb)\tre(hot)\tim(hot)\tre(open)\tim(open)\tre(shorted)\tim(shorted)\tre(semirigid_s11)\tim(semirigid_s11)\tre(semirigid_s12s21)\tim(semirigid_s12s21)\tre(semirigid_s22)\tim(semirigid_s22)\tre(antsim1)\tim(antsim1)\tre(antsim2)\tim(antsim2)'
		np.savetxt(output_file_str, output_file, header=header)

		print('File saved to: ' + output_file_str)



	return 0
















def low_band1_switch_correction_2017_05_25C(ant_s11, f_in = np.zeros([0,1]), verification = 'no', o_sw_0 = 1, s_sw_0 = -1, l_sw_0 = 0):  

	"""
	file based on (almost identical to) "low_band1_switch_correction_june_2016"

	"""



	# Loading measurements
	path_folder     = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band1/2017_05_25C/data/s11/raw/InternalSwitch/'

	o_sw_m, f = rc.s1p_read(path_folder + 'Int_Open1.s1p')
	s_sw_m, f = rc.s1p_read(path_folder + 'Int_Short1.s1p')
	l_sw_m, f = rc.s1p_read(path_folder + 'Int_Match1.s1p')

	o_ex,   f = rc.s1p_read(path_folder + 'Ext_Open1.s1p')
	s_ex,   f = rc.s1p_read(path_folder + 'Ext_Short1.s1p')
	l_ex,   f = rc.s1p_read(path_folder + 'Ext_Match1.s1p')

	a6,     f = rc.s1p_read(path_folder + 'Ext_6dB_1.s1p')
	a10,    f = rc.s1p_read(path_folder + 'Ext_10dB_1.s1p')




	# Standards assumed at the switch
	o_sw =  o_sw_0 * np.ones(len(f))
	s_sw =  s_sw_0 * np.ones(len(f))
	l_sw =  l_sw_0 * np.ones(len(f))	




	# Correction at the switch
	o_ex_c, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m, s_sw_m, l_sw_m, o_ex)
	s_ex_c, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m, s_sw_m, l_sw_m, s_ex)
	l_ex_c, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m, s_sw_m, l_sw_m, l_ex)




	# Computation of S-parameters to the receiver input
	resistance_of_match  = 50.11 # male
	md = 1
	oa, sa, la           = rc.agilent_85033E(f, resistance_of_match, md)
	xx, s11, s12s21, s22 = rc.de_embed(oa, sa, la, o_ex_c, s_ex_c, l_ex_c, o_ex_c)





	# Polynomial fit of S-parameters from "f" to input frequency vector "f_in"
	# ------------------------------------------------------------------------


	# Frequency normalization
	fn = f/75e6

	if len(f_in) > 10:
		if f_in[0] > 1e5:
			fn_in = f_in/75e6
		elif f_in[-1] < 300:
			fn_in = f_in/75
	else:
		fn_in = fn	



	# Real-Imaginary parts
	real_s11    = np.real(s11)
	imag_s11    = np.imag(s11)
	real_s12s21 = np.real(s12s21)
	imag_s12s21 = np.imag(s12s21)
	real_s22    = np.real(s22)
	imag_s22    = np.imag(s22)



	# Polynomial fits
	N_poly_terms = 12     # 10 is the best number over 40-120 MHz
	p = np.polyfit(fn, real_s11, N_poly_terms-1)
	fit_real_s11 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s11, N_poly_terms-1)
	fit_imag_s11 = np.polyval(p, fn_in)


	p = np.polyfit(fn, real_s12s21, N_poly_terms-1)
	fit_real_s12s21 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s12s21, N_poly_terms-1)
	fit_imag_s12s21 = np.polyval(p, fn_in)


	p = np.polyfit(fn, real_s22, N_poly_terms-1)
	fit_real_s22 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s22, N_poly_terms-1)
	fit_imag_s22 = np.polyval(p, fn_in)


	fit_s11    = fit_real_s11    + 1j*fit_imag_s11
	fit_s12s21 = fit_real_s12s21 + 1j*fit_imag_s12s21
	fit_s22    = fit_real_s22    + 1j*fit_imag_s22



	# Corrected antenna S11
	corr_ant_s11 = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, ant_s11)




	# Verification
	if verification == 'yes':

		# Correction at the switch

		# OSL
		o_x,  xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m, s_sw_m, l_sw_m, o_ex)
		s_x,  xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m, s_sw_m, l_sw_m, s_ex)
		l_x,  xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m, s_sw_m, l_sw_m, l_ex)
		o_back              = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, o_x)
		s_back              = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, s_x)
		l_back              = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, l_x)




		a6_sw,  xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m, s_sw_m, l_sw_m, a6)
		a6c  = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, a6_sw)

		a10_sw, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m, s_sw_m, l_sw_m, a10)
		a10c = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, a10_sw)




		# From DC resistance
		DC_6dB  = 85.78
		DC_10dB = 60.66 

		gamma_6dB  = np.ones(len(f)) * rc.impedance2gamma(DC_6dB, 50)
		gamma_10dB = np.ones(len(f)) * rc.impedance2gamma(DC_10dB, 50)

		gamma_6dB_plus   = np.ones(len(f)) * rc.impedance2gamma(DC_6dB+0.01, 50)
		gamma_6dB_minus  = np.ones(len(f)) * rc.impedance2gamma(DC_6dB-0.01, 50)

		gamma_10dB_plus  = np.ones(len(f)) * rc.impedance2gamma(DC_10dB+0.01, 50)
		gamma_10dB_minus = np.ones(len(f)) * rc.impedance2gamma(DC_10dB-0.01, 50)



		# Plot
		plt.close()
		plt.close()
		plt.close()
		plt.close()











		# Plot
		plt.close()
		plt.close()
		plt.close()
		plt.close()


		# Agreement between models and calibrated measurements of Keysight OSL
		plt.figure(1, figsize=[18, 10])
		plt.subplot(2,3,1)
		plt.plot(f/1e6, 20*np.log10(np.abs(o_back)))
		plt.plot(f/1e6, 20*np.log10(np.abs(oa)), 'r')
		plt.xlim([50, 100])
		plt.grid()
		plt.title('OPEN')
		plt.ylabel('magnitude [dB]')
		plt.ylim([-0.0003, 0.0003])

		plt.subplot(2,3,2)
		plt.plot(f/1e6, 20*np.log10(np.abs(s_back)))
		plt.plot(f/1e6, 20*np.log10(np.abs(sa)), 'r')
		plt.xlim([50, 100])
		plt.grid()
		plt.title('SHORT')
		plt.ylim([-0.0085, -0.0055])

		plt.subplot(2,3,3)
		plt.plot(f/1e6, 20*np.log10(np.abs(l_back)))
		plt.plot(f/1e6, 20*np.log10(np.abs(la)), 'r')
		plt.xlim([50, 100])
		plt.grid()
		plt.title('MATCH')
		plt.ylim([-57.8, -56.4])



		plt.subplot(2,3,4)
		plt.plot(f/1e6, (180/np.pi)*np.unwrap(np.angle(o_back)))
		plt.plot(f/1e6, (180/np.pi)*np.unwrap(np.angle(oa)), 'r')
		plt.xlim([50, 100])
		plt.grid()
		plt.ylabel('phase [deg]')
		plt.xlabel('frequency [MHz]')
		plt.ylim([-2.4, -1])

		plt.subplot(2,3,5)
		plt.plot(f/1e6, (180/np.pi)*np.unwrap(np.angle(s_back)))
		plt.plot(f/1e6, (180/np.pi)*np.unwrap(np.angle(sa)), 'r')
		plt.xlim([50, 100])
		plt.grid()
		plt.xlabel('frequency [MHz]')
		plt.ylim([177.6, 179])

		plt.subplot(2,3,6)
		plt.plot(f/1e6, (180/np.pi)*np.unwrap(np.angle(l_back)))
		plt.plot(f/1e6, (180/np.pi)*np.unwrap(np.angle(la)), 'r')
		plt.xlim([50, 100])
		plt.grid()
		plt.xlabel('frequency [MHz]')
		plt.ylim([6, 9.5])


		# saving plot
		path = '/DATA/EDGES/results/plots/20170801/'
		plt.savefig(home_folder + path + 'b1.pdf', bbox_inches='tight')
		plt.close()	









		plt.figure(2, figsize=[9, 8])

		plt.subplot(2,1,1)
		plt.plot(f/1e6, 20*np.log10(np.abs(a6c)))		
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB)), 'r')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB_plus)), 'r--')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB_minus)), 'r--')

		#plt.xlim([40, 200])
		#plt.ylim([-11.69,-11.66])
		plt.xlim([50, 100])
		plt.ylim([-11.6,-11.57])
		plt.grid()
		plt.legend(['at receiver input','from DC resistance', '+/- 0.01 Ohms'])
		plt.ylabel('6-dB attenuator\n magnitude [dB]')

		ax = plt.gca()
		ax.ticklabel_format(useOffset=False)		



		plt.subplot(2,1,2)
		plt.plot(f/1e6, 20*np.log10(np.abs(a10c)))
		#plt.ylim([-20.22,-20.18])
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB)), 'r')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB_plus)), 'r--')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB_minus)), 'r--')

		#plt.xlim([40, 200])
		plt.xlim([50, 100])
		plt.grid()
		plt.xlabel('frequency [MHz]')
		plt.ylabel('10-dB attenuator\n magnitude [dB]')

		ax = plt.gca()
		ax.ticklabel_format(useOffset=False)
		plt.ylim([-20.34, -20.30])


		# saving plot
		path = '/DATA/EDGES/results/plots/20170801/'
		plt.savefig(home_folder + path + 'b2.pdf', bbox_inches='tight')
		plt.close()		











		# ------- Fit quality of the S-parameters -------
		# -----------------------------------------------
		plt.figure(3, figsize=[20,12])

		plt.subplot(2,3,1)
		plt.plot(f/1e6, real_s11 - fit_real_s11)
		plt.title('S11')
		plt.grid()
		plt.ylabel(r'$\Delta$ real')
		plt.ylim([-4e-6, 4e-6])
		plt.xlim([50, 100])

		plt.subplot(2,3,4)
		plt.plot(f/1e6, imag_s11 - fit_imag_s11)
		plt.grid()
		plt.xlabel('frequency [MHz]')
		plt.ylabel(r'$\Delta$ imaginary')
		plt.ylim([-4e-6, 4e-6])
		plt.xlim([50, 100])


		plt.subplot(2,3,2)
		plt.plot(f/1e6, real_s12s21 - fit_real_s12s21)
		plt.grid()
		plt.title('S12S21')
		plt.ylim([-4e-5, 4e-5])
		plt.xlim([50, 100])

		plt.subplot(2,3,5)
		plt.plot(f/1e6, imag_s12s21 - fit_imag_s12s21)
		plt.grid()
		plt.xlabel('frequency [MHz]')
		plt.ylim([-4e-5, 4e-5])
		plt.xlim([50, 100])



		plt.subplot(2,3,3)
		plt.plot(f/1e6, real_s22 - fit_real_s22)
		plt.grid()
		plt.title('S22')
		plt.ylim([-4e-5, 4e-5])
		plt.xlim([50, 100])

		plt.subplot(2,3,6)
		plt.plot(f/1e6, imag_s22 - fit_imag_s22)
		plt.grid()
		plt.xlabel('frequency [MHz]')
		plt.ylim([-4e-5, 4e-5])
		plt.xlim([50, 100])


		# saving plot
		path = '/DATA/EDGES/results/plots/20170801/'
		plt.savefig(home_folder + path + 'b3.pdf', bbox_inches='tight')
		plt.close()	


	return (corr_ant_s11, fit_s11, fit_s12s21, fit_s22)






















def low_band1_switch_correction_2017_05_25C_airline(ant_s11, f_in = np.zeros([0,1]), verification = 'no'):  

	"""
	file based on (almost identical to) "low_band1_switch_correction_june_2016"

	"""



	# Loading measurements
	path_folder     = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band1/2017_05_25C/data/s11/raw/InternalSwitch/'

	o_sw_m, f = rc.s1p_read(path_folder + 'Int_Open1.s1p')
	s_sw_m, f = rc.s1p_read(path_folder + 'Int_Short1.s1p')
	l_sw_m, f = rc.s1p_read(path_folder + 'Int_Match1.s1p')

	#o_ex,   f = rc.s1p_read(path_folder + 'Ext_Open1.s1p')
	#s_ex,   f = rc.s1p_read(path_folder + 'Ext_Short1.s1p')
	#l_ex,   f = rc.s1p_read(path_folder + 'Ext_Match1.s1p')

	o_ex,   f = rc.s1p_read(path_folder + 'Ext_Air_Open1.s1p')
	s_ex,   f = rc.s1p_read(path_folder + 'Ext_Air_Short1.s1p')
	l_ex,   f = rc.s1p_read(path_folder + 'Ext_Air_Load2.s1p')

	a6,     f = rc.s1p_read(path_folder + 'Ext_6dB_1.s1p')
	a10,    f = rc.s1p_read(path_folder + 'Ext_10dB_1.s1p')




	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f))
	s_sw = -1 * np.ones(len(f))
	l_sw =  0 * np.ones(len(f))	




	# Correction at the switch
	o_ex_c, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m, s_sw_m, l_sw_m, o_ex)
	s_ex_c, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m, s_sw_m, l_sw_m, s_ex)
	l_ex_c, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m, s_sw_m, l_sw_m, l_ex)




	# Computation of S-parameters to the receiver input
	resistance_of_match  = 50.11 # male
	md = 1
	oar, sar, lar  = rc.agilent_85033E(f, resistance_of_match, md)
	oa             = rc.terminated_airline_8043S15(f, oar)
	sa             = rc.terminated_airline_8043S15(f, sar)
	la             = rc.terminated_airline_8043S15(f, lar)	



	xx, s11, s12s21, s22 = rc.de_embed(oa, sa, la, o_ex_c, s_ex_c, l_ex_c, o_ex_c)





	# Polynomial fit of S-parameters from "f" to input frequency vector "f_in"
	# ------------------------------------------------------------------------


	# Frequency normalization
	fn = f/75e6

	if len(f_in) > 10:
		if f_in[0] > 1e5:
			fn_in = f_in/75e6
		elif f_in[-1] < 300:
			fn_in = f_in/75
	else:
		fn_in = fn	



	# Real-Imaginary parts
	real_s11    = np.real(s11)
	imag_s11    = np.imag(s11)
	real_s12s21 = np.real(s12s21)
	imag_s12s21 = np.imag(s12s21)
	real_s22    = np.real(s22)
	imag_s22    = np.imag(s22)



	# Polynomial fits
	N_poly_terms = 10     # 10 is the best number over 40-120 MHz
	p = np.polyfit(fn, real_s11, N_poly_terms-1)
	fit_real_s11 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s11, N_poly_terms-1)
	fit_imag_s11 = np.polyval(p, fn_in)


	p = np.polyfit(fn, real_s12s21, N_poly_terms-1)
	fit_real_s12s21 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s12s21, N_poly_terms-1)
	fit_imag_s12s21 = np.polyval(p, fn_in)


	p = np.polyfit(fn, real_s22, N_poly_terms-1)
	fit_real_s22 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s22, N_poly_terms-1)
	fit_imag_s22 = np.polyval(p, fn_in)


	fit_s11    = fit_real_s11    + 1j*fit_imag_s11
	fit_s12s21 = fit_real_s12s21 + 1j*fit_imag_s12s21
	fit_s22    = fit_real_s22    + 1j*fit_imag_s22



	# Corrected antenna S11
	corr_ant_s11 = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, ant_s11)




	# Verification
	if verification == 'yes':

		# Correction at the switch
		a6_sw,  xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m, s_sw_m, l_sw_m, a6)
		a10_sw, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m, s_sw_m, l_sw_m, a10)		

		a6c  = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, a6_sw)
		a10c = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, a10_sw)


		# From DC resistance
		DC_6dB  = 85.78
		DC_10dB = 60.66 

		gamma_6dB  = np.ones(len(f)) * rc.impedance2gamma(DC_6dB, 50)
		gamma_10dB = np.ones(len(f)) * rc.impedance2gamma(DC_10dB, 50)

		gamma_6dB_plus   = np.ones(len(f)) * rc.impedance2gamma(DC_6dB+0.01, 50)
		gamma_6dB_minus  = np.ones(len(f)) * rc.impedance2gamma(DC_6dB-0.01, 50)

		gamma_10dB_plus  = np.ones(len(f)) * rc.impedance2gamma(DC_10dB+0.01, 50)
		gamma_10dB_minus = np.ones(len(f)) * rc.impedance2gamma(DC_10dB-0.01, 50)



		# Plot
		plt.close()
		plt.close()
		plt.close()
		plt.close()


		plt.subplot(2,1,1)
		plt.plot(f/1e6, 20*np.log10(np.abs(a6c)))		
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB)), 'r')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB_plus)), 'r--')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB_minus)), 'r--')

		#plt.xlim([40, 200])
		plt.grid()
		plt.legend(['at receiver input','from DC resistance', '+/- 0.01 Ohms'])
		plt.ylabel('6-dB attenuator\n magnitude [dB]')

		ax = plt.gca()
		ax.ticklabel_format(useOffset=False)		



		plt.subplot(2,1,2)
		plt.plot(f/1e6, 20*np.log10(np.abs(a10c)))
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB)), 'r')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB_plus)), 'r--')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB_minus)), 'r--')

		#plt.xlim([40, 200])
		plt.grid()
		plt.xlabel('frequency [MHz]')
		plt.ylabel('10-dB attenuator\n magnitude [dB]')


		ax = plt.gca()
		ax.ticklabel_format(useOffset=False)		








		#plt.subplot(2,2,2)
		#plt.plot(f/1e6, 20*np.log10(np.abs(a6c)))		
		#plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB)), 'r')
		#plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB_plus)), 'r--')
		#plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB_minus)), 'r--')
		##plt.xlim([50, 100])
		##plt.ylim([-11.69,-11.66])
		#plt.grid()

		#ax = plt.gca()
		#ax.ticklabel_format(useOffset=False)		



		#plt.subplot(2,2,4)
		#plt.plot(f/1e6, 20*np.log10(np.abs(a10c)))
		##plt.ylim([-20.22,-20.18])
		#plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB)), 'r')
		#plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB_plus)), 'r--')
		#plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB_minus)), 'r--')
		##plt.xlim([50, 100])
		#plt.grid()
		#plt.xlabel('frequency [MHz]')		

		#ax = plt.gca()
		#ax.ticklabel_format(useOffset=False)		



		# ------- Fit quality of the S-parameters -------
		# -----------------------------------------------
		plt.figure(2)

		plt.subplot(3,2,1)
		plt.plot(f/1e6, real_s11 - fit_real_s11)

		plt.subplot(3,2,2)
		plt.plot(f/1e6, imag_s11 - fit_imag_s11)

		plt.subplot(3,2,3)
		plt.plot(f/1e6, real_s12s21 - fit_real_s12s21)

		plt.subplot(3,2,4)
		plt.plot(f/1e6, imag_s12s21 - fit_imag_s12s21)

		plt.subplot(3,2,5)
		plt.plot(f/1e6, real_s22 - fit_real_s22)

		plt.subplot(3,2,6)
		plt.plot(f/1e6, imag_s22 - fit_imag_s22)


	return (corr_ant_s11, fit_s11, fit_s12s21, fit_s22)














def low_band1_switch_correction_2017_05_25C_CHANGES_IN_LOAD(ant_s11, f_in = np.zeros([0,1]), verification = 'no'): 

	"""
	file based on (almost identical to) "low_band1_switch_correction_june_2016"

	"""



	# Loading measurements
	path_folder     = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band1/2017_05_25C/data/s11/raw/InternalSwitch/'

	o_sw_m, f = rc.s1p_read(path_folder + 'Int_Open1.s1p')
	s_sw_m, f = rc.s1p_read(path_folder + 'Int_Short1.s1p')
	l_sw_m, f = rc.s1p_read(path_folder + 'Int_Match1.s1p')

	o_ex,   f = rc.s1p_read(path_folder + 'Ext_Open1.s1p')
	s_ex,   f = rc.s1p_read(path_folder + 'Ext_Short1.s1p')
	l_ex,   f = rc.s1p_read(path_folder + 'Ext_Match1.s1p')

	#o_ex,   f = rc.s1p_read(path_folder + 'Ext_Air_Open1.s1p')
	#s_ex,   f = rc.s1p_read(path_folder + 'Ext_Air_Short1.s1p')
	#l_ex,   f = rc.s1p_read(path_folder + 'Ext_Air_Load2.s1p')

	a6,     f = rc.s1p_read(path_folder + 'Ext_6dB_1.s1p')
	a10,    f = rc.s1p_read(path_folder + 'Ext_10dB_1.s1p')




	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f))
	s_sw = -1 * np.ones(len(f))
	l_sw =  0 * np.ones(len(f))

	# Perturbed load reflection
	l_sw_perturbed = rc.impedance2gamma(50.05, 50) * np.ones(len(f))


	# Correction at the switch
	o_ex_c, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m, s_sw_m, l_sw_m, o_ex)
	s_ex_c, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw_perturbed, o_sw_m, s_sw_m, l_sw_m, s_ex)
	l_ex_c, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw_perturbed, o_sw_m, s_sw_m, l_sw_m, l_ex)


	# Computation of S-parameters to the receiver input
	resistance_of_match  = 50.11 # male
	md = 1
	oa, sa, la  = rc.agilent_85033E(f, resistance_of_match, md)
	#oa             = rc.terminated_airline_8043S15(f, oar)
	#sa             = rc.terminated_airline_8043S15(f, sar)
	#la             = rc.terminated_airline_8043S15(f, lar)	



	xx, s11, s12s21, s22 = rc.de_embed(oa, sa, la, o_ex_c, s_ex_c, l_ex_c, o_ex_c)





	# Polynomial fit of S-parameters from "f" to input frequency vector "f_in"
	# ------------------------------------------------------------------------


	# Frequency normalization
	fn = f/75e6

	if len(f_in) > 10:
		if f_in[0] > 1e5:
			fn_in = f_in/75e6
		elif f_in[-1] < 300:
			fn_in = f_in/75
	else:
		fn_in = fn	



	# Real-Imaginary parts
	real_s11    = np.real(s11)
	imag_s11    = np.imag(s11)
	real_s12s21 = np.real(s12s21)
	imag_s12s21 = np.imag(s12s21)
	real_s22    = np.real(s22)
	imag_s22    = np.imag(s22)



	# Polynomial fits
	N_poly_terms = 10     # 10 is the best number over 40-120 MHz
	p = np.polyfit(fn, real_s11, N_poly_terms-1)
	fit_real_s11 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s11, N_poly_terms-1)
	fit_imag_s11 = np.polyval(p, fn_in)


	p = np.polyfit(fn, real_s12s21, N_poly_terms-1)
	fit_real_s12s21 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s12s21, N_poly_terms-1)
	fit_imag_s12s21 = np.polyval(p, fn_in)


	p = np.polyfit(fn, real_s22, N_poly_terms-1)
	fit_real_s22 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s22, N_poly_terms-1)
	fit_imag_s22 = np.polyval(p, fn_in)


	fit_s11    = fit_real_s11    + 1j*fit_imag_s11
	fit_s12s21 = fit_real_s12s21 + 1j*fit_imag_s12s21
	fit_s22    = fit_real_s22    + 1j*fit_imag_s22



	# Corrected antenna S11
	corr_ant_s11 = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, ant_s11)




	# Verification
	if verification == 'yes':

		# Correction at the switch
		a6_sw,  xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m, s_sw_m, l_sw_m, a6)
		a10_sw, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, l_sw, o_sw_m, s_sw_m, l_sw_m, a10)		

		a6c  = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, a6_sw)
		a10c = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, a10_sw)


		# From DC resistance
		DC_6dB  = 85.78
		DC_10dB = 60.66 

		gamma_6dB  = np.ones(len(f)) * rc.impedance2gamma(DC_6dB, 50)
		gamma_10dB = np.ones(len(f)) * rc.impedance2gamma(DC_10dB, 50)

		gamma_6dB_plus   = np.ones(len(f)) * rc.impedance2gamma(DC_6dB+0.01, 50)
		gamma_6dB_minus  = np.ones(len(f)) * rc.impedance2gamma(DC_6dB-0.01, 50)

		gamma_10dB_plus  = np.ones(len(f)) * rc.impedance2gamma(DC_10dB+0.01, 50)
		gamma_10dB_minus = np.ones(len(f)) * rc.impedance2gamma(DC_10dB-0.01, 50)



		# Plot
		plt.close()
		plt.close()
		plt.close()
		plt.close()


		plt.subplot(2,1,1)
		plt.plot(f/1e6, 20*np.log10(np.abs(a6c)))		
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB)), 'r')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB_plus)), 'r--')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB_minus)), 'r--')

		#plt.xlim([40, 200])
		#plt.ylim([-11.69,-11.66])
		plt.grid()
		plt.legend(['at receiver input','from DC resistance', '+/- 0.01 Ohms'])
		plt.ylabel('6-dB attenuator\n magnitude [dB]')

		ax = plt.gca()
		ax.ticklabel_format(useOffset=False)		



		plt.subplot(2,1,2)
		plt.plot(f/1e6, 20*np.log10(np.abs(a10c)))
		#plt.ylim([-20.22,-20.18])
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB)), 'r')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB_plus)), 'r--')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB_minus)), 'r--')

		#plt.xlim([40, 200])
		plt.grid()
		plt.xlabel('frequency [MHz]')
		plt.ylabel('10-dB attenuator\n magnitude [dB]')

		ax = plt.gca()
		ax.ticklabel_format(useOffset=False)		



		#plt.subplot(2,2,2)
		#plt.plot(f/1e6, 20*np.log10(np.abs(a6c)))		
		#plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB)), 'r')
		#plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB_plus)), 'r--')
		#plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB_minus)), 'r--')
		##plt.xlim([50, 100])
		##plt.ylim([-11.69,-11.66])
		#plt.grid()

		#ax = plt.gca()
		#ax.ticklabel_format(useOffset=False)		



		#plt.subplot(2,2,4)
		#plt.plot(f/1e6, 20*np.log10(np.abs(a10c)))
		##plt.ylim([-20.22,-20.18])
		#plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB)), 'r')
		#plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB_plus)), 'r--')
		#plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB_minus)), 'r--')
		##plt.xlim([50, 100])
		#plt.grid()
		#plt.xlabel('frequency [MHz]')		

		#ax = plt.gca()
		#ax.ticklabel_format(useOffset=False)		



		# ------- Fit quality of the S-parameters -------
		# -----------------------------------------------
		plt.figure(2)

		plt.subplot(3,2,1)
		plt.plot(f/1e6, real_s11 - fit_real_s11)

		plt.subplot(3,2,2)
		plt.plot(f/1e6, imag_s11 - fit_imag_s11)

		plt.subplot(3,2,3)
		plt.plot(f/1e6, real_s12s21 - fit_real_s12s21)

		plt.subplot(3,2,4)
		plt.plot(f/1e6, imag_s12s21 - fit_imag_s12s21)

		plt.subplot(3,2,5)
		plt.plot(f/1e6, real_s22 - fit_real_s22)

		plt.subplot(3,2,6)
		plt.plot(f/1e6, imag_s22 - fit_imag_s22)


	return (corr_ant_s11, fit_s11, fit_s12s21, fit_s22)





























def calibration_processing_low_band1_2017_05_25C(flow, fhigh, save='no', save_folder=0):


	"""
	Modification: May, 2017.

	"""


	# Main folder
	main_folder     = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band1/2017_05_25C/'


	# Paths for source data
	path_spectra    = main_folder + 'data/spectra/300_350/'
	path_resistance = main_folder + 'data/resistance/corrected/'
	path_s11        = main_folder + 'data/s11/corrected/'


	# Creating output folders
	if save == 'yes':

		if not exists(main_folder + 'results/' + save_folder + '/temp/'):
			makedirs(main_folder + 'results/' + save_folder + '/temp/')

		if not exists(main_folder + 'results/' + save_folder + '/spectra/'):
			makedirs(main_folder + 'results/' + save_folder + '/spectra/')

		if not exists(main_folder + 'results/' + save_folder + '/s11/'):
			makedirs(main_folder + 'results/' + save_folder + '/s11/')

		if not exists(main_folder + 'results/' + save_folder + '/data/'):
			makedirs(main_folder + 'results/' + save_folder + '/data/')

		if not exists(main_folder + 'results/' + save_folder + '/calibration_files/'):
			makedirs(main_folder + 'results/' + save_folder + '/calibration_files/')			

		if not exists(main_folder + 'results/' + save_folder + '/plots/'):
			makedirs(main_folder + 'results/' + save_folder + '/plots/')


		# Output folders
		path_par_temp    = main_folder + 'results/' + save_folder + '/temp/'
		path_par_spectra = main_folder + 'results/' + save_folder + '/spectra/'
		path_par_s11     = main_folder + 'results/' + save_folder + '/s11/'
		path_data        = main_folder + 'results/' + save_folder + '/data/'




	# Spectra/resistance files

	# Ambient (THESE FILES SHOW A RESONANCE !!!  DO NOT USE)
	#file_ambient1 = path_spectra + 'level1_Ambient_load_2017_127_00_300_350.mat'
	#file_ambient2 = path_spectra + 'level1_Ambient_load_2017_128_00_300_350.mat'
	#file_ambient3 = path_spectra + 'level1_Ambient_load_2017_129_00_300_350.mat'
	#spec_ambient  = [file_ambient1, file_ambient2, file_ambient3]

	file_ambient1 = path_spectra + 'level1_Ambient_redo_2017_144_21_300_350.mat'
	file_ambient2 = path_spectra + 'level1_Ambient_redo_2017_145_00_300_350.mat'
	file_ambient3 = path_spectra + 'level1_Ambient_redo_2017_146_00_300_350.mat'	
	spec_ambient  = [file_ambient1, file_ambient2]  # DO NOT USE file_ambient3

	res_ambient   = path_resistance + 'ambient_load_2.txt'



	# Hot
	file_hot1 = path_spectra + 'level1_Hot_Load_2017_129_00_300_350.mat'	
	file_hot2 = path_spectra + 'level1_Hot_Load_2017_130_00_300_350.mat'
	spec_hot  = [file_hot1, file_hot2]
	res_hot   = path_resistance + 'hot_load.txt'



	# Open Cable
	file_open1 = path_spectra + 'level1_Open_Cable_2017_139_19_300_350.mat'
	#file_open2 = path_spectra + 'level1_Open_Cable_2017_140_00_300_350.mat'
	#file_open3 = path_spectra + 'level1_Open_Cable_2017_141_00_300_350.mat'
	spec_open  = [file_open1] #, file_open2, file_open3]
	res_open   = path_resistance + 'open_cable.txt'



	# Shorted Cable
	file_shorted1 = path_spectra + 'level1_Short_Cable_2017_139_00_300_350.mat'
	spec_shorted  = [file_shorted1]
	res_shorted   = path_resistance + 'shorted_cable.txt'



	# Antenna Simulator 1
	file_sim11  = path_spectra + 'level1_AntSim1_2017_135_20_300_350.mat'	
	file_sim12  = path_spectra + 'level1_AntSim1_2017_136_00_300_350.mat'
	spec_sim1   = [file_sim11, file_sim12]
	res_sim1    = path_resistance + 'antenna_simulator1.txt'



	# Antenna Simulator 2
	file_sim21  = path_spectra + 'level1_Antsim2_redo_2017_133_00_300_350.mat'	
	file_sim22  = path_spectra + 'level1_Antsim2_redo_2017_134_00_300_350.mat'
	file_sim23  = path_spectra + 'level1_Antsim2_redo_2017_135_00_300_350.mat'	
	spec_sim2   = [file_sim21, file_sim22, file_sim23]
	res_sim2    = path_resistance + 'antenna_simulator2.txt'	






	# Average calibration spectra / physical temperature
	# Percentage of initial data to leave out
	percent = 5 # 5%
	ssa,    phys_temp_ambient    = average_calibration_spectrum(spec_ambient,    res_ambient, 1*percent, plot='no')
	ssh,    phys_temp_hot        = average_calibration_spectrum(spec_hot,        res_hot,     6*percent, plot='no')
	sso,    phys_temp_open       = average_calibration_spectrum(spec_open,       res_open,    1*percent, plot='no')
	sss,    phys_temp_shorted    = average_calibration_spectrum(spec_shorted,    res_shorted, 1*percent, plot='no')
	sss1,   phys_temp_sim1       = average_calibration_spectrum(spec_sim1,       res_sim1,    1*percent, plot='no')
	sss2,   phys_temp_sim2       = average_calibration_spectrum(spec_sim2,       res_sim2,    1*percent, plot='no')






	# Select frequency range
	ff, ilow, ihigh = frequency_edges(flow, fhigh)
	fe    = ff[ilow:ihigh+1]
	sa    = ssa[ilow:ihigh+1]
	sh    = ssh[ilow:ihigh+1]
	so    = sso[ilow:ihigh+1]
	ss    = sss[ilow:ihigh+1]	
	ss1   = sss1[ilow:ihigh+1]
	ss2   = sss2[ilow:ihigh+1]




	# Spectra modeling
	fen = (fe-75)/25
	fit_spec_ambient    = fit_polynomial_fourier('fourier',    fen, sa,     7,  plot='no')
	fit_spec_hot        = fit_polynomial_fourier('fourier',    fen, sh,     7,  plot='no')
	fit_spec_open       = fit_polynomial_fourier('fourier',    fen, so,    27,  plot='no')
	fit_spec_shorted    = fit_polynomial_fourier('fourier',    fen, ss,    27,  plot='no')
	fit_spec_sim1       = fit_polynomial_fourier('fourier',    fen, ss1,   15,  plot='no')
	fit_spec_sim2       = fit_polynomial_fourier('fourier',    fen, ss2,   15,  plot='no')


	#model_spec_ambient    = model_evaluate('fourier', fit_spec_ambient[0],    fen)
	#model_spec_hot        = model_evaluate('fourier', fit_spec_hot[0],        fen)
	#model_spec_open       = model_evaluate('fourier', fit_spec_open[0],       fen)
	#model_spec_shorted    = model_evaluate('fourier', fit_spec_shorted[0],    fen)
	#model_spec_sim1       = model_evaluate('fourier', fit_spec_sim1[0],       fen)
	#model_spec_sim2       = model_evaluate('fourier', fit_spec_sim2[0],       fen)







	# Loading S11 data (both files produce same results)
	#s11 = np.genfromtxt(path_s11 + 's11_calibration_low_band_LNA25degC_2017-05-24-02-15-40.txt')
	s11 = np.genfromtxt(path_s11 + 's11_calibration_low_band_LNA25degC_2017-05-26-11-42-38_second_ambient_load.txt')


	for i in range(len(s11[:,0])-1):
		if (s11[i,0] <= flow) and (s11[i+1,0] > flow):
			index_low = i
		if (s11[i,0] < fhigh) and (s11[i+1,0] >= fhigh):
			index_high = i+1
	index_s11 = np.arange(index_low, index_high+1)

	# Frequency / complex data
	f_s11       = s11[index_s11, 0]
	s11_LNA     = s11[index_s11, 1]  + 1j*s11[index_s11, 2]
	s11_amb     = s11[index_s11, 3]  + 1j*s11[index_s11, 4]
	s11_hot     = s11[index_s11, 5]  + 1j*s11[index_s11, 6]
	s11_open    = s11[index_s11, 7]  + 1j*s11[index_s11, 8]
	s11_shorted = s11[index_s11, 9]  + 1j*s11[index_s11, 10]
	s11_sr      = s11[index_s11, 11] + 1j*s11[index_s11, 12]
	s12s21_sr   = s11[index_s11, 13] + 1j*s11[index_s11, 14]
	s22_sr      = s11[index_s11, 15] + 1j*s11[index_s11, 16]
	s11_simu1   = s11[index_s11, 17] + 1j*s11[index_s11, 18]
	s11_simu2   = s11[index_s11, 19] + 1j*s11[index_s11, 20]




	# Magnitude / Angle

	# LNA
	s11_LNA_mag     = np.abs(s11_LNA)
	s11_LNA_ang     = np.unwrap(np.angle(s11_LNA))

	# Ambient
	s11_amb_mag     = np.abs(s11_amb)
	s11_amb_ang     = np.unwrap(np.angle(s11_amb))

	# Hot
	s11_hot_mag     = np.abs(s11_hot)
	s11_hot_ang     = np.unwrap(np.angle(s11_hot))

	# Open
	s11_open_mag    = np.abs(s11_open)
	s11_open_ang    = np.unwrap(np.angle(s11_open))

	# Shorted
	s11_shorted_mag = np.abs(s11_shorted)
	s11_shorted_ang = np.unwrap(np.angle(s11_shorted))

	# sr-s11
	s11_sr_mag      = np.abs(s11_sr)
	s11_sr_ang      = np.unwrap(np.angle(s11_sr))

	# sr-s12s21
	s12s21_sr_mag   = np.abs(s12s21_sr)
	s12s21_sr_ang   = np.unwrap(np.angle(s12s21_sr))

	# sr-s22
	s22_sr_mag      = np.abs(s22_sr)
	s22_sr_ang      = np.unwrap(np.angle(s22_sr))

	# Simu1
	s11_simu1_mag   = np.abs(s11_simu1)
	s11_simu1_ang   = np.unwrap(np.angle(s11_simu1))

	# Simu2
	s11_simu2_mag   = np.abs(s11_simu2)
	s11_simu2_ang   = np.unwrap(np.angle(s11_simu2))	





	# Modeling S11

	f_s11n = (f_s11-75)/25

	fit_s11_LNA_mag     = fit_polynomial_fourier('polynomial', f_s11n, s11_LNA_mag,     11, plot='no')  # 
	fit_s11_LNA_ang     = fit_polynomial_fourier('polynomial', f_s11n, s11_LNA_ang,     11, plot='no')  # 

	fit_s11_amb_mag     = fit_polynomial_fourier('fourier',    f_s11n, s11_amb_mag,     27, plot='no')  # 
	fit_s11_amb_ang     = fit_polynomial_fourier('fourier',    f_s11n, s11_amb_ang,     27, plot='no')  # 

	fit_s11_hot_mag     = fit_polynomial_fourier('fourier',    f_s11n, s11_hot_mag,     27, plot='no')  #  
	fit_s11_hot_ang     = fit_polynomial_fourier('fourier',    f_s11n, s11_hot_ang,     27, plot='no')  # 

	fit_s11_open_mag    = fit_polynomial_fourier('fourier',    f_s11n, s11_open_mag,    27, plot='no')  #
	fit_s11_open_ang    = fit_polynomial_fourier('fourier',    f_s11n, s11_open_ang,    27, plot='no')  #

	fit_s11_shorted_mag = fit_polynomial_fourier('fourier',    f_s11n, s11_shorted_mag, 27, plot='no')  #
	fit_s11_shorted_ang = fit_polynomial_fourier('fourier',    f_s11n, s11_shorted_ang, 27, plot='no')  #

	fit_s11_sr_mag      = fit_polynomial_fourier('polynomial', f_s11n, s11_sr_mag,       5, plot='no')  # 
	fit_s11_sr_ang      = fit_polynomial_fourier('polynomial', f_s11n, s11_sr_ang,       5, plot='no')  # 

	fit_s12s21_sr_mag   = fit_polynomial_fourier('polynomial', f_s11n, s12s21_sr_mag,    5, plot='no')  # 
	fit_s12s21_sr_ang   = fit_polynomial_fourier('polynomial', f_s11n, s12s21_sr_ang,    5, plot='no')  # 

	fit_s22_sr_mag      = fit_polynomial_fourier('polynomial', f_s11n, s22_sr_mag,       5, plot='no')  # 
	fit_s22_sr_ang      = fit_polynomial_fourier('polynomial', f_s11n, s22_sr_ang,       5, plot='no')  # 

	fit_s11_simu1_mag   = fit_polynomial_fourier('fourier',    f_s11n, s11_simu1_mag,    19, plot='no')  #
	fit_s11_simu1_ang   = fit_polynomial_fourier('fourier',    f_s11n, s11_simu1_ang,    19, plot='no')  #

	fit_s11_simu2_mag   = fit_polynomial_fourier('fourier',    f_s11n, s11_simu2_mag,    19, plot='no')  #
	fit_s11_simu2_ang   = fit_polynomial_fourier('fourier',    f_s11n, s11_simu2_ang,    19, plot='no')  #	










	# Saving output parameters
	if save == 'yes':


		# Average spectra data in frequency range selected
		spectra = np.array([fe, sa, sh, so, ss, ss1, ss2]).T		

		# RMS residuals
		RMS_spectra = np.zeros((6,1))
		RMS_s11     = np.zeros((20,1))

		# Spectra
		RMS_spectra[0, 0] = fit_spec_ambient[2]
		RMS_spectra[1, 0] = fit_spec_hot[2]
		RMS_spectra[2, 0] = fit_spec_open[2]
		RMS_spectra[3, 0] = fit_spec_shorted[2]
		RMS_spectra[4, 0] = fit_spec_sim1[2]
		RMS_spectra[5, 0] = fit_spec_sim2[2]


		# S11
		RMS_s11[0, 0]  = fit_s11_LNA_mag[2]
		RMS_s11[1, 0]  = fit_s11_LNA_ang[2]
		RMS_s11[2, 0]  = fit_s11_amb_mag[2]
		RMS_s11[3, 0]  = fit_s11_amb_ang[2]
		RMS_s11[4, 0]  = fit_s11_hot_mag[2]
		RMS_s11[5, 0]  = fit_s11_hot_ang[2]
		RMS_s11[6, 0]  = fit_s11_open_mag[2]
		RMS_s11[7, 0]  = fit_s11_open_ang[2]
		RMS_s11[8, 0]  = fit_s11_shorted_mag[2]
		RMS_s11[9, 0]  = fit_s11_shorted_ang[2]
		RMS_s11[10, 0] = fit_s11_sr_mag[2]
		RMS_s11[11, 0] = fit_s11_sr_ang[2]
		RMS_s11[12, 0] = fit_s12s21_sr_mag[2]
		RMS_s11[13, 0] = fit_s12s21_sr_ang[2]
		RMS_s11[14, 0] = fit_s22_sr_mag[2]
		RMS_s11[15, 0] = fit_s22_sr_ang[2]
		RMS_s11[16, 0] = fit_s11_simu1_mag[2]
		RMS_s11[17, 0] = fit_s11_simu1_ang[2]
		RMS_s11[18, 0] = fit_s11_simu2_mag[2]
		RMS_s11[19, 0] = fit_s11_simu2_ang[2]



		# Formatting fit parameters

		# Physical temperature
		phys_temp = np.zeros((6,1))
		phys_temp[0,0] = phys_temp_ambient
		phys_temp[1,0] = phys_temp_hot
		phys_temp[2,0] = phys_temp_open
		phys_temp[3,0] = phys_temp_shorted
		phys_temp[4,0] = phys_temp_sim1
		phys_temp[5,0] = phys_temp_sim2		


		# Spectra
		par_spec_ambient    = np.reshape(fit_spec_ambient[0],    (-1,1))
		par_spec_hot        = np.reshape(fit_spec_hot[0],        (-1,1))
		par_spec_open       = np.reshape(fit_spec_open[0],       (-1,1))
		par_spec_shorted    = np.reshape(fit_spec_shorted[0],    (-1,1))
		par_spec_sim1       = np.reshape(fit_spec_sim1[0],       (-1,1))
		par_spec_sim2       = np.reshape(fit_spec_sim2[0],       (-1,1))


		# S11
		par_s11_LNA_mag     = np.reshape(fit_s11_LNA_mag[0],     (-1,1))
		par_s11_LNA_ang     = np.reshape(fit_s11_LNA_ang[0],     (-1,1))
		par_s11_amb_mag     = np.reshape(fit_s11_amb_mag[0],     (-1,1))
		par_s11_amb_ang     = np.reshape(fit_s11_amb_ang[0],     (-1,1))
		par_s11_hot_mag     = np.reshape(fit_s11_hot_mag[0],     (-1,1))
		par_s11_hot_ang     = np.reshape(fit_s11_hot_ang[0],     (-1,1))
		par_s11_open_mag    = np.reshape(fit_s11_open_mag[0],    (-1,1))
		par_s11_open_ang    = np.reshape(fit_s11_open_ang[0],    (-1,1))
		par_s11_shorted_mag = np.reshape(fit_s11_shorted_mag[0], (-1,1))
		par_s11_shorted_ang = np.reshape(fit_s11_shorted_ang[0], (-1,1))

		par_s11_sr_mag      = np.reshape(fit_s11_sr_mag[0],      (-1,1))
		par_s11_sr_ang      = np.reshape(fit_s11_sr_ang[0],      (-1,1))
		par_s12s21_sr_mag   = np.reshape(fit_s12s21_sr_mag[0],   (-1,1))
		par_s12s21_sr_ang   = np.reshape(fit_s12s21_sr_ang[0],   (-1,1))
		par_s22_sr_mag      = np.reshape(fit_s22_sr_mag[0],      (-1,1))
		par_s22_sr_ang      = np.reshape(fit_s22_sr_ang[0],      (-1,1))

		par_s11_simu1_mag   = np.reshape(fit_s11_simu1_mag[0],   (-1,1))
		par_s11_simu1_ang   = np.reshape(fit_s11_simu1_ang[0],   (-1,1))
		par_s11_simu2_mag   = np.reshape(fit_s11_simu2_mag[0],   (-1,1))
		par_s11_simu2_ang   = np.reshape(fit_s11_simu2_ang[0],   (-1,1))




		# Saving

		np.savetxt(path_data + 'average_spectra_300_350.txt', spectra)

		np.savetxt(path_par_temp    + 'physical_temperatures.txt', phys_temp)

		np.savetxt(path_par_spectra + 'par_spec_amb.txt',     par_spec_ambient)
		np.savetxt(path_par_spectra + 'par_spec_hot.txt',     par_spec_hot)
		np.savetxt(path_par_spectra + 'par_spec_open.txt',    par_spec_open)
		np.savetxt(path_par_spectra + 'par_spec_shorted.txt', par_spec_shorted)
		np.savetxt(path_par_spectra + 'par_spec_simu1.txt',   par_spec_sim1)
		np.savetxt(path_par_spectra + 'par_spec_simu2.txt',   par_spec_sim2)
		np.savetxt(path_par_spectra + 'RMS_spec.txt',         RMS_spectra)

		np.savetxt(path_par_s11 + 'par_s11_LNA_mag.txt',      par_s11_LNA_mag)
		np.savetxt(path_par_s11 + 'par_s11_LNA_ang.txt',      par_s11_LNA_ang)
		np.savetxt(path_par_s11 + 'par_s11_amb_mag.txt',      par_s11_amb_mag)
		np.savetxt(path_par_s11 + 'par_s11_amb_ang.txt',      par_s11_amb_ang)
		np.savetxt(path_par_s11 + 'par_s11_hot_mag.txt',      par_s11_hot_mag)
		np.savetxt(path_par_s11 + 'par_s11_hot_ang.txt',      par_s11_hot_ang)
		np.savetxt(path_par_s11 + 'par_s11_open_mag.txt',     par_s11_open_mag)
		np.savetxt(path_par_s11 + 'par_s11_open_ang.txt',     par_s11_open_ang)
		np.savetxt(path_par_s11 + 'par_s11_shorted_mag.txt',  par_s11_shorted_mag)
		np.savetxt(path_par_s11 + 'par_s11_shorted_ang.txt',  par_s11_shorted_ang)

		np.savetxt(path_par_s11 + 'par_s11_sr_mag.txt',       par_s11_sr_mag)
		np.savetxt(path_par_s11 + 'par_s11_sr_ang.txt',       par_s11_sr_ang)
		np.savetxt(path_par_s11 + 'par_s12s21_sr_mag.txt',    par_s12s21_sr_mag)
		np.savetxt(path_par_s11 + 'par_s12s21_sr_ang.txt',    par_s12s21_sr_ang)
		np.savetxt(path_par_s11 + 'par_s22_sr_mag.txt',       par_s22_sr_mag)
		np.savetxt(path_par_s11 + 'par_s22_sr_ang.txt',       par_s22_sr_ang)

		np.savetxt(path_par_s11 + 'par_s11_simu1_mag.txt',    par_s11_simu1_mag)
		np.savetxt(path_par_s11 + 'par_s11_simu1_ang.txt',    par_s11_simu1_ang)
		np.savetxt(path_par_s11 + 'par_s11_simu2_mag.txt',    par_s11_simu2_mag)
		np.savetxt(path_par_s11 + 'par_s11_simu2_ang.txt',    par_s11_simu2_ang)


		np.savetxt(path_par_s11 + 'RMS_s11.txt',       	      RMS_s11)


	# End
	print('Files processed.')

	return 1














def low_band_level2_to_level3(band, year_day, save='no', save_folder='', save_flag='', sun_el_max=-10, moon_el_max=90, amb_hum_max=90, min_receiver_temp=23.4, max_receiver_temp=27.4, ant_s11=262, ant_s11_Nfit=10, fgl=1, glt='value', glp=0.5, fal=1, fbcl=1, receiver_temperature='actual', low_band_cal_file=1, beam_correction='yes'):

	# Configuration
	# -------------

	#sun_el_max         = -10    # maximum sun elevation
	#moon_el_max        = 90     # maximum moon elevation
	#amb_hum_max        = 90     # maximum ambient humidity
	#min_receiver_temp  = 23.4   # limits of receiver temperature (23degC - 27degC), PLUS correction of 0.4degC for systematic thermistor offset
	#max_receiver_temp  = 27.4   # limits of receiver temperature (23degC - 27degC), PLUS correction of 0.4degC for systematic thermistor offset

	#ant_s11  = 262              # antenna S11 to use    # 'average'

	#fgl      = 1	             # flag ground loss
	#glt      = 'value'          # ground loss type
	#glp      = 0.5              # ground loss percentage
	#fal      = 1                # flag antenna pannel loss
	#fbcl     = 1                # flag balun connector loss 
	#receiver_temperature  = 1, or 25   # 1 for actual measured temperature, or 25 for 25degC

	#low_band_cal_file = 1       #  For Low-Band 1, Original 2015 calibration 50-100 MHz
	#low_band_cal_file = 2       #  For Low-Band 1, Original 2017 calibration 50-100 MHz
	#low_band_cal_file = 3       #  For Low-Band 1, Original 2017 calibration 50-120 MHz
					# Low-Band 2 does not care about calibration file number	
	# beam_correction = 1        # For Low-Band 1, original ground plane, -7 deg, 40-100 MHz
	# beam_correction = 2        # For Low-Band 1, extended ground plane, -7 deg, 40-120 MHz
	# beam_correction = 1        # For Low-Band 2, NS, -2 deg, 40-100 MHz
	# beam_correction = 2        # For Low-Band 2, EW, 87 deg, 40-100 MHz

	# List of files to process
	# ------------------------
	#datelist_raw = data_analysis_date_list(band, 'blade', case=date_list_case) # list of daily measurements
	#datelist_old = data_analysis_daily_spectra_filter(band, datelist_raw)      # selection of daily measurements.
	#datelist     = np.copy(datelist_old)                                       # further selection of daily measurements


	fin = 0
	tc_all = 0
	wc_all = 0
	mc_all = 0
	#rc_all = 0
	#pc_all = 0
	#rms_all = 0


	# Load daily data
	# ---------------
	LST_1 = 0
	LST_2 = 24
	fin, t_2D, w_2D, m_2D = data_selection_single_day_v3(band, year_day, LST_1, LST_2, sun_el_max=sun_el_max, moon_el_max=moon_el_max, amb_hum_max=amb_hum_max, min_receiver_temp=min_receiver_temp, max_receiver_temp=max_receiver_temp)

	# Cut the data at 100 MHz in cases where the calibration goes only to 100 MHz
	# ---------------------------------------------------------------------------
	if (band == 'low_band_2015') and (low_band_cal_file <= 2):
		if np.max(fin) > 100:
			fin  = fin[fin<=100]
			t_2D = t_2D[:, fin<=100]
			w_2D = w_2D[:, fin<=100]


	# Continue if there are data available
	# ------------------------------------
	if np.sum(t_2D) > 0:

		# RFI cleaning based on the average of the day
		# --------------------------------------------
		#avt0, avw0 = spectral_averaging(t_2D, w_2D)                                            # computing daily average
		#avt1, avw1 = RFI_excision_raw_frequency(fin, avt0, avw0)                               # RFI filter A
		#avt, avw   = RFI_cleaning_std(fin, avt1, avw1, n_sigma = 3.5, df_MHz = 20, npar = 4)   # RFI filter B


		# Combined gain (loss), computed only once, at the beginning, same for all days
		# -----------------------------------------------------------------------------
		cg = combined_gain(band, fin, antenna_s11_day=ant_s11, antenna_s11_Nfit=ant_s11_Nfit, flag_ground_loss=fgl, ground_loss_type=glt, ground_loss_percent=glp, flag_antenna_loss=fal, flag_balun_connector_loss=fbcl)			


		# Chromaticity factor, recomputed for every day because the LSTs are different 
		# ----------------------------------------------------------------------------
		if beam_correction != 'no':
			cf = antenna_beam_factor_interpolation(band, m_2D[:,3], fin, case_beam_factor=beam_correction)


		# Antenna S11
		# -----------
		#s11_ant = models_antenna_s11(band, 'blade', fin, antenna_s11_day=ant_s11, model_type='polynomial')
		s11_ant = models_antenna_s11_remove_delay(band, 'blade', fin, antenna_s11_day=ant_s11, model_type='polynomial', Nfit=ant_s11_Nfit, delay_0=0.175)





		# Receiver temperature correction
		# -----------------------------
		if receiver_temperature == 25:
			RecTemp_base = 25
		elif receiver_temperature == 1:   # 'Actual'
			RecTemp_base = m_2D[i,-2]-0.4    # Correction of 0.4 degC is necessary
		RecTemp = RecTemp_base	

		# Receiver calibration quantities
		# -------------------------------					
		s11_LNA, sca, off, TU, TC, TS = receiver_calibration(band, fin, receiver_temperature=RecTemp, low_band_cal_file=low_band_cal_file)		




		# Process every 39-sec spectra from the day
		# -----------------------------------------
		flag_x = 0

		for i in range(len(t_2D[:,0])):

			print('---------------------- ' + year_day + ' --- ' + str(i+1) + ' of ' + str(len(t_2D[:,0])))


			# Calibrated antenna temperature with losses and beam chromaticity
			# ----------------------------------------------------------------
			tc_with_loss_and_beam = calibrated_antenna_temperature(t_2D[i,:], s11_ant, s11_LNA, sca, off, TU, TC, TS)


			# Removing loss
			# -------------
			Tambient = 273.15+m_2D[i,9]
			tc_with_beam = (tc_with_loss_and_beam - Tambient*(1-cg))/cg


			# Removing beam chromaticity
			# --------------------------
			if beam_correction == 'no':
				tc = np.copy(tc_with_beam)

			else:
				tc = tc_with_beam/cf[i,:]








			# Zero-level data with RFI
			# ------------------------
			wc = np.copy(w_2D[i,:])  # original weights for individual spectra
			tc[wc==0] = 0            # zeroing temperature of flagged channels


			#wc[avw==0] = 0           # applying additional flagging based on daily average








			# Model fit, residuals, and RMS
			# -----------------------------
			if (np.sum(tc) > 0) and (np.sum(wc) > 0) and (np.sum(np.isnan(tc)) == 0) and (np.sum(np.isnan(wc)) == 0) and (np.sum(np.isinf(tc)) == 0) and (np.sum(np.isinf(wc)) == 0):

				## Polynomial parameters from binned spectra
				#Nsamples = 16 # 97 kHz
				#Nfg      = 5
				#av_fin, av_tc, av_wc  = spectral_binning_number_of_samples(fin, tc, wc, nsamples=Nsamples)
				#if 
					#p        = fit_polynomial_fourier('EDGES_polynomial', av_fin/200, av_tc, Nfg, Weights=av_wc)
					## Residuals at raw resolution
					#model    = model_evaluate('EDGES_polynomial', p[0], fin/200)
					#r        = tc - model
					#r[wc==0] = 0
					#rms      = np.std(r[wc>0])


				# Accumulating data and results
				# -----------------------------
				if flag_x == 0:
					tc_all  = np.copy(tc)
					wc_all  = np.copy(wc)
					mc_all  = np.copy(m_2D[i,:])
					#rc_all  = np.copy(r)
					#pc_all  = np.copy(p[0])
					#rms_all = np.copy(rms)
					flag_x = 1

				elif flag_x > 0:
					tc_all = np.vstack((tc_all, tc))
					wc_all = np.vstack((wc_all, wc))
					mc_all = np.vstack((mc_all, m_2D[i,:]))
					#rc_all = np.vstack((rc_all, r))
					#pc_all = np.vstack((pc_all, p[0]))
					#rms_all = np.append(rms_all, rms)


		# Save
		# --------------
		if save =='yes':
			path_save = home_folder + '/DATA/EDGES/spectra/level3/' + band + '/' + save_folder + '/'
			save_file = path_save + year_day + save_flag + '.hdf5'	

			with h5py.File(save_file, 'w') as hf:
				hf.create_dataset('frequency',            data = fin)
				hf.create_dataset('antenna_temperature',  data = tc_all)
				hf.create_dataset('weights',              data = wc_all)
				hf.create_dataset('meta_data',            data = mc_all)
				#hf.create_dataset('residuals',            data = rc_all)
				#hf.create_dataset('parameters',           data = pc_all)
				#hf.create_dataset('rms',                  data = rms_all)


	return fin, tc_all, wc_all, mc_all     #, rc_all, pc_all, rms_all

























def low_band_level2_to_level3_FAST(band, year_day, save='no', save_folder='', save_flag='', sun_el_max=-10, moon_el_max=90, amb_hum_max=90, min_receiver_temp=23.4, max_receiver_temp=27.4, ant_s11=262, ant_s11_Nfit=10, fgl=1, glt='value', glp=0.5, fal=1, fbcl=1, receiver_temperature=25, low_band_cal_file=1, beam_correction='yes'):

	"""
	Use this file instead of the version without FAST

	"""

	# CHANGE THIS INFORMATION !!!!!!!

	# Configuration
	# -------------

	#sun_el_max         = -10    # maximum sun elevation
	#moon_el_max        = 90     # maximum moon elevation
	#amb_hum_max        = 90     # maximum ambient humidity
	#min_receiver_temp  = 23.4   # limits of receiver temperature (23degC - 27degC), PLUS correction of 0.4degC for systematic thermistor offset
	#max_receiver_temp  = 27.4   # limits of receiver temperature (23degC - 27degC), PLUS correction of 0.4degC for systematic thermistor offset

	#ant_s11  = 262              # antenna S11 to use    # 'average'

	#fgl      = 1	             # flag ground loss
	#glt      = 'value'          # ground loss type
	#glp      = 0.5              # ground loss percentage
	#fal      = 1                # flag antenna pannel loss
	#fbcl     = 1                # flag balun connector loss 
	#receiver_temperature  = 1, or 25   # 1 for actual measured temperature, or 25 for 25degC

	#low_band_cal_file = 1       #  For Low-Band 1, Original 2015 calibration 50-100 MHz
	#low_band_cal_file = 2       #  For Low-Band 1, Original 2017 calibration 50-100 MHz
	#low_band_cal_file = 3       #  For Low-Band 1, Original 2017 calibration 50-120 MHz
					# Low-Band 2 does not care about calibration file number	
	# beam_correction = 1        # For Low-Band 1, original ground plane, -7 deg, 40-100 MHz
	# beam_correction = 2        # For Low-Band 1, extended ground plane, -7 deg, 40-120 MHz
	# beam_correction = 1        # For Low-Band 2, NS, -2 deg, 40-100 MHz
	# beam_correction = 2        # For Low-Band 2, EW, 87 deg, 40-100 MHz

	# List of files to process
	# ------------------------
	#datelist_raw = data_analysis_date_list(band, 'blade', case=date_list_case) # list of daily measurements
	#datelist_old = data_analysis_daily_spectra_filter(band, datelist_raw)      # selection of daily measurements.
	#datelist     = np.copy(datelist_old)                                       # further selection of daily measurements

	fin  = 0
	tc   = 0
	w_2D = 0
	m_2D = 0

	# Load daily data
	# ---------------
	LST_1 = 0
	LST_2 = 24
	fin, t_2D, w_2D, m_2D = data_selection_single_day_v3(band, year_day, LST_1, LST_2, sun_el_max=sun_el_max, moon_el_max=moon_el_max, amb_hum_max=amb_hum_max, min_receiver_temp=min_receiver_temp, max_receiver_temp=max_receiver_temp)

	# Cut the data at 100 MHz in cases where the calibration goes only to 100 MHz
	# ---------------------------------------------------------------------------
	if (band == 'low_band_2015') and (low_band_cal_file <= 2):
		if np.max(fin) > 100:
			fin  = fin[fin<=100]
			t_2D = t_2D[:, fin<=100]
			w_2D = w_2D[:, fin<=100]

	# Continue if there are data available
	# ------------------------------------
	if np.sum(t_2D) > 0:

		# Chromaticity factor, recomputed for every day because the LSTs are different 
		# ----------------------------------------------------------------------------
		if beam_correction != 'no':
			cf = np.zeros((len(m_2D[:,0]), len(fin)))
			for j in range(len(m_2D[:,0])):
				print(j)
				cf[j,:] = antenna_beam_factor_interpolation(band, np.array([m_2D[j,3]]), fin, case_beam_factor=beam_correction)

		# Antenna S11
		# -----------
		#s11_ant = models_antenna_s11(band, 'blade', fin, antenna_s11_day=ant_s11, model_type='polynomial')
		s11_ant = models_antenna_s11_remove_delay(band, 'blade', fin, antenna_s11_day=ant_s11, model_type='polynomial', Nfit=ant_s11_Nfit)

		# Receiver temperature correction
		# -----------------------------
		#if receiver_temperature == 25:
			#RecTemp_base = 25
		#elif receiver_temperature == 1:   # 'Actual'
			#RecTemp_base = m_2D[i,-2]-0.4    # Correction of 0.4 degC is necessary
		#RecTemp = RecTemp_base	

		# Receiver calibration quantities
		# -------------------------------
		print('Receiver calibration')
		s11_LNA, sca, off, TU, TC, TS = receiver_calibration(band, fin, receiver_temperature=receiver_temperature, low_band_cal_file=low_band_cal_file)		

		# Calibrated antenna temperature with losses and beam chromaticity
		# ----------------------------------------------------------------
		tc_with_loss_and_beam = calibrated_antenna_temperature(t_2D, s11_ant, s11_LNA, sca, off, TU, TC, TS)

		# Removing loss
		# -------------
		print('Loss correction')

		# Combined gain (loss), computed only once, at the beginning, same for all days
		# -----------------------------------------------------------------------------
		cg = combined_gain(band, fin, antenna_s11_day=ant_s11, antenna_s11_Nfit=ant_s11_Nfit, flag_ground_loss=fgl, ground_loss_type=glt, ground_loss_percent=glp, flag_antenna_loss=fal, flag_balun_connector_loss=fbcl)		

		Tambient = 273.15 + 25 #m_2D[i,9]		
		tc_with_beam = (tc_with_loss_and_beam - Tambient*(1-cg))/cg

		# Removing beam chromaticity
		# --------------------------
		if beam_correction == 'no':
			print('NO beam correction')
			tc = np.copy(tc_with_beam)
		else:
			print('Beam correction')
			tc = tc_with_beam/cf

		# Save
		# --------------
		if save =='yes':
			path_save = home_folder + '/DATA/EDGES/spectra/level3/' + band + '/' + save_folder + '/'
			save_file = path_save + year_day + save_flag + '.hdf5'	

			with h5py.File(save_file, 'w') as hf:
				hf.create_dataset('frequency',            data = fin)
				hf.create_dataset('antenna_temperature',  data = tc)
				hf.create_dataset('weights',              data = w_2D)
				hf.create_dataset('meta_data',            data = m_2D)

	return fin, tc, w_2D, m_2D























def data_analysis_low_band_spectra_average(band, filename, case, GHA1=5.5, GHA2=18.5, GHA_center_array=np.arange(6,19,1), flow=61, fhigh=99, Nfg=4, SUN_LOWER_LIM=-90, SUN_HIGHER_LIM=90, MOON_LOWER_LIM=-90, MOON_HIGHER_LIM=90):

	"""
	June 2017

	"""

	# Loading data

	# Testing
	print('XXX')




	# Low-Band 2015, Original Ground Plane
	if case == 100:
		path            = home_folder + '/DATA/EDGES/spectra/level3/low_band_2015/original_gp_no_bc_s11_2016_177_switch2017/'     #   comparison_memo246/'
		dl              = data_analysis_date_list('low_band_2015', 'blade', case=0)


		#dl              = ['2015_302_00', '2015_303_00'] #, '2015_288_00', '2015_289_00', '2015_291_00', '2015_292_00', '2015_293_00', '2015_294_00', '2015_295_00', '2015_296_00', '2015_297_00', '2015_298_00'] #np.copy(dl_old)
		#dl = ['2016_043_00', '2016_047_00']







	# Low-Band 2015, Extended Ground Plane
	if case == 200:
		#path   = home_folder + '/DATA/EDGES/spectra/level3/low_band_2015/extended_gp_yes_bc_s11_2016_243/'
		path   = home_folder + '/DATA/EDGES/spectra/level3/low_band_2015/extended_gp_yes_bc_s11_2016_243_50_120MHz/'
		# path   = home_folder + '/DATA/EDGES/spectra/level3/low_band_2015/extended_gp_yes_bc_s11_2017_93/'
		# path   = home_folder + '/DATA/EDGES/spectra/level3/low_band_2015/extended_gp_yes_bc_s11_2016_243_no_ground_loss/'
		# path   = home_folder + '/DATA/EDGES/spectra/level3/low_band_2015/extended_gp_no_bc_s11_2016_243/'

		# path   = home_folder + '/DATA/EDGES/spectra/level3/low_band_2015/extended_gp_yes_bc_s11_2016_243_cal2015_nfit7_wfit7/'
		# path   = home_folder + '/DATA/EDGES/spectra/level3/low_band_2015/extended_gp_yes_bc_s11_2016_243_cal2017_nfit7_wfit7/'

		# path     = home_folder + '/DATA/EDGES/spectra/level3/low_band_2015/extended_gp_yes_bc_s11_2016_243_switch2017/'
		#path     = home_folder + '/DATA/EDGES/spectra/level3/low_band_2015/extended_gp_yes_bc_s11_2017_93_switch2017/'
		#path     = home_folder + '/DATA/EDGES/spectra/level3/low_band_2015/extended_gp_yes_bc_s11_2015_342_switch2015/'

		dl       = data_analysis_date_list('low_band_2015', 'blade', case=1)

		#dl              = ['2016_261_00', '2016_262_00', '2016_263_00', '2016_264_00', '2016_265_00', '2016_266_00', '2016_267_00', '2016_268_00', '2016_269_00', '2016_270_00', '2016_271_00', '2016_273_15', '2016_274_00', '2016_275_00', '2016_276_00', '2016_277_00', '2016_278_00', '2016_279_00']
		#dl = ['2017_093_00']






	# Low-Band 2015, Extended Ground Plane, Files starting with 2017-153
	if case == 210:
		#path     = home_folder + '/DATA/EDGES/spectra/level3/low_band_2015/extended_gp_yes_bc_s11_2017_172.3_50_120MHz/'

		path     = home_folder + '/DATA/EDGES/spectra/level3/low_band_2015/original_gp_no_bc_s11_2015_342_50_120MHz/'
		dl       = data_analysis_date_list('low_band_2015', 'blade', case=0)
		#dl       = dl[0:10]












	# Low-Band2 2016, NS
	if case == 300:
		#path        = home_folder + '/DATA/EDGES/spectra/level3/low_band2_2017/NS_nominal/'
		#path        = home_folder + '/DATA/EDGES/spectra/level3/low_band2_2017/NS_nfit7_wfit7/'
		#path        = home_folder + '/DATA/EDGES/spectra/level3/low_band2_2017/NS_23/'
		#path        = home_folder + '/DATA/EDGES/spectra/level3/low_band2_2017/NS_27/'
		#path        = home_folder + '/DATA/EDGES/spectra/level3/low_band2_2017/NS_no_bc/'
		path        = home_folder + '/DATA/EDGES/spectra/level3/low_band2_2017/NS_no_gl/'
		dl          = data_analysis_date_list('low_band2_2017', 'blade', case=1)












	# Low-Band2 2016, EW
	if case == 400:
		#path   = home_folder + '/DATA/EDGES/spectra/level3/low_band2_2017/EW_with_shield_nominal/'
		#path   = home_folder + '/DATA/EDGES/spectra/level3/low_band2_2017/EW_with_shield_23/'
		#path   = home_folder + '/DATA/EDGES/spectra/level3/low_band2_2017/EW_with_shield_27/'
		#path   = home_folder + '/DATA/EDGES/spectra/level3/low_band2_2017/EW_with_shield_nfit7_wfit7/'
		#path   = home_folder + '/DATA/EDGES/spectra/level3/low_band2_2017/EW_with_shield_no_gl/'
		#path   = home_folder + '/DATA/EDGES/spectra/level3/low_band2_2017/EW_with_shield_no_bc/'
		#path   = home_folder + '/DATA/EDGES/spectra/level3/low_band2_2017/EW_with_shield_152_1/'
		#path   = home_folder + '/DATA/EDGES/spectra/level3/low_band2_2017/EW_with_shield_152_2/'
		path   = home_folder + '/DATA/EDGES/spectra/level3/low_band2_2017/EW_with_shield_153_2/'
		dl     = data_analysis_date_list('low_band2_2017', 'blade', case=2)


		#dl     = dl_old[1::]   # 
		#dl     = ['2017_160_00', '2017_162_00']











	# Low-Band2 2016, EW NO Shield
	if case == 500:
		#path  = home_folder + '/DATA/EDGES/spectra/level3/low_band2_2017/EW_with_NO_shield_nominal/'
		#path  = home_folder + '/DATA/EDGES/spectra/level3/low_band2_2017/EW_with_NO_shield_nfit7_wfit7/'
		#path  = home_folder + '/DATA/EDGES/spectra/level3/low_band2_2017/EW_with_NO_shield_23/'
		#path  = home_folder + '/DATA/EDGES/spectra/level3/low_band2_2017/EW_with_NO_shield_27/'
		#path  = home_folder + '/DATA/EDGES/spectra/level3/low_band2_2017/EW_with_NO_shield_no_gl/'
		path  = home_folder + '/DATA/EDGES/spectra/level3/low_band2_2017/EW_with_NO_shield_no_bc/'
		dl    = data_analysis_date_list('low_band2_2017', 'blade', case=3)

		#dl = ['2017_236_00']

















	flag_total = 0
	for j in range(len(dl)):  #  # range(15): #


		print(j+1)

		# Loading data
		file_name = dl[j]
		f0, t0, w0, m0 = level3_read_raw_spectra(path + file_name + '.hdf5')




		# RFI flaging for FM band
		kk, wk   = RFI_excision_raw_frequency(f0, t0[0,:], w0[0,:])        # RFI filter A
		t0[:, wk == 0] = 0
		w0[:, wk == 0] = 0




		# GHA and elevation cuts
		GHAx           = m0[:,4]
		GHAx[GHAx < 0] = GHAx[GHAx < 0] + 24

		SUN_EL  = m0[:,6]
		#SUN_LIM  = 90 #-10

		MOON_EL  = m0[:,8]
		#MOON_LIM = 90  		

		t1   = t0[(GHAx >= GHA1) & (GHAx <= GHA2) & (SUN_EL <= SUN_HIGHER_LIM) & (SUN_EL >= SUN_LOWER_LIM) & (MOON_EL <= MOON_HIGHER_LIM) & (MOON_EL >= MOON_LOWER_LIM), :]
		w1   = w0[(GHAx >= GHA1) & (GHAx <= GHA2) & (SUN_EL <= SUN_HIGHER_LIM) & (SUN_EL >= SUN_LOWER_LIM) & (MOON_EL <= MOON_HIGHER_LIM) & (MOON_EL >= MOON_LOWER_LIM), :]
		m1   = m0[(GHAx >= GHA1) & (GHAx <= GHA2) & (SUN_EL <= SUN_HIGHER_LIM) & (SUN_EL >= SUN_LOWER_LIM) & (MOON_EL <= MOON_HIGHER_LIM) & (MOON_EL >= MOON_LOWER_LIM), :]









		# Continue only if there are data
		shape_t1 = t1.shape
		if shape_t1[0] > 0:
			print(t1.shape)

			# Cut to desired frequency range
			f      = f0[(f0>=flow) & (f0<=fhigh)]
			t_raw1 = t1[:, (f0>=flow) & (f0<=fhigh)]
			w_raw1 = w1[:, (f0>=flow) & (f0<=fhigh)]
			m_raw1 = np.copy(m1)
			GHA    = m1[:,4]


			# Sort with increasing GHA
			index   = np.argsort(GHA)
			t_raw00 = t_raw1[index,:]
			w_raw00 = w_raw1[index,:]
			m_raw00 = m_raw1[index,:]
			GHA00   = GHA[index]



			# Removing traces with no data, or with nans or infs
			trs = np.sum(t_raw00, axis=1)
			wrs = np.sum(w_raw00, axis=1)

			t_raw0 = t_raw00[ (trs>0) & (wrs>0) & (np.isnan(trs)==False) & (np.isnan(wrs)==False) & (np.isinf(trs)==False) & (np.isinf(wrs)==False), :]
			w_raw0 = w_raw00[ (trs>0) & (wrs>0) & (np.isnan(trs)==False) & (np.isnan(wrs)==False) & (np.isinf(trs)==False) & (np.isinf(wrs)==False), :]
			m_raw0 = m_raw00[ (trs>0) & (wrs>0) & (np.isnan(trs)==False) & (np.isnan(wrs)==False) & (np.isinf(trs)==False) & (np.isinf(wrs)==False), :]
			GHA0   = GHA00[ (trs>0) & (wrs>0) & (np.isnan(trs)==False) & (np.isnan(wrs)==False) & (np.isinf(trs)==False) & (np.isinf(wrs)==False) ]




			# RFI cleaning based on RMS-GHA relationship
			lt0 = len(t_raw0[:,0])

			rms_bi_all = np.zeros(lt0)
			for i in range(lt0):

				print(file_name + ': RFI RMS-GHA: ' + str(i+1))

				ti = t_raw0[i,:]
				wi = w_raw0[i,:]

				Nsamples      = 64 # 97 kHz
				fbX, tbX, wbX = spectral_binning_number_of_samples(f, ti, wi, nsamples=Nsamples)
				fbi = fbX[(fbX >= 50) & (fbX <= 100)]
				tbi = tbX[(fbX >= 50) & (fbX <= 100)]
				wbi = wbX[(fbX >= 50) & (fbX <= 100)]

				Nfg_RFI  = 4 # This is just for this RFI test, not necessarily the same as in the actual analysis
				par_fg   = fit_polynomial_fourier('EDGES_polynomial', fbi/200, tbi, Nfg_RFI, Weights=wbi)
				model_bi = model_evaluate('EDGES_polynomial', par_fg[0], fbi/200)
				rbi      = tbi - model_bi
				rms_bi   = np.sqrt(np.sum((rbi[wbi>0])**2)/len(fbi[wbi>0]))				
				rms_bi_all[i] = rms_bi

				print(rms_bi)



			Npt = np.floor((GHA2 - GHA1)/2)   # number of polynomial terms in GHA-RMS fit
			if Npt < 2:
				Npt = 2	
			weights_cleaned = data_analysis_filter_RMS_GHA(GHA0, rms_bi_all, Npoly_terms=Npt, deltaRMS_K=2, GHA_bin=0.1, std_threshold=3)




			# Removing data with outlying RMSs
			t_raw = t_raw0[weights_cleaned>0,:]
			w_raw = w_raw0[weights_cleaned>0,:]
			m_raw = m_raw0[weights_cleaned>0,:]
			GHA   = GHA0[weights_cleaned>0]














			# Averaging every Ntraces traces for efficiency
			lt = len(t_raw[:,0])
			if lt > 1:



				Ntraces = 10
				lavt = int(np.floor(lt/Ntraces))
				t = np.zeros((lavt, len(f)))
				w = np.zeros((lavt, len(f)))
				m = np.zeros((lavt, 4))

				for i in range(lavt):

					print(file_name + ': absolute average: ' + str(i+1))

					# Spectral averaging
					if i < (lavt-1):

						i1       = i*Ntraces
						i2       = (i+1)*Ntraces
						avt, avw = spectral_averaging(t_raw[i1:i2,:], w_raw[i1:i2,:])

						GG       = GHA[i1:i2] 	
						if np.max(GG) - np.min(GG) > 20:
							GG[GG<12] = GG[GG<12] + 24
							GG2       = np.mean(GG)
							if GG2 > 24:
								GG2 = GG2 - 24
						else:
							GG2       = np.mean(GG)
						av_gha   = GG2

						t[i,:] = avt
						w[i,:] = avw
						m[i,:] = np.array([m_raw[i1,0], m_raw[i1,1], m_raw[i1,2], av_gha])					




					elif i == (lavt-1):

						i1       = i*Ntraces
						print('Last bin: ' + str(len(t_raw[i1::,:])))
						if len(t_raw[i1::,:]) > 0:

							avt, avw = spectral_averaging(t_raw[i1::,:], w_raw[i1::,:])

							GG       = GHA[i1::]	
							if np.max(GG) - np.min(GG) > 20:
								GG[GG<12] = GG[GG<12] + 24
								GG2       = np.mean(GG)
								if GG2 > 24:
									GG2 = GG2 - 24
							else:
								GG2       = np.mean(GG)
							av_gha   = GG2

							t[i,:] = avt
							w[i,:] = avw
							m[i,:] = np.array([m_raw[i1,0], m_raw[i1,1], m_raw[i1,2], av_gha])



















				# Total average 
				# -----------------------------------	


				flag_daily = 0
				for i in range(lavt):

					# Loading one raw trace at a time
					ti = t[i,:]
					wi = w[i,:]
					mi = m[i,:]


					if (np.sum(ti) > 0) and (np.sum(wi) > 0) and (np.sum(np.isnan(ti)) == 0) and (np.sum(np.isnan(wi)) == 0) and (np.sum(np.isinf(ti)) == 0) and (np.sum(np.isinf(wi)) == 0):

						# RFI cleanning
						wi2 = RFI_cleaning_spectrum(f, ti, wi, Nsamples=32, Nterms_fg=16, Nterms_std=3, Nsigma=4)
						ti[wi2 == 0] = 0
						wi[wi2 == 0] = 0


						# Polynomial parameters from binned spectra
						Nsamples      = 16 # 97 kHz
						fbi, tbi, wbi = spectral_binning_number_of_samples(f, ti, wi, nsamples=Nsamples)


						if (np.sum(np.isnan(tbi)) == 0) and (np.sum(np.isnan(wbi)) == 0) and (np.sum(np.isinf(tbi)) == 0) and (np.sum(np.isinf(wbi)) == 0):

							par_fg  = fit_polynomial_fourier('EDGES_polynomial', fbi/200, tbi, Nfg, Weights=wbi)
							model_i = model_evaluate('EDGES_polynomial', par_fg[0], f/200)
							ri      = ti - model_i
							rms_i   = np.sqrt(np.sum((ri[wi>0])**2)/len(f[wi>0]))

							print(dl[j] + ', ' + str(i+1) + ' of ' + str(lavt) + ', RMS: ' + str(round(rms_i)) + ' K')

							if flag_daily == 0:
								t_day   = np.copy(ti)
								w_day   = np.copy(wi)
								m_day   = np.copy(mi)
								r_day   = np.copy(ri)
								p_day   = np.copy(par_fg[0])
								rms_day = np.copy(rms_i)
								flag_daily = 1

							elif flag_daily > 0:
								t_day   = np.vstack((t_day, ti))
								w_day   = np.vstack((w_day, wi))
								m_day   = np.vstack((m_day, mi))
								r_day   = np.vstack((r_day, ri))
								p_day   = np.vstack((p_day, par_fg[0]))
								rms_day = np.append(rms_day, rms_i)




				if len(t_day.shape) == 2:

					# Spectral averaging
					print(str(r_day.shape))
					rd, wd = spectral_averaging(r_day, w_day)

					# Spectral binning
					fb, rdb, wdb = spectral_binning_number_of_samples(f, rd, wd, nsamples=64)

					# RMS of binned residuals
					rms_d = np.sqrt(np.sum((rdb[wdb>0])**2)/len(fb[wdb>0]))

					# Average model parameters
					pdb = np.mean(p_day, axis=0)

					# Evaluating foreground model at binned frequencies
					td_fg = model_evaluate('EDGES_polynomial', pdb, fb/200)

					# Binned total temperature
					tdb = td_fg + rdb






					RMS_daily_lim = 1000   # 0.300     # 1000000  #   Kelvin


					print('--------------------------')
					print('DAILY RESIDUAL RMS: ' + str(rms_d))

					# Accumulating daily binned data, as well as raw data
					if (flag_total == 0) and (rms_d < RMS_daily_lim):
						tb_d   = np.copy(tdb)
						rb_d   = np.copy(rdb)
						wb_d   = np.copy(wdb)
						pb_d   = np.copy(pdb)
						mb_d   = np.copy(m_day[0, 0:3])
						rmsb_d = np.copy(rms_d)

						tr    = np.copy(t_day)
						rr    = np.copy(r_day)
						wr    = np.copy(w_day)
						mr    = np.copy(m_day)
						pr    = np.copy(p_day)
						rmsr  = np.copy(rms_day)

						flag_total = 1


					elif (flag_total > 0) and (rms_d < RMS_daily_lim):
						tb_d   = np.vstack((tb_d, tdb))
						rb_d   = np.vstack((rb_d, rdb))
						wb_d   = np.vstack((wb_d, wdb))
						pb_d   = np.vstack((pb_d, pdb))
						mb_d   = np.vstack((mb_d, m_day[0, 0:3]))
						rmsb_d = np.vstack((rmsb_d, rms_d))		

						tr    = np.vstack((tr, t_day))
						rr    = np.vstack((rr, r_day))
						wr    = np.vstack((wr, w_day))
						mr    = np.vstack((mr, m_day))
						pr    = np.vstack((pr, p_day))
						rmsr  = np.append(rmsr, rms_day)



				else:
					print('NO DATA')





	# GHA total averages
	dGHA                 = GHA_center_array[1] - GHA_center_array[0]
	GHA_raw              = mr[:,3]
	GHA_raw[GHA_raw < 0] = GHA_raw[GHA_raw < 0] + 24

	flag = 0

	tb_tg   = np.zeros((len(GHA_center_array), len(fb)))
	rb_tg   = np.zeros((len(GHA_center_array), len(fb)))
	wb_tg   = np.zeros((len(GHA_center_array), len(fb)))
	pb_tg   = np.zeros((len(GHA_center_array), len(pr[0,:])))
	rmsb_tg = np.zeros(len(GHA_center_array))



	for i in range(len(GHA_center_array)):

		print('GHA average center: ' + str(GHA_center_array[i]))

		Gl = GHA_center_array[i] - (dGHA/2)
		Gh = GHA_center_array[i] + (dGHA/2)


		if (Gl >= 0) and (Gh >= 0) and (Gh > Gl):
			r = rr[(GHA_raw>=Gl) & (GHA_raw<=Gh), :]
			w = wr[(GHA_raw>=Gl) & (GHA_raw<=Gh), :]
			p = pr[(GHA_raw>=Gl) & (GHA_raw<=Gh), :]


		if (Gl < 0) and (GHA_center_array[i] >= 0) and (Gh > 0) and (Gh > GHA_center_array[i]):
			r = rr[(GHA_raw>=(Gl+24)) | (GHA_raw<=Gh), :]
			w = wr[(GHA_raw>=(Gl+24)) | (GHA_raw<=Gh), :]
			p = pr[(GHA_raw>=(Gl+24)) | (GHA_raw<=Gh), :]


		if (Gl >= 0) and (GHA_center_array[i] > 0) and (Gh > 24):
			r = rr[(GHA_raw>=Gl) | (GHA_raw<=(Gh-24)), :]
			w = wr[(GHA_raw>=Gl) | (GHA_raw<=(Gh-24)), :]
			p = pr[(GHA_raw>=Gl) | (GHA_raw<=(Gh-24)), :]			




		if np.sum(r) != 0:

			print('number of raw spectra: ' + str(len(r[:,0])))

			# Spectral averaging
			rav, wav   = spectral_averaging(r, w)

			# Spectral binning
			fb, rb, wb = spectral_binning_number_of_samples(f, rav, wav, nsamples=64)

			# Average model parameters
			pb         = np.mean(p, axis=0)

			# Evaluating foreground model at binned frequencies
			tb_fg      = model_evaluate('EDGES_polynomial', pb, fb/200)

			# Binned total temperature
			tb         = tb_fg  +  rb

			# RMS
			rmsb = np.sqrt(np.sum((rb[wb>0])**2)/len(fb[wb>0]))


			# Storing data
			tb_tg[i, :] = tb	
			rb_tg[i, :] = rb
			wb_tg[i, :] = wb
			pb_tg[i, :] = pb
			rmsb_tg[i]  = rmsb

			if flag == 0:				
				flag = 1	




	# Total average	

	# Spectral averaging
	rav_t, wav_t = spectral_averaging(rr, wr)

	# Spectral binning
	fb, rb_t, wb_t = spectral_binning_number_of_samples(f, rav_t, wav_t, nsamples=64)

	# Average model parameters
	pb_t = np.mean(pr, axis=0)

	# Evaluating foreground model at binned frequencies
	tb_fg_t = model_evaluate('EDGES_polynomial', pb_t, fb/200)

	# Binned total temperature
	tb_t = tb_fg_t + rb_t

	# RMS
	rmsb_t = np.sqrt(np.sum((rb_t[wb_t>0])**2)/len(fb[wb_t>0]))

	print('RMS of total: ' + str(rmsb_t))



	## RAW:                fr, tr,    rr,    wr,    mr,     rmsr
	## DAY_AVERAGE_TOTAL:  fb, tb_d,  rb_d,  wb_d,  mb_d,   rmsb_d
	## AVERAGE_GHA:        fb, tb_tg, rb_tg, wb_tg, gha_tg, rmsb_tg
	## AVERAGE:            fb, tb_t,  rb_t,  wb_t,  rmsb_t


	## Saving data
	save_file = home_folder + '/DATA/EDGES/spectra/level4/' + band + '/' + filename + '.hdf5'

	with h5py.File(save_file, 'w') as hf:

		hf.create_dataset('raw_f',         data = f)
		hf.create_dataset('raw_t',         data = tr)
		hf.create_dataset('raw_r',         data = rr)
		hf.create_dataset('raw_w',         data = wr)
		hf.create_dataset('raw_p',         data = pr)
		hf.create_dataset('raw_m',         data = mr)
		hf.create_dataset('raw_rms',       data = rmsr)


		hf.create_dataset('day_f',         data = fb)
		hf.create_dataset('day_t',         data = tb_d)
		hf.create_dataset('day_r',         data = rb_d)
		hf.create_dataset('day_w',         data = wb_d)
		hf.create_dataset('day_p',         data = pb_d)
		hf.create_dataset('day_m',         data = mb_d)
		hf.create_dataset('day_rms',       data = rmsb_d)


		hf.create_dataset('gha_f',         data = fb)
		hf.create_dataset('gha_t',         data = tb_tg)
		hf.create_dataset('gha_r',         data = rb_tg)
		hf.create_dataset('gha_w',         data = wb_tg)
		hf.create_dataset('gha_p',         data = pb_tg)
		hf.create_dataset('gha_gha',       data = GHA_center_array)
		hf.create_dataset('gha_rms',       data = rmsb_tg)


		hf.create_dataset('tot_f',         data = fb)
		hf.create_dataset('tot_t',         data = tb_t)
		hf.create_dataset('tot_r',         data = rb_t)
		hf.create_dataset('tot_w',         data = wb_t)
		hf.create_dataset('tot_p',         data = pb_t)
		hf.create_dataset('tot_rms',       data = rmsb_t)


	out = [f, tr, rr, wr, pr, mr, rmsr, fb, tb_d, rb_d, wb_d, pb_d, mb_d, rmsb_d, tb_tg, rb_tg, wb_tg, pb_tg, GHA_center_array, rmsb_tg, tb_t, rb_t, wb_t, pb_t, rmsb_t]

	return out  # GHA0, rms_bi_all, weights_cleaned, 


















def level4_read(path_file):

	with h5py.File(path_file,'r') as hf:
		#print([key for key in hf.keys()])

		hf_f = hf.get('raw_f')
		f    = np.array(hf_f)

		hf_t = hf.get('raw_t')
		t    = np.array(hf_t)

		hf_r = hf.get('raw_r')
		r    = np.array(hf_r)

		hf_w = hf.get('raw_w')
		w    = np.array(hf_w)

		hf_p = hf.get('raw_p')
		p    = np.array(hf_p)

		hf_m = hf.get('raw_m')
		m    = np.array(hf_m)

		hf_rms = hf.get('raw_rms')
		rms    = np.array(hf_rms)



		hf_f = hf.get('day_f')
		fb_d  = np.array(hf_f)

		hf_t = hf.get('day_t')
		tb_d  = np.array(hf_t)

		hf_r = hf.get('day_r')
		rb_d  = np.array(hf_r)

		hf_w = hf.get('day_w')
		wb_d  = np.array(hf_w)

		hf_p = hf.get('day_p')
		pb_d  = np.array(hf_p)

		hf_m = hf.get('day_m')
		mb_d  = np.array(hf_m)

		hf_rms = hf.get('day_rms')
		rmsb_d  = np.array(hf_rms)



		hf_f = hf.get('gha_f')
		fb_g  = np.array(hf_f)

		hf_t = hf.get('gha_t')
		tb_g  = np.array(hf_t)

		hf_r = hf.get('gha_r')
		rb_g  = np.array(hf_r)

		hf_w = hf.get('gha_w')
		wb_g  = np.array(hf_w)

		hf_p = hf.get('gha_p')
		pb_g  = np.array(hf_p)

		hf_g   = hf.get('gha_gha')
		ghab_g  = np.array(hf_g)

		hf_rms = hf.get('gha_rms')
		rmsb_g  = np.array(hf_rms)



		hf_f = hf.get('tot_f')
		fb_t  = np.array(hf_f)

		hf_t = hf.get('tot_t')
		tb_t  = np.array(hf_t)

		hf_r = hf.get('tot_r')
		rb_t  = np.array(hf_r)

		hf_w = hf.get('tot_w')
		wb_t  = np.array(hf_w)

		hf_p = hf.get('tot_p')
		pb_t  = np.array(hf_p)

		hf_rms = hf.get('tot_rms')
		rmsb_t  = np.array(hf_rms)


	out = [f, t, r, w, p, m, rms, fb_d, tb_d, rb_d, wb_d, pb_d, mb_d, rmsb_d, fb_g, tb_g, rb_g, wb_g, pb_g, ghab_g, rmsb_g, fb_t, tb_t, rb_t, wb_t, pb_t, rmsb_t]


	return out





























def data_analysis_low_band_spectra_plots():

	"""
	July 1, 2017

	"""


	#o = plot_spectra_residuals(fb_cut, rb_all[rmsb_all[:,1]<250,:], wb_all[rmsb_all[:,1]<250,:], 'daily', mb_all[rmsb_all[:,1]<250,1].astype(int), K=0.8, rms_offset=0, flow_lim=58, fhigh_lim=105, xticks_low=60, xticks_high=100, xticks_delta=10, rms_text_freq=100, fontsize=10, size_x_column=8, size_y=10, NSC=8, y_label='day of year 2015', plot_name='hola')
	o = eg.plot_spectra_residuals(fb, rb_total, wb_total, 'daily', mb_total[:,1].astype(int), K=0.8, rms_offset=0, flow_lim=59, fhigh_lim=105, xticks_low=60, xticks_high=100, xticks_delta=5, rms_text_freq=99.5, fontsize=10, size_x_column=8, size_y=15, NSC=20, y_label='day of year 2015', plot_name='hola')

	o = test_low_band_signature_search(fb_c, tb_c, wb_c, 61, 99, 4, 7, SNR_or_errorbar='errorbar')

	fbb    = o[0]
	res_fg = o[3]
	rms_fg = o[4]
	res_21 = o[-6]
	rms_21 = o[-7]
	model  = o[-1]
	a21    = o[-5]
	d21    = o[-4]
	vr     = o[-3]
	dv     = o[-2]


	plt.close()
	plt.close()

	plt.subplot(3,1,1)
	plt.plot(fbb, 1000*res_fg)
	plt.ylim([-500, 500])
	plt.grid()
	plt.ylabel('[mK]')
	plt.text(85, -400, 'RMS = '+str(round(1000*rms_fg))+' mK')

	plt.subplot(3,1,2)
	plt.plot(fbb, -1000*model)
	plt.ylim([-1300, 100])
	plt.grid()
	plt.ylabel('[mK]')
	plt.text(87, -1*200, r'a21     = ' + str(round(1000*a21)) + ' mK')
	plt.text(87, -1*400, r'd21     = ' + str(round(1000*d21)) + ' mK')
	plt.text(87, -1*600, r'snr     = ' + str(round(a21/d21)))
	plt.text(87, -1*800, r'$\nu_r$       = ' + str(round(vr)) + ' MHz')
	plt.text(87, -1*1000, r'$\Delta\nu$     = ' + str(dv) + ' MHz')

	plt.subplot(3,1,3)
	plt.plot(fbb, 1000*res_21)
	plt.ylim([-500, 500])
	plt.grid()
	plt.xlabel('frequency [MHz]')
	plt.ylabel('[mK]')
	plt.text(85, -400, 'RMS = '+str(round(1000*rms_21))+' mK')	


	return 0

















def data_analysis_low_band_MCMC(vb, db, nb, wb, save='no', save_filename='x', flow=50, fhigh=100, model_fg='EDGES_polynomial', Nfg=5, model_21cm='gaussian_flattened_1', N21=5, sine_cosine='no', Nchain=10000, Nthreads=6, rejected_fraction=0.3, tau0=7, tilt=0, a21_eor=0.028): 

	'''

	Sept 12, 2017

	## Example of running the code
	## 5 terms 60-94 MHz   20 mK noise
	## 6 terms 60-95 MHz   12 mK noise
	## samples, par, v, t21, res, rms = eg.data_analysis_low_band_MCMC(fb, tb, (20/20)*nb, wb, flow=60, fhigh=94, model_fg='EDGES_polynomial', Nfg=5, model_21cm='gaussian_flattened_1', Nchain=6000, Nthreads=6)

	## Example of plotting 21-cm models
	## plt.plot(v, tcosmo_all[np.random.randint(len(tcosmo_all[:,0]), size=500) ,:].T, color='c', alpha=0.1)
	## plt.plot(v, tcosmo_all[-1,:], color='k')


	'''


	# Setting Up MCMC
	# -----------------------------------------------------
	# Cutting data within desired range	
	v = vb[(vb>=flow) & (vb<=fhigh)]
	d = db[(vb>=flow) & (vb<=fhigh)]
	n = nb[(vb>=flow) & (vb<=fhigh)]
	w = wb[(vb>=flow) & (vb<=fhigh)]


	# Noise profile
	# sigma_noise = 0.03* np.ones(len(v))  #(60  - 0.5*v)/1000  # in K   (~ 30 mK at 60 MHz, and 10 mK at 100 MHz)


	# MCMC
	#if model_21cm == 'gaussian_flattened_1':
		#N21=3


	if sine_cosine == 'yes':
		Nsc = 2
	elif sine_cosine == 'no':
		Nsc = 0

	Ndim     = Nfg + N21 + Nsc
	Nwalkers = 2*Ndim + 2
	vn       = flow + (fhigh-flow)/2



	# Random start point of the chain
	p0 = (np.random.uniform(size=Ndim*Nwalkers).reshape((Nwalkers, Ndim)) - 0.5) / 1         # noise STD: ([0,1] - 0.5) / 10  =  [-0.05, 0.05]

	# Appropriate offset to the random starting point of some parameters
	# First are foreground model coefficients
	x        = fit_polynomial_fourier(model_fg, v/vn, d, Nfg, Weights=w)
	poly_par = x[0]	
	for i in range(Nfg):
		p0[:,i] = p0[:,i] + poly_par[i]


	# Next are phenomenological models
	if model_21cm == 'gaussian_flattened_1':
		p0[:,Nfg+0] = p0[:,Nfg+0] - 0.5
		p0[:,Nfg+1] = p0[:,Nfg+1] + 78
		p0[:,Nfg+2] = p0[:,Nfg+2] + 20
		if N21 > 3:
			p0[:,Nfg+3] = p0[:,Nfg+3] + 3			
			if N21 > 4:
				p0[:,Nfg+4] = p0[:,Nfg+4] + 0


	elif (model_21cm == 'tanh_EoR'):
		if (N21 == 2):
			p0[:,Nfg+0] = p0[:,Nfg+0] + 13
			p0[:,Nfg+1] = p0[:,Nfg+1] + 1

		elif (N21 == 3):
			p0[:,Nfg+0] = p0[:,Nfg+0] + 0.0
			p0[:,Nfg+1] = p0[:,Nfg+1] + 13
			p0[:,Nfg+2] = p0[:,Nfg+2] + 1


	# If there is a "sine" and "cosine" functions added, their starting points are around zero 



	# Computing results
	# ------------------------------------------------------
	print('Computing MCMC ...')
	sampler = ec.EnsembleSampler(Nwalkers, Ndim, data_analysis_low_band_MCMC_log_likelihood, threads=Nthreads, args=(v[w>0], d[w>0], n[w>0]), kwargs={'model_fg':model_fg, 'Nfg':Nfg, 'vn':vn, 'model_21cm':model_21cm, 'N21':N21, 'sine_cosine':sine_cosine, 'tau0':tau0, 'tilt':tilt, 'a21_eor':a21_eor})
	sampler.run_mcmc(p0, Nchain)




	# Analyzing results
	# ------------------------------------------------------

	# All samples
	#samples = sampler.chain.reshape((-1, Ndim))


	# Only accepted samples
	samples_cut = sampler.chain[:, (np.int(rejected_fraction*Nchain)):, :].reshape((-1, Ndim))




	# For flattened gaussian Invert sign of a21 and multiply by 1000
	if model_21cm == 'gaussian_flattened_1':
		samples_cut[:,Nfg] = -1000*samples_cut[:,Nfg]


	# For tanh_EoR, just multiply by 1000
	elif (model_21cm == 'tanh_EoR') and (N21 == 3):
		samples_cut[:,Nfg] = 1000*samples_cut[:,Nfg]	




	# Corner plot for 21-cm parameters
	if (model_21cm == 'gaussian_flattened_1') and (sine_cosine == 'no'):
		if N21 == 3:
			labels=[r'$A$ [mK]', r'$\nu_0$ [MHz]', r'$w$ [MHz]']
		elif N21 == 4:
			labels=[r'$A$ [mK]', r'$\nu_0$ [MHz]', r'$w$ [MHz]', r'$\tau$']
		elif N21 == 5:
			labels=[r'$A$ [mK]', r'$\nu_0$ [MHz]', r'$w$ [MHz]', r'$\tau$', r'$\chi$']
			
			
	elif (model_21cm == 'gaussian_flattened_1') and (sine_cosine == 'yes'):
		if N21 == 3:
			labels=[r'$A$ [mK]', r'$\nu_0$ [MHz]', r'$w$ [MHz]', r'Asine', r'Acosine']
		elif N21 == 4:
			labels=[r'$A$ [mK]', r'$\nu_0$ [MHz]', r'$w$ [MHz]', r'$\tau$', r'Asine', r'Acosine']
		elif N21 == 5:
			labels=[r'$A$ [mK]', r'$\nu_0$ [MHz]', r'$w$ [MHz]', r'$\tau$', r'$\chi$', r'Asine', r'Acosine']			
	
			
			
			


	elif model_21cm == 'tanh_EoR':
		if N21 == 2:
			labels=[r'$z_r$', r'$\Delta z$']

		elif N21 == 3:
			labels=[r'$a_{21}$ [mK]', r'$z_r$', r'$\Delta z$']




	fig = corner.corner(samples_cut[:,Nfg::], labels=labels, bins=50, label_kwargs={'fontsize':17}, levels=(0.68,0.95))
	#fig.set_size_inches(14,10)
	#path_plot_save = home_folder + '/Desktop/'
	#plt.savefig(path_plot_save + 'test.png', bbox_inches='tight')
	#plt.close()





	# , r'$\tau$', r'$\chi$'



	# Best fit parameters and 95% C.L.
	best_fit_parameters = np.zeros((Ndim,7))
	for i in range(len(samples_cut[0,:])):
		per = np.percentile(samples_cut[:,i], [50, 50-(68.27/2), 50+(68.27/2), 50-(95.45/2), 50+(95.45/2), 50-(99.73/2), 50+(99.73/2)], axis=0)
		print('best fit and 68% limits: ' + str(per[0]) + '+' + str(per[2]-per[0]) + str(per[1]-per[0]))
		best_fit_parameters[i,:] = np.copy(per)







	# Storing 21-cm models, residuals, and rms
	# ------------------------------------------------------
	#
	# Initializing arrays
	Tcosmo_all     = np.zeros((len(samples_cut[:,0])+1, len(v)))   # Array of 21cm models
	residuals_all  = np.zeros((len(samples_cut[:,0])+1, len(v)))   # Array of residuals
	rms_all        = np.zeros(len(samples_cut[:,0])+1)             # Array of RMS 

	# First, processing all the samples
	if model_21cm == 'gaussian_flattened_1':
		for i in range(len(samples_cut[:,0])):
			Tfg     = model_evaluate(model_fg, samples_cut[i,0:Nfg], v/vn)				
			if N21 > 3:
				tau0 = samples_cut[i, Nfg+3]
				if N21 > 4:
					tilt = samples_cut[i, Nfg+4]				
			Tcosmo  = model_eor_flattened_gaussian(v, model_type=int(model_21cm[-1]), T21=-samples_cut[i, Nfg]/1000, vr=samples_cut[i, Nfg+1], dv=samples_cut[i, Nfg+2], tau0=tau0, tilt=tilt)

			Tfull   = Tfg + Tcosmo
			rms     = np.sqrt(np.sum(((d-Tfull)[w>0])**2)/len(v[w>0]))

			Tcosmo_all[i,:]     = Tcosmo
			residuals_all[i,:]  = d - Tfull
			rms_all[i]          = rms			




	if model_21cm == 'tanh_EoR':
		for i in range(len(samples_cut[:,0])):
			Tfg     = model_evaluate(model_fg, samples_cut[i,0:Nfg], v/vn)

			if N21 == 2:
				Tcosmo, x1, x2 = model_eor(v, T21=a21_eor, model_type='tanh', zr=samples_cut[i, Nfg], dz=samples_cut[i, Nfg+1])

			elif N21 == 3:
				Tcosmo, x1, x2 = model_eor(v, T21=samples_cut[i, Nfg]/1000, model_type='tanh', zr=samples_cut[i, Nfg+1], dz=samples_cut[i, Nfg+2])

			Tfull   = Tfg + Tcosmo
			rms     = np.sqrt(np.sum(((d-Tfull)[w>0])**2)/len(v[w>0]))

			Tcosmo_all[i,:]     = Tcosmo
			residuals_all[i,:]  = d - Tfull
			rms_all[i]          = rms			




	# Now, for the best fit model
	Tfg     = model_evaluate(model_fg, best_fit_parameters[0:Nfg,1], v/vn)

	if model_21cm == 'gaussian_flattened_1':		
		if N21 > 3:
			tau0 = best_fit_parameters[Nfg+3,0]
			if N21 > 4:
				tilt = best_fit_parameters[Nfg+4,0]
		Tcosmo  = model_eor_flattened_gaussian(v, model_type=int(model_21cm[-1]), T21=-best_fit_parameters[Nfg,0]/1000, vr=best_fit_parameters[Nfg+1,0], dv=best_fit_parameters[Nfg+2,0], tau0=tau0, tilt=tilt)


	if model_21cm == 'tanh_EoR':
		if N21 == 2:
			Tcosmo, x1, x2 = model_eor(v, T21=a21_eor, model_type='tanh', zr=best_fit_parameters[Nfg,0], dz=best_fit_parameters[Nfg+1,0])

		elif N21 == 3:
			Tcosmo, x1, x2 = model_eor(v, T21=best_fit_parameters[Nfg,0]/1000, model_type='tanh', zr=best_fit_parameters[Nfg+1,0], dz=best_fit_parameters[Nfg+2,0])


	Tfull   = Tfg + Tcosmo
	rms     = np.sqrt(np.sum(((d-Tfull)[w>0])**2)/len(v[w>0]))

	Tcosmo_all[-1,:]     = Tcosmo
	residuals_all[-1,:]  = d - Tfull
	rms_all[-1]          = rms



	# Saving data
	if save == 'yes':

		save_file = home_folder + '/DATA/EDGES/results/low_band/products/MCMC_results/' + save_filename + '.hdf5'
		with h5py.File(save_file, 'w') as hf:

			hf.create_dataset('f',    data = v)
			hf.create_dataset('t',    data = d)
			hf.create_dataset('n',    data = n)
			hf.create_dataset('w',    data = w)
			hf.create_dataset('Nfg',  data = Nfg)
			hf.create_dataset('N21',  data = N21)
			hf.create_dataset('fn',   data = vn)

			hf.create_dataset('samples',               data = samples_cut)
			hf.create_dataset('best_fit_parameters',   data = best_fit_parameters)
			hf.create_dataset('models_21cm',           data = Tcosmo_all)
			hf.create_dataset('residuals',             data = residuals_all)
			hf.create_dataset('rms',                   data = rms_all)



	return v, d, n, w, Nfg, N21, vn, samples_cut, best_fit_parameters, Tcosmo_all, residuals_all, rms_all






















def read_low_band_MCMC(path_file):

	"""
	Sept 23, 2017

	"""

	with h5py.File(path_file,'r') as hf:
		#print([key for key in hf.keys()])

		hfx    = hf.get('f')
		f      = np.array(hfx)

		hfx    = hf.get('t')
		t      = np.array(hfx)

		hfx    = hf.get('n')
		n      = np.array(hfx)

		hfx    = hf.get('w')
		w      = np.array(hfx)

		hfx    = hf.get('Nfg')
		Nfg      = np.array(hfx)

		hfx    = hf.get('N21')
		N21    = np.array(hfx)

		hfx    = hf.get('fn')
		fn     = np.array(hfx)


		hfx     = hf.get('samples')
		samples = np.array(hfx)

		hfx     = hf.get('best_fit_parameters')
		par     = np.array(hfx)

		hfx     = hf.get('models_21cm')
		models  = np.array(hfx)

		hfx     = hf.get('residuals')
		res     = np.array(hfx)

		hfx     = hf.get('rms')
		rms     = np.array(hfx)


	return f, t, n, w, Nfg, N21, fn, samples, par, models, res, rms










def low_band_signature_search(vb, tb, wb, flow, fhigh, Nfg, SNR_or_errorbar, save='no', save_filename='xx', fg_model='EDGES_polynomial', vr_array=0, dv_array=0, tau_array=0, chi_array=0):

	"""
	Sept 23, 2017
	Previously known as 'test_low_band_signature_search'

	"""


	# Cutting data within desired range	
	v = vb[(vb>=flow) & (vb<=fhigh)]
	t = tb[(vb>=flow) & (vb<=fhigh)]
	w = wb[(vb>=flow) & (vb<=fhigh)]



	# Only use physical model if 5 polynomial terms are used
	if (fg_model == 'EDGES_polynomial'):
		fg_model1 = 'EDGES_polynomial'
		fg_model2 = 'EDGES_polynomial_plus_gaussian_frequency'
		message   = 'Using EDGES polynomial.'
		print('----------------------------------------------------------------------------')
		print(message)
		print('----------------------------------------------------------------------------')		


	elif (fg_model == 'Physical_model') and (Nfg == 5):
		fg_model1 = 'Physical_model'
		fg_model2 = 'Physical_model_plus_gaussian_frequency'
		message   = 'Using Physical model.'
		print('----------------------------------------------------------------------------')
		print(message)
		print('----------------------------------------------------------------------------')		


	elif (fg_model == 'Physical_model') and (Nfg != 5):
		fg_model1 = 'EDGES_polynomial'
		fg_model2 = 'EDGES_polynomial_plus_gaussian_frequency'
		message   = 'Using EDGES polynomial. Physical model is only used with 5 polynomial terms.'
		print('----------------------------------------------------------------------------')
		print(message)
		print('----------------------------------------------------------------------------')






	# Fitting just foreground
	p_fg   = fit_polynomial_fourier(fg_model1, v, t, Nfg, Weights=w)
	m_fg   = model_evaluate(fg_model1, p_fg[0], v)
	res_fg = t-m_fg
	rms_fg = np.sqrt(np.sum(res_fg[w>0]**2)/len(res_fg[w>0]))


	# Initializing output arrays
	par_all  = np.zeros((len(vr_array), len(dv_array), len(tau_array), len(chi_array)))
	dpar_all = np.zeros((len(vr_array), len(dv_array), len(tau_array), len(chi_array)))
	res_all  = np.zeros((len(vr_array), len(dv_array), len(tau_array), len(chi_array), len(v)))
	rms_all  = np.zeros((len(vr_array), len(dv_array), len(tau_array), len(chi_array)))

	# Sweep over frequency and duration and computing main results
	for j in range(len(vr_array)):
		for i in range(len(dv_array)):
			for k in range(len(tau_array)):
				for h in range(len(chi_array)):

					print([vr_array[j], dv_array[i], tau_array[k], chi_array[h]])

					p_full = fit_polynomial_fourier(fg_model2, v, t, Nfg, Weights=w, fr=vr_array[j], df=dv_array[i], gaussian_flatness_tau=tau_array[k], gaussian_flatness_tilt=chi_array[h])
					m_full = model_evaluate(fg_model2, p_full[0], v, fr=vr_array[j], df=dv_array[i], gaussian_flatness_tau=tau_array[k], gaussian_flatness_tilt=chi_array[h])
					r_full = t-m_full
					rms    = np.sqrt(np.sum(r_full[w>0]**2)/len(r_full[w>0]))

					par_all[j, i, k, h]   = -p_full[0][-1]
					dpar_all[j, i, k, h]  = np.sqrt(np.diag(p_full[3])[-1])
					res_all[j, i, k, h,:] = r_full
					rms_all[j, i, k, h]   = rms





	# Full signal-to-noise array
	SNR_all = par_all/dpar_all

	# Finding best fit parameters
	best_SNR  = 0
	best_rms  = 1e6
	best_d21  = 1e6
	flag = 0

	best_a21 = 0
	best_d21 = 0
	best_vr  = 0
	best_dv  = 0
	best_tau = 0
	best_chi = 0	

	best_res      = np.zeros(len(v))
	best_model_21 = np.zeros(len(v))	

	for j in range(len(vr_array)):
		for i in range(len(dv_array)):
			for k in range(len(tau_array)):
				for h in range(len(chi_array)):

					if (SNR_or_errorbar == 'SNR') and (SNR_all[j,i,k,h] > best_SNR):
						flag = 1

					elif (SNR_or_errorbar == 'errorbar') and (dpar_all[j,i,k,h] < best_d21):  # (rms_all[j,i] < RMS):
						flag = 1

					if flag == 1:
						best_SNR = SNR_all[j,i,k,h]
						best_rms = rms_all[j,i,k,h]
						best_d21 = dpar_all[j,i,k,h]

						best_a21 = par_all[j,i,k,h]
						#best_d21 = dpar_all[j,i,k,h]
						best_vr  = vr_array[j]
						best_dv  = dv_array[i]
						best_tau = tau_array[k]
						best_chi = chi_array[h]

						best_res      = res_all[j,i,k,h,:]
						best_model_21 = model_eor_flattened_gaussian(v, model_type=1, T21=best_a21, vr=best_vr, dv=best_dv, tau0=best_tau, tilt=best_chi)
						flag     = 0




	# Here, just displaying foreground model message again
	print('----------------------------------------------------------------------------')
	print(message)
	print('----------------------------------------------------------------------------')





	# Saving data
	if save == 'yes':

		save_file = home_folder + '/DATA/EDGES/results/low_band/products/SNR_search_results/' + save_filename + '.hdf5'
		with h5py.File(save_file, 'w') as hf:

			hf.create_dataset('v',              data = v)
			hf.create_dataset('t',              data = t)
			hf.create_dataset('w',              data = w)

			hf.create_dataset('res_fg',         data = res_fg)
			hf.create_dataset('rms_fg',         data = Nfg)

			hf.create_dataset('vr_array',       data = vr_array)
			hf.create_dataset('dv_array',       data = dv_array)
			hf.create_dataset('tau_array',      data = tau_array)
			hf.create_dataset('chi_array',      data = chi_array)

			hf.create_dataset('par_all',        data = par_all)
			hf.create_dataset('dpar_all',       data = dpar_all)
			hf.create_dataset('res_all',        data = res_all)
			hf.create_dataset('rms_all',        data = rms_all)
			hf.create_dataset('SNR_all',        data = SNR_all)

			hf.create_dataset('best_a21',       data = best_a21)
			hf.create_dataset('best_d21',       data = best_d21)
			hf.create_dataset('best_vr',        data = best_vr)
			hf.create_dataset('best_dv',        data = best_dv)
			hf.create_dataset('best_tau',       data = best_tau)
			hf.create_dataset('best_chi',       data = best_chi)
			hf.create_dataset('best_model_21',  data = best_model_21)
			hf.create_dataset('best_res',       data = best_res)
			hf.create_dataset('best_rms',       data = best_rms)
			hf.create_dataset('best_SNR',       data = best_SNR)


	return v, t, w, res_fg, rms_fg, vr_array, dv_array, tau_array, chi_array, par_all, dpar_all, res_all, rms_all, SNR_all, best_a21, best_d21, best_vr, best_dv, best_tau, best_chi, best_model_21, best_res, best_rms, best_SNR








def read_low_band_signature_search(path_file):

	"""
	Sept 23, 2017

	"""

	with h5py.File(path_file,'r') as hf:
		#print([key for key in hf.keys()])


		hfx    = hf.get('v')
		v      = np.array(hfx)

		hfx    = hf.get('t')
		t      = np.array(hfx)

		hfx    = hf.get('w')
		w      = np.array(hfx)

		hfx    = hf.get('res_fg')
		res_fg = np.array(hfx)

		hfx    = hf.get('rms_fg')
		rms_fg = np.array(hfx)


		hfx        = hf.get('vr_array')
		vr_array   = np.array(hfx)

		hfx        = hf.get('dv_array')
		dv_array   = np.array(hfx)

		hfx        = hf.get('tau_array')
		tau_array  = np.array(hfx)

		hfx        = hf.get('chi_array')
		chi_array  = np.array(hfx)


		hfx      = hf.get('par_all')
		par_all  = np.array(hfx)

		hfx      = hf.get('dpar_all')
		dpar_all = np.array(hfx)

		hfx      = hf.get('res_all')
		res_all  = np.array(hfx)

		hfx      = hf.get('rms_all')
		rms_all  = np.array(hfx)

		hfx      = hf.get('SNR_all')
		SNR_all  = np.array(hfx)


		hfx      = hf.get('best_a21')
		best_a21 = np.array(hfx)

		hfx      = hf.get('best_d21')
		best_d21 = np.array(hfx)

		hfx      = hf.get('best_vr')        
		best_vr  = np.array(hfx)

		hfx      = hf.get('best_dv')
		best_dv  = np.array(hfx)

		hfx      = hf.get('best_tau')
		best_tau = np.array(hfx)

		hfx      = hf.get('best_chi')
		best_chi = np.array(hfx)

		hfx           = hf.get('best_model_21')
		best_model_21 = np.array(hfx)

		hfx      = hf.get('best_res')
		best_res = np.array(hfx)

		hfx      = hf.get('best_rms')
		best_rms = np.array(hfx)

		hfx      = hf.get('best_SNR')
		best_SNR = np.array(hfx)



	return v, t, w, res_fg, rms_fg, vr_array, dv_array, tau_array, chi_array, par_all, dpar_all, res_all, rms_all, SNR_all, best_a21, best_d21, best_vr, best_dv, best_tau, best_chi, best_model_21, best_res, best_rms, best_SNR 
























def data_analysis_filter_RMS_GHA(GHA_orig, RMS, Npoly_terms=10, deltaRMS_K=1, GHA_bin=0.1, std_threshold=3, RMS_min=3.5, RMS_max=20):

	"""

	For this filter to work properly, it is necessary to use as many data points as possible

	"""

	#print(Npoly_terms)


	# GHA from 0 to 24
	GHA = np.copy(GHA_orig)
	if (np.min(GHA) < 0) & (np.max(GHA) < 12):
		GHA[GHA < 0] = GHA[GHA < 0] + 24

	# Initializing arrays
	GHA_bin_limits = np.arange(0,24+(GHA_bin/2), GHA_bin)
	index   = np.arange(len(GHA))
	weights = np.ones(len(GHA))


	# Preliminary filter
	weights[RMS < RMS_min] = 0
	weights[RMS > RMS_max] = 0


	# Fitting polynomial to RMS vs GHA for initial hard filter
	par     = np.polyfit(GHA[weights>0]/10, RMS[weights>0], Npoly_terms-1)
	model   = np.polyval(par, GHA/10)


	# Initial hard filter
	weights[(RMS < (model - deltaRMS_K)) | (RMS > (model + deltaRMS_K))] = 0	

	# Iterate 10 times. This is sufficient
	for k in range(10):

		# Sweep over GHA bins
		for i in range(len(GHA_bin_limits)-1):

			# Indices for data in bin
			index_set = index[(GHA>=GHA_bin_limits[i]) & (GHA<=GHA_bin_limits[i+1]) & (weights>0)]

			# Sweep over data in bin if there are more than 4 data points. Otherwise the < 4 points are left with weight = 1
			if len(index_set) > 4:
				median_RMS = np.median(RMS[index_set])
				std_RMS    = np.std(RMS[index_set])

				for j in range(len(index_set)):

					# Assign weight = 0 to points more than "std_threshold" sigma from the median for that pixel
					if np.abs(RMS[index_set[j]]-median_RMS) > (std_threshold * std_RMS):
						weights[index_set[j]] = 0

	return weights

















def data_analysis_low_band_spectral_index_fit(v, t, w, sigma, gamma_fit='no', p0=[5000, 2.5]):	
	"""
	This function uses non-linear least squares to fit the reference temperature and spectral index from the low-band data
	"""

	#out = spo.leastsq(data_analysis_low_band_spectral_index_fit_difference, x0, args=(v[w>0], t[w>0]), full_output=True)

	if gamma_fit == 'no':
		out = spo.curve_fit(power_law_model_no_gamma, v[w>0], t[w>0], p0=p0, sigma=sigma[w>0], absolute_sigma=True, method='lm')

		# Estimates
		p        = out[0]
		cov      = out[1]

		T0       = p[0]
		beta     = p[1]

		model     = power_law_model_no_gamma(v, T0, beta)
		residuals = t - model
		RMS_SQ    = np.sum((residuals[w>0])**2)/len(v[w>0])   # RMS squared
		full_cov  = RMS_SQ * cov
		dT0       = np.sqrt(np.diag(full_cov)[0]) 
		dbeta     = np.sqrt(np.diag(full_cov)[1])
		RMS       = np.sqrt(RMS_SQ)

		out = [T0, beta, dT0, dbeta, residuals, RMS]



	if gamma_fit == 'yes':
		out = spo.curve_fit(power_law_model_with_gamma, v[w>0], t[w>0], p0=p0, sigma=sigma[w>0], absolute_sigma=True, method='lm')	

		# Estimates
		p        = out[0]
		cov      = out[1]

		T0       = p[0]
		beta     = p[1]
		gamma    = p[2]

		model     = power_law_model_with_gamma(v, T0, beta, gamma)
		residuals = t - model
		RMS_SQ    = np.sum((residuals[w>0])**2)/len(v[w>0])   # RMS squared
		full_cov  = RMS_SQ * cov
		dT0       = np.sqrt(np.diag(full_cov)[0]) 
		dbeta     = np.sqrt(np.diag(full_cov)[1])
		dgamma    = np.sqrt(np.diag(full_cov)[2])
		RMS       = np.sqrt(RMS_SQ)

		out = [T0, beta, gamma, dT0, dbeta, dgamma, residuals, RMS]


	return out






def power_law_model_no_gamma(v, T0, beta, vref=75, Tcmb=2.725):	
	"""
	Power law model without gamma
	"""

	Tsky = T0*(v/vref)**beta    +    Tcmb

	return Tsky






def power_law_model_with_gamma(v, T0, beta, gamma, vref=75, Tcmb=2.725):	
	"""
	Power law model with gamma
	"""

	Tsky = T0*(v/vref)**((beta + gamma*np.log10(v/vref)))    +    Tcmb

	return Tsky


















def spectral_index_low_band(case, file_name):


	"""
	TO DO:
	1) Make the vector of noise standard deviation more realistic, derive from data
	2) Preinitialize 72xN arrays, and store results there, instead of current approach of accumulating

	This function works for one file at a time.  Keep it that way.
	file_name = '2017_085_00'

	"""


	if case == 3:
		path            = home_folder + '/DATA/EDGES/spectra/level3/low_band2_2017/NS_nominal/'
		case_RMS_filter = 3


	# Loading data
	f, t, w, m, r, par, rms = level3_read_raw_spectra(path + file_name + '.hdf5')


	# Weights based on RMS at each GHA
	weights = data_analysis_filter_RMS_GHA(case_RMS_filter, m[:,4], rms, GHA_bin=0.1, std_threshold=3)	
	t0   = t[weights>0,:]
	w0   = w[weights>0,:] 
	m0   = m[weights>0,:] 
	#r0   = r[weights>0,:] 
	#p0   = p[weights>0,:] 	
	#rms0 = rms[weights>0] 



	# Raw LST 
	# ------------------------------
	LST          = m0[:,3]
	LST[LST < 0] = LST[LST < 0] + 24	

	# Creating LST bins
	LST_centers = np.arange(0+(24/72)/2, 24, (24/72))
	LST_edges   = np.arange(0, 24+(24/72), (24/72))


	MOON_EL  = m0[:,8]
	MOON_LIM = 90       # no need for Moon cut

	# Compute spectral index at every LST bin

	flag = 0
	for i in range(len(LST_centers)):

		LST1 = LST_edges[i]
		LST2 = LST_edges[i+1]

		# LST (and MOON) cut	
		t   = t0[(LST >= LST1) & (LST < LST2) & (MOON_EL < MOON_LIM), :]
		w   = w0[(LST >= LST1) & (LST < LST2) & (MOON_EL < MOON_LIM), :]
		m   = m0[(LST >= LST1) & (LST < LST2) & (MOON_EL < MOON_LIM), :]
		#r   = r0[(LST >= LST1) & (LST < LST2) & (MOON_EL < MOON_LIM), :]
		#p   = p0[(LST >= LST1) & (LST < LST2) & (MOON_EL < MOON_LIM), :]
		#rms = rms0[(LST >= LST1) & (LST < LST2) & (MOON_EL < MOON_LIM)]


		# Number of traces to average
		Nav = len(t[:,0])

		# Print
		print(i+1)
		print('---' + str(Nav))



		if len(rms) > 1:
			# Spectral averaging
			tav, wav = spectral_averaging(t, w)


			# Parameter fit



			# HERE !!!!!
			# ------------------------------------------------
			# Make the vector of noise standard deviation more realistic
			sigma = 100*np.ones(len(f))
			# ------------------------------------------------



			out_no_gamma   = data_analysis_low_band_spectral_index_fit(f, tav, wav, sigma, gamma_fit='no',  p0=[5000, 2.5])
			out_yes_gamma  = data_analysis_low_band_spectral_index_fit(f, tav, wav, sigma, gamma_fit='yes', p0=[5000, 2.5, 0])


			T0   = out_no_gamma[0]
			b0   = out_no_gamma[1]
			dT0  = out_no_gamma[2]
			db0  = out_no_gamma[3]
			res0 = out_no_gamma[4]
			RMS0 = out_no_gamma[5]

			T1   = out_yes_gamma[0]
			b1   = out_yes_gamma[1]
			g1   = out_yes_gamma[2]
			dT1  = out_yes_gamma[3]
			db1  = out_yes_gamma[4]
			dg1  = out_yes_gamma[5]
			res1 = out_yes_gamma[6]
			RMS1 = out_yes_gamma[7]


			# Flag to identify the Sun elevation
			if np.max(m[:,6]) > -10:
				sun = 0

			elif np.max(m[:,6]) <= -10:
				sun = 1

			# Store results					
			if flag == 0:
				lst_all    = np.copy(LST_centers[i])
				sun_all    = np.copy(sun)
				Nav_all    = np.copy(Nav)
				wav_all    = np.copy(wav)

				res0_all = np.copy(res0)
				T0_all   = np.copy(T0)
				dT0_all  = np.copy(dT0)
				b0_all   = np.copy(b0)
				db0_all  = np.copy(db0)
				RMS0_all = np.copy(RMS0)

				res1_all = np.copy(res1)
				T1_all  = np.copy(T1)
				dT1_all = np.copy(dT1)
				b1_all  = np.copy(b1)
				db1_all = np.copy(db1)
				g1_all  = np.copy(g1)
				dg1_all = np.copy(dg1)
				RMS1_all = np.copy(RMS1)

				flag       = 1

			else:
				lst_all   = np.append(lst_all,  LST_centers[i])
				sun_all   = np.append(sun_all,  sun)
				Nav_all   = np.append(Nav_all,  Nav)
				wav_all   = np.vstack((wav_all, wav))

				res0_all    = np.vstack((res0_all,   res0))
				T0_all    = np.vstack((T0_all,   T0))
				dT0_all   = np.vstack((dT0_all,  dT0))
				b0_all    = np.vstack((b0_all,   b0))
				db0_all   = np.vstack((db0_all,  db0))
				RMS0_all  = np.vstack((RMS0_all, RMS0))

				res1_all    = np.vstack((res1_all,   res1))
				T1_all    = np.vstack((T1_all,   T1))
				dT1_all   = np.vstack((dT1_all,  dT1))
				b1_all    = np.vstack((b1_all,   b1))
				db1_all   = np.vstack((db1_all,  db1))
				g1_all    = np.vstack((g1_all,   g1))
				dg1_all   = np.vstack((dg1_all,  dg1))					
				RMS1_all  = np.vstack((RMS1_all, RMS1))			



	out = [f, lst_all, sun_all, Nav_all, wav_all, res0_all, T0_all, dT0_all, b0_all, db0_all, RMS0_all, res1_all, T1_all, dT1_all, b1_all, db1_all, g1_all, dg1_all, RMS1_all]


	return out






















def models_antenna_s11_remove_delay(band, antenna, f_MHz, antenna_s11_day = 87, model_type='polynomial', Nfit=9, MC_mag='no', MC_ang='no', sigma_mag=0.0001, sigma_ang_deg=0.1):    # Nfit=9, delay_0=0.17



	if (band == 'high_band_2015') and (antenna == 'fourpoint'):

		delay_0=0.089


		# Paths
		path_data = edges_folder + 'calibration/antenna_s11/high_band1/s11/corrected/'

		
		# 2015
		
		if (antenna_s11_day == 109):
			d = np.genfromtxt(path_data + '2015_109_07_39/average_2015_109_07_39.txt'); print('Antenna S11: 2015-109')
			
			
		if (antenna_s11_day == 119):
			d = np.genfromtxt(path_data + '2015_119_13_04/average_2015_119_13_04.txt'); print('Antenna S11: 2015-119')
		

		if (antenna_s11_day == 120):
			d = np.genfromtxt(path_data + '2015_120_14_05/average_2015_120_14_05.txt'); print('Antenna S11: 2015-120')


		if (antenna_s11_day == 123):
			d = np.genfromtxt(path_data + '2015_123_14_32/average_2015_123_14_32.txt'); print('Antenna S11: 2015-123')


		if (antenna_s11_day == 124):
			d = np.genfromtxt(path_data + '2015_124_13_27/average_2015_124_13_27.txt'); print('Antenna S11: 2015-124')		


		if (antenna_s11_day == 157):
			d = np.genfromtxt(path_data + '2015_157_03_51/S11_antenna_high_band_2015_157_03_51.txt'); print('Antenna S11: 2015-157')




	if (band == 'high_band_2015') and (antenna == 'blade'):

		delay_0=0.089


		# Paths
		path_data = home_folder + '/DATA/EDGES/calibration/antenna_s11/high_band1/s11/corrected/'		


		# 2015
	
		if (antenna_s11_day == 212):
			d = np.genfromtxt(path_data + '2015_212_18_55/average_2015_212_18_55.txt'); print('Antenna S11: 2015-212')

		if (antenna_s11_day == 262):
			d = np.genfromtxt(path_data + '2015_262_19_14/S11_blade_high_band_2015_262_19_14.txt'); print('Antenna S11: 2015-262')



		# 2016

		if (antenna_s11_day == 242):
			d = np.genfromtxt(path_data + '2016_242/S11_blade_high_band_2016_242.txt'); print('Antenna S11: 2016-242')












	if (band == 'low_band_2015') and (antenna == 'blade'):

		delay_0=0.175




		# Paths
		path_data = home_folder + 'calibration/antenna_s11/low_band1/s11/corrected/'


		# Original Ground Plane
		# ---------------------------------------

		# 2015

		if (antenna_s11_day == 289):
			d = np.genfromtxt(path_data + '2015_289_21_27/average_2015_289_21_27.txt'); print('Antenna S11: 2015-289')

		if (antenna_s11_day == 289.2):
			d = np.genfromtxt(path_data + '2015_289_21_27_cal2017/average_2015_289_21_27_cal2017.txt'); print('Antenna S11: 2015-289 -- Cal2017')



		if (antenna_s11_day == 342):
			d = np.genfromtxt(path_data + '2015_342_03_14/average_2015_342_03_14.txt'); print('Antenna S11: 2015-342')

		if (antenna_s11_day == 342.2):
			d = np.genfromtxt(path_data + '2015_342_03_14_cal2017/average_2015_342_03_14_cal2017.txt'); print('Antenna S11: 2015-342 -- Cal2017')



		if (antenna_s11_day == 175):
			d = np.genfromtxt(path_data + '2016_175_00/average_2016_175_00.txt'); print('Antenna S11: 2015-175')



		if (antenna_s11_day == 177):
			d = np.genfromtxt(path_data + '2016_177_00/average_2016_177_00.txt'); print('Antenna S11: 2015-177')

		if (antenna_s11_day == 177.2):
			d = np.genfromtxt(path_data + '2016_177_00_cal2017/average_2016_177_00_cal2017.txt'); print('Antenna S11: 2015-177 -- Cal2017')




		# Extended Ground Plane
		# ---------------------------------------

		# 2016
		if (antenna_s11_day == 243):
			d = np.genfromtxt(path_data + '2016_243/S11_blade_low_band_2016_243.txt'); print('Antenna S11: 2016-243')

		if (antenna_s11_day == 243.2):
			d = np.genfromtxt(path_data + '2016_243_cal2017/S11_blade_low_band_2016_243_cal2017.txt'); print('Antenna S11: 2016-243 -- Cal2017')

		if (antenna_s11_day == 243.3):
			d = np.genfromtxt(path_data + '2016_243_cal2017_08/S11_blade_low_band_2016_243_cal2017_08.txt'); print('Antenna S11: 2016-243 -- Cal2017-08')



		# 2017
		if (antenna_s11_day == 93):
			d = np.genfromtxt(path_data + '20170403_average/S11_blade_low_band_2017_093.txt'); print('Antenna S11: 2017-93')

		if (antenna_s11_day == 93.2):
			d = np.genfromtxt(path_data + '20170403_average_cal2017/S11_blade_low_band_2017_093_cal2017.txt'); print('Antenna S11: 2017-93 --- Cal2017')

		if (antenna_s11_day == 93.3):
			d = np.genfromtxt(path_data + '20170403_average_cal2017_08/S11_blade_low_band_2017_093_cal2017_08.txt'); print('Antenna S11: 2017-93 --- Cal2017-08')



		# After "problematic" receiver and switch recalibration at ASU

		if (antenna_s11_day == 152):
			d = np.genfromtxt(path_data + '20170601b/S11_blade_low_band_2017_152_using_2015_switch_parameters.txt'); print('Antenna S11: 2017-152')

		if (antenna_s11_day == 152.2):
			d = np.genfromtxt(path_data + '20170601/S11_blade_low_band_2017_152.txt'); print('Antenna S11: 2017-152 --- Cal2017')

		if (antenna_s11_day == 152.3):
			d = np.genfromtxt(path_data + '20170601_cal2017_08/S11_blade_low_band_2017_152_cal2017_08.txt'); print('Antenna S11: 2017-152 --- Cal2017-08')



		if (antenna_s11_day == 153):
			d = np.genfromtxt(path_data + 'low1_20170602_night3_b/S11_blade_low_band_2017_153_NIGHT_using_2015_switch_parameters.txt'); print('Antenna S11: 2017-153')

		if (antenna_s11_day == 153.2):
			d = np.genfromtxt(path_data + 'low1_20170602_night3/S11_blade_low_band_2017_153_NIGHT.txt'); print('Antenna S11: 2017-153 --- Cal2017')

		if (antenna_s11_day == 153.3):
			d = np.genfromtxt(path_data + 'low1_20170602_night3_cal2017_08/S11_blade_low_band_2017_153_NIGHT_cal2017_08.txt'); print('Antenna S11: 2017-153 --- Cal2017-08')




		if (antenna_s11_day == 172):
			d = np.genfromtxt(path_data + '2017-06-21-low1-onceperminute/S11_blade_low_band_2017_172_continuous_switch_2015.txt'); print('Antenna S11: 2017-172')		

		if (antenna_s11_day == 172.2):
			d = np.genfromtxt(path_data + '2017-06-21-low1-onceperminute/S11_blade_low_band_2017_172_continuous_switch_2017_05.txt'); print('Antenna S11: 2017-172 --- Cal2017')

		if (antenna_s11_day == 172.3):
			d = np.genfromtxt(path_data + '2017-06-21-low1-onceperminute_cal2017_08/S11_blade_low_band_2017_172_continuous_cal2017_08.txt'); print('Antenna S11: 2017-172 --- Cal2017-08')







	if (band == 'low_band2_2017') and (antenna == 'blade'):

		delay_0=0.175


		# Paths
		path_data = home_folder + '/DATA/EDGES/calibration/antenna_s11/low_band2/s11/corrected/'



		# NS with SHIELD
		# ----------------------------------------
		if (antenna_s11_day == 87):
			d = np.genfromtxt(path_data + 'low2-mar28-1/average_low2-mar28-1.txt'); print('Antenna S11: 2017-87')


		# EW with SHIELD
		# ----------------------------------------
		if (antenna_s11_day == 152.1):
			d = np.genfromtxt(path_data + 'low2-2017-06-01-thurs-ew-2/S11_blade_low_band_2017_152_BEFORE.txt'); print('Antenna S11: 2017-152 BEFORE BALUN MEASUREMENT')

		if (antenna_s11_day == 152.2):
			d = np.genfromtxt(path_data + 'low2-2017-06-01-thurs-ew-normalagain-2/S11_blade_low_band_2017_152_AFTER.txt'); print('Antenna S11: 2017-152 AFTER BALUN MEASUREMENT')

		if (antenna_s11_day == 153.1):
			d = np.genfromtxt(path_data + 'low2_20170602_friday_inpit2/S11_blade_low_band_2017_153_INPIT.txt'); print('Antenna S11: 2017-153 INPIT')

		if (antenna_s11_day == 153.2):
			d = np.genfromtxt(path_data + 'low2_20170602_friday_reconnect_after_vnainpit3/S11_blade_low_band_2017_153_NORMAL.txt'); print('Antenna S11: 2017-153 NORMAL AFTER INPIT')


		# EW no SHIELD
		# ----------------------------------------
		if (antenna_s11_day == 180):
			d = np.genfromtxt(path_data + '2017-06-29-low2-noshield_average/S11_blade_low_band_2017_180_NO_SHIELD.txt'); print('Antenna S11: 2017-180 NORMAL NO SHIELD')






	flow  = np.min(f_MHz)
	fhigh = np.max(f_MHz)

	d_cut = d[(d[:,0]>= flow*1e6) & (d[:,0]<= fhigh*1e6), :]


	f_orig_MHz = d_cut[:,0]/1e6
	s11    = d_cut[:,1] + 1j*d_cut[:,2]


	# Removing delay from S11
	delay = delay_0 * f_orig_MHz
	re_wd = np.abs(s11) * np.cos(delay + np.unwrap(np.angle(s11)))
	im_wd = np.abs(s11) * np.sin(delay + np.unwrap(np.angle(s11)))



	par_re_wd = np.polyfit(f_orig_MHz, re_wd, Nfit-1)
	par_im_wd = np.polyfit(f_orig_MHz, im_wd, Nfit-1)

	model_re_wd = np.polyval(par_re_wd, f_MHz)
	model_im_wd = np.polyval(par_im_wd, f_MHz)


	model_s11_wd = model_re_wd + 1j*model_im_wd
	ra    = model_s11_wd * np.exp(-1j*delay_0 * f_MHz)







	# Monte Carlo realizations
	# MC_mag='no', MC_ang='no', sigma_mag=0.0001, sigma_ang_deg=0.1
	if (MC_mag == 'yes') or (MC_ang == 'yes'):

		# Magnitude and angle
		abs_s11 = np.abs(ra)
		ang_s11 = np.angle(ra)


		# Uncertainty in magnitude
		if MC_mag == 'yes':
			noise     = np.random.uniform(np.zeros(len(f_MHz)), np.ones(len(f_MHz))) - 0.5
			nterms    = np.random.randint(1,16) # up to 15 terms
			par_poly  = np.polyfit(f_MHz/200, noise, nterms-1)
			poly      = np.polyval(par_poly, f_MHz/200)
			RMS       = np.sqrt(np.sum(np.abs(poly)**2)/len(poly))
			norm_poly = poly/RMS  # normalize to have RMS of ONE

			#sigma_mag = 0.0001	
			abs_s11   = abs_s11 + norm_poly*sigma_mag*np.random.normal()


		# Uncertainty in phase
		if MC_ang == 'yes':
			noise     = np.random.uniform(np.zeros(len(f_MHz)), np.ones(len(f_MHz))) - 0.5
			nterms    = np.random.randint(1,16) # up to 15 terms
			par_poly  = np.polyfit(f_MHz/200, noise, nterms-1)
			poly      = np.polyval(par_poly, f_MHz/200)
			RMS       = np.sqrt(np.sum(np.abs(poly)**2)/len(poly))
			norm_poly = poly/RMS  # normalize to have RMS of ONE

			#sigma_ang_deg = 0.1
			sigma_ang     = (np.pi/180)*sigma_ang_deg
			ang_s11       = ang_s11 + norm_poly*sigma_ang*np.random.normal()


		# MC realization of the antenna reflection coefficient
		ra = abs_s11 * (np.cos(ang_s11) + 1j*np.sin(ang_s11))






	return ra #, s11, f_orig_MHz

















def simulated_data_for_comparisons_with_alan():


	# Calibrated noisy input sky temperature
	ff, il, ih          = frequency_edges(50, 100)
	f                   = ff[il:ih+1]
	t21, x1, x2         = model_eor(f, T21=-0.5, model_type='gaussian_flattened_1', fr=75, df=20, tau0=7, tilt=0)
	tfg                 = 2000*(f/75)**(-2.5)
	tc_no_noise         = t21 + tfg
	noise               = 0 # np.random.normal(np.zeros(len(f)), 0.01)   # 10 mK noise
	tc                  = tc_no_noise + noise



	# Adding beam chromaticity
	GHA = 0

	# LST of Galactic Center
	LST_gc = 17 + (45/60) + (40.04/(60*60))

	# Conversion
	LST = GHA + LST_gc
	if LST > 24:
		LST = LST - 24

	# Adding beam
	#cf           = antenna_beam_factor_interpolation('low_band2_2017', np.array([LST]), f, case_beam_factor=22)
	cf = 1
	tc_with_beam = cf * tc


	# Antenna S11
	s11_ant = models_antenna_s11_remove_delay('low_band2_2017', 'blade', f, antenna_s11_day = 153, model_type='polynomial', Nfit=10, delay_0=0.175)	


	# Adding loss
	#cg                    = combined_gain('low_band2_2017', f, antenna_s11_day = 153, flag_ground_loss=1, ground_loss_type='value', ground_loss_percent=0.5, flag_antenna_loss=1, flag_balun_connector_loss=1)
	cg                    = 1
	Tambient              = 273 + 25
	tc_with_loss_and_beam = cg * tc_with_beam   +  Tambient*(1-cg) 


	# Receiver calibration quantities					
	s11_LNA, sca, off, TU, TC, TS = receiver_calibration('low_band2_2017', f, receiver_temperature=25, low_band_cal_file=1)	
	#sca = 1
	#off = 0


	# Undoing receiver calibration
	tunc = uncalibrated_antenna_temperature(tc_with_loss_and_beam, s11_ant, s11_LNA, sca, off, TU, TC, TS, Tamb_internal=300)

	#tcal = calibrated_antenna_temperature(tunc, s11_ant, s11_LNA, sca, off, TU, TC, TS, Tamb_internal=300)



	# Compute power ratio
	TL  = 300
	TNS = 350
	PR  = (tunc - TL) / TNS




	# Save
	outT = np.array([f, tc, tc_with_beam, tc_with_loss_and_beam, tunc, PR])
	out  = outT.T 
	np.savetxt(home_folder + '/Desktop/simulation_case5_six_columns_no_loss_no_beam_corruption_no_noise.txt', out, header='freq\tt1\tt2\tt3\tt4\tpower ratio')



	#TTUU = PR * TNS + TL
	#TTCC = calibrated_antenna_temperature(tunc, s11_ant, s11_LNA, sca, off, TU, TC, TS, Tamb_internal=300)

	return tc, tc_with_beam, tc_with_loss_and_beam, tunc, PR, TTUU, TTCC






















def low_band1_switch_correction_2017_07_25C(ant_s11, f_in = np.zeros([0,1]), verification = 'no', repetition=1):  

	"""


	"""



	# Loading measurements
	path_root_folder     = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band1/2017_07_15C_25C_35C/data/s11/raw/InternalSwitch/Lowband1_switch_rechar_July_2017/lowband1/25C/'

	if repetition == 1:
		path_folder = path_root_folder + 'pass01/NoAirline/'

	if repetition == 2:
		path_folder = path_root_folder + 'pass02/NoAirline/'


	# External Open
	o_sw_o, f = rc.s1p_read(path_folder + 'Open/Open.s1p')
	o_sw_s, f = rc.s1p_read(path_folder + 'Open/Short.s1p')
	o_sw_m, f = rc.s1p_read(path_folder + 'Open/Match.s1p')
	o_sw_e, f = rc.s1p_read(path_folder + 'Open/External.s1p')


	# Standards assumed at the switch
	sw_o =  1 * np.ones(len(f))
	sw_s = -1 * np.ones(len(f))
	sw_m =  0 * np.ones(len(f))	


	# Correction at the switch
	o_ex, xx1, xx2, xx3 = rc.de_embed(sw_o, sw_s, sw_m, o_sw_o, o_sw_s, o_sw_m, o_sw_e)	





	# External Short
	s_sw_o, f = rc.s1p_read(path_folder + 'Short/Open.s1p')
	s_sw_s, f = rc.s1p_read(path_folder + 'Short/Short.s1p')
	s_sw_m, f = rc.s1p_read(path_folder + 'Short/Match.s1p')
	s_sw_e, f = rc.s1p_read(path_folder + 'Short/External.s1p')

	# Correction at the switch
	s_ex, xx1, xx2, xx3 = rc.de_embed(sw_o, sw_s, sw_m, s_sw_o, s_sw_s, s_sw_m, s_sw_e)





	# External Match
	m_sw_o, f = rc.s1p_read(path_folder + 'Match/Open.s1p')
	m_sw_s, f = rc.s1p_read(path_folder + 'Match/Short.s1p')
	m_sw_m, f = rc.s1p_read(path_folder + 'Match/Match.s1p')
	m_sw_e, f = rc.s1p_read(path_folder + 'Match/External.s1p')

	# Correction at the switch
	m_ex, xx1, xx2, xx3 = rc.de_embed(sw_o, sw_s, sw_m, m_sw_o, m_sw_s, m_sw_m, m_sw_e)










	# Computation of S-parameters to the receiver input
	resistance_of_match  = 50.11 # male
	md = 1
	oa, sa, ma           = rc.agilent_85033E(f, resistance_of_match, md)
	xx, s11, s12s21, s22 = rc.de_embed(oa, sa, ma, o_ex, s_ex, m_ex, o_ex)









	## Loading measurements
	#path_root_folder     = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band1/2017_07_25C/data/s11/raw/InternalSwitch/Lowband1_switch_rechar_July_2017/lowband1/25C/'

	##if repetition == 1:
	#path_folder = path_root_folder + 'pass01/NoAirline/'




	# External Attn6
	a6_sw_o, f = rc.s1p_read(path_folder + '6dB/Open.s1p')
	a6_sw_s, f = rc.s1p_read(path_folder + '6dB/Short.s1p')
	a6_sw_m, f = rc.s1p_read(path_folder + '6dB/Match.s1p')
	a6_sw_e, f = rc.s1p_read(path_folder + '6dB/External.s1p')


	# External Attn10
	a10_sw_o, f = rc.s1p_read(path_folder + '10dB/Open.s1p')
	a10_sw_s, f = rc.s1p_read(path_folder + '10dB/Short.s1p')
	a10_sw_m, f = rc.s1p_read(path_folder + '10dB/Match.s1p')
	a10_sw_e, f = rc.s1p_read(path_folder + '10dB/External.s1p')







	# Polynomial fit of S-parameters from "f" to input frequency vector "f_in"
	# ------------------------------------------------------------------------


	# Frequency normalization
	fn = f/75e6

	if len(f_in) > 10:
		if f_in[0] > 1e5:
			fn_in = f_in/75e6
		elif f_in[-1] < 300:
			fn_in = f_in/75
	else:
		fn_in = fn	



	# Real-Imaginary parts
	real_s11    = np.real(s11)
	imag_s11    = np.imag(s11)
	real_s12s21 = np.real(s12s21)
	imag_s12s21 = np.imag(s12s21)
	real_s22    = np.real(s22)
	imag_s22    = np.imag(s22)



	# Polynomial fits
	N_poly_terms = 10     # 10 is the best number over 40-120 MHz
	p = np.polyfit(fn, real_s11, N_poly_terms-1)
	fit_real_s11 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s11, N_poly_terms-1)
	fit_imag_s11 = np.polyval(p, fn_in)


	p = np.polyfit(fn, real_s12s21, N_poly_terms-1)
	fit_real_s12s21 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s12s21, N_poly_terms-1)
	fit_imag_s12s21 = np.polyval(p, fn_in)


	p = np.polyfit(fn, real_s22, N_poly_terms-1)
	fit_real_s22 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s22, N_poly_terms-1)
	fit_imag_s22 = np.polyval(p, fn_in)


	fit_s11    = fit_real_s11    + 1j*fit_imag_s11
	fit_s12s21 = fit_real_s12s21 + 1j*fit_imag_s12s21
	fit_s22    = fit_real_s22    + 1j*fit_imag_s22



	# Corrected antenna S11
	corr_ant_s11 = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, ant_s11)






	# Verification
	if verification == 'yes':


		# OSL
		o_ex,  xx1, xx2, xx3 = rc.de_embed(sw_o, sw_s, sw_m, o_sw_o, o_sw_s, o_sw_m, o_sw_e)
		o_back               = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, o_ex)

		s_ex,  xx1, xx2, xx3 = rc.de_embed(sw_o, sw_s, sw_m, s_sw_o, s_sw_s, s_sw_m, s_sw_e)
		s_back               = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, s_ex)

		m_ex,  xx1, xx2, xx3 = rc.de_embed(sw_o, sw_s, sw_m, m_sw_o, m_sw_s, m_sw_m, m_sw_e)
		m_back               = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, m_ex)



		# Attenuators
		a6_ex,  xx1, xx2, xx3 = rc.de_embed(sw_o, sw_s, sw_m, a6_sw_o, a6_sw_s, a6_sw_m, a6_sw_e)
		a6  = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, a6_ex)

		a10_ex, xx1, xx2, xx3 = rc.de_embed(sw_o, sw_s, sw_m, a10_sw_o, a10_sw_s, a10_sw_m, a10_sw_e)		
		a10 = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, a10_ex)



		# From DC resistance
		DC_6dB  = 85.78
		DC_10dB = 60.66 

		gamma_6dB  = np.ones(len(f)) * rc.impedance2gamma(DC_6dB, 50)
		gamma_10dB = np.ones(len(f)) * rc.impedance2gamma(DC_10dB, 50)

		gamma_6dB_plus   = np.ones(len(f)) * rc.impedance2gamma(DC_6dB+0.01, 50)
		gamma_6dB_minus  = np.ones(len(f)) * rc.impedance2gamma(DC_6dB-0.01, 50)

		gamma_10dB_plus  = np.ones(len(f)) * rc.impedance2gamma(DC_10dB+0.01, 50)
		gamma_10dB_minus = np.ones(len(f)) * rc.impedance2gamma(DC_10dB-0.01, 50)








		# Plot
		plt.close()
		plt.close()
		plt.close()
		plt.close()


		# Agreement between models and calibrated measurements of Keysight OSL
		plt.figure(1, figsize=[18, 10])
		plt.subplot(2,3,1)
		plt.plot(f/1e6, 20*np.log10(np.abs(o_back)))
		plt.plot(f/1e6, 20*np.log10(np.abs(oa)), 'r')
		plt.xlim([50, 100])
		plt.grid()
		plt.title('OPEN')
		plt.ylabel('magnitude [dB]')
		plt.ylim([-0.0003, 0.0003])

		plt.subplot(2,3,2)
		plt.plot(f/1e6, 20*np.log10(np.abs(s_back)))
		plt.plot(f/1e6, 20*np.log10(np.abs(sa)), 'r')
		plt.xlim([50, 100])
		plt.grid()
		plt.title('SHORT')
		plt.ylim([-0.0085, -0.0055])

		plt.subplot(2,3,3)
		plt.plot(f/1e6, 20*np.log10(np.abs(m_back)))
		plt.plot(f/1e6, 20*np.log10(np.abs(ma)), 'r')
		plt.xlim([50, 100])
		plt.grid()
		plt.title('MATCH')
		plt.ylim([-57.8, -56.4])



		plt.subplot(2,3,4)
		plt.plot(f/1e6, (180/np.pi)*np.unwrap(np.angle(o_back)))
		plt.plot(f/1e6, (180/np.pi)*np.unwrap(np.angle(oa)), 'r')
		plt.xlim([50, 100])
		plt.grid()
		plt.ylabel('phase [deg]')
		plt.xlabel('frequency [MHz]')
		plt.ylim([-2.4, -1])

		plt.subplot(2,3,5)
		plt.plot(f/1e6, (180/np.pi)*np.unwrap(np.angle(s_back)))
		plt.plot(f/1e6, (180/np.pi)*np.unwrap(np.angle(sa)), 'r')
		plt.xlim([50, 100])
		plt.grid()
		plt.xlabel('frequency [MHz]')
		plt.ylim([177.6, 179])

		plt.subplot(2,3,6)
		plt.plot(f/1e6, (180/np.pi)*np.unwrap(np.angle(m_back)))
		plt.plot(f/1e6, (180/np.pi)*np.unwrap(np.angle(ma)), 'r')
		plt.xlim([50, 100])
		plt.grid()
		plt.xlabel('frequency [MHz]')
		plt.ylim([6, 9.5])

		# saving plot
		path = '/DATA/EDGES/results/plots/20170801/'
		plt.savefig(home_folder + path + 'c1.pdf', bbox_inches='tight')
		plt.close()			







		# Agreement between DC resistance and calibrated measurements of attenuators

		plt.figure(2, figsize=[9, 8])
		plt.subplot(2,1,1)
		plt.plot(f/1e6, 20*np.log10(np.abs(a6)))		
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB)), 'r')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB_plus)), 'r--')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB_minus)), 'r--')

		#plt.xlim([40, 200])
		plt.ylim([-11.600,-11.570])
		plt.grid()
		plt.legend(['at receiver input','from DC resistance', '+/- 0.01 Ohms'], loc=0)
		plt.ylabel('6-dB attenuator\n magnitude [dB]')

		ax = plt.gca()
		ax.ticklabel_format(useOffset=False)		



		plt.subplot(2,1,2)
		plt.plot(f/1e6, 20*np.log10(np.abs(a10)))
		plt.ylim([-20.34,-20.30])
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB)), 'r')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB_plus)), 'r--')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB_minus)), 'r--')

		#plt.xlim([40, 200])
		plt.grid()
		plt.xlabel('frequency [MHz]')
		plt.ylabel('10-dB attenuator\n magnitude [dB]')

		ax = plt.gca()
		ax.ticklabel_format(useOffset=False)


		# saving plot
		path = '/DATA/EDGES/results/plots/20170801/'
		plt.savefig(home_folder + path + 'c2.pdf', bbox_inches='tight')
		plt.close()	





		# ------- Fit quality of the S-parameters -------
		# -----------------------------------------------
		plt.figure(3, figsize=[20,12])

		plt.subplot(2,3,1)
		plt.plot(f/1e6, real_s11 - fit_real_s11)
		plt.title('S11')
		plt.grid()
		plt.ylabel(r'$\Delta$ real')
		plt.ylim([-4e-6, 4e-6])
		plt.xlim([50, 100])

		plt.subplot(2,3,4)
		plt.plot(f/1e6, imag_s11 - fit_imag_s11)
		plt.grid()
		plt.xlabel('frequency [MHz]')
		plt.ylabel(r'$\Delta$ imaginary')
		plt.ylim([-4e-6, 4e-6])
		plt.xlim([50, 100])


		plt.subplot(2,3,2)
		plt.plot(f/1e6, real_s12s21 - fit_real_s12s21)
		plt.grid()
		plt.title('S12S21')
		plt.ylim([-4e-5, 4e-5])
		plt.xlim([50, 100])

		plt.subplot(2,3,5)
		plt.plot(f/1e6, imag_s12s21 - fit_imag_s12s21)
		plt.grid()
		plt.xlabel('frequency [MHz]')
		plt.ylim([-4e-5, 4e-5])
		plt.xlim([50, 100])



		plt.subplot(2,3,3)
		plt.plot(f/1e6, real_s22 - fit_real_s22)
		plt.grid()
		plt.title('S22')
		plt.ylim([-4e-5, 4e-5])
		plt.xlim([50, 100])

		plt.subplot(2,3,6)
		plt.plot(f/1e6, imag_s22 - fit_imag_s22)
		plt.grid()
		plt.xlabel('frequency [MHz]')
		plt.ylim([-4e-5, 4e-5])
		plt.xlim([50, 100])


		# saving plot
		path = '/DATA/EDGES/results/plots/20170801/'
		plt.savefig(home_folder + path + 'c3.pdf', bbox_inches='tight')
		plt.close()	


	return (corr_ant_s11, fit_s11, fit_s12s21, fit_s22)



















def low_band1_switch_correction_2017_07_15C(ant_s11, f_in = np.zeros([0,1]), verification = 'no', repetition=1):  

	"""


	"""



	# Loading measurements
	path_root_folder     = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band1/2017_07_15C_25C_35C/data/s11/raw/InternalSwitch/Lowband1_switch_rechar_July_2017/lowband1/15C/'

	if repetition == 1:
		path_folder = path_root_folder + 'pass01/NoAirline/'


	# External Open
	o_sw_o, f = rc.s1p_read(path_folder + 'Open/Open.s1p')
	o_sw_s, f = rc.s1p_read(path_folder + 'Open/Short.s1p')
	o_sw_m, f = rc.s1p_read(path_folder + 'Open/Match.s1p')
	o_sw_e, f = rc.s1p_read(path_folder + 'Open/External.s1p')


	# Standards assumed at the switch
	sw_o =  1 * np.ones(len(f))
	sw_s = -1 * np.ones(len(f))
	sw_m =  0 * np.ones(len(f))	


	# Correction at the switch
	o_ex, xx1, xx2, xx3 = rc.de_embed(sw_o, sw_s, sw_m, o_sw_o, o_sw_s, o_sw_m, o_sw_e)	





	# External Short
	s_sw_o, f = rc.s1p_read(path_folder + 'Short/Open.s1p')
	s_sw_s, f = rc.s1p_read(path_folder + 'Short/Short.s1p')
	s_sw_m, f = rc.s1p_read(path_folder + 'Short/Match.s1p')
	s_sw_e, f = rc.s1p_read(path_folder + 'Short/External.s1p')

	# Correction at the switch
	s_ex, xx1, xx2, xx3 = rc.de_embed(sw_o, sw_s, sw_m, s_sw_o, s_sw_s, s_sw_m, s_sw_e)





	# External Match
	m_sw_o, f = rc.s1p_read(path_folder + 'Match/Open.s1p')
	m_sw_s, f = rc.s1p_read(path_folder + 'Match/Short.s1p')
	m_sw_m, f = rc.s1p_read(path_folder + 'Match/Match.s1p')
	m_sw_e, f = rc.s1p_read(path_folder + 'Match/External.s1p')

	# Correction at the switch
	m_ex, xx1, xx2, xx3 = rc.de_embed(sw_o, sw_s, sw_m, m_sw_o, m_sw_s, m_sw_m, m_sw_e)










	# Computation of S-parameters to the receiver input
	resistance_of_match  = 50.22   # 50.22 is the resistance at 15degC acording to Memo 97 by Leroy 
	md = 1
	oa, sa, ma           = rc.agilent_85033E(f, resistance_of_match, md)
	xx, s11, s12s21, s22 = rc.de_embed(oa, sa, ma, o_ex, s_ex, m_ex, o_ex)









	## Loading measurements
	#path_root_folder     = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band1/2017_07_25C/data/s11/raw/InternalSwitch/Lowband1_switch_rechar_July_2017/lowband1/25C/'

	##if repetition == 1:
	#path_folder = path_root_folder + 'pass01/NoAirline/'




	# External Attn6
	a6_sw_o, f = rc.s1p_read(path_folder + '6dB/Open.s1p')
	a6_sw_s, f = rc.s1p_read(path_folder + '6dB/Short.s1p')
	a6_sw_m, f = rc.s1p_read(path_folder + '6dB/Match.s1p')
	a6_sw_e, f = rc.s1p_read(path_folder + '6dB/External.s1p')


	# External Attn10
	a10_sw_o, f = rc.s1p_read(path_folder + '10dB/Open.s1p')
	a10_sw_s, f = rc.s1p_read(path_folder + '10dB/Short.s1p')
	a10_sw_m, f = rc.s1p_read(path_folder + '10dB/Match.s1p')
	a10_sw_e, f = rc.s1p_read(path_folder + '10dB/External.s1p')







	#corr_ant_s11 = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, ant_s11)










	# Polynomial fit of S-parameters from "f" to input frequency vector "f_in"
	# ------------------------------------------------------------------------


	# Frequency normalization
	fn = f/75e6

	if len(f_in) > 10:
		if f_in[0] > 1e5:
			fn_in = f_in/75e6
		elif f_in[-1] < 300:
			fn_in = f_in/75
	else:
		fn_in = fn	



	# Real-Imaginary parts
	real_s11    = np.real(s11)
	imag_s11    = np.imag(s11)
	real_s12s21 = np.real(s12s21)
	imag_s12s21 = np.imag(s12s21)
	real_s22    = np.real(s22)
	imag_s22    = np.imag(s22)



	# Polynomial fits
	N_poly_terms = 10     # 10 is the best number over 40-120 MHz
	p = np.polyfit(fn, real_s11, N_poly_terms-1)
	fit_real_s11 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s11, N_poly_terms-1)
	fit_imag_s11 = np.polyval(p, fn_in)


	p = np.polyfit(fn, real_s12s21, N_poly_terms-1)
	fit_real_s12s21 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s12s21, N_poly_terms-1)
	fit_imag_s12s21 = np.polyval(p, fn_in)


	p = np.polyfit(fn, real_s22, N_poly_terms-1)
	fit_real_s22 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s22, N_poly_terms-1)
	fit_imag_s22 = np.polyval(p, fn_in)


	fit_s11    = fit_real_s11    + 1j*fit_imag_s11
	fit_s12s21 = fit_real_s12s21 + 1j*fit_imag_s12s21
	fit_s22    = fit_real_s22    + 1j*fit_imag_s22



	# Corrected antenna S11
	corr_ant_s11 = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, ant_s11)






	# Verification
	if verification == 'yes':



		# Correction at the switch
		a6_ex,  xx1, xx2, xx3 = rc.de_embed(sw_o, sw_s, sw_m, a6_sw_o, a6_sw_s, a6_sw_m, a6_sw_e)
		a10_ex, xx1, xx2, xx3 = rc.de_embed(sw_o, sw_s, sw_m, a10_sw_o, a10_sw_s, a10_sw_m, a10_sw_e)		

		a6  = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, a6_ex)
		a10 = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, a10_ex)



		# From DC resistance
		DC_6dB  = 85.78
		DC_10dB = 60.66 

		gamma_6dB  = np.ones(len(f)) * rc.impedance2gamma(DC_6dB, 50)
		gamma_10dB = np.ones(len(f)) * rc.impedance2gamma(DC_10dB, 50)

		gamma_6dB_plus   = np.ones(len(f)) * rc.impedance2gamma(DC_6dB+0.01, 50)
		gamma_6dB_minus  = np.ones(len(f)) * rc.impedance2gamma(DC_6dB-0.01, 50)

		gamma_10dB_plus  = np.ones(len(f)) * rc.impedance2gamma(DC_10dB+0.01, 50)
		gamma_10dB_minus = np.ones(len(f)) * rc.impedance2gamma(DC_10dB-0.01, 50)



		# Plot
		plt.close()
		plt.close()
		plt.close()
		plt.close()


		plt.subplot(2,1,1)
		plt.plot(f/1e6, 20*np.log10(np.abs(a6)))		
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB)), 'r')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB_plus)), 'r--')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB_minus)), 'r--')

		#plt.xlim([40, 200])
		plt.ylim([-11.600,-11.580])
		plt.grid()
		plt.legend(['at receiver input','from DC resistance', '+/- 0.01 Ohms'], loc=0)
		plt.ylabel('6-dB attenuator\n magnitude [dB]')

		ax = plt.gca()
		ax.ticklabel_format(useOffset=False)		



		plt.subplot(2,1,2)
		plt.plot(f/1e6, 20*np.log10(np.abs(a10)))
		plt.ylim([-20.34,-20.31])
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB)), 'r')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB_plus)), 'r--')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB_minus)), 'r--')

		#plt.xlim([40, 200])
		plt.grid()
		plt.xlabel('frequency [MHz]')
		plt.ylabel('10-dB attenuator\n magnitude [dB]')

		ax = plt.gca()
		ax.ticklabel_format(useOffset=False)		



		#plt.subplot(2,2,2)
		#plt.plot(f/1e6, 20*np.log10(np.abs(a6c)))		
		#plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB)), 'r')
		#plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB_plus)), 'r--')
		#plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB_minus)), 'r--')
		##plt.xlim([50, 100])
		##plt.ylim([-11.69,-11.66])
		#plt.grid()

		#ax = plt.gca()
		#ax.ticklabel_format(useOffset=False)		



		#plt.subplot(2,2,4)
		#plt.plot(f/1e6, 20*np.log10(np.abs(a10c)))
		##plt.ylim([-20.22,-20.18])
		#plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB)), 'r')
		#plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB_plus)), 'r--')
		#plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB_minus)), 'r--')
		##plt.xlim([50, 100])
		#plt.grid()
		#plt.xlabel('frequency [MHz]')		

		#ax = plt.gca()
		#ax.ticklabel_format(useOffset=False)		



		# ------- Fit quality of the S-parameters -------
		# -----------------------------------------------
		plt.figure(2)

		plt.subplot(3,2,1)
		plt.plot(f/1e6, real_s11 - fit_real_s11)

		plt.subplot(3,2,2)
		plt.plot(f/1e6, imag_s11 - fit_imag_s11)

		plt.subplot(3,2,3)
		plt.plot(f/1e6, real_s12s21 - fit_real_s12s21)

		plt.subplot(3,2,4)
		plt.plot(f/1e6, imag_s12s21 - fit_imag_s12s21)

		plt.subplot(3,2,5)
		plt.plot(f/1e6, real_s22 - fit_real_s22)

		plt.subplot(3,2,6)
		plt.plot(f/1e6, imag_s22 - fit_imag_s22)






	return (corr_ant_s11, fit_s11, fit_s12s21, fit_s22)


























def low_band1_switch_correction_2017_07_35C(ant_s11, f_in = np.zeros([0,1]), verification = 'no', repetition=1):  

	"""


	"""



	# Loading measurements
	path_root_folder     = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band1/2017_07_15C_25C_35C/data/s11/raw/InternalSwitch/Lowband1_switch_rechar_July_2017/lowband1/35C/'

	if repetition == 1:
		path_folder = path_root_folder + 'pass01/NoAirline/'


	# External Open
	o_sw_o, f = rc.s1p_read(path_folder + 'Open/Open.s1p')
	o_sw_s, f = rc.s1p_read(path_folder + 'Open/Short.s1p')
	o_sw_m, f = rc.s1p_read(path_folder + 'Open/Match.s1p')
	o_sw_e, f = rc.s1p_read(path_folder + 'Open/External.s1p')


	# Standards assumed at the switch
	sw_o =  1 * np.ones(len(f))
	sw_s = -1 * np.ones(len(f))
	sw_m =  0 * np.ones(len(f))	


	# Correction at the switch
	o_ex, xx1, xx2, xx3 = rc.de_embed(sw_o, sw_s, sw_m, o_sw_o, o_sw_s, o_sw_m, o_sw_e)	





	# External Short
	s_sw_o, f = rc.s1p_read(path_folder + 'Short/Open.s1p')
	s_sw_s, f = rc.s1p_read(path_folder + 'Short/Short.s1p')
	s_sw_m, f = rc.s1p_read(path_folder + 'Short/Match.s1p')
	s_sw_e, f = rc.s1p_read(path_folder + 'Short/External.s1p')

	# Correction at the switch
	s_ex, xx1, xx2, xx3 = rc.de_embed(sw_o, sw_s, sw_m, s_sw_o, s_sw_s, s_sw_m, s_sw_e)





	# External Match
	m_sw_o, f = rc.s1p_read(path_folder + 'Match_cooler_load/Open.s1p')
	m_sw_s, f = rc.s1p_read(path_folder + 'Match_cooler_load/Short.s1p')
	m_sw_m, f = rc.s1p_read(path_folder + 'Match_cooler_load/Match.s1p')
	m_sw_e, f = rc.s1p_read(path_folder + 'Match_cooler_load/External.s1p')

	# Correction at the switch
	m_ex, xx1, xx2, xx3 = rc.de_embed(sw_o, sw_s, sw_m, m_sw_o, m_sw_s, m_sw_m, m_sw_e)










	# Computation of S-parameters to the receiver input
	resistance_of_match  = 50.11  #     At 35degC it is 50.00 acording to Memo 97 from Leroy 
	md = 1
	oa, sa, ma           = rc.agilent_85033E(f, resistance_of_match, md)
	xx, s11, s12s21, s22 = rc.de_embed(oa, sa, ma, o_ex, s_ex, m_ex, o_ex)









	## Loading measurements
	#path_root_folder     = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band1/2017_07_25C/data/s11/raw/InternalSwitch/Lowband1_switch_rechar_July_2017/lowband1/25C/'

	##if repetition == 1:
	#path_folder = path_root_folder + 'pass01/NoAirline/'




	# External Attn6
	a6_sw_o, f = rc.s1p_read(path_folder + '6dB/Open.s1p')
	a6_sw_s, f = rc.s1p_read(path_folder + '6dB/Short.s1p')
	a6_sw_m, f = rc.s1p_read(path_folder + '6dB/Match.s1p')
	a6_sw_e, f = rc.s1p_read(path_folder + '6dB/External.s1p')


	# External Attn10
	a10_sw_o, f = rc.s1p_read(path_folder + '10dB/Open.s1p')
	a10_sw_s, f = rc.s1p_read(path_folder + '10dB/Short.s1p')
	a10_sw_m, f = rc.s1p_read(path_folder + '10dB/Match.s1p')
	a10_sw_e, f = rc.s1p_read(path_folder + '10dB/External.s1p')







	#corr_ant_s11 = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, ant_s11)










	# Polynomial fit of S-parameters from "f" to input frequency vector "f_in"
	# ------------------------------------------------------------------------


	# Frequency normalization
	fn = f/75e6

	if len(f_in) > 10:
		if f_in[0] > 1e5:
			fn_in = f_in/75e6
		elif f_in[-1] < 300:
			fn_in = f_in/75
	else:
		fn_in = fn	



	# Real-Imaginary parts
	real_s11    = np.real(s11)
	imag_s11    = np.imag(s11)
	real_s12s21 = np.real(s12s21)
	imag_s12s21 = np.imag(s12s21)
	real_s22    = np.real(s22)
	imag_s22    = np.imag(s22)



	# Polynomial fits
	N_poly_terms = 10     # 10 is the best number over 40-120 MHz
	p = np.polyfit(fn, real_s11, N_poly_terms-1)
	fit_real_s11 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s11, N_poly_terms-1)
	fit_imag_s11 = np.polyval(p, fn_in)


	p = np.polyfit(fn, real_s12s21, N_poly_terms-1)
	fit_real_s12s21 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s12s21, N_poly_terms-1)
	fit_imag_s12s21 = np.polyval(p, fn_in)


	p = np.polyfit(fn, real_s22, N_poly_terms-1)
	fit_real_s22 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s22, N_poly_terms-1)
	fit_imag_s22 = np.polyval(p, fn_in)


	fit_s11    = fit_real_s11    + 1j*fit_imag_s11
	fit_s12s21 = fit_real_s12s21 + 1j*fit_imag_s12s21
	fit_s22    = fit_real_s22    + 1j*fit_imag_s22



	# Corrected antenna S11
	corr_ant_s11 = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, ant_s11)






	# Verification
	if verification == 'yes':



		# Correction at the switch
		a6_ex,  xx1, xx2, xx3 = rc.de_embed(sw_o, sw_s, sw_m, a6_sw_o, a6_sw_s, a6_sw_m, a6_sw_e)
		a10_ex, xx1, xx2, xx3 = rc.de_embed(sw_o, sw_s, sw_m, a10_sw_o, a10_sw_s, a10_sw_m, a10_sw_e)		

		a6  = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, a6_ex)
		a10 = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, a10_ex)



		# From DC resistance
		DC_6dB  = 85.78
		DC_10dB = 60.66 

		gamma_6dB  = np.ones(len(f)) * rc.impedance2gamma(DC_6dB, 50)
		gamma_10dB = np.ones(len(f)) * rc.impedance2gamma(DC_10dB, 50)

		gamma_6dB_plus   = np.ones(len(f)) * rc.impedance2gamma(DC_6dB+0.01, 50)
		gamma_6dB_minus  = np.ones(len(f)) * rc.impedance2gamma(DC_6dB-0.01, 50)

		gamma_10dB_plus  = np.ones(len(f)) * rc.impedance2gamma(DC_10dB+0.01, 50)
		gamma_10dB_minus = np.ones(len(f)) * rc.impedance2gamma(DC_10dB-0.01, 50)



		# Plot
		plt.close()
		plt.close()
		plt.close()
		plt.close()


		plt.subplot(2,1,1)
		plt.plot(f/1e6, 20*np.log10(np.abs(a6)))		
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB)), 'r')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB_plus)), 'r--')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB_minus)), 'r--')

		#plt.xlim([40, 200])
		plt.ylim([-11.600,-11.580])
		plt.grid()
		plt.legend(['at receiver input','from DC resistance', '+/- 0.01 Ohms'], loc=0)
		plt.ylabel('6-dB attenuator\n magnitude [dB]')

		ax = plt.gca()
		ax.ticklabel_format(useOffset=False)		



		plt.subplot(2,1,2)
		plt.plot(f/1e6, 20*np.log10(np.abs(a10)))
		plt.ylim([-20.34,-20.31])
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB)), 'r')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB_plus)), 'r--')
		plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB_minus)), 'r--')

		#plt.xlim([40, 200])
		plt.grid()
		plt.xlabel('frequency [MHz]')
		plt.ylabel('10-dB attenuator\n magnitude [dB]')

		ax = plt.gca()
		ax.ticklabel_format(useOffset=False)		



		#plt.subplot(2,2,2)
		#plt.plot(f/1e6, 20*np.log10(np.abs(a6c)))		
		#plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB)), 'r')
		#plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB_plus)), 'r--')
		#plt.plot(f/1e6, 20*np.log10(np.abs(gamma_6dB_minus)), 'r--')
		##plt.xlim([50, 100])
		##plt.ylim([-11.69,-11.66])
		#plt.grid()

		#ax = plt.gca()
		#ax.ticklabel_format(useOffset=False)		



		#plt.subplot(2,2,4)
		#plt.plot(f/1e6, 20*np.log10(np.abs(a10c)))
		##plt.ylim([-20.22,-20.18])
		#plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB)), 'r')
		#plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB_plus)), 'r--')
		#plt.plot(f/1e6, 20*np.log10(np.abs(gamma_10dB_minus)), 'r--')
		##plt.xlim([50, 100])
		#plt.grid()
		#plt.xlabel('frequency [MHz]')		

		#ax = plt.gca()
		#ax.ticklabel_format(useOffset=False)		



		# ------- Fit quality of the S-parameters -------
		# -----------------------------------------------
		plt.figure(2)

		plt.subplot(3,2,1)
		plt.plot(f/1e6, real_s11 - fit_real_s11)

		plt.subplot(3,2,2)
		plt.plot(f/1e6, imag_s11 - fit_imag_s11)

		plt.subplot(3,2,3)
		plt.plot(f/1e6, real_s12s21 - fit_real_s12s21)

		plt.subplot(3,2,4)
		plt.plot(f/1e6, imag_s12s21 - fit_imag_s12s21)

		plt.subplot(3,2,5)
		plt.plot(f/1e6, real_s22 - fit_real_s22)

		plt.subplot(3,2,6)
		plt.plot(f/1e6, imag_s22 - fit_imag_s22)






	return (corr_ant_s11, fit_s11, fit_s12s21, fit_s22)







# data_analysis_model_rejection_detection: 37958


















def low_band1_switch_correction_2017_08_15C_25C_35C(ant_s11, f_in = np.zeros([0,1]), Tswitch = 25):  

	"""

	August 31, 2017

	Measurements conducted by Leroy around August 20 Using VNA E5072A

	"""




	# Loading measurements
	path_folder     = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band1/2017_08_15C_25C_35C/data/s11/raw/Receiver_1_SP4T_Test_3/'


	if Tswitch == 15:
		dir_temp = '15C/'
		resistance_of_match  = 50.12 + 0.05  # assuming physical temp. of load of 20degC, and variation of 0.01 ohm per degree	

	elif Tswitch == 25:
		dir_temp = '25C/'
		resistance_of_match  = 50.12

	elif Tswitch == 35:
		dir_temp = '35C/'
		resistance_of_match  = 50.12 - 0.05  # assuming physical temp. of load of 30degC, and variation of 0.01 ohm per degree




	# External Open
	o_sw_o, f = rc.s1p_read(path_folder + dir_temp + 'Open/Open.S1P')
	o_sw_s, f = rc.s1p_read(path_folder + dir_temp + 'Open/Short.S1P')
	o_sw_m, f = rc.s1p_read(path_folder + dir_temp + 'Open/Match.S1P')
	o_sw_e, f = rc.s1p_read(path_folder + dir_temp + 'Open/External.S1P')

	# Standards assumed at the switch
	sw_o =  1 * np.ones(len(f))
	sw_s = -1 * np.ones(len(f))
	sw_m =  0 * np.ones(len(f))	

	# Correction at the switch
	o_ex, xx1, xx2, xx3 = rc.de_embed(sw_o, sw_s, sw_m, o_sw_o, o_sw_s, o_sw_m, o_sw_e)	




	# External Short
	s_sw_o, f = rc.s1p_read(path_folder + dir_temp + 'Short/Open.S1P')
	s_sw_s, f = rc.s1p_read(path_folder + dir_temp + 'Short/Short.S1P')
	s_sw_m, f = rc.s1p_read(path_folder + dir_temp + 'Short/Match.S1P')
	s_sw_e, f = rc.s1p_read(path_folder + dir_temp + 'Short/External.S1P')

	# Correction at the switch
	s_ex, xx1, xx2, xx3 = rc.de_embed(sw_o, sw_s, sw_m, s_sw_o, s_sw_s, s_sw_m, s_sw_e)




	# External Match
	m_sw_o, f = rc.s1p_read(path_folder + dir_temp + 'Match/Open.S1P')
	m_sw_s, f = rc.s1p_read(path_folder + dir_temp + 'Match/Short.S1P')
	m_sw_m, f = rc.s1p_read(path_folder + dir_temp + 'Match/Match.S1P')
	m_sw_e, f = rc.s1p_read(path_folder + dir_temp + 'Match/External.S1P')

	# Correction at the switch
	m_ex, xx1, xx2, xx3 = rc.de_embed(sw_o, sw_s, sw_m, m_sw_o, m_sw_s, m_sw_m, m_sw_e)





	# Computation of S-parameters to the receiver input

	md = 1
	oa, sa, ma           = rc.agilent_85033E(f, resistance_of_match, md)
	xx, s11, s12s21, s22 = rc.de_embed(oa, sa, ma, o_ex, s_ex, m_ex, o_ex)








	# Polynomial fit of S-parameters from "f" to input frequency vector "f_in"
	# ------------------------------------------------------------------------

	# Frequency normalization
	fn = f/75e6

	if len(f_in) > 10:
		if f_in[0] > 1e5:
			fn_in = f_in/75e6
		elif f_in[-1] < 300:
			fn_in = f_in/75
	else:
		fn_in = fn	



	# Real-Imaginary parts of the S-parameters
	real_s11    = np.real(s11)
	imag_s11    = np.imag(s11)
	real_s12s21 = np.real(s12s21)
	imag_s12s21 = np.imag(s12s21)
	real_s22    = np.real(s22)
	imag_s22    = np.imag(s22)



	# Polynomial fits
	N_poly_terms = 10     # 10 is the best number over 40-120 MHz

	p = np.polyfit(fn, real_s11, N_poly_terms-1)
	fit_real_s11 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s11, N_poly_terms-1)
	fit_imag_s11 = np.polyval(p, fn_in)



	p = np.polyfit(fn, real_s12s21, N_poly_terms-1)
	fit_real_s12s21 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s12s21, N_poly_terms-1)
	fit_imag_s12s21 = np.polyval(p, fn_in)



	p = np.polyfit(fn, real_s22, N_poly_terms-1)
	fit_real_s22 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s22, N_poly_terms-1)
	fit_imag_s22 = np.polyval(p, fn_in)



	fit_s11    = fit_real_s11    + 1j*fit_imag_s11
	fit_s12s21 = fit_real_s12s21 + 1j*fit_imag_s12s21
	fit_s22    = fit_real_s22    + 1j*fit_imag_s22




	# Corrected antenna S11
	corr_ant_s11 = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, ant_s11)



	return (corr_ant_s11, fit_s11, fit_s12s21, fit_s22)




























def model_eor_mesinger(model_number, freq_interp, interpolation_kind='linear'):

	"""
	Sept 27, 2017
	"""

	# The frequency range of the models is:     40-202 MHz

	# Loading data
	print('Model number: ' + str(model_number))  # from 0 to 9,999	
	data_folder = home_folder + '/DATA/EDGES/global_21cm_models/mesinger3/GlobalHistoryDatabase/'
	d = np.genfromtxt(data_folder + 'AveData_0.000000_' + str(model_number) + '.000000.txt')
	z_raw     = d[:,0]
	xhi_raw   = d[:,1]
	model_raw = d[:,2]/1000

	# Frequency vector
	freq_raw = redshift2frequency(z_raw)

	# Removing data above 200 MHz, since some of them have obvious artifacts
	freq  = freq_raw[freq_raw<=200]
	z     = z_raw[freq_raw<=200]
	xhi   = xhi_raw[freq_raw<=200]
	model = model_raw[freq_raw<=200]

	# Interpolation of model	
	func_xhi   = spi.interp1d(freq, xhi, kind=interpolation_kind)	
	xhi_interp = func_xhi(freq_interp)

	func_model   = spi.interp1d(freq, model, kind=interpolation_kind)	
	model_interp = func_model(freq_interp)

	# Using this format for compatibility
	ao = (xhi_interp)  

	return model_interp, ao




def model_rejection_mesinger():

	# Loading High-band data
	d = np.genfromtxt('/home/ramo7131/DATA/EDGES/results/high_band/products/average_spectrum/high_band_2015_LST_0.26_6.26_dates_2015_250_299_nominal.txt')	
	Nfg  = 5


	# Probing models
	out_rs = np.zeros((10000,3))
	for i in range(10000):
		print(i)
		model_number = i
		model21, aux = model_eor_mesinger(model_number, d[:,0], interpolation_kind='linear')

		par      = fit_polynomial_fourier('EDGES_polynomial_plus_external', d[:,0], d[:,1], Nfg, Weights=d[:,2], external_model_in_K=model21)
		p21      = par[0][-1]
		dp21_old = np.sqrt(np.diag(par[3])[-1])

		dp21 = (35/17)*dp21_old

		rs = (1-p21)/dp21
		cz = p21/dp21

		out_rs[i,0] = i
		out_rs[i,1] = rs
		out_rs[i,2] = cz


	# Saving results		
	path_file = home_folder + '/DATA/EDGES/results/high_band/products/model_rejection/mesinger/first_pass_10000/first_pass_10000.txt'

	header = 'model_number\trejection_significance\tconsistency_with_zero'
	np.savetxt(path_file, out_rs, header=header)

	print('File saved to: ' + path_file)		


	return out_rs













def model_eor_anastasia_16000(model_number, fnew, interpolation_kind='linear'):

	"""

	Oct 9, 2017

	"""

	# Loading set of models
	path_file = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/global21cm_v1_original_models/Data.mat'
	d         = sio.loadmat(path_file)
	data_all  = d['Data']

	# Loading set of parameters
	path_file = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/global21cm_v1_original_models/Params.mat'
	p         = sio.loadmat(path_file)
	par_all   = p['Params']


	# Selecting model number
	model     = data_all[model_number,:]	
	par       = par_all[model_number,:]

	# Interpolating to input frequency
	z          = np.arange(5, 50.1, 0.1)
	freq       = redshift2frequency(z)
	func_model = spi.interp1d(freq, model, kind=interpolation_kind)
	mnew       = func_model(fnew)


	return mnew/1000, par







def model_rejection_anastasia_16000():

	# Loading High-band data
	d = np.genfromtxt('/home/ramo7131/DATA/EDGES/results/high_band/products/average_spectrum/high_band_2015_LST_0.26_6.26_dates_2015_250_299_nominal.txt')	
	Nfg  = 5


	# Probing models
	out = np.zeros((16310,10))
	for i in range(16310):
		print(i+1)
		model_number = i
		model21, par21 = model_eor_anastasia_16000(model_number, d[:,0], interpolation_kind='linear')

		par      = fit_polynomial_fourier('EDGES_polynomial_plus_external', d[:,0], d[:,1], Nfg, Weights=d[:,2], external_model_in_K=model21)
		p21      = par[0][-1]
		dp21_old = np.sqrt(np.diag(par[3])[-1])

		dp21 = (35/17)*dp21_old

		rs = (1-p21)/dp21
		cz = p21/dp21

		out[i,0] = i+1
		out[i,1] = rs
		out[i,2] = cz
		out[i,3::] = par21


	# Saving results		
	path_file = home_folder + '/DATA/EDGES/results/high_band/products/model_rejection/global_21cm_anastasia/original_models_16000/results.txt'

	header = 'model_number\trejection_significance\tconsistency_with_zero\tP1\tP2\tP3\tP4\tP5\tP6\tP7'
	np.savetxt(path_file, out, header=header)

	print('File saved to: ' + path_file)

	return out












def high_band_SVD():

	v, t, w, d, at, ah, rc, rm  = level3_read(home_folder + '/DATA/EDGES/spectra/level3/high_band_2015/results_paper_1/high_band_2015_LST_0.26_6.26_dates_2015_250_299_nominal.hdf5')
	avt, avw = spectral_averaging(t, w)
	vb, tb, wb = data_analysis_spectrum_high_to_low_resolution(v, avt, avw, pre_rfi_flagging='yes', post_rfi_flagging='yes')
	tb_all = tb.reshape(-1,1)
	wb_all = wb.reshape(-1,1)

	par     = fit_polynomial_fourier('EDGES_polynomial', vb, tb, 5, Weights=wb)
	model   = par[1]
	RMS     = np.sqrt(np.sum(((tb-model)[wb>0])**2)/np.sum(len(vb)))
	RMS_all = np.copy(RMS)

	for i in range(100):
		print('MCMC: ' + str(i+1))

		v, t, w, d, at, ah, rc, rm = level3_read(home_folder + '/DATA/EDGES/spectra/level3/high_band_2015/results_paper_1/high_band_2015_LST_0.26_6.26_dates_2015_250_299_MC' + str(i+1) + '.hdf5')
		avt, avw   = spectral_averaging(t, w)
		vb, tb, wb = data_analysis_spectrum_high_to_low_resolution(v, avt, avw, pre_rfi_flagging='yes', post_rfi_flagging='yes')
		tb_all     = np.hstack((tb_all, tb.reshape(-1,1)))
		wb_all     = np.hstack((wb_all, wb.reshape(-1,1)))		

		par     = fit_polynomial_fourier('EDGES_polynomial', vb, tb, 5, Weights=wb)
		model   = par[1]
		RMS     = np.sqrt(np.sum(((tb-model)[wb>0])**2)/np.sum(len(vb)))
		RMS_all = np.append(RMS_all, RMS)


	return vb, tb_all, wb_all, RMS_all

























def low_band1_s11_calibration_measurements_2017_09_25C(flow, fhigh, save='no', flag=''):

	"""

	Oct 6, 2017

	"""




	# Data paths
	main_path    = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band1/2017_09_25C/data/s11/raw/'

	path_LNA     = main_path + 'Receiver/'
	path_ambient = main_path + 'AmbientLoad/'
	path_hot     = main_path + 'HotLoad/'
	path_open    = main_path + 'LongCableOpen/'
	path_shorted = main_path + 'LongCableShort/'
	path_sim2    = main_path + 'AntSim2/'



	# ------- Receiver S11 ------------------------

	# Reading measurements
	o,   fr0  = rc.s1p_read(path_LNA + 'open02.s1p')           # 2nd repetition is a little better
	s,   fr0  = rc.s1p_read(path_LNA + 'short02.s1p')
	l,   fr0  = rc.s1p_read(path_LNA + 'match02.s1p')
	LNA0, fr0 = rc.s1p_read(path_LNA + 'receiver02.s1p')


	# Models of standards
	resistance_of_match = 49.99 # female
	md = 1
	oa, sa, la = rc.agilent_85033E(fr0, resistance_of_match, md)

	# Correction of measurements
	LNAc, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA0)

	LNA = LNAc[(fr0/1e6>=flow) & (fr0/1e6<=fhigh)]
	fr  = fr0[(fr0/1e6>=flow) & (fr0/1e6<=fhigh)]






	# Calibration loads
	# ---------------------------------------------------------------------------------------------------

	# Ambient load
	# -------------------
	o_m,  f_a = rc.s1p_read(path_ambient + 'open02.s1p')         # 2nd repetition is a little better
	s_m,  f_a = rc.s1p_read(path_ambient + 'short02.s1p')
	l_m,  f_a = rc.s1p_read(path_ambient + 'match02.s1p')
	a_m,  f_a = rc.s1p_read(path_ambient + 'external02.s1p')

	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_a))
	s_sw = -1 * np.ones(len(f_a))
	l_sw =  0 * np.ones(len(f_a))

	# Correction at switch
	a_sw_c, x1, x2, x3 = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, a_m)

	# Correction at receiver input
	a_cc = low_band1_switch_correction_2017_08_15C_25C_35C(a_sw_c, f_in = f_a, Tswitch = 25)
	a_c  = a_cc[0]

	a  = a_c[(f_a/1e6>=flow) & (f_a/1e6<=fhigh)]
	fa = f_a[(f_a/1e6>=flow) & (f_a/1e6<=fhigh)]






	# Hot load
	# -------------------
	o_m,  f_h = rc.s1p_read(path_hot + 'open02.s1p')          # 2nd repetition is a little better
	s_m,  f_h = rc.s1p_read(path_hot + 'short02.s1p')
	l_m,  f_h = rc.s1p_read(path_hot + 'match02.s1p')
	h_m,  f_h = rc.s1p_read(path_hot + 'external02.s1p')

	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_h))
	s_sw = -1 * np.ones(len(f_h))
	l_sw =  0 * np.ones(len(f_h))

	# Correction at switch
	h_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, h_m)

	# Correction at receiver input
	h_cc = low_band1_switch_correction_2017_08_15C_25C_35C(h_sw_c, f_in = f_a, Tswitch = 25)
	h_c  = h_cc[0]

	h  = h_c[(f_h/1e6>=flow) & (f_h/1e6<=fhigh)]
	fh = f_h[(f_h/1e6>=flow) & (f_h/1e6<=fhigh)]










	# Open Cable 
	# -------------------
	o_m,  f_oc = rc.s1p_read(path_open + 'open02.s1p')        # Using 2nd repetition for consistency
	s_m,  f_oc = rc.s1p_read(path_open + 'short02.s1p')
	l_m,  f_oc = rc.s1p_read(path_open + 'match02.s1p')
	oc_m, f_oc = rc.s1p_read(path_open + 'external02.s1p')

	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_oc))
	s_sw = -1 * np.ones(len(f_oc))
	l_sw =  0 * np.ones(len(f_oc))

	# Correction at switch
	oc_sw_c, x1, x2, x3 = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, oc_m)

	# Correction at receiver input
	oc_cc = low_band1_switch_correction_2017_08_15C_25C_35C(oc_sw_c, f_in = f_oc, Tswitch = 25)
	oc_c  = oc_cc[0]

	oc  = oc_c[(f_oc/1e6>=flow) & (f_oc/1e6<=fhigh)]
	foc = f_oc[(f_oc/1e6>=flow) & (f_oc/1e6<=fhigh)]








	# Shorted Cable
	# -------------------
	o_m,  f_sc = rc.s1p_read(path_shorted + 'open02.s1p')        # Using 2nd repetition for consistency
	s_m,  f_sc = rc.s1p_read(path_shorted + 'short02.s1p')
	l_m,  f_sc = rc.s1p_read(path_shorted + 'match02.s1p')
	sc_m, f_sc = rc.s1p_read(path_shorted + 'external02.s1p')

	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_sc))
	s_sw = -1 * np.ones(len(f_sc))
	l_sw =  0 * np.ones(len(f_sc))

	# Correction at switch
	sc_sw_c, x1, x2, x3 = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, sc_m)

	# Correction at receiver input
	sc_cc = low_band1_switch_correction_2017_08_15C_25C_35C(sc_sw_c, f_in = f_sc, Tswitch = 25)
	sc_c  = sc_cc[0]

	sc  = sc_c[(f_sc/1e6>=flow) & (f_sc/1e6<=fhigh)]
	fsc = f_sc[(f_sc/1e6>=flow) & (f_sc/1e6<=fhigh)]







	# Antenna Simulator 2 before               
	# --------------------------
	o_m,  f_q2 = rc.s1p_read(path_sim2 + 'open01.s1p')          # Using 2nd repetition for consistency
	s_m,  f_q2 = rc.s1p_read(path_sim2 + 'short01.s1p')
	l_m,  f_q2 = rc.s1p_read(path_sim2 + 'match01.s1p')
	q2_m, f_q2 = rc.s1p_read(path_sim2 + 'external01.s1p')

	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_q2))
	s_sw = -1 * np.ones(len(f_q2))
	l_sw =  0 * np.ones(len(f_q2))

	# Correction at switch
	q2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, q2_m)

	# Correction at receiver input
	q2_cc = low_band1_switch_correction_2017_08_15C_25C_35C(q2_sw_c, f_in = f_q2, Tswitch = 25)
	q2_c  = q2_cc[0]

	q2  = q2_c[(f_q2/1e6>=flow) & (f_q2/1e6<=fhigh)]
	fq2 = f_q2[(f_q2/1e6>=flow) & (f_q2/1e6<=fhigh)]








	# Saving
	# ---------------------------------------------
	if save == 'yes':

		# Loading S-parameters of semi-rigid cable (they are at 1 MHz)
		# --------------------------------------------------------------
		spar0      = np.genfromtxt(home_folder + '/DATA/EDGES/calibration/receiver_calibration/high_band1/2015_03_25C/data/S11/corrected_delay/semi_rigid_s_parameters.txt')
		f_sr0      = spar0[:, 0]
		spar       = spar0[(f_sr0>=flow) & (f_sr0<=fhigh), :]

		xf_sr       = spar[:, 0]
		xs11_srr    = spar[:, 1]
		xs11_sri    = spar[:, 2]
		xs12s21_srr = spar[:, 3]
		xs12s21_sri = spar[:, 4]
		xs22_srr    = spar[:, 5]
		xs22_sri    = spar[:, 6]

		# Best fit is with 5 terms over 40-120 MHz
		pp = np.polyfit(xf_sr, xs11_srr, 4);     s11r    = np.polyval(pp, fr/1e6)
		pp = np.polyfit(xf_sr, xs11_sri, 4);     s11i    = np.polyval(pp, fr/1e6)
		pp = np.polyfit(xf_sr, xs12s21_srr, 4);  s12s21r = np.polyval(pp, fr/1e6)
		pp = np.polyfit(xf_sr, xs12s21_sri, 4);  s12s21i = np.polyval(pp, fr/1e6)
		pp = np.polyfit(xf_sr, xs22_srr, 4);     s22r    = np.polyval(pp, fr/1e6)
		pp = np.polyfit(xf_sr, xs22_sri, 4);     s22i    = np.polyval(pp, fr/1e6)




		# Now, saving data
		temp = np.array([ fr/1e6, 
		                  np.real(LNA),  np.imag(LNA),
		                  np.real(a),    np.imag(a),    np.real(h),    np.imag(h),
		                  np.real(oc),   np.imag(oc),   np.real(sc),   np.imag(sc),
		                  s11r,          s11i,          s12s21r,       s12s21i,        s22r,         s22i,
		                  np.real(q2),  np.imag(q2)])

		output_file     = temp.T
		save_path       = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band1/2017_09_25C/data/s11/corrected/'
		temperature_LNA = '25degC'
		output_file_str = save_path + 's11_calibration_low_band_LNA' + temperature_LNA + '_' + tt.strftime('%Y-%m-%d-%H-%M-%S') + flag + '.txt'

		header = 'freq [MHz]\tre(receiver)\tim(receiver)\tre(amb)\tim(amb)\tre(hot)\tim(hot)\tre(open)\tim(open)\tre(shorted)\tim(shorted)\tre(semirigid_s11)\tim(semirigid_s11)\tre(semirigid_s12s21)\tim(semirigid_s12s21)\tre(semirigid_s22)\tim(semirigid_s22)\tre(antsim2)\tim(antsim2)'
		np.savetxt(output_file_str, output_file, header=header)

		print('File saved to: ' + output_file_str)



	return output_file














def calibration_processing_low_band1_2017_09_25C(flow, fhigh, save='no', save_folder=0):


	"""

	Modification: October, 2017.

	"""


	# Main folder
	main_folder     = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band1/2017_09_25C/'


	# Paths for source data
	path_spectra    = main_folder + 'data/spectra/300_350/'
	path_resistance = main_folder + 'data/resistance/corrected/'
	path_s11        = main_folder + 'data/s11/corrected/'


	# Creating output folders
	if save == 'yes':

		if not exists(main_folder + 'results/' + save_folder + '/temp/'):
			makedirs(main_folder + 'results/' + save_folder + '/temp/')

		if not exists(main_folder + 'results/' + save_folder + '/spectra/'):
			makedirs(main_folder + 'results/' + save_folder + '/spectra/')

		if not exists(main_folder + 'results/' + save_folder + '/s11/'):
			makedirs(main_folder + 'results/' + save_folder + '/s11/')

		if not exists(main_folder + 'results/' + save_folder + '/data/'):
			makedirs(main_folder + 'results/' + save_folder + '/data/')

		if not exists(main_folder + 'results/' + save_folder + '/calibration_files/'):
			makedirs(main_folder + 'results/' + save_folder + '/calibration_files/')			

		if not exists(main_folder + 'results/' + save_folder + '/plots/'):
			makedirs(main_folder + 'results/' + save_folder + '/plots/')


		# Output folders
		path_par_temp    = main_folder + 'results/' + save_folder + '/temp/'
		path_par_spectra = main_folder + 'results/' + save_folder + '/spectra/'
		path_par_s11     = main_folder + 'results/' + save_folder + '/s11/'
		path_data        = main_folder + 'results/' + save_folder + '/data/'




	# Spectra/resistance files
	file_ambient1 = path_spectra + 'level1_AmbientLoad_2017_257_21_300_350.mat'
	file_ambient2 = path_spectra + 'level1_AmbientLoad_2017_258_00_300_350.mat'
	file_ambient3 = path_spectra + 'level1_AmbientLoad_2017_259_00_300_350.mat'
	file_ambient4 = path_spectra + 'level1_AmbientLoad_2017_260_00_300_350.mat'
	spec_ambient  = [file_ambient1, file_ambient2, file_ambient3, file_ambient4]
	res_ambient   = path_resistance + 'ambient.txt'


	# Hot
	file_hot1 = path_spectra + 'level1_HotLoad_2017_260_17_300_350.mat'	
	file_hot2 = path_spectra + 'level1_HotLoad_2017_261_00_300_350.mat'
	file_hot3 = path_spectra + 'level1_HotLoad_2017_262_00_300_350.mat'
	spec_hot  = [file_hot1, file_hot2, file_hot3]   #  
	res_hot   = path_resistance + 'hot.txt'


	# Open Cable
	file_open1 = path_spectra + 'level1_LongCableOpen_2017_262_22_300_350.mat'
	file_open2 = path_spectra + 'level1_LongCableOpen_2017_263_00_300_350.mat'
	spec_open  = [file_open1, file_open2]  # 
	res_open   = path_resistance + 'open.txt'


	# Shorted Cable
	file_shorted1 = path_spectra + 'level1_LongCableShort_2017_264_23_300_350.mat'
	file_shorted2 = path_spectra + 'level1_LongCableShort_2017_265_00_300_350.mat'
	file_shorted3 = path_spectra + 'level1_LongCableShort_2017_266_00_300_350.mat'
	spec_shorted  = [file_shorted1, file_shorted2, file_shorted3] #  
	res_shorted   = path_resistance + 'shorted.txt'


	# Antenna Simulator 2
	file_sim21  = path_spectra + 'level1_SimAnt2_2017_266_01_300_350.mat'
	file_sim22  = path_spectra + 'level1_SimAnt2_2017_267_00_300_350.mat'
	file_sim23  = path_spectra + 'level1_SimAnt2_2017_268_00_300_350.mat'
	spec_sim2   = [file_sim21, file_sim22, file_sim23]
	res_sim2    = path_resistance + 'antsim2.txt'






	# Average calibration spectra / physical temperature
	# Percentage of initial data to leave out
	percent = 5 # 5%
	ssa,    phys_temp_ambient    = average_calibration_spectrum(spec_ambient,    res_ambient, 1*percent, plot='no')
	ssh,    phys_temp_hot        = average_calibration_spectrum(spec_hot,        res_hot,     2*percent, plot='no')
	sso,    phys_temp_open       = average_calibration_spectrum(spec_open,       res_open,    2*percent, plot='no')
	sss,    phys_temp_shorted    = average_calibration_spectrum(spec_shorted,    res_shorted, 2*percent, plot='no')
	sss1,   phys_temp_sim1       = average_calibration_spectrum(spec_sim2,       res_sim2,    1*percent, plot='no')
	sss2,   phys_temp_sim2       = average_calibration_spectrum(spec_sim2,       res_sim2,    1*percent, plot='no')






	# Select frequency range
	ff, ilow, ihigh = frequency_edges(flow, fhigh)
	fe    = ff[ilow:ihigh+1]
	sa    = ssa[ilow:ihigh+1]
	sh    = ssh[ilow:ihigh+1]
	so    = sso[ilow:ihigh+1]
	ss    = sss[ilow:ihigh+1]
	ss1   = sss1[ilow:ihigh+1]
	ss2   = sss2[ilow:ihigh+1]



	# RFI cleaning of cable measurements at raw resolution
	Nsigma    = 3.5
	Nterms_fg = 45
	wo     = RFI_cleaning_spectrum_raw(fe, so, np.ones(len(fe)), Nterms_fg=Nterms_fg, Nsigma=Nsigma)   # 45 terms for 50-120 MHz
	ws     = RFI_cleaning_spectrum_raw(fe, ss, np.ones(len(fe)), Nterms_fg=Nterms_fg, Nsigma=Nsigma)   # 45 terms for 50-120 MHz


	# Spectra modeling
	fen = (fe-75)/25
	fit_spec_ambient    = fit_polynomial_fourier('fourier',    fen, sa,     9,  plot='no')
	fit_spec_hot        = fit_polynomial_fourier('fourier',    fen, sh,     9,  plot='no')
	fit_spec_open       = fit_polynomial_fourier('fourier',    fen, so,    31, Weights=wo, plot='no')
	fit_spec_shorted    = fit_polynomial_fourier('fourier',    fen, ss,    31, Weights=ws, plot='no')
	fit_spec_sim1       = fit_polynomial_fourier('fourier',    fen, ss1,   15,  plot='no')
	fit_spec_sim2       = fit_polynomial_fourier('fourier',    fen, ss2,   15,  plot='no')


	# Second layer of RFI cleanning
	model_open    = fit_spec_open[1]
	model_shorted = fit_spec_shorted[1]	
	wo2 = RFI_cleaning_spectrum_raw(fe, so-model_open,    wo, Nterms_fg=1, Nsigma=2.5)
	ws2 = RFI_cleaning_spectrum_raw(fe, ss-model_shorted, ws, Nterms_fg=1, Nsigma=2.5)


	# Replacing channels with RFI with models
	for i in range(len(fe)):
		if wo2[i] == 0:
			so[i] = model_open[i]

		if ws2[i] == 0:
			ss[i] = model_shorted[i]	






	# Loading S11 data (both files produce same results)
	s11 = np.genfromtxt(path_s11 + 's11_calibration_low_band_LNA25degC_2017-10-07-22-03-04.txt')

	for i in range(len(s11[:,0])-1):
		if (s11[i,0] <= flow) and (s11[i+1,0] > flow):
			index_low = i
		if (s11[i,0] < fhigh) and (s11[i+1,0] >= fhigh):
			index_high = i+1
	index_s11 = np.arange(index_low, index_high+1)

	# Frequency / complex data
	f_s11       = s11[index_s11, 0]
	s11_LNA     = s11[index_s11, 1]  + 1j*s11[index_s11, 2]
	s11_amb     = s11[index_s11, 3]  + 1j*s11[index_s11, 4]
	s11_hot     = s11[index_s11, 5]  + 1j*s11[index_s11, 6]
	s11_open    = s11[index_s11, 7]  + 1j*s11[index_s11, 8]
	s11_shorted = s11[index_s11, 9]  + 1j*s11[index_s11, 10]
	s11_sr      = s11[index_s11, 11] + 1j*s11[index_s11, 12]
	s12s21_sr   = s11[index_s11, 13] + 1j*s11[index_s11, 14]
	s22_sr      = s11[index_s11, 15] + 1j*s11[index_s11, 16]
	s11_simu2   = s11[index_s11, 17] + 1j*s11[index_s11, 18]
	s11_simu1   = np.copy(s11_simu2)




	# Magnitude / Angle

	# LNA
	s11_LNA_mag     = np.abs(s11_LNA)
	s11_LNA_ang     = np.unwrap(np.angle(s11_LNA))

	# Ambient
	s11_amb_mag     = np.abs(s11_amb)
	s11_amb_ang     = np.unwrap(np.angle(s11_amb))

	# Hot
	s11_hot_mag     = np.abs(s11_hot)
	s11_hot_ang     = np.unwrap(np.angle(s11_hot))

	# Open
	s11_open_mag    = np.abs(s11_open)
	s11_open_ang    = np.unwrap(np.angle(s11_open))

	# Shorted
	s11_shorted_mag = np.abs(s11_shorted)
	s11_shorted_ang = np.unwrap(np.angle(s11_shorted))

	# sr-s11
	s11_sr_mag      = np.abs(s11_sr)
	s11_sr_ang      = np.unwrap(np.angle(s11_sr))

	# sr-s12s21
	s12s21_sr_mag   = np.abs(s12s21_sr)
	s12s21_sr_ang   = np.unwrap(np.angle(s12s21_sr))

	# sr-s22
	s22_sr_mag      = np.abs(s22_sr)
	s22_sr_ang      = np.unwrap(np.angle(s22_sr))

	# Simu1
	s11_simu1_mag   = np.abs(s11_simu1)
	s11_simu1_ang   = np.unwrap(np.angle(s11_simu1))

	# Simu2
	s11_simu2_mag   = np.abs(s11_simu2)
	s11_simu2_ang   = np.unwrap(np.angle(s11_simu2))	





	# Modeling S11

	f_s11n = (f_s11-75)/25

	fit_s11_LNA_mag     = fit_polynomial_fourier('polynomial', f_s11n, s11_LNA_mag,     15, plot='no') # 15
	fit_s11_LNA_ang     = fit_polynomial_fourier('polynomial', f_s11n, s11_LNA_ang,     15, plot='no') # 15

	fit_s11_amb_mag     = fit_polynomial_fourier('fourier',    f_s11n, s11_amb_mag,     27, plot='no') 
	fit_s11_amb_ang     = fit_polynomial_fourier('fourier',    f_s11n, s11_amb_ang,     27, plot='no') 

	fit_s11_hot_mag     = fit_polynomial_fourier('fourier',    f_s11n, s11_hot_mag,     27, plot='no')  
	fit_s11_hot_ang     = fit_polynomial_fourier('fourier',    f_s11n, s11_hot_ang,     27, plot='no') 

	fit_s11_open_mag    = fit_polynomial_fourier('fourier',    f_s11n, s11_open_mag,    27, plot='no')
	fit_s11_open_ang    = fit_polynomial_fourier('fourier',    f_s11n, s11_open_ang,    27, plot='no')

	fit_s11_shorted_mag = fit_polynomial_fourier('fourier',    f_s11n, s11_shorted_mag, 27, plot='no')
	fit_s11_shorted_ang = fit_polynomial_fourier('fourier',    f_s11n, s11_shorted_ang, 27, plot='no')

	fit_s11_sr_mag      = fit_polynomial_fourier('polynomial', f_s11n, s11_sr_mag,       5, plot='no') 
	fit_s11_sr_ang      = fit_polynomial_fourier('polynomial', f_s11n, s11_sr_ang,       5, plot='no') 

	fit_s12s21_sr_mag   = fit_polynomial_fourier('polynomial', f_s11n, s12s21_sr_mag,    5, plot='no') 
	fit_s12s21_sr_ang   = fit_polynomial_fourier('polynomial', f_s11n, s12s21_sr_ang,    5, plot='no') 

	fit_s22_sr_mag      = fit_polynomial_fourier('polynomial', f_s11n, s22_sr_mag,       5, plot='no') 
	fit_s22_sr_ang      = fit_polynomial_fourier('polynomial', f_s11n, s22_sr_ang,       5, plot='no') 

	fit_s11_simu1_mag   = fit_polynomial_fourier('fourier',    f_s11n, s11_simu1_mag,    19, plot='no')
	fit_s11_simu1_ang   = fit_polynomial_fourier('fourier',    f_s11n, s11_simu1_ang,    19, plot='no')

	fit_s11_simu2_mag   = fit_polynomial_fourier('fourier',    f_s11n, s11_simu2_mag,    19, plot='no')
	fit_s11_simu2_ang   = fit_polynomial_fourier('fourier',    f_s11n, s11_simu2_ang,    19, plot='no')



	# Saving output parameters
	if save == 'yes':


		# Average spectra data in frequency range selected
		spectra = np.array([fe, sa, sh, so, ss, ss1, ss2]).T		

		# RMS residuals
		RMS_spectra = np.zeros((6,1))
		RMS_s11     = np.zeros((20,1))

		# Spectra
		RMS_spectra[0, 0] = fit_spec_ambient[2]
		RMS_spectra[1, 0] = fit_spec_hot[2]
		RMS_spectra[2, 0] = fit_spec_open[2]
		RMS_spectra[3, 0] = fit_spec_shorted[2]
		RMS_spectra[4, 0] = fit_spec_sim1[2]
		RMS_spectra[5, 0] = fit_spec_sim2[2]


		# S11
		RMS_s11[0, 0]  = fit_s11_LNA_mag[2]
		RMS_s11[1, 0]  = fit_s11_LNA_ang[2]
		RMS_s11[2, 0]  = fit_s11_amb_mag[2]
		RMS_s11[3, 0]  = fit_s11_amb_ang[2]
		RMS_s11[4, 0]  = fit_s11_hot_mag[2]
		RMS_s11[5, 0]  = fit_s11_hot_ang[2]
		RMS_s11[6, 0]  = fit_s11_open_mag[2]
		RMS_s11[7, 0]  = fit_s11_open_ang[2]
		RMS_s11[8, 0]  = fit_s11_shorted_mag[2]
		RMS_s11[9, 0]  = fit_s11_shorted_ang[2]
		RMS_s11[10, 0] = fit_s11_sr_mag[2]
		RMS_s11[11, 0] = fit_s11_sr_ang[2]
		RMS_s11[12, 0] = fit_s12s21_sr_mag[2]
		RMS_s11[13, 0] = fit_s12s21_sr_ang[2]
		RMS_s11[14, 0] = fit_s22_sr_mag[2]
		RMS_s11[15, 0] = fit_s22_sr_ang[2]
		RMS_s11[16, 0] = fit_s11_simu1_mag[2]
		RMS_s11[17, 0] = fit_s11_simu1_ang[2]
		RMS_s11[18, 0] = fit_s11_simu2_mag[2]
		RMS_s11[19, 0] = fit_s11_simu2_ang[2]



		# Formatting fit parameters

		# Physical temperature
		phys_temp = np.zeros((6,1))
		phys_temp[0,0] = phys_temp_ambient
		phys_temp[1,0] = phys_temp_hot
		phys_temp[2,0] = phys_temp_open
		phys_temp[3,0] = phys_temp_shorted
		phys_temp[4,0] = phys_temp_sim1
		phys_temp[5,0] = phys_temp_sim2		


		# Spectra
		par_spec_ambient    = np.reshape(fit_spec_ambient[0],    (-1,1))
		par_spec_hot        = np.reshape(fit_spec_hot[0],        (-1,1))
		par_spec_open       = np.reshape(fit_spec_open[0],       (-1,1))
		par_spec_shorted    = np.reshape(fit_spec_shorted[0],    (-1,1))
		par_spec_sim1       = np.reshape(fit_spec_sim1[0],       (-1,1))
		par_spec_sim2       = np.reshape(fit_spec_sim2[0],       (-1,1))


		# S11
		par_s11_LNA_mag     = np.reshape(fit_s11_LNA_mag[0],     (-1,1))
		par_s11_LNA_ang     = np.reshape(fit_s11_LNA_ang[0],     (-1,1))
		par_s11_amb_mag     = np.reshape(fit_s11_amb_mag[0],     (-1,1))
		par_s11_amb_ang     = np.reshape(fit_s11_amb_ang[0],     (-1,1))
		par_s11_hot_mag     = np.reshape(fit_s11_hot_mag[0],     (-1,1))
		par_s11_hot_ang     = np.reshape(fit_s11_hot_ang[0],     (-1,1))
		par_s11_open_mag    = np.reshape(fit_s11_open_mag[0],    (-1,1))
		par_s11_open_ang    = np.reshape(fit_s11_open_ang[0],    (-1,1))
		par_s11_shorted_mag = np.reshape(fit_s11_shorted_mag[0], (-1,1))
		par_s11_shorted_ang = np.reshape(fit_s11_shorted_ang[0], (-1,1))

		par_s11_sr_mag      = np.reshape(fit_s11_sr_mag[0],      (-1,1))
		par_s11_sr_ang      = np.reshape(fit_s11_sr_ang[0],      (-1,1))
		par_s12s21_sr_mag   = np.reshape(fit_s12s21_sr_mag[0],   (-1,1))
		par_s12s21_sr_ang   = np.reshape(fit_s12s21_sr_ang[0],   (-1,1))
		par_s22_sr_mag      = np.reshape(fit_s22_sr_mag[0],      (-1,1))
		par_s22_sr_ang      = np.reshape(fit_s22_sr_ang[0],      (-1,1))

		par_s11_simu1_mag   = np.reshape(fit_s11_simu1_mag[0],   (-1,1))
		par_s11_simu1_ang   = np.reshape(fit_s11_simu1_ang[0],   (-1,1))
		par_s11_simu2_mag   = np.reshape(fit_s11_simu2_mag[0],   (-1,1))
		par_s11_simu2_ang   = np.reshape(fit_s11_simu2_ang[0],   (-1,1))




		# Saving

		np.savetxt(path_data + 'average_spectra_300_350.txt', spectra)

		np.savetxt(path_par_temp    + 'physical_temperatures.txt', phys_temp)

		np.savetxt(path_par_spectra + 'par_spec_amb.txt',     par_spec_ambient)
		np.savetxt(path_par_spectra + 'par_spec_hot.txt',     par_spec_hot)
		np.savetxt(path_par_spectra + 'par_spec_open.txt',    par_spec_open)
		np.savetxt(path_par_spectra + 'par_spec_shorted.txt', par_spec_shorted)
		np.savetxt(path_par_spectra + 'par_spec_simu1.txt',   par_spec_sim1)
		np.savetxt(path_par_spectra + 'par_spec_simu2.txt',   par_spec_sim2)
		np.savetxt(path_par_spectra + 'RMS_spec.txt',         RMS_spectra)

		np.savetxt(path_par_s11 + 'par_s11_LNA_mag.txt',      par_s11_LNA_mag)
		np.savetxt(path_par_s11 + 'par_s11_LNA_ang.txt',      par_s11_LNA_ang)
		np.savetxt(path_par_s11 + 'par_s11_amb_mag.txt',      par_s11_amb_mag)
		np.savetxt(path_par_s11 + 'par_s11_amb_ang.txt',      par_s11_amb_ang)
		np.savetxt(path_par_s11 + 'par_s11_hot_mag.txt',      par_s11_hot_mag)
		np.savetxt(path_par_s11 + 'par_s11_hot_ang.txt',      par_s11_hot_ang)
		np.savetxt(path_par_s11 + 'par_s11_open_mag.txt',     par_s11_open_mag)
		np.savetxt(path_par_s11 + 'par_s11_open_ang.txt',     par_s11_open_ang)
		np.savetxt(path_par_s11 + 'par_s11_shorted_mag.txt',  par_s11_shorted_mag)
		np.savetxt(path_par_s11 + 'par_s11_shorted_ang.txt',  par_s11_shorted_ang)

		np.savetxt(path_par_s11 + 'par_s11_sr_mag.txt',       par_s11_sr_mag)
		np.savetxt(path_par_s11 + 'par_s11_sr_ang.txt',       par_s11_sr_ang)
		np.savetxt(path_par_s11 + 'par_s12s21_sr_mag.txt',    par_s12s21_sr_mag)
		np.savetxt(path_par_s11 + 'par_s12s21_sr_ang.txt',    par_s12s21_sr_ang)
		np.savetxt(path_par_s11 + 'par_s22_sr_mag.txt',       par_s22_sr_mag)
		np.savetxt(path_par_s11 + 'par_s22_sr_ang.txt',       par_s22_sr_ang)

		np.savetxt(path_par_s11 + 'par_s11_simu1_mag.txt',    par_s11_simu1_mag)
		np.savetxt(path_par_s11 + 'par_s11_simu1_ang.txt',    par_s11_simu1_ang)
		np.savetxt(path_par_s11 + 'par_s11_simu2_mag.txt',    par_s11_simu2_mag)
		np.savetxt(path_par_s11 + 'par_s11_simu2_ang.txt',    par_s11_simu2_ang)


		np.savetxt(path_par_s11 + 'RMS_s11.txt',       	      RMS_s11)


	# End
	print('Files processed.')

	return 1















def likelihood_21cm(vv, tt, ww, noise_std, syst_std, model_21, Nfg, v0):

	v = vv[ww>0]
	t = tt[ww>0]
	w = ww[ww>0]


	# Covariance matrix of noise
	if np.isscalar(noise_std):
		cov_noise = (noise_std**2)*np.eye(len(w))

	elif (np.ndim(noise_std == 1) and len(noise_std) == len(ww)):
		noise_std = noise_std[ww>0]
		cov_noise = np.diag(noise_std**2)





	# Covariance matrix of systematics
	if np.isscalar(syst_std):
		cov_syst = (syst_std**2)*np.eye(len(w))

	elif np.ndim(syst_std) == 1:
		syst_std = syst_std[ww>0]
		cov_syst = np.diag(syst_std**2)





	# Foreground model and parameter covariance matrix
	if len(model_21) == len(ww):
		model_21 = model_21[ww>0]
	par          = fit_polynomial_fourier('EDGES_polynomial', v/v0, t-model_21, 5, Weights=w)
	
	print(par[0])
	model_fg     = par[1]
	cov_theta_fg = par[3]

	# Producing "design" matrix with foreground functions
	AT  = np.zeros((Nfg, len(v)))
	for i in range(Nfg):
		AT[i,:] = (v/v0)**(-2.5+i)
	A = AT.T

	# Formal way of computing the fg uncertainties, i.e., adding the noise and systematics covariance matrices
	cov_theta_fg_2 = np.linalg.inv(np.dot(np.dot(A.T, np.linalg.inv(cov_noise + cov_syst)), A))




	# Foreground parameter covariance matrix projected onto frequency domain
	#cov_fg  = np.dot(np.dot(A, cov_theta_fg), (A.T))
	cov_fg  = np.dot(np.dot(A, cov_theta_fg_2), (A.T))



	# Total covariance matrix
	cov_total     = cov_noise + cov_syst + cov_fg

	# Inverse of total covariance matrix
	inv_cov_total = np.linalg.inv(cov_total)


	# Computing likelihood
	amplitude    = 1/(np.sqrt(((2*np.pi)**len(v))*np.linalg.det(90*cov_total)))
	diff         = np.reshape(t-model_21-model_fg, (1,-1))
	chi_sq       = np.dot(np.dot(diff, inv_cov_total), diff.T)

	L = amplitude * np.exp(-(1/2)*chi_sq) 	
	# This likelihood is not normalized, i.e., it is not absolute. To normalize it, it has to be multiplied by 1/np.sqrt(90**(len(v))). But this is a very small number. In practice it is zero. Therefore, I don't do it.


	return L[0,0], par[0]   #, cov_fg, cov_fg_2












def likelihood_21cm_V2(vv, tt, ww, noise_std, syst_std, mm_21, Nfg, v0, foreground_model = 'EDGES_polynomial'):
	
	"""
	
	This version (V2) implements the refined likelihood derivation developed by N. Kern and R. Monsalve during Christmas 2017.
	
	The length of vv, tt, ww, and mm_21 is the same, and equal to the full frequency vector (v), even for the channels that do not have useful data. 
	
	"""

	# Keeping only valid data
	v        = vv[ww>0]
	t        = tt[ww>0]
	w        = ww[ww>0]
	model_21 = mm_21[ww>0]



	# Covariance matrix of noise
	if np.isscalar(noise_std):
		SIGMA_noise = (noise_std**2)*np.eye(len(w))

	elif (np.ndim(noise_std == 1) and len(noise_std) == len(ww)):
		noise_std   = noise_std[ww>0]
		SIGMA_noise = np.diag(noise_std**2)



	# Covariance matrix of systematics
	if np.isscalar(syst_std):
		SIGMA_syst = (syst_std**2)*np.eye(len(w))

	elif np.ndim(syst_std) == 1:
		syst_std   = syst_std[ww>0]
		SIGMA_syst = np.diag(syst_std**2)



	# Total data covariance matrix
	SIGMA_data = SIGMA_noise + SIGMA_syst
	




	# Foreground model and parameter covariance matrix
	#'EDGES_polynomial'
	
	# Producing "design" matrix with foreground functions
	AT  = np.zeros((Nfg, len(v)))
	par           = fit_polynomial_fourier(foreground_model, v/v0, t-model_21, Nfg, Weights=w)
	model_fg      = par[1]
	
	if foreground_model == 'EDGES_polynomial':
		for i in range(Nfg):
			AT[i,:] = (v/v0)**(-2.5+i)
			
	elif (foreground_model == 'Physical_model') and (Nfg == 5):
		AT[0,:] = ((v/v0)**(-2.5))
		AT[1,:] = ((v/v0)**(-2.5)) *  (np.log(v/v0))
		AT[2,:] = ((v/v0)**(-2.5)) * ((np.log(v/v0))**2)
		AT[3,:] = ((v/v0)**(-4.5))
		AT[4,:] = ((v/v0)**(-2))			
				
	A = AT.T




	# Covariance matrix of foreground parameters
	C = np.linalg.inv(np.dot(np.dot(A.T, np.linalg.inv(SIGMA_data)), A))


	# Covariance matrix of foregrounds projected onto frequency domain
	#cov_fg  = np.dot(np.dot(A, cov_theta_fg), (A.T))
	SIGMA_fg  = np.dot(np.dot(A, C), (A.T))
	
	#print('%.20f' %np.linalg.det(1e3*C))
	


	inv_SIGMA_data = np.linalg.inv(SIGMA_data)
	inv_SIGMA_fg   = np.linalg.inv(SIGMA_fg)
	V              = np.linalg.inv(inv_SIGMA_fg - inv_SIGMA_data)
	
	aug_SIGMA     = SIGMA_data + V
	inv_aug_SIGMA = np.linalg.inv(aug_SIGMA)
	#print(np.linalg.det(inv_aug_SIGMA))


	# Computing likelihood
	amplitude    = 1
	d_star       = np.reshape(t-model_21-model_fg, (1,-1))
	chi_sq       = np.dot(np.dot(d_star, inv_aug_SIGMA), d_star.T)[0,0]
	L            = amplitude * np.exp(-(1/2)*chi_sq)
	# This likelihood is normalized to 1, i.e., it is not absolute.


	return L, par[0], chi_sq


























def likelihood_mesinger(flow=90, fhigh=190, simulated='yes_above_145', residual_fraction=0.8, save_suffix='_temp', model_fg='EDGES_polynomial'):

	# Loading High-band data
	#v, t, w, noise_std_profile, model_with_noise = EDGES_high_band_data(save='no', simulated='yes_noise_plus_ripples', residual_fraction=0.8)
	vv, tt, ww, NN = EDGES_high_band_data(save='no', simulated=simulated, residual_fraction=residual_fraction)
	
	v = vv[(vv>=flow) & (vv<=fhigh)]
	t = tt[(vv>=flow) & (vv<=fhigh)]
	w = ww[(vv>=flow) & (vv<=fhigh)]
	
	noise_std_profile = NN[(vv>=flow) & (vv<=fhigh)]


	# Probing models
	out_L  = np.zeros((10000, 2))
	par_fg = np.zeros((10000, 5))
	
	for i in range(10000):
		model_number = i

		model21, aux = model_eor_mesinger(model_number, v, interpolation_kind='linear')

		L, parX, chi_sq = likelihood_21cm_V2(v, t, w, noise_std_profile, 0.035, model21, 5, 140, foreground_model = model_fg)
		
		out_L[i,0]  = i
		out_L[i,1]  = L
		
		par_fg[i,:] = parX


	# Saving results		
	path_file = home_folder + '/DATA/EDGES/results/high_band/products/model_rejection/mesinger/likelihood/likelihood_10000models' + save_suffix + '.txt'

	header = 'model_number\tlikelihood'
	np.savetxt(path_file, out_L, header=header)

	print('File saved to: ' + path_file)		


	return out_L, par_fg




















def fialkov_loading_hires_data():
	"""

	2017-11-06

	"""



	for i in range(1000): 

		print(i+1)

		# Loading models, parameters, and Likelihoods
		file_name            = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/Global21cmV2/output_files/grid_Npix10_' + str(i+1) + '.mat'
		mat                  = sio.loadmat(file_name)

		models_set = mat['Signal']  # in K
		flags_set  = mat['flag']
		par_set    = mat['parameters_21cm_set']
		pp1        = mat['p1']; p1_set = pp1[0,:]
		pp2        = mat['p2']; p2_set = pp2[0,:]
		pp3        = mat['p3']; p3_set = pp3[0,:]
		pp4        = mat['p4']; p4_set = pp4[0,:]
		pp5        = mat['p5']; p5_set = pp5[0,:]
		pp6        = mat['p6']; p6_set = pp6[0,:]
		pp7        = mat['p7']; p7_set = pp7[0,:]


		if i == 0:
			models = np.copy(models_set)
			flags  = np.copy(flags_set)
			par    = np.copy(par_set)
			p1     = np.copy(p1_set)
			p2     = np.copy(p2_set)
			p3     = np.copy(p3_set)
			p4     = np.copy(p4_set)
			p5     = np.copy(p5_set)
			p6     = np.copy(p6_set)
			p7     = np.copy(p7_set)


		elif i > 0:
			#models = np.array([])
			models = np.append(models, models_set, axis=0)
			flags  = np.append(flags,  flags_set,  axis=0)
			par    = np.append(par,    par_set,    axis=0)


	#par_list             = [p1, p2, p3, p4, p5, p6, p7]



	save_file = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/Global21cmV2/output_files/grid_Npix10_full.hdf5'
	with h5py.File(save_file, 'w') as hf:


		print('hola')


		hf.create_dataset('Signal',           data = models)
		hf.create_dataset('flag',             data = flags)
		hf.create_dataset('parameters_21cm',  data = par)
		hf.create_dataset('p1',               data = p1)
		hf.create_dataset('p2',               data = p2)
		hf.create_dataset('p3',               data = p3)
		hf.create_dataset('p4',               data = p4)
		hf.create_dataset('p5',               data = p5)
		hf.create_dataset('p6',               data = p6)
		hf.create_dataset('p7',               data = p7)

	return models, flags, par






























def OLD_likelihood_fialkov_Npix5():

	# Loading High-band data
	d = np.genfromtxt('/home/ramo7131/DATA/EDGES/results/high_band/products/average_spectrum/high_band_2015_LST_0.26_6.26_dates_2015_250_299_nominal.txt')	


	# Computing noise standard deviation.
	# We divide the antenna temperature by sqrt(weights), and scale this division to enclose 68% of data after fitting and removing a polynomal and differencing from channel to channel
	Nk = 16
	par = fit_polynomial_fourier('EDGES_polynomial', d[:,0]/140, d[:,1], Nk, Weights=d[:,2])
	model = par[1]
	res   = d[:,1]-model

	diff    = np.zeros(len(d[:,1]))
	weights = np.zeros(len(d[:,1]))
	for i in range(len(d[:,1])-1):
		diff[i+1]    = res[i+1] - res[i]
		if np.abs(diff[i+1]) < 0.1:
			weights[i+1] = 1


	profile_not_normalized = d[:,1]/np.sqrt(d[:,2])
	profile = profile_not_normalized/np.max(profile_not_normalized[d[:,2]>0])
	max_diff = np.max(np.abs(diff[weights>0]))
	resolution = 10*max_diff/1e4
	scale = np.arange(0, 10*max_diff, resolution)
	error = 1e6
	for i in range(len(scale)):
		full = (np.abs(diff) - scale[i]*profile)[weights==1]
		len_full  = len(full)
		len_below = len(full[full<0])
		error_new = np.abs((len_below/len_full)-0.68)
		if error_new < error:
			error = np.copy(error_new)
			correct_scale_diff = scale[i]


	# Noise standard deviation	
	noise_std_profile = correct_scale_diff*profile/np.sqrt(2)



	# Probing models
	file_name = home_folder + '/Desktop/MCMC/model_grids/grid_Npix5.mat'
	mat       = sio.loadmat(file_name)
	models          = mat['Signal']/1000  # in K
	flags           = mat['flag']
	parameters_21cm = mat['parameters_21cm']
	p1              = mat['p1']
	p2              = mat['p2']
	p3              = mat['p3']
	p4              = mat['p4']
	p5              = mat['p5']
	p6              = mat['p6']
	p7              = mat['p7']


	# Frequency vector
	z_raw    = np.arange(5,50.05,0.1)
	freq_raw = redshift2frequency(z_raw)


	Nmodels = len(models[:,0])
	out_L   = np.zeros((Nmodels,2))
	for i in range(Nmodels):
		out_L[i,0]   = i		
		print(i+1)
		if np.sum(flags[i,:]) == 0:

			# Raw model
			model21_raw = models[i,:]

			# Interpolation of model
			func_model = spi.interp1d(freq_raw, model21_raw, kind='linear')	
			model21    = func_model(d[:,0])

			# Computing and storing the likelihood
			L = likelihood_21cm(d[:,0], d[:,1], d[:,2], noise_std_profile, 0.035, model21, 5, 140)
			out_L[i,1] = L

		else:
			out_L[i,1] = 0




	# Saving results
	path_file = home_folder + '/DATA/EDGES/results/high_band/products/model_rejection/global_21cm_anastasia/likelihood/likelihood_grid_Npix5_20171027_cov2.txt'

	header = 'model_number\tlikelihood'
	np.savetxt(path_file, out_L, header=header)
	print('File saved to: ' + path_file)		


	return out_L, z_raw, models, flags, parameters_21cm, p1, p2, p3, p4, p5, p6, p7















def likelihood_fialkov_Npix5():
	
	"""
	Dec 19, 2017
	
	"""
	

	# Loading High-band data
	d = np.genfromtxt('/home/ramo7131/DATA/EDGES/results/high_band/products/average_spectrum/high_band_2015_LST_0.26_6.26_dates_2015_250_299_nominal.txt')	


	# Computing noise standard deviation.
	# We divide the antenna temperature by sqrt(weights), and scale this division to enclose 68% of data after fitting and removing a polynomal and differencing from channel to channel
	Nk = 16
	par = fit_polynomial_fourier('EDGES_polynomial', d[:,0]/140, d[:,1], Nk, Weights=d[:,2])
	model = par[1]
	res   = d[:,1]-model

	diff    = np.zeros(len(d[:,1]))
	weights = np.zeros(len(d[:,1]))
	for i in range(len(d[:,1])-1):
		diff[i+1]    = res[i+1] - res[i]
		if np.abs(diff[i+1]) < 0.1:
			weights[i+1] = 1


	profile_not_normalized = d[:,1]/np.sqrt(d[:,2])
	profile = profile_not_normalized/np.max(profile_not_normalized[d[:,2]>0])
	max_diff = np.max(np.abs(diff[weights>0]))
	resolution = 10*max_diff/1e4
	scale = np.arange(0, 10*max_diff, resolution)
	error = 1e6
	for i in range(len(scale)):
		full = (np.abs(diff) - scale[i]*profile)[weights==1]
		len_full  = len(full)
		len_below = len(full[full<0])
		error_new = np.abs((len_below/len_full)-0.68)
		if error_new < error:
			error = np.copy(error_new)
			correct_scale_diff = scale[i]


	# Noise standard deviation	
	noise_std_profile = correct_scale_diff*profile/np.sqrt(2)








	# Frequency vector
	z_raw    = np.arange(5,50.05,0.1)
	freq_raw = redshift2frequency(z_raw)


	# Initializing output array with random numbers, as a worst case scenario
	Nm       = 5**7
	out_L    = np.random.normal(size=(Nm, 2))	
	out_par  = np.random.normal(size=(Nm, 7))
	out_flag = np.random.normal(size=(Nm, 3))


	k = 0
	for j in range(8): 

		print(i+1)

		# Loading models, parameters, and Likelihoods
		file_name            = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/Global21cmV4/output_files/grid_Npar7_Npix5_' + str(j+1) + '.mat'
		mat                  = sio.loadmat(file_name)

		models = mat['Signal']/1000  # in K
		flags  = mat['flag']
		par    = mat['parameters_21cm_set']
		pp1    = mat['p1']; p1 = pp1[0,:]
		pp2    = mat['p2']; p2 = pp2[0,:]
		pp3    = mat['p3']; p3 = pp3[0,:]
		pp4    = mat['p4']; p4 = pp4[0,:]
		pp5    = mat['p5']; p5 = pp5[0,:]
		pp6    = mat['p6']; p6 = pp6[0,:]
		pp7    = mat['p7']; p7 = pp7[0,:]



	
		Nmodels = len(models[:,0])
		
		for i in range(Nmodels):
			
			# Computing and storing likelihood
			out_L[k,0] = k
			
			print(k)
			if np.sum(flags[i,:]) == 0:
	
				# Raw model
				model21_raw = models[i,:]
	
				# Interpolation of model
				func_model  = spi.interp1d(freq_raw, model21_raw, kind='linear')	
				model21     = func_model(d[:,0])
	
				# Computing and storing the likelihood
				L = likelihood_21cm(d[:,0], d[:,1], d[:,2], noise_std_profile, 0.035, model21, 5, 140)
				out_L[k,1] = L
	
			else:
				out_L[k,1] = 0
			
			# Storing parameter values
			out_par[k,:]  = par[i,:]
			
			# Storing flags
			out_flag[k,:] = flags[i,:]
			
						
			k = k + 1
	

	# Saving results
	#path_file = home_folder + '/DATA/EDGES/results/high_band/products/model_rejection/global_21cm_anastasia/likelihood/likelihood_grid_Npix5_20171027_cov2.txt'

	#header = 'model_number\tlikelihood'
	#np.savetxt(path_file, out_L, header=header)
	#print('File saved to: ' + path_file)	
	
	
	save_file = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/Global21cmV4/results/results_Npix5_full.hdf5'
	with h5py.File(save_file, 'w') as hf:

		hf.create_dataset('likelihood',        data = out_L)
		hf.create_dataset('parameters_21cm',   data = out_par)
		hf.create_dataset('flags',             data = out_flag)	


	return out_L, out_par, out_flag     #out_L, z_raw, models, flags, parameters_21cm, p1, p2, p3, p4, p5, p6, p7












def likelihood_fialkov_Npix10():

	# Loading High-band data
	d = np.genfromtxt('/home/ramo7131/DATA/EDGES/results/high_band/products/average_spectrum/high_band_2015_LST_0.26_6.26_dates_2015_250_299_nominal.txt')	


	# Computing noise standard deviation.
	# We divide the antenna temperature by sqrt(weights), and scale this division to enclose 68% of data after fitting and removing a polynomal and differencing from channel to channel
	Nk = 16
	par = fit_polynomial_fourier('EDGES_polynomial', d[:,0]/140, d[:,1], Nk, Weights=d[:,2])
	model = par[1]
	res   = d[:,1]-model

	diff    = np.zeros(len(d[:,1]))
	weights = np.zeros(len(d[:,1]))
	for i in range(len(d[:,1])-1):
		diff[i+1]    = res[i+1] - res[i]
		if np.abs(diff[i+1]) < 0.1:
			weights[i+1] = 1


	profile_not_normalized = d[:,1]/np.sqrt(d[:,2])
	profile = profile_not_normalized/np.max(profile_not_normalized[d[:,2]>0])
	max_diff = np.max(np.abs(diff[weights>0]))
	resolution = 10*max_diff/1e4
	scale = np.arange(0, 10*max_diff, resolution)
	error = 1e6
	for i in range(len(scale)):
		full = (np.abs(diff) - scale[i]*profile)[weights==1]
		len_full  = len(full)
		len_below = len(full[full<0])
		error_new = np.abs((len_below/len_full)-0.68)
		if error_new < error:
			error = np.copy(error_new)
			correct_scale_diff = scale[i]


	# Noise standard deviation	
	noise_std_profile = correct_scale_diff*profile/np.sqrt(2)



	# Frequency vector
	z_raw    = np.arange(5,50.05,0.1)
	freq_raw = redshift2frequency(z_raw)









	# Initializing output array with random numbers, as a worst case scenario
	out_L    = np.random.normal(size=(10000000, 2))	
	out_par  = np.random.normal(size=(10000000, 7))
	out_flag = np.random.normal(size=(10000000, 3))


	k = 0
	for j in range(1000): 

		print(i+1)

		# Loading models, parameters, and Likelihoods
		file_name            = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/Global21cmV3/output_files/grid_Npix10_' + str(j+1) + '.mat'
		mat                  = sio.loadmat(file_name)

		models = mat['Signal']/1000  # in K
		flags  = mat['flag']
		par    = mat['parameters_21cm_set']
		pp1    = mat['p1']; p1 = pp1[0,:]
		pp2    = mat['p2']; p2 = pp2[0,:]
		pp3    = mat['p3']; p3 = pp3[0,:]
		pp4    = mat['p4']; p4 = pp4[0,:]
		pp5    = mat['p5']; p5 = pp5[0,:]
		pp6    = mat['p6']; p6 = pp6[0,:]
		pp7    = mat['p7']; p7 = pp7[0,:]



	
		Nmodels = len(models[:,0])
		
		for i in range(Nmodels):
			
			# Computing and storing likelihood
			out_L[k,0] = k
			
			print(k)
			if np.sum(flags[i,:]) == 0:
	
				# Raw model
				model21_raw = models[i,:]
	
				# Interpolation of model
				func_model  = spi.interp1d(freq_raw, model21_raw, kind='linear')	
				model21     = func_model(d[:,0])
	
				# Computing and storing the likelihood
				L = likelihood_21cm(d[:,0], d[:,1], d[:,2], noise_std_profile, 0.035, model21, 5, 140)
				out_L[k,1] = L
	
			else:
				out_L[k,1] = 0
			
			# Storing parameter values
			out_par[k,:]  = par[i,:]
			
			# Storing flags
			out_flag[k,:] = flags[i,:]
			
						
			k = k + 1
	

	# Saving results
	#path_file = home_folder + '/DATA/EDGES/results/high_band/products/model_rejection/global_21cm_anastasia/likelihood/likelihood_grid_Npix5_20171027_cov2.txt'

	#header = 'model_number\tlikelihood'
	#np.savetxt(path_file, out_L, header=header)
	#print('File saved to: ' + path_file)	
	
	
	save_file = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/Global21cmV3/results/results_Npix10_full.hdf5'
	with h5py.File(save_file, 'w') as hf:

		hf.create_dataset('likelihood',        data = out_L)
		hf.create_dataset('parameters_21cm',   data = out_par)
		hf.create_dataset('flags',             data = out_flag)	


	return out_L, out_par, out_flag     #out_L, z_raw, models, flags, parameters_21cm, p1, p2, p3, p4, p5, p6, p7
















def likelihood_fialkov_Npar4_Npix20(simulated_data, simulated_residual_fraction, save_filename_suffix, vlow, vhigh, Nfg, syst_std=0.035, foreground_model='EDGES_polynomial'):
	
	"""
	
	Dec 31, 2017 (yeah, that's right!!)
	
	simulated_data:
	'no'
	'yes_just_noise'
	'yes_above_125'
	'yes_above_145'
	'yes_noise_plus_ripples'
	
	IF 'yes_noise_plus_ripples':
	simulated_residual_fraction: 0, 0.25, etc.

	
	"""
	
	
	# Loading High-band data
	v_full, t_full, w_full, noise_full = EDGES_high_band_data(save='no', save_suffix='_test', simulated=simulated_data, residual_fraction=simulated_residual_fraction)
	
	
	# Cutting frequency
	v                 = v_full[(v_full>=vlow) & (v_full<=vhigh)]
	t                 = t_full[(v_full>=vlow) & (v_full<=vhigh)]
	w                 = w_full[(v_full>=vlow) & (v_full<=vhigh)]
	noise_std_profile = noise_full[(v_full>=vlow) & (v_full<=vhigh)]
	
	print('Length of spectrum: ' + str(len(v)))
	
		
	# Frequency vector
	z_raw    = np.arange(5,50.05,0.1)
	freq_raw = redshift2frequency(z_raw)

	# Initializing output array with random numbers, as a worst case scenario
	sz = 20**4
	
	out_signals  = np.random.normal(size=(sz, len(v)))
	out_par_21   = np.random.normal(size=(sz, 7))
	out_flags    = np.random.normal(size=(sz, 4))
	out_xHI59    = np.random.normal(size=(sz))
	out_xHI754   = np.random.normal(size=(sz))	
	out_Zeta     = np.random.normal(size=(sz))
	
	#out_L_xHI59  = np.random.normal(size=(sz))
	#out_L_xHI754 = np.random.normal(size=(sz))
	#out_L_Zeta   = np.random.normal(size=(sz))

	out_L        = np.random.normal(size=(sz))
	out_chi_sq   = np.random.normal(size=(sz))
	out_par_fg   = np.random.normal(size=(sz, Nfg))
	


	k = 0
	for j in range(16):

		# Loading models, parameters, and Likelihoods
		file_name            = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/Global21cmV5/output_files/grid_Npar4_Npix20_' + str(j+1) + '.mat'
		mat                  = sio.loadmat(file_name)

		models = mat['Signal']/1000  # in K
		xHI59  = mat['xHI59'][0]
		xHI754 = mat['xHI754'][0]
		v011   = mat['v011'][0]
		v016   = mat['v016'][0]
		Zeta   = mat['Zeta'][0]
		par    = mat['parameters_21cm_set']		
		pp1    = mat['p1']; p1 = pp1[0,:]
		pp2    = mat['p2']; p2 = pp2[0,:]
		pp3    = mat['p3']; p3 = pp3[0,:]
		pp4    = mat['p4']; p4 = pp4[0,:]
		pp5    = mat['p5']; p5 = pp5[0,:]
		pp6    = mat['p6']; p6 = pp6[0,:]
		pp7    = mat['p7']; p7 = pp7[0,:]
		flags  = mat['flag']
	
		Nmodels = len(models[:,0])
		
		for i in range(Nmodels):
			
			# Raw model
			model21_raw = models[i,:]
		
			# Interpolation of model
			func_model  = spi.interp1d(freq_raw, model21_raw, kind='linear')
			model21     = func_model(v)
		
			# Storing models
			out_signals[k,:] = model21	


			# Storing parameter values
			out_par_21[k,:] = par[i,:]
		
			# Storing flags
			out_flags[k,:]  = flags[i,:]
		
			# Storing xHI
			out_xHI59[k]  = xHI59[i]
			out_xHI754[k] = xHI754[i]
			
			# Storing Zeta
			out_Zeta[k]   = Zeta[i]			
		
			# Computing likelihood of models based on estimates for xHI. (arXiv:1411.5375, arXiv:1712.01860)
			#x1, x2 = likelihood_xHI(xHI59[i], xHI754[i])
			#out_L_xHI59[k]  = x1
			#out_L_xHI754[k] = x2
			
			# Computing likelihood of models based on Zeta (ionizing efficiency).
			#out_L_Zeta[k]   = likelihood_Zeta(Zeta[i], par[i,0])
			
		
		
			# Computing and storing likelihoods and related results
			print(k)
			#if np.sum(flags[i,0:2]) == 0:  # only considering first two flags
			
	
			# Computing and storing the likelihood
			#L = likelihood_21cm(d[:,0], d[:,1], d[:,2], noise_std_profile, 0.035, model21, 5, 140)
			L, par_fg, chi_sq = likelihood_21cm_V2(v, t, w, noise_std_profile, syst_std, model21, Nfg, 140, foreground_model = foreground_model)
				
				
			out_L[k]        = L
			out_chi_sq[k]   = chi_sq
			out_par_fg[k,:] = par_fg
				
			#else:
				#out_L[k]        = 0
				#out_chi_sq[k]   = 0
				#out_par_fg[k,:] = np.zeros(5)
									
			k = k + 1
		

	# Saving		
	save_file = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/Global21cmV5/results/results_Npar4_Npix20' + save_filename_suffix + '.hdf5'
	with h5py.File(save_file, 'w') as hf:
		
		hf.create_dataset('frequency',         data = v)
		hf.create_dataset('signals',           data = out_signals)
		hf.create_dataset('parameters_21cm',   data = out_par_21)
		hf.create_dataset('p1',                data = p1)
		hf.create_dataset('p2',                data = p2)
		hf.create_dataset('p3',                data = p3)
		hf.create_dataset('p4',                data = p4)
		hf.create_dataset('p5',                data = p5)
		hf.create_dataset('p6',                data = p6)
		hf.create_dataset('p7',                data = p7)		
		hf.create_dataset('flags',             data = out_flags)
		hf.create_dataset('xHI59',             data = out_xHI59)
		hf.create_dataset('xHI754',            data = out_xHI754)
		hf.create_dataset('Zeta',              data = out_Zeta)
		
		#hf.create_dataset('likelihood_xHI59',  data = out_L_xHI59)
		#hf.create_dataset('likelihood_xHI754', data = out_L_xHI754)
		#hf.create_dataset('likelihood_Zeta',   data = out_L_Zeta)
		hf.create_dataset('likelihood_EDGES',  data = out_L)
		hf.create_dataset('chi_sq',            data = out_chi_sq)
		hf.create_dataset('parameters_fg',     data = out_par_fg)
		
		

	return 0












def likelihood_fialkov_Npar5_Npix20(simulated_data, simulated_residual_fraction, save_filename_suffix, vlow, vhigh, Nfg, syst_std=0.035, foreground_model='EDGES_polynomial'):
	
	"""
	
	Jan 25, 2018
	
	simulated_data:
	'no'
	'yes_just_noise'
	'yes_above_125'
	'yes_above_145'
	'yes_noise_plus_ripples'
	
	IF 'yes_noise_plus_ripples':
	simulated_residual_fraction: 0, 0.25, etc.

	
	"""
	
	
	# Loading High-band data
	v_full, t_full, w_full, noise_full = EDGES_high_band_data(save='no', save_suffix='_test', simulated=simulated_data, residual_fraction=simulated_residual_fraction)
	
	
	# Cutting frequency
	v                 = v_full[(v_full>=vlow) & (v_full<=vhigh)]
	t                 = t_full[(v_full>=vlow) & (v_full<=vhigh)]
	w                 = w_full[(v_full>=vlow) & (v_full<=vhigh)]
	noise_std_profile = noise_full[(v_full>=vlow) & (v_full<=vhigh)]
	
	print('Length of spectrum: ' + str(len(v)))
	
		
	# Frequency vector
	z_raw    = np.arange(5,50.05,0.1)
	freq_raw = redshift2frequency(z_raw)

	# Initializing output array with random numbers, as a worst case scenario
	sz = 20**5    # 3,200,000
	
	out_signals  = np.random.normal(size=(sz, len(v)))
	out_par_21   = np.random.normal(size=(sz, 7))
	out_flags    = np.random.normal(size=(sz, 4))
	out_xHI59    = np.random.normal(size=(sz))
	out_xHI754   = np.random.normal(size=(sz))	
	out_Zeta     = np.random.normal(size=(sz))
	
	#out_L_xHI59  = np.random.normal(size=(sz))
	#out_L_xHI754 = np.random.normal(size=(sz))
	#out_L_Zeta   = np.random.normal(size=(sz))

	out_L        = np.random.normal(size=(sz))
	out_chi_sq   = np.random.normal(size=(sz))
	out_par_fg   = np.random.normal(size=(sz, Nfg))
	


	k = 0
	for j in range(320):

		# Loading models, parameters, and Likelihoods
		#file_name            = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/Global21cmV5/output_files/Npar5_tau_0.055-0.090/grid_Npar5_Npix20_' + str(j+1) + '.mat'
		file_name            = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/Global21cmV5/output_files2/Npar5_vmin_instead_of_Rmfp/grid_Npar5_Npix20_' + str(j+1) + '.mat'
		mat                  = sio.loadmat(file_name)

		models = mat['Signal']/1000  # in K
		xHI59  = mat['xHI59'][0]
		xHI754 = mat['xHI754'][0]
		v011   = mat['v011'][0]
		v016   = mat['v016'][0]
		Zeta   = mat['Zeta'][0]
		par    = mat['parameters_21cm_set']		
		pp1    = mat['p1']; p1 = pp1[0,:]
		pp2    = mat['p2']; p2 = pp2[0,:]
		pp3    = mat['p3']; p3 = pp3[0,:]
		pp4    = mat['p4']; p4 = pp4[0,:]
		pp5    = mat['p5']; p5 = pp5[0,:]
		pp6    = mat['p6']; p6 = pp6[0,:]
		pp7    = mat['p7']; p7 = pp7[0,:]
		flags  = mat['flag']
	
		Nmodels = len(models[:,0])
		
		for i in range(Nmodels):
			
			# Raw model
			model21_raw = models[i,:]
		
			# Interpolation of model
			func_model  = spi.interp1d(freq_raw, model21_raw, kind='linear')
			model21     = func_model(v)
		
			# Storing models
			out_signals[k,:] = model21	


			# Storing parameter values
			out_par_21[k,:] = par[i,:]
		
			# Storing flags
			out_flags[k,:]  = flags[i,:]
		
			# Storing xHI
			out_xHI59[k]  = xHI59[i]
			out_xHI754[k] = xHI754[i]
			
			# Storing Zeta
			out_Zeta[k]   = Zeta[i]			
		
			# Computing likelihood of models based on estimates for xHI. (arXiv:1411.5375, arXiv:1712.01860)
			#x1, x2 = likelihood_xHI(xHI59[i], xHI754[i])
			#out_L_xHI59[k]  = x1
			#out_L_xHI754[k] = x2
			
			# Computing likelihood of models based on Zeta (ionizing efficiency).
			#out_L_Zeta[k]   = likelihood_Zeta(Zeta[i], par[i,0])
			
		
		
			# Computing and storing likelihoods and related results
			print(k)
			#if np.sum(flags[i,0:2]) == 0:  # only considering first two flags
			
	
			# Computing and storing the likelihood
			#L = likelihood_21cm(d[:,0], d[:,1], d[:,2], noise_std_profile, 0.035, model21, 5, 140)
			L, par_fg, chi_sq = likelihood_21cm_V2(v, t, w, noise_std_profile, syst_std, model21, Nfg, 140, foreground_model = foreground_model)
				
				
			out_L[k]        = L
			out_chi_sq[k]   = chi_sq
			out_par_fg[k,:] = par_fg
				
			#else:
				#out_L[k]        = 0
				#out_chi_sq[k]   = 0
				#out_par_fg[k,:] = np.zeros(5)
									
			k = k + 1
		

	# Saving		
	#save_file = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/Global21cmV5/results/Npar5_tau_0.055-0.090/results_Npar5_Npix20' + save_filename_suffix + '.hdf5'
	save_file = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/Global21cmV5/results/Npar5_vmin_instead_of_Rmfp/results_Npar5_Npix20' + save_filename_suffix + '.hdf5'
	with h5py.File(save_file, 'w') as hf:
		
		hf.create_dataset('frequency',         data = v)
		hf.create_dataset('signals',           data = out_signals)
		hf.create_dataset('parameters_21cm',   data = out_par_21)
		hf.create_dataset('p1',                data = p1)
		hf.create_dataset('p2',                data = p2)
		hf.create_dataset('p3',                data = p3)
		hf.create_dataset('p4',                data = p4)
		hf.create_dataset('p5',                data = p5)
		hf.create_dataset('p6',                data = p6)
		hf.create_dataset('p7',                data = p7)		
		hf.create_dataset('flags',             data = out_flags)
		hf.create_dataset('xHI59',             data = out_xHI59)
		hf.create_dataset('xHI754',            data = out_xHI754)
		hf.create_dataset('Zeta',              data = out_Zeta)
		
		#hf.create_dataset('likelihood_xHI59',  data = out_L_xHI59)
		#hf.create_dataset('likelihood_xHI754', data = out_L_xHI754)
		#hf.create_dataset('likelihood_Zeta',   data = out_L_Zeta)
		
		hf.create_dataset('likelihood_EDGES',  data = out_L)
		hf.create_dataset('chi_sq',            data = out_chi_sq)
		hf.create_dataset('parameters_fg',     data = out_par_fg)
		
		

	return 0


























def plot_fialkov_models_likelihood():
	
	file_name = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/Global21cmV5/results/results_Npar4_Npix20_90-190MHz_Nfg5.hdf5'
	v, signals, par_21, p1, p2, p3, p4, p5, p6, p7, flags, xHI59, xHI754, Zeta, LE, chi_sq, par_fg = read_likelihood_fialkov(file_name)  # L_xHI59, L_xHI754, L_Zeta, 
	
	
	# Frequency vector
	z_raw = np.arange(5,50.05,0.1)
	freq  = redshift2frequency(z_raw)

	for j in range(16):

		# Loading models, parameters, and Likelihoods
		file_name   = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/Global21cmV5/output_files/grid_Npar4_Npix20_' + str(j+1) + '.mat'
		mat         = sio.loadmat(file_name)
		models_file = mat['Signal']/1000  # in K
		
		print(j)
		if j == 0:
			models = np.copy(models_file)
		elif j > 0:
			models = np.append(models, models_file, axis=0)
	
	
	LLE = np.log10(LE/np.max(LE))
	
	i_subset = np.random.randint(0, len(LLE), size=3000)
	ix       = np.argsort(LLE[i_subset])
	ir       = ix[::-1]
	
	min_LLE = np.min(LLE)
	max_LLE = np.max(LLE)
	
	
	
	
		
	# ---------------------------------------

	sx = 6
	sy = 4
	x0 = 0.12
	y0 = 0.12
	dx = 0.75
	dy = 0.75

	cb_x0 = 0.9
	cb_dx = 0.02
	cb_dy = (11/13)*dy

	xmin = 40
	xmax = 203

	ymin = -290
	ymax = 40

	lw   = 6		


	
	
	CMAP = cm.gnuplot
	XY = [[0,0],[0,0]]	
	
	min_log_like = -4
	max_log_like =  0
	levels = np.arange(min_log_like, max_log_like+0.001, 0.001)
	IMAGE_MAP = plt.contourf(XY, levels, cmap=CMAP, vmin=min_log_like, vmax=max_log_like)
	print(levels)
	plt.close()


	plt.close()
	plt.close()
	plt.close()
	
	
	
	
	
	fig  = plt.figure(num=1, figsize=(sx, sy))
	ax   = fig.add_axes([x0, y0, dx, dy])
	for i in range(len(i_subset)):   # len(LE)
		kc = (LLE[i_subset[ir[i]]]-min_log_like)/(max_log_like-min_log_like)
		c  = CMAP(kc)
		ax.plot(freq, 1000*models[i_subset[ir[i]],:], color=c, linewidth=0.12)


	ax.plot([90, 90], [-400,100], c=[0,0.7,0], linestyle='--', linewidth=lw)
	ax.plot([190, 190], [-400,100], c=[0,0.7,0], linestyle='--', linewidth=lw)
	ax.set_xticks([50, 70, 90, 110, 130, 150, 170, 190])
	##ax.set_xticklabels([])
	ax.set_xlim([xmin, xmax])
	ax.set_ylim([ymin, ymax])
	ax.set_xlabel('frequency [MHz]')
	ax.set_ylabel('temperature [mK]')
	ax.grid()
	ax.arrow(90, -280, 90, 0,   fc=[0,0.7,0], ec=[0,0.7,0], head_width=15, head_length=10,   linewidth=1, zorder=6)
	ax.arrow(190, -280, -90, 0, fc=[0,0.7,0], ec=[0,0.7,0], head_width=15, head_length=10,   linewidth=1, zorder=6)		
	plt.text(106,-275, 'EDGES High-Band', fontsize=15, color=[0,0.7,0])

	cax1 = fig.add_axes([(9.86/10)*cb_x0, (y0+0*dy)+(dy/13), cb_dx, cb_dy])
	cbar = plt.colorbar(IMAGE_MAP, cax=cax1, ticks=np.arange(-7,0.1,1))
	cbar.ax.set_ylabel(r'$log_{10}(L/L_{\rm max})$', fontsize=12)
	
	
	ax2 = ax.twiny()
	ax2.set_xlabel(r'$z$', fontsize=14)
	z0 = frequency2redshift(40)
	ax2.set_xticks(np.array((np.abs(redshift2frequency(28)-40), np.abs(redshift2frequency(24)-40), np.abs(redshift2frequency(20)-40), np.abs(redshift2frequency(18)-40), np.abs(redshift2frequency(16)-40), np.abs(redshift2frequency(14)-40), np.abs(redshift2frequency(12)-40), np.abs(redshift2frequency(10)-40), np.abs(redshift2frequency(9)-40), np.abs(redshift2frequency(8)-40), np.abs(redshift2frequency(7)-40), np.abs(202-40))))
	ax2.set_xticklabels(['28', '24', '20', '18', '16', '14', '12', '10', '9', '8', '7', '6'])	

	
	plt.savefig(home_folder + '/DATA/EDGES/results/plots/20180123/fialkov_models_likelihood.pdf', bbox_inches='tight')	
	
	return 0










def likelihood_xHI(model_xHI59, model_xHI708, model_xHI754): 

	"""
	Jan 25, 2018
	"""


	# One-sided Gaussian constraint from arXiv:1411.5375 (McGreer et al.)
	peak_xHI59  = 0.06
	sigma_xHI59 = 0.05
	
	if np.isscalar(model_xHI59) == True:	# scalar
		if model_xHI59 <= peak_xHI59:
			L_xHI59 = 1
			
		elif model_xHI59 > peak_xHI59:
			L_xHI59 = np.exp(-(1/2)*((model_xHI59-peak_xHI59)/(sigma_xHI59))**2)
			
	elif len(model_xHI59.shape) == 1:  # numpy array of 1 dimension
		L_xHI59 = np.exp(-(1/2)*((model_xHI59-peak_xHI59)/(sigma_xHI59))**2)
		L_xHI59[model_xHI59 <= peak_xHI59] = 1
		






	# Constraint at z=7.08 from Greig et al. 2017. We use the Small EoR morphology
	d = np.genfromtxt(home_folder + '/DATA/EDGES_old/global_21cm_models/greig_ULASJ1120_NFPDF/ULASJ1120_NFPDF.txt')
	
	par       = np.polyfit(d[:,0], d[:,1], 6)
	L_xHI708  = np.polyval(par, model_xHI708)
	Norm      = 1.9339544424420476
	L_xHI708  = L_xHI708 / Norm
	




	
	
	
	# DIRECT Constraint from arXiv:1712.01860 (Banados et al.)
	d = np.genfromtxt(home_folder + '/DATA/EDGES_old/global_21cm_models/banados/banados2017_fig3_xHIpdf_dist.dat')
	raw_xHI754_N   = d[:,0] #np.append(d[:,0], 1)
	raw_L_xHI754_N = d[:,1]
	
	# Adding two points at the beginning that reach to zero
	raw_xHI754_N   = np.insert(raw_xHI754_N, 0, 0)
	raw_L_xHI754_N = np.insert(raw_L_xHI754_N, 0, 0)
	
	raw_xHI754_N   = np.insert(raw_xHI754_N, 1, 0.19)
	raw_L_xHI754_N = np.insert(raw_L_xHI754_N, 1, 0)
	
	# Adding a point at xHI=1
	raw_xHI754_N   = np.append(raw_xHI754_N, 1)
	raw_L_xHI754_N = np.append(raw_L_xHI754_N, raw_L_xHI754_N[-1])
	
	# Normalize
	Norm           = 2.563
	raw_L_xHI754_N = raw_L_xHI754_N / Norm

	# Interpolation
	function_xHI754_N = spi.interp1d(raw_xHI754_N, raw_L_xHI754_N, kind='linear')
	
	# Evaluating function at input value model_xHI754
	L_xHI754_N = function_xHI754_N(model_xHI754)
	
	
	
	
	# CONSERVATIVE Constraint from arXiv:1712.01860 (Banados et al.)
	raw_xHI754_C      = np.array([0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0])
	Norm              = 1.7065      # normalization constant so that maximum likelihood possible is 1
	raw_L_xHI754_C    = np.array([0.1, 0.2, 0.45, 0.74, 1.09, 1.42, 1.66, 1.66, 1.28, 0.82, 0.55]) / Norm
	function_xHI754_C = spi.interp1d(raw_xHI754_C, raw_L_xHI754_C, kind='cubic')
	
	# Evaluating function at input value model_xHI754
	L_xHI754_C = function_xHI754_C(model_xHI754)
	
	

	return L_xHI59, L_xHI708, L_xHI754_N, L_xHI754_C











def likelihood_xHI_mason2018(model_xHI): 

	"""
	Sept 25, 2018
	"""
	
	d = np.genfromtxt(home_folder + '/DATA/EDGES_old/global_21cm_models/mason2018_pdf/Mason2018_xHI_z7_pentericci14_N67.txt')
	raw_xHI   = d[:,0]
	raw_L_xHI = d[:,1]
	Norm      = np.max(raw_L_xHI)
	raw_L_xHI = raw_L_xHI / Norm
	
	function_xHI = spi.interp1d(raw_xHI, raw_L_xHI, kind='linear')
	L_xHI        = function_xHI(model_xHI)
	
	return L_xHI


	
	














def likelihood_Zeta(Zeta, f_star):
	
	"""
	Jan 25, 2018
	
	"""
	
	
	if (np.isscalar(Zeta) == True) and (np.isscalar(f_star) == True):    # scalar
		if Zeta <= 40000*f_star:
			L = 1
		
		elif Zeta > 40000*f_star:
			L = 0
			
	elif (len(Zeta.shape) == 1) and (len(f_star.shape) == 1):  # numpy array of 1 dimension
		L = np.ones(len(Zeta))
		L[Zeta > 40000*f_star] = 0
		
	return L








def likelihood_tau_planck(tau, tau0=0.058, sigma=0.012):
	
	"""
	Jan 27, 2018
	
	"""
		
	L = np.exp(  -(1/2) * (((tau-tau0)/sigma)**2)  )
	
	return L
















def read_likelihood_fialkov(file_name, version='v6'):
	"""
	Jan 3, 2018 (yeah, that's right!!)
	"""
	
	with h5py.File(file_name, 'r') as hf:
		
		
		x       = hf.get('frequency')
		v       = np.array(x)
		
		x       = hf.get('signals',)
		signals = np.array(x)
		
		x       = hf.get('parameters_21cm')
		par_21  = np.array(x)
		
		x       = hf.get('p1')
		p1      = np.array(x)
		
		x  = hf.get('p2')
		p2 = np.array(x)
		
		x  = hf.get('p3')
		p3 = np.array(x)
		
		x  = hf.get('p4')
		p4 = np.array(x)
		
		x  = hf.get('p5')
		p5 = np.array(x)
		
		x  = hf.get('p6')
		p6 = np.array(x)
		
		x  = hf.get('p7')
		p7 = np.array(x)
		
		x     = hf.get('flags')
		flags = np.array(x)
		
		x      = hf.get('xHI59')
		xHI59  = np.array(x)

		if version == 'v6':
			x      = hf.get('xHI708')
			xHI708 = np.array(x)
		elif version == 'v5':
			xHI708 = 0
		
		x      = hf.get('xHI754')
		xHI754 = np.array(x)
		
		x      = hf.get('Zeta')
		Zeta   = np.array(x)
	
		#x       = hf.get('likelihood_xHI59')
		#L_xHI59 = np.array(x)
		
		#x        = hf.get('likelihood_xHI754')
		#L_xHI754 = np.array(x)
		
		#x        = hf.get('likelihood_Zeta')
		#L_Zeta   = np.array(x)
		
		x = hf.get('likelihood_EDGES')
		L = np.array(x)
		
		x      = hf.get('chi_sq')
		chi_sq = np.array(x)
		
		x      = hf.get('parameters_fg')
		par_fg = np.array(x)
		
		
		
	# Reordering of 21cm parameters
	Xpar_21 = np.copy(par_21)
	Xpar_21[:,0] = np.copy(par_21[:,1])  # vc
	Xpar_21[:,1] = np.copy(par_21[:,0])  # f*
	Xpar_21[:,2] = np.copy(par_21[:,2])  # fx
	Xpar_21[:,3] = np.copy(par_21[:,4])  # alpha
	Xpar_21[:,4] = np.copy(par_21[:,5])  # vmin
	Xpar_21[:,5] = np.copy(par_21[:,3])  # tau
	Xpar_21[:,6] = np.copy(par_21[:,6])  # Rmfp
	
	
	Xp1 = np.copy(p2)
	Xp2 = np.copy(p1)
	Xp3 = np.copy(p3)
	Xp4 = np.copy(p5)
	Xp5 = np.copy(p6)
	Xp6 = np.copy(p4)
	Xp7 = np.copy(p7)
	
	
	
		
			
	return v, signals, Xpar_21, Xp1, Xp2, Xp3, Xp4, Xp5, Xp6, Xp7, flags, xHI59, xHI708, xHI754, Zeta, L, chi_sq, par_fg  # L_xHI59, L_xHI754, L_Zeta, 




























def fialkov_probabilities_lores():


	# Just to get the list of parameters
	file_name = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/Global21cmV4/output_files/grid_Npar7_Npix5_1.mat'
	mat       = sio.loadmat(file_name)
	models_set           = mat['Signal']/1000  # in K
	flags_set            = mat['flag']
	parameters_21cm_set  = mat['parameters_21cm_set']
	pp1                  = mat['p1']; p1 = pp1[0,:]
	pp2                  = mat['p2']; p2 = pp2[0,:]
	pp3                  = mat['p3']; p3 = pp3[0,:]
	pp4                  = mat['p4']; p4 = pp4[0,:]
	pp5                  = mat['p5']; p5 = pp5[0,:]
	pp6                  = mat['p6']; p6 = pp6[0,:]
	pp7                  = mat['p7']; p7 = pp7[0,:]
	par_list             = [p1, p2, p3, p4, p5, p6, p7]

	
	
	
	# Likelihood results
	file_name = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/Global21cmV4/results/results_Npix5_full.hdf5'
	with h5py.File(file_name, 'r') as hf:

		X  = hf.get('likelihood')
		LL = np.array(X)
		L  = LL[:,1]
		
		X  = hf.get('chi_sq')
		XX = np.array(X)
		X2 = XX[:,1]		
		
		X               = hf.get('parameters_21cm')
		parameters_21cm = np.array(X)
		
		X               = hf.get('parameters_fg')
		parameters_fg   = np.array(X)		

		X     = hf.get('flags')
		flags = np.array(X)		
			
			




	#Npix   = 10


	## Loading models, parameters, and Likelihoods
	#file_name = home_folder + '/Desktop/MCMC/model_grids/grid_Npix5.mat'
	#mat       = sio.loadmat(file_name)
	#models           = mat['Signal']/1000  # in K
	#flags            = mat['flag']
	#parameters_21cm  = mat['parameters_21cm']
	#pp1              = mat['p1']; p1 = pp1[0,:]
	#pp2              = mat['p2']; p2 = pp2[0,:]
	#pp3              = mat['p3']; p3 = pp3[0,:]
	#pp4              = mat['p4']; p4 = pp4[0,:]
	#pp5              = mat['p5']; p5 = pp5[0,:]
	#pp6              = mat['p6']; p6 = pp6[0,:]
	#pp7              = mat['p7']; p7 = pp7[0,:]
	#par_list         = [p1, p2, p3, p4, p5, p6, p7]

	#path_file = home_folder + '/DATA/EDGES/results/high_band/products/model_rejection/global_21cm_anastasia/likelihood/likelihood_grid_Npix5_20171027_cov2.txt'
	#Ld = np.genfromtxt(path_file)
	#L  = Ld[:,1]











	Npix   = 5


	# Initialize output lists
	area_all        = []
	pix_all         = []
	Prob_all        = []
	Prob_limits_all = []
	Prob_par1_all   = []
	Prob_par2_all   = []
	Prob_par3_all   = []
	Prob_par4_all   = []
	Prob_par5_all   = []
	Prob_par6_all   = []
	Prob_par7_all   = []


	# Compute all the parameter combination
	for ka in range(len(par_list)):

		# if a=3, b=4,5,6  (from 0 to 6)
		list_b  = list(range(len(par_list) - (ka+1)))
		range_b = list(np.asarray(list_b) + (ka+1))






		for kb in range_b:

			# Likelihood for each pair of parameters
			# --------------------------------------

			# List of values for the two parameters
			pa    = par_list[ka] 
			pb    = par_list[kb]


			# Log to linear and back
			## Edges of the pixels
			if ka < 3:
				lpa          = np.log10(pa)
				delta_la     = lpa[1] - lpa[0]
				edges_la     = lpa - (delta_la/2)
				last_edge_la = edges_la[-1] + delta_la
				edges_a      = np.append(edges_la, last_edge_la)
				#edges_la     = np.append(edges_la, last_edge_la)
				#edges_a      = 10**(edges_la)

			if ka >= 3:
				delta_a     = pa[1] - pa[0]				
				edges_a     = np.asarray(pa) - (delta_a/2)
				last_edge_a = edges_a[-1] + delta_a
				edges_a     = np.append(edges_a, last_edge_a)



			if kb < 3:
				lpb          = np.log10(pb)
				delta_lb     = lpb[1] - lpb[0]
				edges_lb     = lpb - (delta_lb/2)
				last_edge_lb = edges_lb[-1] + delta_lb
				edges_b      = np.append(edges_lb, last_edge_lb)
				#edges_lb     = np.append(edges_lb, last_edge_lb)
				#edges_b      = 10**(edges_lb)				

			if kb >= 3:
				delta_b     = pb[1] - pb[0]				
				edges_b     = np.asarray(pb) - (delta_b/2)
				last_edge_b = edges_b[-1] + delta_b
				edges_b     = np.append(edges_b, last_edge_b)			






			## Edges of the pixels
			#delta_a     = pa[1] - pa[0]				
			#edges_a     = np.asarray(pa) - (delta_a/2)
			#last_edge_a = edges_a[-1] + delta_a
			#edges_a     = np.append(edges_a, last_edge_a)
			#print(edges_a)

			#delta_b     = pb[1] - pb[0]				
			#edges_b     = np.asarray(pb) - (delta_b/2)
			#last_edge_b = edges_b[-1] + delta_b
			#edges_b     = np.append(edges_b, last_edge_b)			




			# Values of each of the two parameters, for each of the models evaluated
			par_a = parameters_21cm[:,ka]
			par_b = parameters_21cm[:,kb]




			# Likelihood and area in each pixel
			LX_av      = np.zeros((Npix, Npix))
			area_pixel = np.zeros((Npix, Npix))
			pix        = np.zeros((Npix, Npix))
			for index_b in range(Npix):
				for index_a in range(Npix):
					a                       = pa[index_a]
					b                       = pb[index_b]			
					LX                      = L[(par_a == a) & (par_b == b)]
					LX                      = LX[LX != 0]
					LX_av[index_b, index_a]      = np.sum(LX) / len(LX)    # likelihood weighted by number of pixels with good data
					pix[index_b, index_a]   = len(LX)
					area_pixel[index_b, index_a] = (edges_a[index_a+1] - edges_a[index_a]) * (edges_b[index_b+1] - edges_b[index_b])  # delta_a * delta_b ##


			# Area of pixel normalized to the area of all pixels with non-NaN likelihood
			normalized_area_pixel = area_pixel/np.sum(area_pixel[np.isnan(LX_av)==False])


			# Normalized probability for flat priors
			#Prob = LX_av/np.sum(LX_av[np.isnan(LX_av)==False])  # discarding points with NaNs
			area_weighted_LX_av = LX_av * normalized_area_pixel
			integral_area_weighted_LX_av = np.sum(area_weighted_LX_av[np.isnan(LX_av)==False])   # discarding points with NaNs
			Prob = area_weighted_LX_av / integral_area_weighted_LX_av 


			## Normalized probability
			#for index_b in range(Npix):
				#for index_a in range(Npix):			

			# Probability limits
			Prob_1D = Prob.reshape(1,-1)[0]
			ix = np.argsort(Prob_1D)
			Prob_limits_1D = np.zeros(len(ix))
			acc_prob = 0

			for i in range(len(ix)):
				if np.isnan(Prob_1D[ix[i]]) == False:
					acc_prob = acc_prob + Prob_1D[ix[i]]
					#print(acc_prob)
					if 0 <= acc_prob <= 0.05:
					#if 0 <= acc_prob <= 0.1:
						Prob_limits_1D[ix[i]] = 0

					elif 0.05 <= acc_prob <= 0.32:
					#elif 0.1 <= acc_prob <= 0.4:
						Prob_limits_1D[ix[i]] = 1

					elif 0.32 <= acc_prob <= 1.01:
					#elif 0.4 <= acc_prob <= 1.01:
						Prob_limits_1D[ix[i]] = 2

				elif np.isnan(Prob_1D[ix[i]]) == True:
					Prob_limits_1D[ix[i]] = np.nan

			Prob_limits = Prob_limits_1D.reshape(Npix, Npix)		


			# 1D probability profile

			if (ka == 0):
				Prob_par1 = np.sum(Prob, axis=0)
				Prob_par1_all.append(Prob_par1)

			elif (kb == 0):
				Prob_par1 = np.sum(Prob, axis=1)
				Prob_par1_all.append(Prob_par1)


			if (ka == 1):
				Prob_par2 = np.sum(Prob, axis=0)
				Prob_par2_all.append(Prob_par2)

			elif (kb == 1):
				Prob_par2 = np.sum(Prob, axis=1)
				Prob_par2_all.append(Prob_par2)			


			if (ka == 2):
				Prob_par3 = np.sum(Prob, axis=0)
				Prob_par3_all.append(Prob_par3)

			elif (kb == 2):
				Prob_par3 = np.sum(Prob, axis=1)
				Prob_par3_all.append(Prob_par3)	


			if (ka == 3):
				Prob_par4 = np.sum(Prob, axis=0)
				Prob_par4_all.append(Prob_par4)

			elif (kb == 3):
				Prob_par4 = np.sum(Prob, axis=1)
				Prob_par4_all.append(Prob_par4)			


			if (ka == 4):
				Prob_par5 = np.sum(Prob, axis=0)
				Prob_par5_all.append(Prob_par5)

			elif (kb == 4):
				Prob_par5 = np.sum(Prob, axis=1)
				Prob_par5_all.append(Prob_par5)		


			if (ka == 5):
				Prob_par6 = np.sum(Prob, axis=0)
				Prob_par6_all.append(Prob_par6)

			elif (kb == 5):
				Prob_par6 = np.sum(Prob, axis=1)
				Prob_par6_all.append(Prob_par6)		


			if (ka == 6):
				Prob_par7 = np.sum(Prob, axis=0)
				Prob_par7_all.append(Prob_par7)

			elif (kb == 6):
				Prob_par7 = np.sum(Prob, axis=1)
				Prob_par7_all.append(Prob_par7)





			# Storing results
			area_all.append(normalized_area_pixel)
			Prob_all.append(Prob)
			Prob_limits_all.append(Prob_limits)
			pix_all.append(pix)



	return p1, p2, p3, p4, p5, p6, p7, pix_all, Prob_all, Prob_limits_all, Prob_par1_all, Prob_par2_all, Prob_par3_all, Prob_par4_all, Prob_par5_all, Prob_par6_all, Prob_par7_all



















def fialkov_probabilities_lores_5par():


	# Just to get the list of parameters
	file_name            = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/Global21cmV4/output_files/grid_Npar7_Npix5_1.mat'
	mat                  = sio.loadmat(file_name)
	models_set           = mat['Signal']/1000  # in K         #  NOT used
	flags_set            = mat['flag']                        #  NOT used
	parameters_21cm_set  = mat['parameters_21cm_set']         #  NOT used
	pp1                  = mat['p1']; p1 = pp1[0,:]           
	pp2                  = mat['p2']; p2 = pp2[0,:]
	pp3                  = mat['p3']; p3 = pp3[0,:]
	pp4                  = mat['p4']; p4 = pp4[0,:]
	pp5                  = mat['p5']; p5 = pp5[0,:]
	pp6                  = mat['p6']; p6 = pp6[0,:]
	pp7                  = mat['p7']; p7 = pp7[0,:]
	#par_list             = [p1, p2, p3, p4, p5, p6, p7]
	

	
	
	
	# Likelihood results
	file_name = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/Global21cmV4/results/results_Npix5_full.hdf5'
	with h5py.File(file_name, 'r') as hf:

		X       = hf.get('likelihood')
		LL      = np.array(X)
		L_7par  = LL[:,1]
		
		X                    = hf.get('parameters_21cm')
		parameters_21cm_7par = np.array(X)

		X          = hf.get('flags')
		flags_7par = np.array(X)		
			



	
	# Fixing 2 parameters (5 and 6, out of 7)
	par_list = [p1, p2, p3, p4, p7]  # p5, p6, 	
	
	p5_fixed = p5[2]
	p6_fixed = p6[2]
	
	parameters_21cm = parameters_21cm_7par[(parameters_21cm_7par[:,4] == p5_fixed) & (parameters_21cm_7par[:,5] == p6_fixed), :]
	parameters_21cm = parameters_21cm[:,[0,1,2,3,6]]
	
	L               = L_7par[(parameters_21cm_7par[:,4] == p5_fixed) & (parameters_21cm_7par[:,5] == p6_fixed)]
	
	flags           = flags_7par[(parameters_21cm_7par[:,4] == p5_fixed) & (parameters_21cm_7par[:,5] == p6_fixed), :]
	







	Npix   = 5

	# Initialize output lists
	area_all        = []
	pix_all         = []
	Prob_all        = []
	Prob_limits_all = []
	Prob_par1_all   = []
	Prob_par2_all   = []
	Prob_par3_all   = []
	Prob_par4_all   = []
	Prob_par5_all   = []
	#Prob_par6_all   = []
	#Prob_par7_all   = []


	# Compute all the parameter combination
	for ka in range(len(par_list)):

		# if a=3, b=4,5,6  (from 0 to 6)
		list_b  = list(range(len(par_list) - (ka+1)))
		range_b = list(np.asarray(list_b) + (ka+1))

		for kb in range_b:

			# Likelihood for each pair of parameters
			# --------------------------------------

			# List of values for the two parameters
			pa    = par_list[ka] 
			pb    = par_list[kb]


			# Log to linear and back
			## Edges of the pixels
			if ka < 3:
				lpa          = np.log10(pa)
				delta_la     = lpa[1] - lpa[0]
				edges_la     = lpa - (delta_la/2)
				last_edge_la = edges_la[-1] + delta_la
				edges_a     = np.append(edges_la, last_edge_la)
				#edges_la     = np.append(edges_la, last_edge_la)
				#edges_a      = 10**(edges_la)

			if ka >= 3:
				delta_a     = pa[1] - pa[0]				
				edges_a     = np.asarray(pa) - (delta_a/2)
				last_edge_a = edges_a[-1] + delta_a
				edges_a     = np.append(edges_a, last_edge_a)



			if kb < 3:
				lpb          = np.log10(pb)
				delta_lb     = lpb[1] - lpb[0]
				edges_lb     = lpb - (delta_lb/2)
				last_edge_lb = edges_lb[-1] + delta_lb
				edges_b     = np.append(edges_lb, last_edge_lb)
				#edges_lb     = np.append(edges_lb, last_edge_lb)
				#edges_b      = 10**(edges_lb)				

			if kb >= 3:
				delta_b     = pb[1] - pb[0]				
				edges_b     = np.asarray(pb) - (delta_b/2)
				last_edge_b = edges_b[-1] + delta_b
				edges_b     = np.append(edges_b, last_edge_b)			






			## Edges of the pixels
			#delta_a     = pa[1] - pa[0]				
			#edges_a     = np.asarray(pa) - (delta_a/2)
			#last_edge_a = edges_a[-1] + delta_a
			#edges_a     = np.append(edges_a, last_edge_a)
			#print(edges_a)

			#delta_b     = pb[1] - pb[0]				
			#edges_b     = np.asarray(pb) - (delta_b/2)
			#last_edge_b = edges_b[-1] + delta_b
			#edges_b     = np.append(edges_b, last_edge_b)			




			# Values of each of the two parameters, for each of the models evaluated
			par_a = parameters_21cm[:,ka]
			par_b = parameters_21cm[:,kb]




			# Likelihood and area in each pixel
			LX_av      = np.zeros((Npix, Npix))
			area_pixel = np.zeros((Npix, Npix))
			pix        = np.zeros((Npix, Npix))
			for index_b in range(Npix):
				for index_a in range(Npix):
					a                       = pa[index_a]
					b                       = pb[index_b]		
					LX                      = L[(par_a == a) & (par_b == b)]
					LX                      = LX[LX != 0]
					LX_av[index_b, index_a] = np.sum(LX) / len(LX)    # likelihood weighted by number of pixels with good data
					pix[index_b, index_a]   = len(LX)
					area_pixel[index_b, index_a] = (edges_a[index_a+1] - edges_a[index_a]) * (edges_b[index_b+1] - edges_b[index_b])  # delta_a * delta_b ##


			# Area of pixel normalized to the area of all pixels with non-NaN likelihood
			normalized_area_pixel = area_pixel/np.sum(area_pixel[np.isnan(LX_av)==False])


			# Normalized probability for flat priors
			#Prob = LX_av/np.sum(LX_av[np.isnan(LX_av)==False])  # discarding points with NaNs
			area_weighted_LX_av = LX_av * normalized_area_pixel
			integral_area_weighted_LX_av = np.sum(area_weighted_LX_av[np.isnan(LX_av)==False])   # discarding points with NaNs
			Prob = area_weighted_LX_av / integral_area_weighted_LX_av 


			## Normalized probability
			#for index_b in range(Npix):
				#for index_a in range(Npix):			

			# Probability limits
			Prob_1D = Prob.reshape(1,-1)[0]
			ix = np.argsort(Prob_1D)
			Prob_limits_1D = np.zeros(len(ix))
			acc_prob = 0

			for i in range(len(ix)):
				if np.isnan(Prob_1D[ix[i]]) == False:
					acc_prob = acc_prob + Prob_1D[ix[i]]
					#print(acc_prob)
					if 0 <= acc_prob <= 0.05:
					#if 0 <= acc_prob <= 0.1:
						Prob_limits_1D[ix[i]] = 0

					elif 0.05 <= acc_prob <= 0.32:
					#elif 0.1 <= acc_prob <= 0.4:
						Prob_limits_1D[ix[i]] = 1

					elif 0.32 <= acc_prob <= 1.01:
					#elif 0.4 <= acc_prob <= 1.01:
						Prob_limits_1D[ix[i]] = 2

				elif np.isnan(Prob_1D[ix[i]]) == True:
					Prob_limits_1D[ix[i]] = np.nan

			Prob_limits = Prob_limits_1D.reshape(Npix, Npix)		


			# 1D probability profile

			if (ka == 0):
				Prob_par1 = np.sum(Prob, axis=0)
				Prob_par1_all.append(Prob_par1)

			elif (kb == 0):
				Prob_par1 = np.sum(Prob, axis=1)
				Prob_par1_all.append(Prob_par1)


			if (ka == 1):
				Prob_par2 = np.sum(Prob, axis=0)
				Prob_par2_all.append(Prob_par2)

			elif (kb == 1):
				Prob_par2 = np.sum(Prob, axis=1)
				Prob_par2_all.append(Prob_par2)			


			if (ka == 2):
				Prob_par3 = np.sum(Prob, axis=0)
				Prob_par3_all.append(Prob_par3)

			elif (kb == 2):
				Prob_par3 = np.sum(Prob, axis=1)
				Prob_par3_all.append(Prob_par3)	


			if (ka == 3):
				Prob_par4 = np.sum(Prob, axis=0)
				Prob_par4_all.append(Prob_par4)

			elif (kb == 3):
				Prob_par4 = np.sum(Prob, axis=1)
				Prob_par4_all.append(Prob_par4)			


			if (ka == 4):
				Prob_par5 = np.sum(Prob, axis=0)
				Prob_par5_all.append(Prob_par5)

			elif (kb == 4):
				Prob_par5 = np.sum(Prob, axis=1)
				Prob_par5_all.append(Prob_par5)		


			#if (ka == 5):
				#Prob_par6 = np.sum(Prob, axis=0)
				#Prob_par6_all.append(Prob_par6)

			#elif (kb == 5):
				#Prob_par6 = np.sum(Prob, axis=1)
				#Prob_par6_all.append(Prob_par6)		


			#if (ka == 6):
				#Prob_par7 = np.sum(Prob, axis=0)
				#Prob_par7_all.append(Prob_par7)

			#elif (kb == 6):
				#Prob_par7 = np.sum(Prob, axis=1)
				#Prob_par7_all.append(Prob_par7)





			# Storing results
			area_all.append(normalized_area_pixel)
			Prob_all.append(Prob)
			Prob_limits_all.append(Prob_limits)
			pix_all.append(pix)



	return p1, p2, p3, p4, p5, p6, p7, pix_all, Prob_all, Prob_limits_all, Prob_par1_all, Prob_par2_all, Prob_par3_all, Prob_par4_all, Prob_par5_all  #, Prob_par6_all, Prob_par7_all





































def fialkov_probabilities_hires():


	# Just to get the list of parameters
	file_name = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/Global21cmV3/output_files/grid_Npix10_1.mat'
	mat       = sio.loadmat(file_name)
	models_set           = mat['Signal']/1000  # in K
	flags_set            = mat['flag']
	parameters_21cm_set  = mat['parameters_21cm_set']
	pp1                  = mat['p1']; p1 = pp1[0,:]
	pp2                  = mat['p2']; p2 = pp2[0,:]
	pp3                  = mat['p3']; p3 = pp3[0,:]
	pp4                  = mat['p4']; p4 = pp4[0,:]
	pp5                  = mat['p5']; p5 = pp5[0,:]
	pp6                  = mat['p6']; p6 = pp6[0,:]
	pp7                  = mat['p7']; p7 = pp7[0,:]
	par_list             = [p1, p2, p3, p4, p5, p6, p7]

	
	
	
	# Likelihood results
	file_name = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/Global21cmV3/results/results_Npix10_full.hdf5'
	with h5py.File(file_name, 'r') as hf:
			
		X  = hf.get('likelihood')
		LL = np.array(X)
		L  = LL[:,1]
		
		X               = hf.get('parameters_21cm')
		parameters_21cm = np.array(X)

		X     = hf.get('flags')
		flags = np.array(X)		
			
			




	Npix   = 10
	

	# Initialize output lists
	area_all        = []
	pix_all         = []
	Prob_all        = []
	Prob_limits_all = []
	Prob_par1_all   = []
	Prob_par2_all   = []
	Prob_par3_all   = []
	Prob_par4_all   = []
	Prob_par5_all   = []
	Prob_par6_all   = []
	Prob_par7_all   = []


	# Compute all the parameter combination
	for ka in range(len(par_list)):

		# if a=3, b=4,5,6  (from 0 to 6)
		list_b  = list(range(len(par_list) - (ka+1)))
		range_b = list(np.asarray(list_b) + (ka+1))

		for kb in range_b:

			# Likelihood for each pair of parameters
			# --------------------------------------

			# List of values for the two parameters
			pa    = par_list[ka] 
			pb    = par_list[kb]



			print((ka, kb))

			# Log to linear and back
			## Edges of the pixels
			if ka < 3:
				lpa          = np.log10(pa)
				delta_la     = lpa[1] - lpa[0]
				edges_la     = lpa - (delta_la/2)
				last_edge_la = edges_la[-1] + delta_la
				edges_a      = np.append(edges_la, last_edge_la)
				#edges_la     = np.append(edges_la, last_edge_la)
				#edges_a      = 10**(edges_la)

			if ka >= 3:
				delta_a     = pa[1] - pa[0]				
				edges_a     = np.asarray(pa) - (delta_a/2)
				last_edge_a = edges_a[-1] + delta_a
				edges_a     = np.append(edges_a, last_edge_a)



			if kb < 3:
				lpb          = np.log10(pb)
				delta_lb     = lpb[1] - lpb[0]
				edges_lb     = lpb - (delta_lb/2)
				last_edge_lb = edges_lb[-1] + delta_lb
				edges_b      = np.append(edges_lb, last_edge_lb)
				#edges_lb     = np.append(edges_lb, last_edge_lb)
				#edges_b      = 10**(edges_lb)				

			if kb >= 3:
				delta_b     = pb[1] - pb[0]				
				edges_b     = np.asarray(pb) - (delta_b/2)
				last_edge_b = edges_b[-1] + delta_b
				edges_b     = np.append(edges_b, last_edge_b)			






			## Edges of the pixels
			#delta_a     = pa[1] - pa[0]				
			#edges_a     = np.asarray(pa) - (delta_a/2)
			#last_edge_a = edges_a[-1] + delta_a
			#edges_a     = np.append(edges_a, last_edge_a)
			#print(edges_a)

			#delta_b     = pb[1] - pb[0]				
			#edges_b     = np.asarray(pb) - (delta_b/2)
			#last_edge_b = edges_b[-1] + delta_b
			#edges_b     = np.append(edges_b, last_edge_b)			




			# Values of each of the two parameters, for each of the models evaluated
			par_a = parameters_21cm[:,ka]
			par_b = parameters_21cm[:,kb]




			# Likelihood and area in each pixel
			LX_av      = np.zeros((Npix, Npix))
			area_pixel = np.zeros((Npix, Npix))
			pix        = np.zeros((Npix, Npix))
			for index_b in range(Npix):
				for index_a in range(Npix):
					a                       = pa[index_a]
					b                       = pb[index_b]			
					LX                      = L[(par_a == a) & (par_b == b)]
					LX                      = LX[LX > 0]  # flagged models have been assigned L = 0
					LX_av[index_b, index_a] = np.sum(LX) / len(LX)    # likelihood weighted by number of pixels with good data
					pix[index_b, index_a]   = len(LX)
					area_pixel[index_b, index_a] = (edges_a[index_a+1] - edges_a[index_a]) * (edges_b[index_b+1] - edges_b[index_b])  # delta_a * delta_b ##


			# Area of pixel normalized to the area of all pixels with non-NaN likelihood
			normalized_area_pixel = area_pixel/np.sum(area_pixel[np.isnan(LX_av)==False])


			# Normalized probability for flat priors
			#Prob = LX_av/np.sum(LX_av[np.isnan(LX_av)==False])  # discarding points with NaNs
			area_weighted_LX_av = LX_av * normalized_area_pixel
			integral_area_weighted_LX_av = np.sum(area_weighted_LX_av[np.isnan(LX_av)==False])   # discarding points with NaNs
			Prob = area_weighted_LX_av / integral_area_weighted_LX_av 


			## Normalized probability
			#for index_b in range(Npix):
				#for index_a in range(Npix):			

			# Probability limits
			Prob_1D = Prob.reshape(1,-1)[0]
			ix = np.argsort(Prob_1D)
			Prob_limits_1D = np.zeros(len(ix))
			acc_prob = 0

			for i in range(len(ix)):
				if np.isnan(Prob_1D[ix[i]]) == False:
					acc_prob = acc_prob + Prob_1D[ix[i]]
					#print(acc_prob)
					if 0 <= acc_prob <= 0.05:
						Prob_limits_1D[ix[i]] = 0

					elif 0.05 <= acc_prob <= 0.32:
						Prob_limits_1D[ix[i]] = 1

					elif 0.32 <= acc_prob <= 1.01:
						Prob_limits_1D[ix[i]] = 2

				elif np.isnan(Prob_1D[ix[i]]) == True:
					Prob_limits_1D[ix[i]] = np.nan

			Prob_limits = Prob_limits_1D.reshape(Npix, Npix)		


			# 1D probability profile

			if (ka == 0):
				Prob_par1 = np.sum(Prob, axis=0)
				Prob_par1_all.append(Prob_par1)

			elif (kb == 0):
				Prob_par1 = np.sum(Prob, axis=1)
				Prob_par1_all.append(Prob_par1)


			if (ka == 1):
				Prob_par2 = np.sum(Prob, axis=0)
				Prob_par2_all.append(Prob_par2)

			elif (kb == 1):
				Prob_par2 = np.sum(Prob, axis=1)
				Prob_par2_all.append(Prob_par2)			


			if (ka == 2):
				Prob_par3 = np.sum(Prob, axis=0)
				Prob_par3_all.append(Prob_par3)

			elif (kb == 2):
				Prob_par3 = np.sum(Prob, axis=1)
				Prob_par3_all.append(Prob_par3)	


			if (ka == 3):
				Prob_par4 = np.sum(Prob, axis=0)
				Prob_par4_all.append(Prob_par4)

			elif (kb == 3):
				Prob_par4 = np.sum(Prob, axis=1)
				Prob_par4_all.append(Prob_par4)			


			if (ka == 4):
				Prob_par5 = np.sum(Prob, axis=0)
				Prob_par5_all.append(Prob_par5)

			elif (kb == 4):
				Prob_par5 = np.sum(Prob, axis=1)
				Prob_par5_all.append(Prob_par5)		


			if (ka == 5):
				Prob_par6 = np.sum(Prob, axis=0)
				Prob_par6_all.append(Prob_par6)

			elif (kb == 5):
				Prob_par6 = np.sum(Prob, axis=1)
				Prob_par6_all.append(Prob_par6)		


			if (ka == 6):
				Prob_par7 = np.sum(Prob, axis=0)
				Prob_par7_all.append(Prob_par7)

			elif (kb == 6):
				Prob_par7 = np.sum(Prob, axis=1)
				Prob_par7_all.append(Prob_par7)





			# Storing results
			area_all.append(normalized_area_pixel)
			pix_all.append(pix)
			Prob_all.append(Prob)
			Prob_limits_all.append(Prob_limits)



	return p1, p2, p3, p4, p5, p6, p7, pix_all, Prob_all, Prob_limits_all, Prob_par1_all, Prob_par2_all, Prob_par3_all, Prob_par4_all, Prob_par5_all, Prob_par6_all, Prob_par7_all

































def fialkov_probabilities_hires_4par(file_name):
	
	"""
	Jan 4, 2018
	
	"""
	

	v, signals, par_21, p1, p2, p3, p4, p5, p6, p7, flags, xHI59, xHI754, Zeta, LE, chi_sq, par_fg = read_likelihood_fialkov(file_name)  # L_xHI59, L_xHI754, L_Zeta
	
	par_list = [p1, p2, p3, p7]
	p4_fixed = p4[0]
	p5_fixed = p5[0]
	p6_fixed = p6[0]

	parameters_21cm = par_21[:,[0,1,2,6]]
	
	#L_xHI59[LE==0] =0
	#L_xHI754[LE==0]=0
	
	#L = L_xHI59
	#L = L_xHI754
	#L = L_Zeta
	#L = LE                         # Likelihood of models based on EDGES data
	#L = L_xHI59 * L_xHI754 #* L_Zeta # Likelihood of models based on xHI constraints
	L = L_xHI59 * L_xHI754 * LE     # * L_Zeta  # All likelihoods multiplied 
	


	Npix   = 20
	

	# Initialize output lists
	area_all        = []
	pix_all         = []
	Prob_all        = []
	Prob_limits_all = []
	Prob_par1_all   = []
	Prob_par2_all   = []
	Prob_par3_all   = []
	Prob_par4_all   = []
	#Prob_par5_all   = []
	#Prob_par6_all   = []
	#Prob_par7_all   = []



	N_high_res  = 80
	p1_hires = np.logspace(np.log10(p1[0]), np.log10(p1[-1]), N_high_res)
	p2_hires = np.logspace(np.log10(p2[0]), np.log10(p2[-1]), N_high_res)
	p3_hires = np.logspace(np.log10(p3[0]), np.log10(p3[-1]), N_high_res)
	p7_hires = np.linspace(p7[0], p7[-1], N_high_res)

	#p1_hires = np.copy(p1)
	#p2_hires = np.copy(p2)
	#p3_hires = np.copy(p3)
	#p7_hires = np.copy(p7)









	# Compute all the parameter combination
	for ka in range(len(par_list)):

		# if a=3, b=4,5,6  (from 0 to 6)
		list_b  = list(range(len(par_list) - (ka+1)))
		range_b = list(np.asarray(list_b) + (ka+1))

		for kb in range_b:

			# Likelihood for each pair of parameters
			# --------------------------------------

			# List of values for the two parameters
			pa    = par_list[ka] 
			pb    = par_list[kb]



			print((ka, kb))

			# Log to linear and back
			## Edges of the pixels
			if ka < 3:
				lpa          = np.log10(pa)
				delta_la     = lpa[1] - lpa[0]
				edges_la     = lpa - (delta_la/2)
				last_edge_la = edges_la[-1] + delta_la
				edges_a      = np.append(edges_la, last_edge_la)
				#edges_la     = np.append(edges_la, last_edge_la)
				#edges_a      = 10**(edges_la)

			if ka >= 3:
				delta_a     = pa[1] - pa[0]				
				edges_a     = np.asarray(pa) - (delta_a/2)
				last_edge_a = edges_a[-1] + delta_a
				edges_a     = np.append(edges_a, last_edge_a)



			if kb < 3:
				lpb          = np.log10(pb)
				delta_lb     = lpb[1] - lpb[0]
				edges_lb     = lpb - (delta_lb/2)
				last_edge_lb = edges_lb[-1] + delta_lb
				edges_b      = np.append(edges_lb, last_edge_lb)
				#edges_lb     = np.append(edges_lb, last_edge_lb)
				#edges_b      = 10**(edges_lb)				

			if kb >= 3:
				delta_b     = pb[1] - pb[0]				
				edges_b     = np.asarray(pb) - (delta_b/2)
				last_edge_b = edges_b[-1] + delta_b
				edges_b     = np.append(edges_b, last_edge_b)






			## Edges of the pixels
			#delta_a     = pa[1] - pa[0]				
			#edges_a     = np.asarray(pa) - (delta_a/2)
			#last_edge_a = edges_a[-1] + delta_a
			#edges_a     = np.append(edges_a, last_edge_a)
			#print(edges_a)

			#delta_b     = pb[1] - pb[0]				
			#edges_b     = np.asarray(pb) - (delta_b/2)
			#last_edge_b = edges_b[-1] + delta_b
			#edges_b     = np.append(edges_b, last_edge_b)			




			# Values of each of the two parameters, for each of the models evaluated
			par_a = parameters_21cm[:,ka]
			par_b = parameters_21cm[:,kb]




			# Likelihood and area in each pixel
			LX_av      = np.zeros((Npix, Npix))
			area_pixel = np.zeros((Npix, Npix))
			pix        = np.zeros((Npix, Npix))
			for index_b in range(Npix):
				for index_a in range(Npix):
					a                       = pa[index_a]
					b                       = pb[index_b]			
					LX                      = L[(par_a == a) & (par_b == b)]
					#LX                      = LX[LX > 0]  # flagged models have been assigned L = 0
					LX_av[index_b, index_a] = np.sum(LX) / len(LX)    # likelihood weighted by number of pixels with good data
					pix[index_b, index_a]   = len(LX)
					area_pixel[index_b, index_a] = (edges_a[index_a+1] - edges_a[index_a]) * (edges_b[index_b+1] - edges_b[index_b])  # delta_a * delta_b ##


			# Area of pixel normalized to the area of all pixels with non-NaN likelihood
			normalized_area_pixel = area_pixel/np.sum(area_pixel[np.isnan(LX_av)==False])


			# Normalized probability for flat priors
			#Prob = LX_av/np.sum(LX_av[np.isnan(LX_av)==False])  # discarding points with NaNs
			#integral_area_weighted_LX_av = np.sum(area_weighted_LX_av[np.isnan(LX_av)==False])   # discarding points with NaNs
			
			AREA_low_res = LX_av * normalized_area_pixel
			
			
			interp_kind = 'linear' #'cubic'
			if (ka < 3) and (kb < 3):
				interp_func = spi.interp2d(lpa, lpb, AREA_low_res, kind=interp_kind)
				lpa_hires   = np.linspace(lpa[0], lpa[-1], N_high_res)
				lpb_hires   = np.linspace(lpb[0], lpb[-1], N_high_res)
				AREA        = interp_func(lpa_hires, lpb_hires)
			
			if (ka < 3) and (kb >= 3):
				interp_func = spi.interp2d(lpa, pb, AREA_low_res, kind=interp_kind)
				lpa_hires   = np.linspace(lpa[0], lpa[-1], N_high_res)
				pb_hires    = np.linspace(pb[0],  pb[-1], N_high_res)
				AREA        = interp_func(lpa_hires, pb_hires)
				
			if (ka >= 3) and (kb < 3):
				interp_func = spi.interp2d(pa, lpb, AREA_low_res, kind=interp_kind)
				pa_hires    = np.linspace(pa[0], pa[-1], N_high_res)
				lpb_hires   = np.linspace(lpb[0], lpb[-1], N_high_res)
				AREA        = interp_func(pa_hires, lpb_hires)			

			if (ka >= 3) and (kb >= 3):
				interp_func = spi.interp2d(pa, pb, AREA_low_res, kind=interp_kind)
				pa_hires    = np.linspace(pa[0], pa[-1], N_high_res)
				pb_hires    = np.linspace(pb[0], pb[-1], N_high_res)
				AREA        = interp_func(pa_hires, pb_hires)


			TOTAL_AREA           = np.sum(AREA[np.isnan(AREA)==False])   # discarding points with NaNs
			Prob_density = AREA / TOTAL_AREA




			Prob = np.copy(Prob_density)













			
			
			## Not used
			## ------------------------------------
			##index_2D = np.arange(0, Npix*Npix)
			#Prob_1D  = Prob_density.reshape(1,-1)[0]
			#ix = np.argsort(Prob_1D)[::-1]   # sorting index in the order of decreasing probability
			
			#acc_prob = 0
			#CDF_1D = np.zeros(Npix*Npix)
			#for i in range(len(ix)):
				#acc_prob = acc_prob + Prob_1D[ix[i]]
				#print(acc_prob)
				#CDF_1D[ix[i]] = acc_prob
								
			#CDF_2D = CDF_1D.reshape(Npix,Npix)#
							
			#Prob = np.copy(CDF_2D)
			
			
			
			
			
			
			


			## Normalized probability
			#for index_b in range(Npix):
				#for index_a in range(Npix):			

			# Probability limits
			Prob_1D = Prob_density.reshape(1,-1)[0]
			ix = np.argsort(Prob_1D)
			Prob_limits_1D = np.zeros(len(ix))
			acc_prob = 0

			for i in range(len(ix)):
				if np.isnan(Prob_1D[ix[i]]) == False:
					acc_prob = acc_prob + Prob_1D[ix[i]]
					#print(acc_prob)
					if 0 <= acc_prob <= 0.05:
						Prob_limits_1D[ix[i]] = 0

					elif 0.05 <= acc_prob <= 0.32:
						Prob_limits_1D[ix[i]] = 1

					elif 0.32 <= acc_prob <= 1.01:
						Prob_limits_1D[ix[i]] = 2

				elif np.isnan(Prob_1D[ix[i]]) == True:
					Prob_limits_1D[ix[i]] = np.nan

			Prob_limits = Prob_limits_1D.reshape(len(Prob_density[:,0]), len(Prob_density[:,1]))
			
			

		

			# 1D probability profile

			if (ka == 0):
				Prob_par1 = np.sum(Prob_density, axis=0)
				Prob_par1_all.append(Prob_par1)

			elif (kb == 0):
				Prob_par1 = np.sum(Prob_density, axis=1)
				Prob_par1_all.append(Prob_par1)


			if (ka == 1):
				Prob_par2 = np.sum(Prob_density, axis=0)
				Prob_par2_all.append(Prob_par2)

			elif (kb == 1):
				Prob_par2 = np.sum(Prob_density, axis=1)
				Prob_par2_all.append(Prob_par2)			


			if (ka == 2):
				Prob_par3 = np.sum(Prob_density, axis=0)
				Prob_par3_all.append(Prob_par3)

			elif (kb == 2):
				Prob_par3 = np.sum(Prob_density, axis=1)
				Prob_par3_all.append(Prob_par3)	


			if (ka == 3):
				Prob_par4 = np.sum(Prob_density, axis=0)
				Prob_par4_all.append(Prob_par4)

			elif (kb == 3):
				Prob_par4 = np.sum(Prob_density, axis=1)
				Prob_par4_all.append(Prob_par4)			


			#if (ka == 4):
				#Prob_par5 = np.sum(Prob, axis=0)
				#Prob_par5_all.append(Prob_par5)

			#elif (kb == 4):
				#Prob_par5 = np.sum(Prob, axis=1)
				#Prob_par5_all.append(Prob_par5)		


			#if (ka == 5):
				#Prob_par6 = np.sum(Prob, axis=0)
				#Prob_par6_all.append(Prob_par6)

			#elif (kb == 5):
				#Prob_par6 = np.sum(Prob, axis=1)
				#Prob_par6_all.append(Prob_par6)		


			#if (ka == 6):
				#Prob_par7 = np.sum(Prob, axis=0)
				#Prob_par7_all.append(Prob_par7)

			#elif (kb == 6):
				#Prob_par7 = np.sum(Prob, axis=1)
				#Prob_par7_all.append(Prob_par7)





			# Storing results
			area_all.append(normalized_area_pixel)
			pix_all.append(pix)
			Prob_all.append(Prob)
			Prob_limits_all.append(Prob_limits)



	return p1_hires, p2_hires, p3_hires, p7_hires, pix_all, Prob_all, Prob_limits_all, Prob_par1_all, Prob_par2_all, Prob_par3_all, Prob_par4_all  #, Prob_par5_all, Prob_par6_all, Prob_par7_all #  p5, p6, p7





























def fialkov_probabilities_hires_5par(file_name, fifth_parameter='Rmfp'):
	
	"""
	
	Jan 25, 2018
	
	"""
	
	
	VERSION = 'v6'    # ONLY v6 has  xHI at z=7.08
		
	v, signals, par_21, p1x, p2x, p3x, p4x, p5x, p6x, p7x, flags, xHI59, xHI708, xHI754, Zeta, LE, chi_sq, par_fg = read_likelihood_fialkov(file_name, version=VERSION)
		
		
	if fifth_parameter == 'Rmfp':
		par_list = [p1x, p2x, p3x, p6x, p7x]
		parameters_21cm = par_21[:,[0,1,2,5,6]]
		
		p1 = np.copy(p1x)
		p2 = np.copy(p2x)
		p3 = np.copy(p3x)
		p4 = np.copy(p6x)
		p5 = np.copy(p7x)
		
	elif fifth_parameter == 'vmin':
		par_list = [p1x, p2x, p3x, p5x, p6x]
		parameters_21cm = par_21[:,[0,1,2,4,5]]
		
		p1 = np.copy(p1x)
		p2 = np.copy(p2x)
		p3 = np.copy(p3x)
		p4 = np.copy(p5x)
		p5 = np.copy(p6x)
	
		
	# These likelihoods are OK, just deactivated
	# ------------------------------------------------------------------
	KK1 = np.copy(xHI59)
	KK2 = np.copy(xHI754)
	
	KK3 = signals[:,-1]        # brightness temperature at ~ 200 MHz
	
	
	
	
	# Here, these variables have values above 1. We make them equal to zero.
	xHI59[xHI59>1]   = 0
	xHI754[xHI754>1] = 0

	# Here, this variable has values below 0. We make them equal to zero.
	xHI708[xHI708<0] = 0
	
	
	# L_tau                            = np.ones(len(LE))
	# L_tau[par_21[:,3]>0.090]         = 0
	
	# L_xHI754[LE==0]=0
	
		
	# Combinations of Likelihood
	# --------------------------------------------------------------
	L_xHI59, L_xHI708, L_xHI754_N, L_xHI754_C  = likelihood_xHI(xHI59, xHI708, xHI754)
	L_xHI_mason                                = likelihood_xHI_mason2018(xHI708)
	L_Zeta                                     = likelihood_Zeta(Zeta, par_21[:,1])
	#L_tau_planck                               = likelihood_tau_planck(par_21[:,5], tau0=0.058, sigma=0.012)  # Planck 2016
	L_tau_planck                               = likelihood_tau_planck(par_21[:,5], tau0=0.056, sigma=0.007)  # Planck 2018 
	
	
	
	
	#L_xHI59[LE==0]   = 0	


		

	
	#L = L_Zeta
	
	
	
	
	
	#L = L_xHI59
	#L = L_xHI708
	#L = L_xHI754_C
	#L = L_xHI_mason
	#L = L_tau_planck
	#L = LE
	
	#L = L_xHI59 * L_xHI708
	#L = L_xHI59 * L_xHI754_C
	#L = L_xHI708 * L_xHI754_C
	#L = L_xHI59 * L_xHI708 * L_xHI754_C
	#L = L_xHI59 * L_xHI708 * L_xHI754_C * L_xHI_mason
	
	#L = L_xHI59 * L_xHI708 * L_xHI754_C * L_xHI_mason * L_tau_planck	
	L = L_xHI59 * L_xHI708 * L_xHI754_C * L_xHI_mason * L_tau_planck * LE
	
	
	



	
	L[ (KK1>1) | (KK2>1) ] = 0
	L[ (flags[:,0]>0) | (KK3<-0.2) | (KK3>0.01) ] = 0
	
	#L[]
	#L[(KK3<-0.2)] = 0
	#L[(KK3>0.01)] = 0
	print(len(L[L==0]))






	
	
	
	
	
	
	
	
	Npix   = 20
	
	# Initialize output lists
	area_all        = []
	pix_all         = []
	Prob_all        = []
	Prob_limits_all = []
	
	Prob_par1_all   = []
	Prob_par2_all   = []
	Prob_par3_all   = []
	Prob_par4_all   = []
	Prob_par5_all   = []



	N_high_res  = 80
	p1_hires = np.logspace(np.log10(p1[0]), np.log10(p1[-1]), N_high_res)
	p2_hires = np.logspace(np.log10(p2[0]), np.log10(p2[-1]), N_high_res)
	p3_hires = np.logspace(np.log10(p3[0]), np.log10(p3[-1]), N_high_res)
	p4_hires = np.linspace(p4[0], p4[-1], N_high_res)
	p5_hires = np.linspace(p5[0], p5[-1], N_high_res)








	# Compute all the parameter combination
	for ka in range(len(par_list)):

		# if a=3, b=4,5,6  (from 0 to 6)
		list_b  = list(range(len(par_list) - (ka+1)))
		range_b = list(np.asarray(list_b) + (ka+1))

		for kb in range_b:

			# ka and kb are the index of the 2 parameters examined


			# Likelihood for each pair of parameters
			# --------------------------------------

			# List of values for the two parameters
			pa    = par_list[ka] 
			pb    = par_list[kb]



			print((ka, kb))
			print(pb)

			# Log to linear and back
			## Edges of the pixels
			if ka < 3:
				lpa          = np.log10(pa)
				delta_la     = lpa[1] - lpa[0]
				edges_la     = lpa - (delta_la/2)
				last_edge_la = edges_la[-1] + delta_la
				edges_a      = np.append(edges_la, last_edge_la)
				#edges_la     = np.append(edges_la, last_edge_la)
				#edges_a      = 10**(edges_la)

			if ka >= 3:
				delta_a     = pa[1] - pa[0]				
				edges_a     = np.asarray(pa) - (delta_a/2)
				last_edge_a = edges_a[-1] + delta_a
				edges_a     = np.append(edges_a, last_edge_a)



			if kb < 3:
				lpb          = np.log10(pb)
				delta_lb     = lpb[1] - lpb[0]
				edges_lb     = lpb - (delta_lb/2)
				last_edge_lb = edges_lb[-1] + delta_lb
				edges_b      = np.append(edges_lb, last_edge_lb)
				#edges_lb     = np.append(edges_lb, last_edge_lb)
				#edges_b      = 10**(edges_lb)				

			if kb >= 3:
				delta_b     = pb[1] - pb[0]				
				edges_b     = np.asarray(pb) - (delta_b/2)
				last_edge_b = edges_b[-1] + delta_b
				edges_b     = np.append(edges_b, last_edge_b)






			## Edges of the pixels
			#delta_a     = pa[1] - pa[0]				
			#edges_a     = np.asarray(pa) - (delta_a/2)
			#last_edge_a = edges_a[-1] + delta_a
			#edges_a     = np.append(edges_a, last_edge_a)
			#print(edges_a)

			#delta_b     = pb[1] - pb[0]				
			#edges_b     = np.asarray(pb) - (delta_b/2)
			#last_edge_b = edges_b[-1] + delta_b
			#edges_b     = np.append(edges_b, last_edge_b)			




			# Values of each of the two parameters, for all the models evaluated
			par_a = parameters_21cm[:,ka]
			par_b = parameters_21cm[:,kb]




			# Likelihood, area, and number of points, in each pixel
			LX_av      = np.zeros((Npix, Npix))
			area_pixel = np.zeros((Npix, Npix))
			pix        = np.zeros((Npix, Npix))
			for index_b in range(Npix):
				for index_a in range(Npix):
					a                       = pa[index_a]
					b                       = pb[index_b]			
					LX                      = L[(par_a == a) & (par_b == b)]
					LX                      = LX[LX > 0]  # flagged models have been assigned L = 0
					LX_av[index_b, index_a] = np.sum(LX) / len(LX)    # likelihood weighted by number of pixels with good data
					pix[index_b, index_a]   = len(LX)
					area_pixel[index_b, index_a] = (edges_a[index_a+1] - edges_a[index_a]) * (edges_b[index_b+1] - edges_b[index_b])  # delta_a * delta_b ##


			# Area of pixel normalized to the area of all pixels with non-NaN likelihood
			normalized_area_pixel = area_pixel/np.sum(area_pixel[np.isnan(LX_av)==False])


			# Normalized probability for flat priors
			#Prob = LX_av/np.sum(LX_av[np.isnan(LX_av)==False])  # discarding points with NaNs
			#integral_area_weighted_LX_av = np.sum(area_weighted_LX_av[np.isnan(LX_av)==False])   # discarding points with NaNs
			
			AREA_low_res = LX_av * normalized_area_pixel
			
			
			
			# Interpolation of 2D PDF to high resolution
			interp_kind = 'linear' #'cubic'
			if (ka < 3) and (kb < 3):
				interp_func = spi.interp2d(lpa, lpb, AREA_low_res, kind=interp_kind)
				lpa_hires   = np.linspace(lpa[0], lpa[-1], N_high_res)
				lpb_hires   = np.linspace(lpb[0], lpb[-1], N_high_res)
				AREA        = interp_func(lpa_hires, lpb_hires)
			
			if (ka < 3) and (kb >= 3):
				interp_func = spi.interp2d(lpa, pb, AREA_low_res, kind=interp_kind)
				lpa_hires   = np.linspace(lpa[0], lpa[-1], N_high_res)
				pb_hires    = np.linspace(pb[0],  pb[-1], N_high_res)
				AREA        = interp_func(lpa_hires, pb_hires)
				
			if (ka >= 3) and (kb < 3):
				interp_func = spi.interp2d(pa, lpb, AREA_low_res, kind=interp_kind)
				pa_hires    = np.linspace(pa[0], pa[-1], N_high_res)
				lpb_hires   = np.linspace(lpb[0], lpb[-1], N_high_res)
				AREA        = interp_func(pa_hires, lpb_hires)			

			if (ka >= 3) and (kb >= 3):
				interp_func = spi.interp2d(pa, pb, AREA_low_res, kind=interp_kind)
				pa_hires    = np.linspace(pa[0], pa[-1], N_high_res)
				pb_hires    = np.linspace(pb[0], pb[-1], N_high_res)
				AREA        = interp_func(pa_hires, pb_hires)


			TOTAL_AREA          = np.sum(AREA[np.isnan(AREA)==False])   # discarding points with NaNs
			Prob_density = AREA / TOTAL_AREA


			Prob = np.copy(Prob_density)













			
			
			## Not used
			## ------------------------------------
			##index_2D = np.arange(0, Npix*Npix)
			#Prob_1D  = Prob_density.reshape(1,-1)[0]
			#ix = np.argsort(Prob_1D)[::-1]   # sorting index in the order of decreasing probability
			
			#acc_prob = 0
			#CDF_1D = np.zeros(Npix*Npix)
			#for i in range(len(ix)):
				#acc_prob = acc_prob + Prob_1D[ix[i]]
				#print(acc_prob)
				#CDF_1D[ix[i]] = acc_prob
								
			#CDF_2D = CDF_1D.reshape(Npix,Npix)#
							
			#Prob = np.copy(CDF_2D)
			


			## Normalized probability
			#for index_b in range(Npix):
				#for index_a in range(Npix):			





			# 2D Probability limits
			Prob_1D = Prob_density.reshape(1,-1)[0]
			ix = np.argsort(Prob_1D)
			Prob_limits_1D = np.zeros(len(ix))
			acc_prob = 0

			for i in range(len(ix)):
				if np.isnan(Prob_1D[ix[i]]) == False:
					acc_prob = acc_prob + Prob_1D[ix[i]]
					#print(acc_prob)
					if 0 <= acc_prob <= 0.05:
						Prob_limits_1D[ix[i]] = 0

					elif 0.05 <= acc_prob <= 0.32:
						Prob_limits_1D[ix[i]] = 1

					elif 0.32 <= acc_prob <= 1.01:
						Prob_limits_1D[ix[i]] = 2

				elif np.isnan(Prob_1D[ix[i]]) == True:
					Prob_limits_1D[ix[i]] = np.nan

			Prob_limits = Prob_limits_1D.reshape(len(Prob_density[:,0]), len(Prob_density[:,1]))
			
			

		

			# 1D probability profile

			if (ka == 0):
				Prob_par1 = np.sum(Prob_density, axis=0)
				Prob_par1_all.append(Prob_par1)

			elif (kb == 0):
				Prob_par1 = np.sum(Prob_density, axis=1)
				Prob_par1_all.append(Prob_par1)


			if (ka == 1):
				Prob_par2 = np.sum(Prob_density, axis=0)
				Prob_par2_all.append(Prob_par2)

			elif (kb == 1):
				Prob_par2 = np.sum(Prob_density, axis=1)
				Prob_par2_all.append(Prob_par2)			


			if (ka == 2):
				Prob_par3 = np.sum(Prob_density, axis=0)
				Prob_par3_all.append(Prob_par3)

			elif (kb == 2):
				Prob_par3 = np.sum(Prob_density, axis=1)
				Prob_par3_all.append(Prob_par3)	


			if (ka == 3):
				Prob_par4 = np.sum(Prob_density, axis=0)
				Prob_par4_all.append(Prob_par4)

			elif (kb == 3):
				Prob_par4 = np.sum(Prob_density, axis=1)
				Prob_par4_all.append(Prob_par4)			


			if (ka == 4):
				Prob_par5 = np.sum(Prob_density, axis=0)
				Prob_par5_all.append(Prob_par5)

			elif (kb == 4):
				Prob_par5 = np.sum(Prob_density, axis=1)
				Prob_par5_all.append(Prob_par5)		








			# Storing results
			area_all.append(normalized_area_pixel)
			pix_all.append(pix)
			Prob_all.append(Prob)
			Prob_limits_all.append(Prob_limits)



	return p1_hires, p2_hires, p3_hires, p4_hires, p5_hires, pix_all, Prob_all, Prob_limits_all, Prob_par1_all, Prob_par2_all, Prob_par3_all, Prob_par4_all, Prob_par5_all



























def fialkov_triangle_plot(low_hi_res = 'high'):

	path_plot_save  = home_folder + '/DATA/EDGES/results/plots/20171219/'
	
	filename_save_1 = 'results_grid_Npix5_FIG1_60_90.pdf'
	filename_save_2 = 'results_grid_Npix5_FIG2_60_90.pdf'
	
	
	
	
	# Loading probabilities of parameters
	if low_hi_res == 'low':
		p1, p2, p3, p4, p5, p6, p7, pix_all, Prob_all, Prob_limits_all, Prob_par1_all, Prob_par2_all, Prob_par3_all, Prob_par4_all, Prob_par5_all, Prob_par6_all, Prob_par7_all = fialkov_probabilities_lores()
		imax = 4
		
		min_prob = 0.02
		max_prob = 0.07
		max_1D   = 0.5
	
		fig2_text_x  = -100
		fig2_text_y1 = 3
		fig2_text_y2 = 2.95
		fig2_text_y3 = 2.9
		
	
	
	elif low_hi_res == 'high':
		p1, p2, p3, p4, p5, p6, p7, pix_all, Prob_all, Prob_limits_all, Prob_par1_all, Prob_par2_all, Prob_par3_all, Prob_par4_all, Prob_par5_all, Prob_par6_all, Prob_par7_all = fialkov_probabilities_hires()
		imax = 9
		
		min_prob = 0.005
		max_prob = 0.015
		max_1D   = 0.2
	
		fig2_text_x  = -100
		fig2_text_y1 = 1
		fig2_text_y2 = 0.95
		fig2_text_y3 = 0.9
		
		



	# Settings for Figures
	# ---------------------------
	size_x = 12
	size_y = 12

	dx     = 0.128
	dy     = 0.128	
	x0     = 0.056
	y0     = 0.059
	x00    = 0.007
	y00    = 0.007


	lp1 = np.log10(p1)
	lp2 = np.log10(p2)
	lp3 = np.log10(p3)





	E12 = [lp1[0]-(lp1[1]-lp1[0])/2, lp1[imax]+(lp1[1]-lp1[0])/2, lp2[0]-(lp2[1]-lp2[0])/2, lp2[imax]+(lp2[1]-lp2[0])/2]
	E13 = [lp1[0]-(lp1[1]-lp1[0])/2, lp1[imax]+(lp1[1]-lp1[0])/2, lp3[0]-(lp3[1]-lp3[0])/2, lp3[imax]+(lp3[1]-lp3[0])/2]
	E14 = [lp1[0]-(lp1[1]-lp1[0])/2, lp1[imax]+(lp1[1]-lp1[0])/2, p4[0]-(p4[1]-p4[0])/2, p4[imax]+(p4[1]-p4[0])/2]
	E15 = [lp1[0]-(lp1[1]-lp1[0])/2, lp1[imax]+(lp1[1]-lp1[0])/2, p5[0]-(p5[1]-p5[0])/2, p5[imax]+(p5[1]-p5[0])/2]
	E16 = [lp1[0]-(lp1[1]-lp1[0])/2, lp1[imax]+(lp1[1]-lp1[0])/2, p6[0]-(p6[1]-p6[0])/2, p6[imax]+(p6[1]-p6[0])/2]
	E17 = [lp1[0]-(lp1[1]-lp1[0])/2, lp1[imax]+(lp1[1]-lp1[0])/2, p7[0]-(p7[1]-p7[0])/2, p7[imax]+(p7[1]-p7[0])/2]

	E23 = [lp2[0]-(lp2[1]-lp2[0])/2, lp2[imax]+(lp2[1]-lp2[0])/2, lp3[0]-(lp3[1]-lp3[0])/2, lp3[imax]+(lp3[1]-lp3[0])/2]
	E24 = [lp2[0]-(lp2[1]-lp2[0])/2, lp2[imax]+(lp2[1]-lp2[0])/2, p4[0]-(p4[1]-p4[0])/2, p4[imax]+(p4[1]-p4[0])/2]
	E25 = [lp2[0]-(lp2[1]-lp2[0])/2, lp2[imax]+(lp2[1]-lp2[0])/2, p5[0]-(p5[1]-p5[0])/2, p5[imax]+(p5[1]-p5[0])/2]
	E26 = [lp2[0]-(lp2[1]-lp2[0])/2, lp2[imax]+(lp2[1]-lp2[0])/2, p6[0]-(p6[1]-p6[0])/2, p6[imax]+(p6[1]-p6[0])/2]
	E27 = [lp2[0]-(lp2[1]-lp2[0])/2, lp2[imax]+(lp2[1]-lp2[0])/2, p7[0]-(p7[1]-p7[0])/2, p7[imax]+(p7[1]-p7[0])/2]

	E34 = [lp3[0]-(lp3[1]-lp3[0])/2, lp3[imax]+(lp3[1]-lp3[0])/2, p4[0]-(p4[1]-p4[0])/2, p4[imax]+(p4[1]-p4[0])/2]
	E35 = [lp3[0]-(lp3[1]-lp3[0])/2, lp3[imax]+(lp3[1]-lp3[0])/2, p5[0]-(p5[1]-p5[0])/2, p5[imax]+(p5[1]-p5[0])/2]
	E36 = [lp3[0]-(lp3[1]-lp3[0])/2, lp3[imax]+(lp3[1]-lp3[0])/2, p6[0]-(p6[1]-p6[0])/2, p6[imax]+(p6[1]-p6[0])/2]
	E37 = [lp3[0]-(lp3[1]-lp3[0])/2, lp3[imax]+(lp3[1]-lp3[0])/2, p7[0]-(p7[1]-p7[0])/2, p7[imax]+(p7[1]-p7[0])/2]

	E45 = [p4[0]-(p4[1]-p4[0])/2, p4[imax]+(p4[1]-p4[0])/2, p5[0]-(p5[1]-p5[0])/2, p5[imax]+(p5[1]-p5[0])/2]
	E46 = [p4[0]-(p4[1]-p4[0])/2, p4[imax]+(p4[1]-p4[0])/2, p6[0]-(p6[1]-p6[0])/2, p6[imax]+(p6[1]-p6[0])/2]
	E47 = [p4[0]-(p4[1]-p4[0])/2, p4[imax]+(p4[1]-p4[0])/2, p7[0]-(p7[1]-p7[0])/2, p7[imax]+(p7[1]-p7[0])/2]

	E56 = [p5[0]-(p5[1]-p5[0])/2, p5[imax]+(p5[1]-p5[0])/2, p6[0]-(p6[1]-p6[0])/2, p6[imax]+(p6[1]-p6[0])/2]
	E57 = [p5[0]-(p5[1]-p5[0])/2, p5[imax]+(p5[1]-p5[0])/2, p7[0]-(p7[1]-p7[0])/2, p7[imax]+(p7[1]-p7[0])/2]

	E67 = [p6[0]-(p6[1]-p6[0])/2, p6[imax]+(p6[1]-p6[0])/2, p7[0]-(p7[1]-p7[0])/2, p7[imax]+(p7[1]-p7[0])/2]









	# Figure 1
	# --------------------------------------------------------------------

	# Figure
	plt.close()
	plt.close()
	plt.close()
	plt.close()
	plt.close()
	plt.close()
	plt.close()
	plt.close()





	f1     = plt.figure(num=1, figsize=(size_x, size_y))

	ax17   = f1.add_axes([1*x0 + 0*(dx+x00), 1*y0 + 0*(dy+y00), dx, dy])
	ax16   = f1.add_axes([1*x0 + 0*(dx+x00), 1*y0 + 1*(dy+y00), dx, dy])
	ax15   = f1.add_axes([1*x0 + 0*(dx+x00), 1*y0 + 2*(dy+y00), dx, dy])
	ax14   = f1.add_axes([1*x0 + 0*(dx+x00), 1*y0 + 3*(dy+y00), dx, dy])
	ax13   = f1.add_axes([1*x0 + 0*(dx+x00), 1*y0 + 4*(dy+y00), dx, dy])
	ax12   = f1.add_axes([1*x0 + 0*(dx+x00), 1*y0 + 5*(dy+y00), dx, dy])
	ax11   = f1.add_axes([1*x0 + 0*(dx+x00), 1*y0 + 6*(dy+y00), dx, dy])


	ax27   = f1.add_axes([1*x0 + 1*(dx+x00), 1*y0 + 0*(dy+y00), dx, dy])
	ax26   = f1.add_axes([1*x0 + 1*(dx+x00), 1*y0 + 1*(dy+y00), dx, dy])
	ax25   = f1.add_axes([1*x0 + 1*(dx+x00), 1*y0 + 2*(dy+y00), dx, dy])
	ax24   = f1.add_axes([1*x0 + 1*(dx+x00), 1*y0 + 3*(dy+y00), dx, dy])
	ax23   = f1.add_axes([1*x0 + 1*(dx+x00), 1*y0 + 4*(dy+y00), dx, dy])
	ax22   = f1.add_axes([1*x0 + 1*(dx+x00), 1*y0 + 5*(dy+y00), dx, dy])

	ax37   = f1.add_axes([1*x0 + 2*(dx+x00), 1*y0 + 0*(dy+y00), dx, dy])
	ax36   = f1.add_axes([1*x0 + 2*(dx+x00), 1*y0 + 1*(dy+y00), dx, dy])
	ax35   = f1.add_axes([1*x0 + 2*(dx+x00), 1*y0 + 2*(dy+y00), dx, dy])
	ax34   = f1.add_axes([1*x0 + 2*(dx+x00), 1*y0 + 3*(dy+y00), dx, dy])
	ax33   = f1.add_axes([1*x0 + 2*(dx+x00), 1*y0 + 4*(dy+y00), dx, dy])

	ax47   = f1.add_axes([1*x0 + 3*(dx+x00), 1*y0 + 0*(dy+y00), dx, dy])
	ax46   = f1.add_axes([1*x0 + 3*(dx+x00), 1*y0 + 1*(dy+y00), dx, dy])
	ax45   = f1.add_axes([1*x0 + 3*(dx+x00), 1*y0 + 2*(dy+y00), dx, dy])
	ax44   = f1.add_axes([1*x0 + 3*(dx+x00), 1*y0 + 3*(dy+y00), dx, dy])

	ax57   = f1.add_axes([1*x0 + 4*(dx+x00), 1*y0 + 0*(dy+y00), dx, dy])
	ax56   = f1.add_axes([1*x0 + 4*(dx+x00), 1*y0 + 1*(dy+y00), dx, dy])
	ax55   = f1.add_axes([1*x0 + 4*(dx+x00), 1*y0 + 2*(dy+y00), dx, dy])

	ax67   = f1.add_axes([1*x0 + 5*(dx+x00), 1*y0 + 0*(dy+y00), dx, dy])
	ax66   = f1.add_axes([1*x0 + 5*(dx+x00), 1*y0 + 1*(dy+y00), dx, dy])

	ax77   = f1.add_axes([1*x0 + 6*(dx+x00), 1*y0 + 0*(dy+y00), dx, dy])








	color_map = 'gray'


	# Column 1	
	ax11.plot(lp1, Prob_par1_all[1], 'k')
	#ax11.plot(lp1, Prob_par1_all[2], 'k')
	#ax11.plot(lp1, Prob_par1_all[3], 'k')
	ax11.set_xticks(lp1)
	ax11.set_yticks([0, 0.1, 0.2, 0.3, 0.4, 0.5])
	ax11.set_xlim(lp1[0]-(lp1[1]-lp1[0])/2, lp1[imax]+(lp1[1]-lp1[0])/2)
	ax11.set_ylim(0, max_1D)
	ax11.grid()
	ax11.set_xticklabels('')
	ax11.set_yticklabels('')

	ax12.imshow(np.flipud(Prob_all[0]), interpolation='none', aspect=(lp1[4]-lp1[0])/(lp2[4]-lp2[0]), extent=E12, cmap=color_map, vmin=min_prob, vmax=max_prob) # , cmap=plt.get_cmap(cmap_name))
	ax12.set_xticks(lp1)
	ax12.set_xticklabels('')
	ax12.set_yticks(lp2)
	ax12.set_yticklabels(np.round(lp2,2), rotation=45)
	ax12.set_ylabel('log10(m.v.c.v. [km/s])', fontsize=9)

	ax13.imshow(np.flipud(Prob_all[1]), interpolation='none', aspect=(lp1[4]-lp1[0])/(lp3[4]-lp3[0]), extent=E13, cmap=color_map, vmin=min_prob, vmax=max_prob) #, vmin=min_rej_sig, vmax=max_rej_sig, cmap=plt.get_cmap(cmap_name))
	ax13.set_xticks(lp1)
	ax13.set_xticklabels('')
	ax13.set_yticks(lp3)
	ax13.set_yticklabels(np.round(lp3,2), rotation=45)
	ax13.set_ylabel('log10(x.r.e)', fontsize=9)	

	ax14.imshow(np.flipud(Prob_all[2]), interpolation='none', aspect=(lp1[4]-lp1[0])/(p4[4]-p4[0]), extent=E14, cmap=color_map, vmin=min_prob, vmax=max_prob) #, vmin=min_rej_sig, vmax=max_rej_sig, cmap=plt.get_cmap(cmap_name))
	ax14.set_xticks(lp1)
	ax14.set_xticklabels('')
	ax14.set_yticks(p4)
	ax14.set_yticklabels(np.round(p4,3), rotation=45)
	ax14.set_ylabel('tau', fontsize=9)		

	ax15.imshow(np.flipud(Prob_all[3]), interpolation='none', aspect=(lp1[4]-lp1[0])/(p5[4]-p5[0]), extent=E15, cmap=color_map, vmin=min_prob, vmax=max_prob) #, vmin=min_rej_sig, vmax=max_rej_sig, cmap=plt.get_cmap(cmap_name))
	ax15.set_xticks(lp1)
	ax15.set_xticklabels('')
	ax15.set_yticks(p5)
	ax15.set_yticklabels(np.round(p5,2), rotation=45)
	ax15.set_ylabel('slope x-ray', fontsize=9)

	ax16.imshow(np.flipud(Prob_all[4]), interpolation='none', aspect=(lp1[4]-lp1[0])/(p6[4]-p6[0]), extent=E16, cmap=color_map, vmin=min_prob, vmax=max_prob) #, vmin=min_rej_sig, vmax=max_rej_sig, cmap=plt.get_cmap(cmap_name))
	ax16.set_xticks(lp1)
	ax16.set_xticklabels('')
	ax16.set_yticks(p6)
	ax16.set_yticklabels(np.round(p6,2), rotation=45)
	ax16.set_ylabel('low cut-off x-ray [KeV]', fontsize=9)

	ax17.imshow(np.flipud(Prob_all[5]), interpolation='none', aspect=(lp1[4]-lp1[0])/(p7[4]-p7[0]), extent=E17, cmap=color_map, vmin=min_prob, vmax=max_prob) #vmin=min_rej_sig, vmax=max_rej_sig, cmap=plt.get_cmap(cmap_name))
	ax17.set_xticks(lp1)
	ax17.set_xticklabels(np.round(lp1,2), rotation=45)
	ax17.set_yticks(p7)
	ax17.set_yticklabels(np.round(p7,2), rotation=45)
	ax17.set_xlabel('log10(s.f.e)', fontsize=9)
	ax17.set_ylabel('m.f.p. [Mpc]', fontsize=9)





	# Column 2
	ax22.plot(lp2, Prob_par2_all[1], 'k')
	#ax22.plot(lp2, Prob_par2_all[2], 'k')
	#ax22.plot(lp2, Prob_par2_all[3], 'k')
	ax22.set_xticks(lp2)
	ax22.set_yticks([0, 0.1, 0.2, 0.3, 0.4, 0.5])
	ax22.set_xlim(lp2[0]-(lp2[1]-lp2[0])/2, lp2[imax]+(lp2[1]-lp2[0])/2)
	ax22.set_ylim(0, max_1D)
	ax22.grid()
	ax22.set_xticklabels('')
	ax22.set_yticklabels('')

	ax23.imshow(np.flipud(Prob_all[6]), interpolation='none', aspect=(lp2[4]-lp2[0])/(lp3[4]-lp3[0]), extent=E23, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax23.set_xticks(lp2)
	ax23.set_xticklabels('')
	ax23.set_yticks(lp3)
	ax23.set_yticklabels('')	

	ax24.imshow(np.flipud(Prob_all[7]), interpolation='none', aspect=(lp2[4]-lp2[0])/(p4[4]-p4[0]), extent=E24, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax24.set_xticks(lp2)
	ax24.set_xticklabels('')
	ax24.set_yticks(p4)
	ax24.set_yticklabels('')	

	ax25.imshow(np.flipud(Prob_all[8]), interpolation='none', aspect=(lp2[4]-lp2[0])/(p5[4]-p5[0]), extent=E25, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax25.set_xticks(lp2)
	ax25.set_xticklabels('')
	ax25.set_yticks(p5)
	ax25.set_yticklabels('')	

	ax26.imshow(np.flipud(Prob_all[9]), interpolation='none', aspect=(lp2[4]-lp2[0])/(p6[4]-p6[0]), extent=E26, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax26.set_xticks(lp2)
	ax26.set_xticklabels('')
	ax26.set_yticks(p6)
	ax26.set_yticklabels('')	

	ax27.imshow(np.flipud(Prob_all[10]), interpolation='none', aspect=(lp2[4]-lp2[0])/(p7[4]-p7[0]), extent=E27, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax27.set_xticks(lp2)
	ax27.set_xticklabels(np.round(lp2,2), rotation=45)
	ax27.set_yticks(p7)
	ax27.set_yticklabels('')
	ax27.set_xlabel('log10(m.v.c.v. [km/s])', fontsize=9)	





	# Column 3
	ax33.plot(lp3, Prob_par3_all[1], 'k')
	#ax33.plot(lp3, Prob_par3_all[2], 'k')
	#ax33.plot(lp3, Prob_par3_all[3], 'k')
	ax33.set_xticks(lp3)
	ax33.set_yticks([0, 0.1, 0.2, 0.3, 0.4, 0.5])
	ax33.set_xlim(lp3[0]-(lp3[1]-lp3[0])/2, lp3[imax]+(lp3[1]-lp3[0])/2)
	ax33.set_ylim(0, max_1D)
	ax33.grid()
	ax33.set_xticklabels('')
	ax33.set_yticklabels('')

	ax34.imshow(np.flipud(Prob_all[11]), interpolation='none', aspect=(lp3[4]-lp3[0])/(p4[4]-p4[0]), extent=E34, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax34.set_xticks(lp3)
	ax34.set_xticklabels('')
	ax34.set_yticks(p4)
	ax34.set_yticklabels('') 		

	ax35.imshow(np.flipud(Prob_all[12]), interpolation='none', aspect=(lp3[4]-lp3[0])/(p5[4]-p5[0]), extent=E35, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax35.set_xticks(lp3)
	ax35.set_xticklabels('')
	ax35.set_yticks(p5)
	ax35.set_yticklabels('')	

	ax36.imshow(np.flipud(Prob_all[13]), interpolation='none', aspect=(lp3[4]-lp3[0])/(p6[4]-p6[0]), extent=E36, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax36.set_xticks(lp3)
	ax36.set_xticklabels('')
	ax36.set_yticks(p6)
	ax36.set_yticklabels('')	

	ax37.imshow(np.flipud(Prob_all[14]), interpolation='none', aspect=(lp3[4]-lp3[0])/(p7[4]-p7[0]), extent=E37, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax37.set_xticks(lp3)
	ax37.set_xticklabels(np.round(lp3,2), rotation=45)
	ax37.set_yticks(p7)
	ax37.set_yticklabels('') 
	ax37.set_xlabel('log10(x.r.e)', fontsize=9)	




	# Column 4
	#ax44.plot(p4, Prob_par4_all[1], 'k')
	ax44.plot(p4, Prob_par4_all[2], 'k')
	#ax44.plot(p4, Prob_par4_all[3], 'k')
	#ax44.plot(p4, Prob_par4_all[4], 'k')
	#ax44.plot(p4, Prob_par4_all[5], 'k')
	ax44.set_xticks(p4)
	ax44.set_yticks([0, 0.1, 0.2, 0.3, 0.4, 0.5])
	ax44.set_xlim(p4[0]-(p4[1]-p4[0])/2, p4[imax]+(p4[1]-p4[0])/2)
	ax44.set_ylim(0, max_1D)
	ax44.grid()
	ax44.set_xticklabels('')
	ax44.set_yticklabels('')

	ax45.imshow(np.flipud(Prob_all[15]), interpolation='none', aspect=(p4[4]-p4[0])/(p5[4]-p5[0]), extent=E45, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax45.set_xticks(p4)
	ax45.set_xticklabels('')
	ax45.set_yticks(p5)
	ax45.set_yticklabels('')	

	ax46.imshow(np.flipud(Prob_all[16]), interpolation='none', aspect=(p4[4]-p4[0])/(p6[4]-p6[0]), extent=E46, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax46.set_xticks(p4)
	ax46.set_xticklabels('')
	ax46.set_yticks(p6)
	ax46.set_yticklabels('')

	ax47.imshow(np.flipud(Prob_all[17]), interpolation='none', aspect=(p4[4]-p4[0])/(p7[4]-p7[0]), extent=E47, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax47.set_xticks(p4)
	ax47.set_xticklabels(np.round(p4,3), rotation=45)
	ax47.set_yticks(p7)
	ax47.set_yticklabels('')
	ax47.set_xlabel('tau', fontsize=9)




	# Column 5
	ax55.plot(p5, Prob_par5_all[1], 'k')
	#ax55.plot(p5, Prob_par5_all[2], 'k')
	#ax55.plot(p5, Prob_par5_all[3], 'k')
	ax55.set_xticks(p5)
	ax55.set_yticks([0, 0.1, 0.2, 0.3, 0.4, 0.5])
	ax55.set_xlim(p5[0]-(p5[1]-p5[0])/2, p5[imax]+(p5[1]-p5[0])/2)
	ax55.set_ylim(0, max_1D)
	ax55.grid()
	ax55.set_xticklabels('')
	ax55.set_yticklabels('')

	ax56.imshow(np.flipud(Prob_all[18]), interpolation='none', aspect=(p5[4]-p5[0])/(p6[4]-p6[0]), extent=E56, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax56.set_xticks(p5)
	ax56.set_xticklabels('')
	ax56.set_yticks(p6)
	ax56.set_yticklabels('')	

	ax57.imshow(np.flipud(Prob_all[19]), interpolation='none', aspect=(p5[4]-p5[0])/(p7[4]-p7[0]), extent=E57, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax57.set_xticks(p5)
	ax57.set_xticklabels(np.round(p5,2), rotation=45)
	ax57.set_yticks(p7)
	ax57.set_yticklabels('')
	ax57.set_xlabel('slope x-ray', fontsize=9)




	# Column 6
	ax66.plot(p6, Prob_par6_all[1], 'k')
	#ax66.plot(p6, Prob_par6_all[2], 'k')
	#ax66.plot(p6, Prob_par6_all[3], 'k')
	ax66.set_xticks(p6)
	ax66.set_yticks([0, 0.1, 0.2, 0.3, 0.4, 0.5])
	ax66.set_xlim(p6[0]-(p6[1]-p6[0])/2, p6[imax]+(p6[1]-p6[0])/2)
	ax66.set_ylim(0, max_1D)
	ax66.grid()
	ax66.set_xticklabels('')
	ax66.set_yticklabels('')

	IMAGE_MAP = ax67.imshow(np.flipud(Prob_all[20]), interpolation='none', aspect=(p6[4]-p6[0])/(p7[4]-p7[0]), extent=E67, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax67.set_xticks(p6)
	ax67.set_xticklabels(np.round(p6,2), rotation=45)
	ax67.set_yticks(p7)
	ax67.set_yticklabels('')
	ax67.set_xlabel('low cut-off x-ray [KeV]', fontsize=9)





	# Column 7
	ax77.plot(p7, Prob_par7_all[1], 'k')
	#ax77.plot(p7, Prob_par7_all[2], 'k')
	#ax77.plot(p7, Prob_par7_all[3], 'k')
	ax77.set_xticks(p7)
	ax77.set_yticks([0, 0.1, 0.2, 0.3, 0.4, 0.5])
	ax77.set_xlim(p7[0]-(p7[1]-p7[0])/2, p7[4]+(p7[1]-p7[0])/2)
	ax77.set_ylim(0, max_1D)
	ax77.grid()
	#ax77.set_xticklabels('')
	ax77.set_yticklabels('')
	ax77.set_xticklabels(np.round(p7,2), rotation=45)
	ax77.set_xlabel('m.f.p. [Mpc]', fontsize=9)




	cb_x0 = 0.6
	cb_y0 = 0.8
	cb_dx = 0.2
	cb_dy = 0.01
	cax1 = f1.add_axes([cb_x0, cb_y0, cb_dx, cb_dy])
	cbar = plt.colorbar(IMAGE_MAP, cax=cax1, ticks=np.arange(min_prob, max_prob+0.005, 0.01), orientation="horizontal")
	cbar.ax.set_xticklabels(np.arange(min_prob, max_prob+0.005, 0.01), rotation=45)
	cbar.ax.set_xlabel(r'probability density', fontsize=12)
	cbar.ax.tick_params(labelsize=12)


	plt.savefig(path_plot_save + filename_save_1, bbox_inches='tight')
	plt.close()
	plt.close()


















	# Figure 2
	# ---------------------------------------------------

	plt.close()
	plt.close()
	plt.close()



	f1     = plt.figure(num=1, figsize=(size_x, size_y))

	ax17   = f1.add_axes([1*x0 + 0*(dx+x00), 1*y0 + 0*(dy+y00), dx, dy])
	ax16   = f1.add_axes([1*x0 + 0*(dx+x00), 1*y0 + 1*(dy+y00), dx, dy])
	ax15   = f1.add_axes([1*x0 + 0*(dx+x00), 1*y0 + 2*(dy+y00), dx, dy])
	ax14   = f1.add_axes([1*x0 + 0*(dx+x00), 1*y0 + 3*(dy+y00), dx, dy])
	ax13   = f1.add_axes([1*x0 + 0*(dx+x00), 1*y0 + 4*(dy+y00), dx, dy])
	ax12   = f1.add_axes([1*x0 + 0*(dx+x00), 1*y0 + 5*(dy+y00), dx, dy])
	ax11   = f1.add_axes([1*x0 + 0*(dx+x00), 1*y0 + 6*(dy+y00), dx, dy])


	ax27   = f1.add_axes([1*x0 + 1*(dx+x00), 1*y0 + 0*(dy+y00), dx, dy])
	ax26   = f1.add_axes([1*x0 + 1*(dx+x00), 1*y0 + 1*(dy+y00), dx, dy])
	ax25   = f1.add_axes([1*x0 + 1*(dx+x00), 1*y0 + 2*(dy+y00), dx, dy])
	ax24   = f1.add_axes([1*x0 + 1*(dx+x00), 1*y0 + 3*(dy+y00), dx, dy])
	ax23   = f1.add_axes([1*x0 + 1*(dx+x00), 1*y0 + 4*(dy+y00), dx, dy])
	ax22   = f1.add_axes([1*x0 + 1*(dx+x00), 1*y0 + 5*(dy+y00), dx, dy])

	ax37   = f1.add_axes([1*x0 + 2*(dx+x00), 1*y0 + 0*(dy+y00), dx, dy])
	ax36   = f1.add_axes([1*x0 + 2*(dx+x00), 1*y0 + 1*(dy+y00), dx, dy])
	ax35   = f1.add_axes([1*x0 + 2*(dx+x00), 1*y0 + 2*(dy+y00), dx, dy])
	ax34   = f1.add_axes([1*x0 + 2*(dx+x00), 1*y0 + 3*(dy+y00), dx, dy])
	ax33   = f1.add_axes([1*x0 + 2*(dx+x00), 1*y0 + 4*(dy+y00), dx, dy])

	ax47   = f1.add_axes([1*x0 + 3*(dx+x00), 1*y0 + 0*(dy+y00), dx, dy])
	ax46   = f1.add_axes([1*x0 + 3*(dx+x00), 1*y0 + 1*(dy+y00), dx, dy])
	ax45   = f1.add_axes([1*x0 + 3*(dx+x00), 1*y0 + 2*(dy+y00), dx, dy])
	ax44   = f1.add_axes([1*x0 + 3*(dx+x00), 1*y0 + 3*(dy+y00), dx, dy])

	ax57   = f1.add_axes([1*x0 + 4*(dx+x00), 1*y0 + 0*(dy+y00), dx, dy])
	ax56   = f1.add_axes([1*x0 + 4*(dx+x00), 1*y0 + 1*(dy+y00), dx, dy])
	ax55   = f1.add_axes([1*x0 + 4*(dx+x00), 1*y0 + 2*(dy+y00), dx, dy])

	ax67   = f1.add_axes([1*x0 + 5*(dx+x00), 1*y0 + 0*(dy+y00), dx, dy])
	ax66   = f1.add_axes([1*x0 + 5*(dx+x00), 1*y0 + 1*(dy+y00), dx, dy])

	ax77   = f1.add_axes([1*x0 + 6*(dx+x00), 1*y0 + 0*(dy+y00), dx, dy])




	color_map = 'gnuplot'
	min_prob = 0
	max_prob = 2






	# Column 1	
	ax11.plot(lp1, Prob_par1_all[1], 'k')
	#ax11.plot(lp1, Prob_par1_all[2], 'k')
	#ax11.plot(lp1, Prob_par1_all[3], 'k')
	ax11.set_xticks(lp1)
	ax11.set_yticks([0, 0.1, 0.2, 0.3, 0.4, 0.5])
	ax11.set_xlim(lp1[0]-(lp1[1]-lp1[0])/2, lp1[imax]+(lp1[1]-lp1[0])/2)
	ax11.set_ylim(0, max_1D)
	ax11.grid()
	ax11.set_xticklabels('')
	ax11.set_yticklabels('')

	ax12.imshow(np.flipud(Prob_limits_all[0]), interpolation='none', aspect=(lp1[4]-lp1[0])/(lp2[4]-lp2[0]), extent=E12, cmap=color_map, vmin=min_prob, vmax=max_prob) # , cmap=plt.get_cmap(cmap_name))
	ax12.set_xticks(lp1)
	ax12.set_xticklabels('')
	ax12.set_yticks(lp2)
	ax12.set_yticklabels(np.round(lp2,2), rotation=45)
	ax12.set_ylabel('log10(m.v.c.v. [km/s])', fontsize=9)

	ax13.imshow(np.flipud(Prob_limits_all[1]), interpolation='none', aspect=(lp1[4]-lp1[0])/(lp3[4]-lp3[0]), extent=E13, cmap=color_map, vmin=min_prob, vmax=max_prob) #, vmin=min_rej_sig, vmax=max_rej_sig, cmap=plt.get_cmap(cmap_name))
	ax13.set_xticks(lp1)
	ax13.set_xticklabels('')
	ax13.set_yticks(lp3)
	ax13.set_yticklabels(np.round(lp3,2), rotation=45)
	ax13.set_ylabel('log10(x.r.e)', fontsize=9)	

	ax14.imshow(np.flipud(Prob_limits_all[2]), interpolation='none', aspect=(lp1[4]-lp1[0])/(p4[4]-p4[0]), extent=E14, cmap=color_map, vmin=min_prob, vmax=max_prob) #, vmin=min_rej_sig, vmax=max_rej_sig, cmap=plt.get_cmap(cmap_name))
	ax14.set_xticks(lp1)
	ax14.set_xticklabels('')
	ax14.set_yticks(p4)
	ax14.set_yticklabels(np.round(p4,3), rotation=45)
	ax14.set_ylabel('tau', fontsize=9)		

	ax15.imshow(np.flipud(Prob_limits_all[3]), interpolation='none', aspect=(lp1[4]-lp1[0])/(p5[4]-p5[0]), extent=E15, cmap=color_map, vmin=min_prob, vmax=max_prob) #, vmin=min_rej_sig, vmax=max_rej_sig, cmap=plt.get_cmap(cmap_name))
	ax15.set_xticks(lp1)
	ax15.set_xticklabels('')
	ax15.set_yticks(p5)
	ax15.set_yticklabels(np.round(p5,2), rotation=45)
	ax15.set_ylabel('slope x-ray', fontsize=9)

	ax16.imshow(np.flipud(Prob_limits_all[4]), interpolation='none', aspect=(lp1[4]-lp1[0])/(p6[4]-p6[0]), extent=E16, cmap=color_map, vmin=min_prob, vmax=max_prob) #, vmin=min_rej_sig, vmax=max_rej_sig, cmap=plt.get_cmap(cmap_name))
	ax16.set_xticks(lp1)
	ax16.set_xticklabels('')
	ax16.set_yticks(p6)
	ax16.set_yticklabels(np.round(p6,2), rotation=45)
	ax16.set_ylabel('low cut-off x-ray [KeV]', fontsize=9)

	ax17.imshow(np.flipud(Prob_limits_all[5]), interpolation='none', aspect=(lp1[4]-lp1[0])/(p7[4]-p7[0]), extent=E17, cmap=color_map, vmin=min_prob, vmax=max_prob) #vmin=min_rej_sig, vmax=max_rej_sig, cmap=plt.get_cmap(cmap_name))
	ax17.set_xticks(lp1)
	ax17.set_xticklabels(np.round(lp1,2), rotation=45)
	ax17.set_yticks(p7)
	ax17.set_yticklabels(np.round(p7,2), rotation=45)
	ax17.set_xlabel('log10(s.f.e)', fontsize=9)
	ax17.set_ylabel('m.f.p. [Mpc]', fontsize=9)





	# Column 2
	ax22.plot(lp2, Prob_par2_all[1], 'k')
	#ax22.plot(lp2, Prob_par2_all[2], 'k')
	#ax22.plot(lp2, Prob_par2_all[3], 'k')
	ax22.set_xticks(lp2)
	ax22.set_yticks([0, 0.1, 0.2, 0.3, 0.4, 0.5])
	ax22.set_xlim(lp2[0]-(lp2[1]-lp2[0])/2, lp2[imax]+(lp2[1]-lp2[0])/2)
	ax22.set_ylim(0, max_1D)
	ax22.grid()
	ax22.set_xticklabels('')
	ax22.set_yticklabels('')

	ax23.imshow(np.flipud(Prob_limits_all[6]), interpolation='none', aspect=(lp2[4]-lp2[0])/(lp3[4]-lp3[0]), extent=E23, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax23.set_xticks(lp2)
	ax23.set_xticklabels('')
	ax23.set_yticks(lp3)
	ax23.set_yticklabels('')	

	ax24.imshow(np.flipud(Prob_limits_all[7]), interpolation='none', aspect=(lp2[4]-lp2[0])/(p4[4]-p4[0]), extent=E24, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax24.set_xticks(lp2)
	ax24.set_xticklabels('')
	ax24.set_yticks(p4)
	ax24.set_yticklabels('')	

	ax25.imshow(np.flipud(Prob_limits_all[8]), interpolation='none', aspect=(lp2[4]-lp2[0])/(p5[4]-p5[0]), extent=E25, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax25.set_xticks(lp2)
	ax25.set_xticklabels('')
	ax25.set_yticks(p5)
	ax25.set_yticklabels('')	

	ax26.imshow(np.flipud(Prob_limits_all[9]), interpolation='none', aspect=(lp2[4]-lp2[0])/(p6[4]-p6[0]), extent=E26, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax26.set_xticks(lp2)
	ax26.set_xticklabels('')
	ax26.set_yticks(p6)
	ax26.set_yticklabels('')	

	ax27.imshow(np.flipud(Prob_limits_all[10]), interpolation='none', aspect=(lp2[4]-lp2[0])/(p7[4]-p7[0]), extent=E27, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax27.set_xticks(lp2)
	ax27.set_xticklabels(np.round(lp2,2), rotation=45)
	ax27.set_yticks(p7)
	ax27.set_yticklabels('')
	ax27.set_xlabel('log10(m.v.c.v. [km/s])', fontsize=9)	





	# Column 3
	ax33.plot(lp3, Prob_par3_all[1], 'k')
	#ax33.plot(lp3, Prob_par3_all[2], 'k')
	#ax33.plot(lp3, Prob_par3_all[3], 'k')
	ax33.set_xticks(lp3)
	ax33.set_yticks([0, 0.1, 0.2, 0.3, 0.4, 0.5])
	ax33.set_xlim(lp3[0]-(lp3[1]-lp3[0])/2, lp3[imax]+(lp3[1]-lp3[0])/2)
	ax33.set_ylim(0, max_1D)
	ax33.grid()
	ax33.set_xticklabels('')
	ax33.set_yticklabels('')

	ax34.imshow(np.flipud(Prob_limits_all[11]), interpolation='none', aspect=(lp3[4]-lp3[0])/(p4[4]-p4[0]), extent=E34, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax34.set_xticks(lp3)
	ax34.set_xticklabels('')
	ax34.set_yticks(p4)
	ax34.set_yticklabels('') 		

	ax35.imshow(np.flipud(Prob_limits_all[12]), interpolation='none', aspect=(lp3[4]-lp3[0])/(p5[4]-p5[0]), extent=E35, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax35.set_xticks(lp3)
	ax35.set_xticklabels('')
	ax35.set_yticks(p5)
	ax35.set_yticklabels('')	

	ax36.imshow(np.flipud(Prob_limits_all[13]), interpolation='none', aspect=(lp3[4]-lp3[0])/(p6[4]-p6[0]), extent=E36, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax36.set_xticks(lp3)
	ax36.set_xticklabels('')
	ax36.set_yticks(p6)
	ax36.set_yticklabels('')	

	ax37.imshow(np.flipud(Prob_limits_all[14]), interpolation='none', aspect=(lp3[4]-lp3[0])/(p7[4]-p7[0]), extent=E37, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax37.set_xticks(lp3)
	ax37.set_xticklabels(np.round(lp3,2), rotation=45)
	ax37.set_yticks(p7)
	ax37.set_yticklabels('') 
	ax37.set_xlabel('log10(x.r.e)', fontsize=9)	




	# Column 4
	#ax44.plot(p4, Prob_par4_all[1], 'k')
	ax44.plot(p4, Prob_par4_all[2], 'k')
	#ax44.plot(p4, Prob_par4_all[3], 'k')
	#ax44.plot(p4, Prob_par4_all[4], 'k')
	#ax44.plot(p4, Prob_par4_all[5], 'k')
	ax44.set_xticks(p4)
	ax44.set_yticks([0, 0.1, 0.2, 0.3, 0.4, 0.5])
	ax44.set_xlim(p4[0]-(p4[1]-p4[0])/2, p4[imax]+(p4[1]-p4[0])/2)
	ax44.set_ylim(0, max_1D)
	ax44.grid()
	ax44.set_xticklabels('')
	ax44.set_yticklabels('')

	ax45.imshow(np.flipud(Prob_limits_all[15]), interpolation='none', aspect=(p4[4]-p4[0])/(p5[4]-p5[0]), extent=E45, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax45.set_xticks(p4)
	ax45.set_xticklabels('')
	ax45.set_yticks(p5)
	ax45.set_yticklabels('')	

	ax46.imshow(np.flipud(Prob_limits_all[16]), interpolation='none', aspect=(p4[4]-p4[0])/(p6[4]-p6[0]), extent=E46, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax46.set_xticks(p4)
	ax46.set_xticklabels('')
	ax46.set_yticks(p6)
	ax46.set_yticklabels('')

	ax47.imshow(np.flipud(Prob_limits_all[17]), interpolation='none', aspect=(p4[4]-p4[0])/(p7[4]-p7[0]), extent=E47, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax47.set_xticks(p4)
	ax47.set_xticklabels(np.round(p4,3), rotation=45)
	ax47.set_yticks(p7)
	ax47.set_yticklabels('')
	ax47.set_xlabel('tau', fontsize=9)




	# Column 5
	ax55.plot(p5, Prob_par5_all[1], 'k')
	#ax55.plot(p5, Prob_par5_all[2], 'k')
	#ax55.plot(p5, Prob_par5_all[3], 'k')
	ax55.set_xticks(p5)
	ax55.set_yticks([0, 0.1, 0.2, 0.3, 0.4, 0.5])
	ax55.set_xlim(p5[0]-(p5[1]-p5[0])/2, p5[imax]+(p5[1]-p5[0])/2)
	ax55.set_ylim(0, max_1D)
	ax55.grid()
	ax55.set_xticklabels('')
	ax55.set_yticklabels('')

	ax56.imshow(np.flipud(Prob_limits_all[18]), interpolation='none', aspect=(p5[4]-p5[0])/(p6[4]-p6[0]), extent=E56, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax56.set_xticks(p5)
	ax56.set_xticklabels('')
	ax56.set_yticks(p6)
	ax56.set_yticklabels('')	

	ax57.imshow(np.flipud(Prob_limits_all[19]), interpolation='none', aspect=(p5[4]-p5[0])/(p7[4]-p7[0]), extent=E57, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax57.set_xticks(p5)
	ax57.set_xticklabels(np.round(p5,2), rotation=45)
	ax57.set_yticks(p7)
	ax57.set_yticklabels('')
	ax57.set_xlabel('slope x-ray', fontsize=9)




	# Column 6
	ax66.plot(p6, Prob_par6_all[1], 'k')
	#ax66.plot(p6, Prob_par6_all[2], 'k')
	#ax66.plot(p6, Prob_par6_all[3], 'k')
	ax66.set_xticks(p6)
	ax66.set_yticks([0, 0.1, 0.2, 0.3, 0.4, 0.5])
	ax66.set_xlim(p6[0]-(p6[1]-p6[0])/2, p6[imax]+(p6[1]-p6[0])/2)
	ax66.set_ylim(0, max_1D)
	ax66.grid()
	ax66.set_xticklabels('')
	ax66.set_yticklabels('')

	IMAGE_MAP = ax67.imshow(np.flipud(Prob_limits_all[20]), interpolation='none', aspect=(p6[4]-p6[0])/(p7[4]-p7[0]), extent=E67, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax67.set_xticks(p6)
	ax67.set_xticklabels(np.round(p6,2), rotation=45)
	ax67.set_yticks(p7)
	ax67.set_yticklabels('')
	ax67.set_xlabel('low cut-off x-ray [KeV]', fontsize=9)





	# Column 7
	ax77.plot(p7, Prob_par7_all[1], 'k')
	#ax77.plot(p7, Prob_par7_all[2], 'k')
	#ax77.plot(p7, Prob_par7_all[3], 'k')
	ax77.set_xticks(p7)
	ax77.set_yticks([0, 0.1, 0.2, 0.3, 0.4, 0.5])
	ax77.set_xlim(p7[0]-(p7[1]-p7[0])/2, p7[imax]+(p7[1]-p7[0])/2)
	ax77.set_ylim(0, max_1D)
	ax77.grid()
	#ax77.set_xticklabels('')
	ax77.set_yticklabels('')
	ax77.set_xticklabels(np.round(p7,2), rotation=45)
	ax77.set_xlabel('m.f.p. [Mpc]', fontsize=9)




	#cb_x0 = 0.6
	#cb_y0 = 0.8
	#cb_dx = 0.2
	#cb_dy = 0.01
	#cax1 = f1.add_axes([cb_x0, cb_y0, cb_dx, cb_dy])
	#cbar = plt.colorbar(IMAGE_MAP, cax=cax1, ticks=np.arange(min_prob, max_prob+0.005, 0.01), orientation="horizontal")
	#cbar.ax.set_xticklabels(np.arange(min_prob, max_prob+0.005, 0.01), rotation=45)
	#cbar.ax.set_xlabel(r'probability density', fontsize=12)
	#cbar.ax.tick_params(labelsize=12)



	plt.text(fig2_text_x, fig2_text_y1, 'YELLOW: encloses 68% of distribution')
	plt.text(fig2_text_x, fig2_text_y2, 'RED: encloses between 68% and 95% of distribution')
	plt.text(fig2_text_x, fig2_text_y3, 'BLACK: encloses 5% of distribution')


	#plt.text(fig2_text_x, fig2_text_y1, 'YELLOW: encloses 60% of distribution')
	#plt.text(fig2_text_x, fig2_text_y2, 'RED: encloses between 60% and 90% of distribution')
	#plt.text(fig2_text_x, fig2_text_y3, 'BLACK: encloses 10% of distribution')





	plt.savefig(path_plot_save + filename_save_2, bbox_inches='tight')
	plt.close()
	plt.close()



	return Prob_all, Prob_limits_all, Prob_par1_all, Prob_par2_all, Prob_par3_all, Prob_par4_all, Prob_par5_all, Prob_par6_all, Prob_par7_all, p1, p2, p3
























def fialkov_triangle_plot_V2_Npar4(likelihood_file_name, plot_file_name):

	path_plot_save  = home_folder + '/DATA/EDGES/results/plots/20180125/'
	
	
	
	p1, p2, p3, p4, pix_all, Prob_all, Prob_limits_all, Prob_par1_all, Prob_par2_all, Prob_par3_all, Prob_par4_all = fialkov_probabilities_hires_4par(likelihood_file_name)
	
	min_prob = 0
	max_prob = 1#0.015
	max_1D   = 1.1

	imax = 79   # 19



	# Settings for Figures
	# ---------------------------
	size_x = 7
	size_y = 7

	dx     = 0.21
	dy     = 0.21	
	x0     = 0.13 #0.056
	y0     = 0.13  #0.059
	x00    = 0.007
	y00    = 0.007


	lp1 = np.log10(p1)
	lp2 = np.log10(p2)
	lp3 = np.log10(p3)





	E12 = [lp1[0]-(lp1[1]-lp1[0])/2, lp1[imax]+(lp1[1]-lp1[0])/2, lp2[0]-(lp2[1]-lp2[0])/2, lp2[imax]+(lp2[1]-lp2[0])/2]
	E13 = [lp1[0]-(lp1[1]-lp1[0])/2, lp1[imax]+(lp1[1]-lp1[0])/2, lp3[0]-(lp3[1]-lp3[0])/2, lp3[imax]+(lp3[1]-lp3[0])/2]
	E14 = [lp1[0]-(lp1[1]-lp1[0])/2, lp1[imax]+(lp1[1]-lp1[0])/2, p4[0]-(p4[1]-p4[0])/2, p4[imax]+(p4[1]-p4[0])/2]

	E23 = [lp2[0]-(lp2[1]-lp2[0])/2, lp2[imax]+(lp2[1]-lp2[0])/2, lp3[0]-(lp3[1]-lp3[0])/2, lp3[imax]+(lp3[1]-lp3[0])/2]
	E24 = [lp2[0]-(lp2[1]-lp2[0])/2, lp2[imax]+(lp2[1]-lp2[0])/2, p4[0]-(p4[1]-p4[0])/2, p4[imax]+(p4[1]-p4[0])/2]

	E34 = [lp3[0]-(lp3[1]-lp3[0])/2, lp3[imax]+(lp3[1]-lp3[0])/2, p4[0]-(p4[1]-p4[0])/2, p4[imax]+(p4[1]-p4[0])/2]




	# Figure
	# ---------------------------------------------------

	plt.close()
	plt.close()
	plt.close()



	f1     = plt.figure(num=1, figsize=(size_x, size_y))

	ax14   = f1.add_axes([1*x0 + 0*(dx+x00), 1*y0 + 0*(dy+y00), dx, dy])
	ax13   = f1.add_axes([1*x0 + 0*(dx+x00), 1*y0 + 1*(dy+y00), dx, dy])
	ax12   = f1.add_axes([1*x0 + 0*(dx+x00), 1*y0 + 2*(dy+y00), dx, dy])
	ax11   = f1.add_axes([1*x0 + 0*(dx+x00), 1*y0 + 3*(dy+y00), dx, dy])

	ax24   = f1.add_axes([1*x0 + 1*(dx+x00), 1*y0 + 0*(dy+y00), dx, dy])
	ax23   = f1.add_axes([1*x0 + 1*(dx+x00), 1*y0 + 1*(dy+y00), dx, dy])
	ax22   = f1.add_axes([1*x0 + 1*(dx+x00), 1*y0 + 2*(dy+y00), dx, dy])

	ax34   = f1.add_axes([1*x0 + 2*(dx+x00), 1*y0 + 0*(dy+y00), dx, dy])
	ax33   = f1.add_axes([1*x0 + 2*(dx+x00), 1*y0 + 1*(dy+y00), dx, dy])
	
	ax44   = f1.add_axes([1*x0 + 3*(dx+x00), 1*y0 + 0*(dy+y00), dx, dy])
	
	
	ax_legend  = f1.add_axes([1*x0 + 2*(dx+x00), 1*y0 + 2*(dy+y00), 2*dx, dy])











	color_map = 'jet'  # '_r'
	
	FS=13
	INTERP = 'bilinear'

	limit_1D_color_95 = [0.75,0.75,0.75]
	limit_1D_color_68 = [0.5,0.5,0.5]
	hatch_pattern = '////'

	f1 = plt.figure(1)

	
	
	
	
	# Column 1
	PN = Prob_par1_all[1]/np.max(Prob_par1_all[1])
	ix = np.argsort(PN)
	total_area = np.sum(PN)
	
	acc_area = 0
	prob = np.zeros(len(PN))
	for i in range(len(ix)):
		acc_area = acc_area + PN[ix[i]]
		if acc_area <= 0.05 * total_area:
			prob[ix[i]] = 0
			
		elif (0.05 * total_area <= acc_area <= 0.32 * total_area):
			prob[ix[i]] = 1
			
		elif (acc_area >= 0.32 * total_area):
			prob[ix[i]] = 2
						
	ax11.bar(lp1[prob==0], PN[prob==0], width=np.abs(lp1[0]-lp1[1]), color=[1,1,1], hatch=hatch_pattern)        #
	ax11.bar(lp1[prob==1], PN[prob==1], width=np.abs(lp1[0]-lp1[1]), color=limit_1D_color_95)  #
	ax11.bar(lp1[prob==2], PN[prob==2], width=np.abs(lp1[0]-lp1[1]), color=limit_1D_color_68)
	ax11.plot(lp1, PN, 'b', linewidth=3)
	
	
	xt = [lp1[0], (1/4)*(lp1[-1]-lp1[0])+lp1[0], (2/4)*(lp1[-1]-lp1[0])+lp1[0], (3/4)*(lp1[-1]-lp1[0])+lp1[0], lp1[-1]]
	ax11.set_xticks(xt)
	ax11.set_yticks([])
	
	X10 = 0.1*(lp1[imax]-lp1[0])
	ax11.set_xlim(lp1[0]-X10, lp1[imax]+X10)
	ax11.set_ylim(0, max_1D)
	
	ax11.set_xticklabels('')
	ax11.set_yticklabels('')





	ax12.imshow(np.flipud(Prob_all[0]/np.nanmax(Prob_all[0])), interpolation=INTERP, aspect=(lp1[4]-lp1[0])/(lp2[4]-lp2[0]), extent=E12, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax12.contour(lp1, lp2, Prob_limits_all[0], colors=['k', 'k'], levels=[contour_level_95, contour_level_68], linestyles=['--', '-'], linewidths=[2,2])
	
	xt = [lp1[0], lp1[4], lp1[9], lp1[14], lp1[19]]
	xt = [lp1[0], (1/4)*(lp1[-1]-lp1[0])+lp1[0], (2/4)*(lp1[-1]-lp1[0])+lp1[0], (3/4)*(lp1[-1]-lp1[0])+lp1[0], lp1[-1]]
	yt = [lp2[0], (1/4)*(lp2[-1]-lp2[0])+lp2[0], (2/4)*(lp2[-1]-lp2[0])+lp2[0], (3/4)*(lp2[-1]-lp2[0])+lp2[0], lp2[-1]]
	
	ax12.set_xticks(xt)
	ax12.set_yticks(yt)
	
	ax12.set_xticklabels('')
	ax12.set_yticklabels(np.round(yt,2), rotation=45)
	
	X10 = 0.1*(lp1[imax]-lp1[0])
	Y10 = 0.1*(lp2[imax]-lp2[0])
	ax12.set_xlim(lp1[0]-X10, lp1[imax]+X10)
	ax12.set_ylim(lp2[0]-Y10, lp2[imax]+Y10)

	ax12.set_ylabel(r'$\log_{10}(\rm V_c)$ [km/s]', fontsize=FS)






	ax13.imshow(np.flipud(Prob_all[1]/np.max(Prob_all[1])), interpolation=INTERP, aspect=(lp1[4]-lp1[0])/(lp3[4]-lp3[0]), extent=E13, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax13.contour(lp1, lp3, Prob_limits_all[1], colors=['k', 'k'], levels=[contour_level_95, contour_level_68], linestyles=['--', '-'], linewidths=[2,2])
	#xt = [lp1[0], lp1[4], lp1[9], lp1[14], lp1[19]]
	xt = [lp1[0], (1/4)*(lp1[-1]-lp1[0])+lp1[0], (2/4)*(lp1[-1]-lp1[0])+lp1[0], (3/4)*(lp1[-1]-lp1[0])+lp1[0], lp1[-1]]
	yt = [lp3[0], (1/4)*(lp3[-1]-lp3[0])+lp3[0], (2/4)*(lp3[-1]-lp3[0])+lp3[0], (3/4)*(lp3[-1]-lp3[0])+lp3[0], lp3[-1]]
	
	ax13.set_xticks(xt)
	ax13.set_yticks(yt)
	
	ax13.set_xticklabels('')	
	ax13.set_yticklabels(np.round(yt,2), rotation=45)

	X10 = 0.1*(lp1[imax]-lp1[0])
	Y10 = 0.1*(lp3[imax]-lp3[0])	
	ax13.set_xlim(lp1[0]-X10, lp1[imax]+X10)
	ax13.set_ylim(lp3[0]-Y10, lp3[imax]+Y10)
	
	ax13.set_ylabel(r'$\log_{10}(f_X)$', fontsize=FS)
	
	
	

	ax14.imshow(np.flipud(Prob_all[2]/np.max(Prob_all[2])), interpolation=INTERP, aspect=(lp1[4]-lp1[0])/(p4[4]-p4[0]), extent=E14, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax14.contour(lp1, p4, Prob_limits_all[2], colors=['k', 'k'], levels=[contour_level_95, contour_level_68], linestyles=['--', '-'], linewidths=[2,2])
	#xt = [lp1[0], lp1[4], lp1[9], lp1[14], lp1[19]]
	xt = [lp1[0], (1/4)*(lp1[-1]-lp1[0])+lp1[0], (2/4)*(lp1[-1]-lp1[0])+lp1[0], (3/4)*(lp1[-1]-lp1[0])+lp1[0], lp1[-1]]
	yt = [p4[0], (1/4)*(p4[-1]-p4[0])+p4[0], (2/4)*(p4[-1]-p4[0])+p4[0], (3/4)*(p4[-1]-p4[0])+p4[0], p4[-1]]
	
	ax14.set_xticks(xt)
	ax14.set_yticks(yt)
	
	ax14.set_xticklabels(np.round(xt,2), rotation=45)
	ax14.set_yticklabels(np.round(yt), rotation=45)
	
	X10 = 0.1*(lp1[imax]-lp1[0])
	Y10 = 0.1*(p4[imax]-p4[0])
	ax14.set_xlim(lp1[0]-X10, lp1[imax]+X10)
	ax14.set_ylim(p4[0]-Y10, p4[imax]+Y10)	
	
	ax14.set_xlabel(r'$\log_{10}$($f_{\bigstar}$)', fontsize=FS)
	ax14.set_ylabel(r'$R_{\rm mfp}$ [Mpc]', fontsize=FS)








	# Column 2
	PN = Prob_par2_all[1]/np.max(Prob_par2_all[1])
	ix = np.argsort(PN)
	total_area = np.sum(PN)
	
	acc_area = 0
	prob = np.zeros(len(PN))
	for i in range(len(ix)):
		acc_area = acc_area + PN[ix[i]]
		if acc_area <= 0.05 * total_area:
			prob[ix[i]] = 0
			
		elif (0.05 * total_area <= acc_area <= 0.32 * total_area):
			prob[ix[i]] = 1
			
		elif (acc_area >= 0.32 * total_area):
			prob[ix[i]] = 2
						
	ax22.bar(lp2[prob==0], PN[prob==0], width=np.abs(lp2[0]-lp2[1]), color=[1,1,1], hatch=hatch_pattern)         #
	ax22.bar(lp2[prob==1], PN[prob==1], width=np.abs(lp2[0]-lp2[1]), color=limit_1D_color_95)   #
	ax22.bar(lp2[prob==2], PN[prob==2], width=np.abs(lp2[0]-lp2[1]), color=limit_1D_color_68)
	ax22.plot(lp2, PN, 'b', linewidth=3)
	
	xt = [lp2[0], (1/4)*(lp2[-1]-lp2[0])+lp2[0], (2/4)*(lp2[-1]-lp2[0])+lp2[0], (3/4)*(lp2[-1]-lp2[0])+lp2[0], lp2[-1]]
	ax22.set_xticks(xt)
	ax22.set_yticks([])
	
	X10 = 0.1*(lp2[imax]-lp2[0])
	ax22.set_xlim(lp2[0]-X10, lp2[imax]+X10)
	ax22.set_ylim(0, max_1D)
	
	ax22.set_xticklabels('')
	ax22.set_yticklabels('')
	
	

	ax23.imshow(np.flipud(Prob_all[3]/np.max(Prob_all[3])), interpolation=INTERP, aspect=(lp2[4]-lp2[0])/(lp3[4]-lp3[0]), extent=E23, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax23.contour(lp2, lp3, Prob_limits_all[3], colors=['k', 'k'], levels=[contour_level_95, contour_level_68], linestyles=['--', '-'], linewidths=[2,2])
	
	xt = [lp2[0], (1/4)*(lp2[-1]-lp2[0])+lp2[0], (2/4)*(lp2[-1]-lp2[0])+lp2[0], (3/4)*(lp2[-1]-lp2[0])+lp2[0], lp2[-1]]
	yt = [lp3[0], (1/4)*(lp3[-1]-lp3[0])+lp3[0], (2/4)*(lp3[-1]-lp3[0])+lp3[0], (3/4)*(lp3[-1]-lp3[0])+lp3[0], lp3[-1]]

	ax23.set_xticks(xt)
	ax23.set_yticks(yt)
	
	ax23.set_xticklabels('')	
	ax23.set_yticklabels('') #np.round(yt,2), rotation=45)	

	X10 = 0.1*(lp2[imax]-lp2[0])
	Y10 = 0.1*(lp3[imax]-lp3[0])
	ax23.set_xlim(lp2[0]-X10, lp2[imax]+X10)
	ax23.set_ylim(lp3[0]-Y10, lp3[imax]+Y10)	

	ax23.set_xlabel('')
	ax23.set_ylabel('')
	
	

	ax24.imshow(np.flipud(Prob_all[4]/np.max(Prob_all[4])), interpolation=INTERP, aspect=(lp2[4]-lp2[0])/(p4[4]-p4[0]), extent=E24, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax24.contour(lp2, p4, Prob_limits_all[4], colors=['k', 'k'], levels=[contour_level_95, contour_level_68], linestyles=['--', '-'], linewidths=[2,2])
	
	xt = [lp2[0], (1/4)*(lp2[-1]-lp2[0])+lp2[0], (2/4)*(lp2[-1]-lp2[0])+lp2[0], (3/4)*(lp2[-1]-lp2[0])+lp2[0], lp2[-1]]
	yt = [p4[0], (1/4)*(p4[-1]-p4[0])+p4[0], (2/4)*(p4[-1]-p4[0])+p4[0], (3/4)*(p4[-1]-p4[0])+p4[0], p4[-1]]

	ax24.set_xticks(xt)
	ax24.set_yticks(yt)
	
	ax24.set_xticklabels(np.round(xt,2), rotation=45)
	ax24.set_yticklabels('') #np.round(yt,2), rotation=45)	

	X10 = 0.1*(lp2[imax]-lp2[0])
	Y10 = 0.1*(p4[imax] -p4[0])
	ax24.set_xlim(lp2[0]-X10, lp2[imax]+X10)
	ax24.set_ylim(p4[0]-Y10,  p4[imax]+Y10)	

	ax24.set_xlabel(r'$\log_{10}(\rm V_c)$ [km/s]', fontsize=FS)
	ax24.set_ylabel('')
	
	
	




	# Column 3
	PN = Prob_par3_all[1]/np.max(Prob_par3_all[1])
	ix = np.argsort(PN)
	total_area = np.sum(PN)
	
	acc_area = 0
	prob = np.zeros(len(PN))
	for i in range(len(ix)):
		acc_area = acc_area + PN[ix[i]]
		if acc_area <= 0.05 * total_area:
			prob[ix[i]] = 0
			
		elif (0.05 * total_area <= acc_area <= 0.32 * total_area):
			prob[ix[i]] = 1
			
		elif (acc_area >= 0.32 * total_area):
			prob[ix[i]] = 2
						
	ax33.bar(lp3[prob==0], PN[prob==0], width=np.abs(lp3[0]-lp3[1]), color=[1,1,1], hatch=hatch_pattern)         #
	ax33.bar(lp3[prob==1], PN[prob==1], width=np.abs(lp3[0]-lp3[1]), color=limit_1D_color_95)   #
	ax33.bar(lp3[prob==2], PN[prob==2], width=np.abs(lp3[0]-lp3[1]), color=limit_1D_color_68)
	ax33.plot(lp3, PN, 'b', linewidth=3)
	
	xt = [lp3[0], (1/4)*(lp3[-1]-lp3[0])+lp3[0], (2/4)*(lp3[-1]-lp3[0])+lp3[0], (3/4)*(lp3[-1]-lp3[0])+lp3[0], lp3[-1]]
	ax33.set_xticks(xt)
	ax33.set_yticks([])
	
	X10 = 0.1*(lp3[imax]-lp3[0])
	ax33.set_xlim(lp3[0]-X10, lp3[imax]+X10)
	ax33.set_ylim(0, max_1D)
	
	ax33.set_xticklabels('')
	ax33.set_yticklabels('')
	
	
	

	IMAGE_MAP = ax34.imshow(np.flipud(Prob_all[5]/np.max(Prob_all[5])), interpolation=INTERP, aspect=(lp3[4]-lp3[0])/(p4[4]-p4[0]), extent=E34, cmap=color_map, vmin=min_prob, vmax=max_prob)  #
	ax34.contour(lp3, p4, Prob_limits_all[5], colors=['k', 'k'], levels=[contour_level_95, contour_level_68], linestyles=['--', '-'], linewidths=[2,2])
	
	xt = [lp3[0], (1/4)*(lp3[-1]-lp3[0])+lp3[0], (2/4)*(lp3[-1]-lp3[0])+lp3[0], (3/4)*(lp3[-1]-lp3[0])+lp3[0], lp3[-1]]
	yt = [p4[0], (1/4)*(p4[-1]-p4[0])+p4[0], (2/4)*(p4[-1]-p4[0])+p4[0], (3/4)*(p4[-1]-p4[0])+p4[0], p4[-1]]

	ax34.set_xticks(xt)
	ax34.set_yticks(yt)
	
	ax34.set_xticklabels(np.round(xt,2), rotation=45)
	ax34.set_yticklabels('') #np.round(yt,2), rotation=45)	

	X10 = 0.1*(lp3[imax]-lp3[0])
	Y10 = 0.1*(p4[imax] -p4[0])
	ax34.set_xlim(lp3[0]-X10, lp3[imax]+X10)
	ax34.set_ylim(p4[0]-Y10,  p4[imax]+Y10)	

	ax34.set_xlabel(r'$\log_{10}(f_X)$', fontsize=FS)
	ax34.set_ylabel('')
	
	print(np.min(Prob_all[5]/np.max(Prob_all[5])))






	# Column 4
	PN = Prob_par4_all[1]/np.max(Prob_par4_all[1])
	ix = np.argsort(PN)
	total_area = np.sum(PN)
	
	acc_area = 0
	prob = np.zeros(len(PN))
	for i in range(len(ix)):
		acc_area = acc_area + PN[ix[i]]
		if acc_area <= 0.05 * total_area:
			prob[ix[i]] = 0
			
		elif (0.05 * total_area <= acc_area <= 0.32 * total_area):
			prob[ix[i]] = 1
			
		elif (acc_area >= 0.32 * total_area):
			prob[ix[i]] = 2
						
	ax44.bar(p4[prob==0], PN[prob==0], width=np.abs(p4[0]-p4[1]), color=[1,1,1], hatch=hatch_pattern)          #
	ax44.bar(p4[prob==1], PN[prob==1], width=np.abs(p4[0]-p4[1]), color=limit_1D_color_95)    
	ax44.bar(p4[prob==2], PN[prob==2], width=np.abs(p4[0]-p4[1]), color=limit_1D_color_68)    
	ax44.plot(p4, PN, 'b', linewidth=3)
	
	xt = [p4[0], (1/4)*(p4[-1]-p4[0])+p4[0], (2/4)*(p4[-1]-p4[0])+p4[0], (3/4)*(p4[-1]-p4[0])+p4[0], p4[-1]]
	ax44.set_xticks(xt)
	ax44.set_yticks([])
	
	X10 = 0.1*(p4[imax]-p4[0])
	ax44.set_xlim(p4[0]-X10, p4[imax]+X10)
	ax44.set_ylim(0, max_1D)
	
	ax44.set_xticklabels(np.round(xt,2), rotation=45)
	ax44.set_yticklabels('')
	
	ax44.set_xlabel(r'$R_{\rm mfp}$ [Mpc]', fontsize=FS)
	
	


	ax_legend.set_xlim(0, 1)
	ax_legend.set_ylim(0, 1)
	lab1 = ax_legend.bar([-0.2, -0.1], [0, 0], width=1.5, color=limit_1D_color_68)
	lab2 = ax_legend.bar([-0.2, -0.1], [0, 0], width=1.5, color=limit_1D_color_95)
	lab3 = ax_legend.bar([-0.2, -0.1], [0, 0], width=1.5, color=[1,1,1], hatch=hatch_pattern)
	lab4, = ax_legend.plot([-0.2, -0.1], [0, 0], 'k',   linewidth=2)
	lab5, = ax_legend.plot([-0.2, -0.1], [0, 0], 'k--', linewidth=2)
	ax_legend.legend([lab1, lab2, lab3, lab4, lab5], ['68%', '95%', '>95%', '68%', '95%'], loc=10, fontsize=13)
	ax_legend.axis('off')




	cb_x0 = 0.5
	cb_y0 = 0.93
	cb_dx = 0.4
	cb_dy = 0.02
	min_prob = 0
	max_prob = 1
	
	cax1 = f1.add_axes([cb_x0, cb_y0, cb_dx, cb_dy])
	cbar = plt.colorbar(IMAGE_MAP, cax=cax1, orientation="horizontal", ticks=[0, 0.25, 0.5, 0.75, 1])#np.arange(min_prob, max_prob+0.005, 0.1))
	cbar.ax.set_xticklabels([0, 0.25, 0.50, 0.75, 1], rotation=45)
	cbar.ax.set_xlabel(r'normalized probability density', fontsize=12)
	cbar.ax.tick_params(labelsize=12)







	plt.savefig(path_plot_save + plot_file_name, bbox_inches='tight')
	plt.close()
	plt.close()



	return 0
























def fialkov_triangle_plot_V2_Npar5(case, plot_file_name, plot_save='no'):
	
	
	"""
	
	2018-04-08
	
	"""
	
	
	

	
	

	path_plot_save  = home_folder + '/DATA/EDGES_old/results/plots/20190128/'
	
	
	if case == 10:
		filename        = home_folder + '/DATA/EDGES_old/global_21cm_models/fialkov/Global21cmV5/results/Npar5_tau_0.055-0.090/results_Npar5_Npix20_90-190MHz.hdf5'
		fifth_parameter = 'Rmfp'
	if case == 11:
		filename        = home_folder + '/DATA/EDGES_old/global_21cm_models/fialkov/Global21cmV5/results/Npar5_tau_0.055-0.090/simulations/results_Npar5_Npix20_simulation_just_noise_FIRST_REPETITION.hdf5'
		fifth_parameter = 'Rmfp'		
	if case == 12:
		filename        = home_folder + '/DATA/EDGES_old/global_21cm_models/fialkov/Global21cmV5/results/Npar5_tau_0.055-0.090_simulations/results_Npar5_Npix20_simulation_just_noise_SECOND_REPETITION.hdf5'
		fifth_parameter = 'Rmfp'		
	if case == 13:
		filename        = home_folder + '/DATA/EDGES_old/global_21cm_models/fialkov/Global21cmV5/results/Npar5_tau_0.055-0.090_simulations/results_Npar5_Npix20_simulation_above_125MHz.hdf5'
		fifth_parameter = 'Rmfp'
	if case == 14:
		filename        = home_folder + '/DATA/EDGES_old/global_21cm_models/fialkov/Global21cmV5/results/Npar5_tau_0.055-0.090_simulations/results_Npar5_Npix20_simulation_above_145MHz.hdf5'
		fifth_parameter = 'Rmfp'

	# NOMINAL 2
	if case == 15:
		filename        = home_folder + '/DATA/EDGES_old/global_21cm_models/fialkov/Global21cmV6/results/results_Npar5_Npix20_Rmfp_xHI708_tau_0.055_0.090.hdf5'
		fifth_parameter = 'Rmfp'




	# if case == 20:
		# filename        = '/home/ramo7131/DATA/EDGES/global_21cm_models/fialkov/Global21cmV5/results/Npar5_vmin_instead_of_Rmfp/results_Npar5_Npix20_90-190MHz.hdf5'
		# fifth_parameter = 'vmin'

	if case == 20:
		filename        = home_folder + '/DATA/EDGES_old/global_21cm_models/fialkov/Global21cmV5/results/Npar5_vmin_instead_of_Rmfp_tau_0.055-0.090/results_Npar5_Npix20_90-190MHz.hdf5'
		fifth_parameter = 'vmin'
	
	# NOMINAL 1
	if case == 21:		
		filename        = home_folder + '/DATA/EDGES_old/global_21cm_models/fialkov/Global21cmV6/results/results_Npar5_Npix20_vmin_xHI708_tau_0.055_0.090.hdf5'
		fifth_parameter = 'vmin'

	if case == 22:		
		filename        = home_folder + '/DATA/EDGES_old/global_21cm_models/fialkov/Global21cmV6/results/results_Npar5_Npix20_vmin_xHI708_tau_0.055_0.090_Physical_model.hdf5'
		fifth_parameter = 'vmin'		


	p1, p2, p3, p4, p5, pix_all, Prob_all, Prob_limits_all, Prob_par1_all, Prob_par2_all, Prob_par3_all, Prob_par4_all, Prob_par5_all = fialkov_probabilities_hires_5par(filename, fifth_parameter=fifth_parameter)
	

	
	



	
	



	# Settings for Figures
	# ---------------------------
	size_x = 10
	size_y = 10

	dx     = 0.174
	dy     = 0.174	
	x0     = 0.08  #0.056
	y0     = 0.075  #0.059
	x00    = 0.007
	y00    = 0.007


	lp1 = np.log10(p1)
	lp2 = np.log10(p2)
	lp3 = np.log10(p3)



	min_prob = 0
	max_prob = 1#0.015
	max_1D   = 1.1

	imax = 79   # 80 pixels after interpolation from 20 pixels # 19
	
	color_map = 'inferno_r'  #'jet'  # '_r'
	
	FS=15
	INTERP = 'bilinear'

	limit_1D_color_95 = [0.75,0.75,0.75]
	limit_1D_color_68 = [0.5,0.5,0.5]
	hatch_pattern = '////'
	
	contour_level_95 = 0.5  # the 95% limit is between values 0 and 1
	contour_level_68 = 1.5  # the 68% limit is between values 1 and 2


	



	E12 = [lp1[0]-(lp1[1]-lp1[0])/2, lp1[imax]+(lp1[1]-lp1[0])/2, lp2[0]-(lp2[1]-lp2[0])/2, lp2[imax]+(lp2[1]-lp2[0])/2]
	E13 = [lp1[0]-(lp1[1]-lp1[0])/2, lp1[imax]+(lp1[1]-lp1[0])/2, lp3[0]-(lp3[1]-lp3[0])/2, lp3[imax]+(lp3[1]-lp3[0])/2]
	E14 = [lp1[0]-(lp1[1]-lp1[0])/2, lp1[imax]+(lp1[1]-lp1[0])/2, p4[0]-(p4[1]-p4[0])/2, p4[imax]+(p4[1]-p4[0])/2]
	E15 = [lp1[0]-(lp1[1]-lp1[0])/2, lp1[imax]+(lp1[1]-lp1[0])/2, p5[0]-(p5[1]-p5[0])/2, p5[imax]+(p5[1]-p5[0])/2]

	E23 = [lp2[0]-(lp2[1]-lp2[0])/2, lp2[imax]+(lp2[1]-lp2[0])/2, lp3[0]-(lp3[1]-lp3[0])/2, lp3[imax]+(lp3[1]-lp3[0])/2]
	E24 = [lp2[0]-(lp2[1]-lp2[0])/2, lp2[imax]+(lp2[1]-lp2[0])/2, p4[0]-(p4[1]-p4[0])/2, p4[imax]+(p4[1]-p4[0])/2]
	E25 = [lp2[0]-(lp2[1]-lp2[0])/2, lp2[imax]+(lp2[1]-lp2[0])/2, p5[0]-(p5[1]-p5[0])/2, p5[imax]+(p5[1]-p5[0])/2]

	E34 = [lp3[0]-(lp3[1]-lp3[0])/2, lp3[imax]+(lp3[1]-lp3[0])/2, p4[0]-(p4[1]-p4[0])/2, p4[imax]+(p4[1]-p4[0])/2]
	E35 = [lp3[0]-(lp3[1]-lp3[0])/2, lp3[imax]+(lp3[1]-lp3[0])/2, p5[0]-(p5[1]-p5[0])/2, p5[imax]+(p5[1]-p5[0])/2]
	
	E45 = [p4[0]-(p4[1]-p4[0])/2, p4[imax]+(p4[1]-p4[0])/2, p5[0]-(p5[1]-p5[0])/2, p5[imax]+(p5[1]-p5[0])/2]




	# Figure
	# ---------------------------------------------------

	plt.close()
	plt.close()
	plt.close()



	f1     = plt.figure(num=1, figsize=(size_x, size_y))

	ax15   = f1.add_axes([1*x0 + 0*(dx+x00), 1*y0 + 0*(dy+y00), dx, dy])
	ax14   = f1.add_axes([1*x0 + 0*(dx+x00), 1*y0 + 1*(dy+y00), dx, dy])
	ax13   = f1.add_axes([1*x0 + 0*(dx+x00), 1*y0 + 2*(dy+y00), dx, dy])
	ax12   = f1.add_axes([1*x0 + 0*(dx+x00), 1*y0 + 3*(dy+y00), dx, dy])
	ax11   = f1.add_axes([1*x0 + 0*(dx+x00), 1*y0 + 4*(dy+y00), dx, dy])

	ax25   = f1.add_axes([1*x0 + 1*(dx+x00), 1*y0 + 0*(dy+y00), dx, dy])
	ax24   = f1.add_axes([1*x0 + 1*(dx+x00), 1*y0 + 1*(dy+y00), dx, dy])
	ax23   = f1.add_axes([1*x0 + 1*(dx+x00), 1*y0 + 2*(dy+y00), dx, dy])
	ax22   = f1.add_axes([1*x0 + 1*(dx+x00), 1*y0 + 3*(dy+y00), dx, dy])

	ax35   = f1.add_axes([1*x0 + 2*(dx+x00), 1*y0 + 0*(dy+y00), dx, dy])
	ax34   = f1.add_axes([1*x0 + 2*(dx+x00), 1*y0 + 1*(dy+y00), dx, dy])
	ax33   = f1.add_axes([1*x0 + 2*(dx+x00), 1*y0 + 2*(dy+y00), dx, dy])
	
	ax45   = f1.add_axes([1*x0 + 3*(dx+x00), 1*y0 + 0*(dy+y00), dx, dy])
	ax44   = f1.add_axes([1*x0 + 3*(dx+x00), 1*y0 + 1*(dy+y00), dx, dy])
	
	ax55   = f1.add_axes([1*x0 + 4*(dx+x00), 1*y0 + 0*(dy+y00), dx, dy])
		
	ax_legend  = f1.add_axes([1*x0 + 2*(dx+x00), 1*y0 + 3*(dy+y00), 2*dx, dy])



















	f1 = plt.figure(1)

		
	
	# Column 1
	PN = Prob_par1_all[1]/np.max(Prob_par1_all[1])
	ix = np.argsort(PN)
	total_area = np.sum(PN)
	
	acc_area = 0
	prob = np.zeros(len(PN))
	for i in range(len(ix)):
		acc_area = acc_area + PN[ix[i]]
		if acc_area <= 0.05 * total_area:
			prob[ix[i]] = 0
			
		elif (0.05 * total_area <= acc_area <= 0.32 * total_area):
			prob[ix[i]] = 1
			
		elif (acc_area >= 0.32 * total_area):
			prob[ix[i]] = 2
						
	ax11.bar(lp1[prob==0], PN[prob==0], width=np.abs(lp1[0]-lp1[1]), color=[1,1,1], hatch=hatch_pattern)        #
	ax11.bar(lp1[prob==1], PN[prob==1], width=np.abs(lp1[0]-lp1[1]), color=limit_1D_color_95)  #
	ax11.bar(lp1[prob==2], PN[prob==2], width=np.abs(lp1[0]-lp1[1]), color=limit_1D_color_68)
	ax11.plot(lp1, PN, 'b', linewidth=3)
	
	# Printing limits of parameter 1
	print(' ')
	print(' ')
	print(' Parameter 1 ')
	print('-----------------------')
	for i in range(len(lp1)):
		if i == 0:
			print(np.round(10**lp1[i],3))
		
		elif (i > 0) and (i < (len(lp1)-1)) and (prob[i] != prob[i+1]):
			limit = lp1[i] + (lp1[i+1] - lp1[i])/2
			print(np.round(10**limit,3))
			
		if i == (len(lp1)-1):
			print(np.round(10**lp1[i],3))
			
			
	
	
	
	#xt = [lp1[0], (1/4)*(lp1[-1]-lp1[0])+lp1[0], (2/4)*(lp1[-1]-lp1[0])+lp1[0], (3/4)*(lp1[-1]-lp1[0])+lp1[0], lp1[-1]]
	xt = [lp1[0], (1/3)*(lp1[-1]-lp1[0])+lp1[0], (2/3)*(lp1[-1]-lp1[0])+lp1[0], lp1[-1]]
	ax11.set_xticks(xt)
	ax11.set_yticks([])
	
	X10 = 0.1*(lp1[imax]-lp1[0])
	ax11.set_xlim(lp1[0]-X10, lp1[imax]+X10)
	ax11.set_ylim(0, max_1D)
	
	ax11.set_xticklabels('')
	ax11.set_yticklabels('')
	#ax11.set_title(r'$\log_{10}$($f_{\bigstar}$)', fontsize=FS)
	ax11.set_title(r'$V_{\rm c}$ [km $\rm s^{-1}$]', fontsize=FS)  # [km/s]





	ax12.imshow(np.flipud(Prob_all[0]/np.nanmax(Prob_all[0])), interpolation=INTERP, aspect=(lp1[4]-lp1[0])/(lp2[4]-lp2[0]), extent=E12, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax12.contour(lp1, lp2, Prob_limits_all[0], colors=['k', 'k'], levels=[contour_level_95, contour_level_68], linestyles=['--', '-'], linewidths=[2,2])
	
	#xt = [lp1[0], lp1[4], lp1[9], lp1[14], lp1[19]]
	#xt = [lp1[0], (1/4)*(lp1[-1]-lp1[0])+lp1[0], (2/4)*(lp1[-1]-lp1[0])+lp1[0], (3/4)*(lp1[-1]-lp1[0])+lp1[0], lp1[-1]]
	#yt = [lp2[0], (1/4)*(lp2[-1]-lp2[0])+lp2[0], (2/4)*(lp2[-1]-lp2[0])+lp2[0], (3/4)*(lp2[-1]-lp2[0])+lp2[0], lp2[-1]]
	yt = [lp2[0], (1/3)*(lp2[-1]-lp2[0])+lp2[0], (2/3)*(lp2[-1]-lp2[0])+lp2[0], lp2[-1]]
	
	ax12.set_xticks(xt)
	ax12.set_yticks(yt)
	
	ax12.set_xticklabels('')
	ax12.set_yticklabels(np.round(10**np.array(yt),3), rotation=45)
	
	X10 = 0.1*(lp1[imax]-lp1[0])
	Y10 = 0.1*(lp2[imax]-lp2[0])
	ax12.set_xlim(lp1[0]-X10, lp1[imax]+X10)
	ax12.set_ylim(lp2[0]-Y10, lp2[imax]+Y10)
	
	ax12.set_ylabel(r'$f_{\rm *}$', fontsize=FS)





	ax13.imshow(np.flipud(Prob_all[1]/np.max(Prob_all[1])), interpolation=INTERP, aspect=(lp1[4]-lp1[0])/(lp3[4]-lp3[0]), extent=E13, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax13.contour(lp1, lp3, Prob_limits_all[1], colors=['k', 'k'], levels=[contour_level_95, contour_level_68], linestyles=['--', '-'], linewidths=[2,2])
	#xt = [lp1[0], lp1[4], lp1[9], lp1[14], lp1[19]]
	#xt = [lp1[0], (1/4)*(lp1[-1]-lp1[0])+lp1[0], (2/4)*(lp1[-1]-lp1[0])+lp1[0], (3/4)*(lp1[-1]-lp1[0])+lp1[0], lp1[-1]]
	#yt = [lp3[0], (1/4)*(lp3[-1]-lp3[0])+lp3[0], (2/4)*(lp3[-1]-lp3[0])+lp3[0], (3/4)*(lp3[-1]-lp3[0])+lp3[0], lp3[-1]]
	yt = [lp3[0], (1/3)*(lp3[-1]-lp3[0])+lp3[0], (2/3)*(lp3[-1]-lp3[0])+lp3[0], lp3[-1]]
	
	ax13.set_xticks(xt)
	ax13.set_yticks(yt)
	
	ax13.set_xticklabels('')	
	ax13.set_yticklabels(np.round(10**np.array(yt),5), rotation=45)

	X10 = 0.1*(lp1[imax]-lp1[0])
	Y10 = 0.1*(lp3[imax]-lp3[0])	
	ax13.set_xlim(lp1[0]-X10, lp1[imax]+X10)
	ax13.set_ylim(lp3[0]-Y10, lp3[imax]+Y10)
	
	ax13.set_ylabel(r'$f_{\rm X}$', fontsize=FS)
	
	
	

	ax14.imshow(np.flipud(Prob_all[2]/np.max(Prob_all[2])), interpolation=INTERP, aspect=(lp1[4]-lp1[0])/(p4[4]-p4[0]), extent=E14, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax14.contour(lp1, p4, Prob_limits_all[2], colors=['k', 'k'], levels=[contour_level_95, contour_level_68], linestyles=['--', '-'], linewidths=[2,2])
	#xt = [lp1[0], lp1[4], lp1[9], lp1[14], lp1[19]]
	#xt = [lp1[0], (1/4)*(lp1[-1]-lp1[0])+lp1[0], (2/4)*(lp1[-1]-lp1[0])+lp1[0], (3/4)*(lp1[-1]-lp1[0])+lp1[0], lp1[-1]]
	#yt = [p4[0], (1/4)*(p4[-1]-p4[0])+p4[0], (2/4)*(p4[-1]-p4[0])+p4[0], (3/4)*(p4[-1]-p4[0])+p4[0], p4[-1]]
	yt = [p4[0], (1/3)*(p4[-1]-p4[0])+p4[0], (2/3)*(p4[-1]-p4[0])+p4[0], p4[-1]]
	
	ax14.set_xticks(xt)
	ax14.set_yticks(yt)
	
	#ax14.set_xticklabels(np.round(xt,2), rotation=45)
	ax14.set_xticklabels('')
	
	X10 = 0.1*(lp1[imax]-lp1[0])
	Y10 = 0.1*(p4[imax]-p4[0])
	ax14.set_xlim(lp1[0]-X10, lp1[imax]+X10)
	ax14.set_ylim(p4[0]-Y10, p4[imax]+Y10)	        ###################################################
	
	#ax14.set_xlabel(r'$\log_{10}$($f_{\bigstar}$)', fontsize=FS)
	
	if case < 20:
		ax14.set_ylabel(r'$\tau_{\rm e}$', fontsize=FS)
		ax14.set_yticklabels(np.round(yt,3), rotation=45)
		
	elif case >= 20:
		ax14.set_ylabel(r'$\nu_{\rm min}$ [keV]', fontsize=FS)
		ax14.set_yticklabels(np.round(yt,2), rotation=45)



	
	
	



	ax15.imshow(np.flipud(Prob_all[3]/np.max(Prob_all[3])), interpolation=INTERP, aspect=(lp1[4]-lp1[0])/(p5[4]-p5[0]), extent=E15, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax15.contour(lp1, p5, Prob_limits_all[3], colors=['k', 'k'], levels=[contour_level_95, contour_level_68], linestyles=['--', '-'], linewidths=[2,2])
	#xt = [lp1[0], lp1[4], lp1[9], lp1[14], lp1[19]]
	#xt = [lp1[0], (1/4)*(lp1[-1]-lp1[0])+lp1[0], (2/4)*(lp1[-1]-lp1[0])+lp1[0], (3/4)*(lp1[-1]-lp1[0])+lp1[0], lp1[-1]]
	#yt = [p5[0], (1/4)*(p5[-1]-p5[0])+p5[0], (2/4)*(p5[-1]-p5[0])+p5[0], (3/4)*(p5[-1]-p5[0])+p5[0], p5[-1]]
	yt = [p5[0], (1/3)*(p5[-1]-p5[0])+p5[0], (2/3)*(p5[-1]-p5[0])+p5[0], p5[-1]]
	
	ax15.set_xticks(xt)
	ax15.set_yticks(yt)
	
	ax15.set_xticklabels(np.round(10**np.array(xt),1), rotation=45)
	
	X10 = 0.1*(lp1[imax]-lp1[0])
	Y10 = 0.1*(p5[imax]-p5[0])
	ax15.set_xlim(lp1[0]-X10, lp1[imax]+X10)
	ax15.set_ylim(p5[0]-Y10, p5[imax]+Y10)	
	
	#ax15.set_xlabel(r'$\log_{10}$($f_{\bigstar}$)', fontsize=FS)
	ax15.set_xlabel(r'$V_{\rm c}$ [km $\rm s^{-1}$]', fontsize=FS)
	
	if case < 20:
		ax15.set_ylabel(r'$R_{\rm mfp}$ [Mpc]', fontsize=FS)
		ax15.set_yticklabels(np.round(yt,1), rotation=45)
		
	elif case >= 20:
		ax15.set_ylabel(r'$\tau_{\rm e}$', fontsize=FS)
		ax15.set_yticklabels(np.round(yt,3), rotation=45)













	# Column 2
	PN = Prob_par2_all[1]/np.max(Prob_par2_all[1])
	ix = np.argsort(PN)
	total_area = np.sum(PN)
	
	acc_area = 0
	prob = np.zeros(len(PN))
	for i in range(len(ix)):
		acc_area = acc_area + PN[ix[i]]
		if acc_area <= 0.05 * total_area:
			prob[ix[i]] = 0
			
		elif (0.05 * total_area <= acc_area <= 0.32 * total_area):
			prob[ix[i]] = 1
			
		elif (acc_area >= 0.32 * total_area):
			prob[ix[i]] = 2
						
	ax22.bar(lp2[prob==0], PN[prob==0], width=np.abs(lp2[0]-lp2[1]), color=[1,1,1], hatch=hatch_pattern)         #
	ax22.bar(lp2[prob==1], PN[prob==1], width=np.abs(lp2[0]-lp2[1]), color=limit_1D_color_95)   #
	ax22.bar(lp2[prob==2], PN[prob==2], width=np.abs(lp2[0]-lp2[1]), color=limit_1D_color_68)
	ax22.plot(lp2, PN, 'b', linewidth=3)
	
	# Printing limits of parameter 2
	print(' ')
	print(' ')
	print(' Parameter 2 ')
	print('-----------------------')
	for i in range(len(lp2)):
		if i == 0:
			print(np.round(10**lp2[i],1))
		
		elif (i > 0) and (i < (len(lp2)-1)) and (prob[i] != prob[i+1]):
			limit = lp2[i] + (lp2[i+1] - lp2[i])/2
			print(np.round(10**limit,1))
			
		if i == (len(lp2)-1):
			print(np.round(10**lp2[i],1))
			
			
			
			
			
			
	
	#xt = [lp2[0], (1/4)*(lp2[-1]-lp2[0])+lp2[0], (2/4)*(lp2[-1]-lp2[0])+lp2[0], (3/4)*(lp2[-1]-lp2[0])+lp2[0], lp2[-1]]
	xt = [lp2[0], (1/3)*(lp2[-1]-lp2[0])+lp2[0], (2/3)*(lp2[-1]-lp2[0])+lp2[0], lp2[-1]]
	ax22.set_xticks(xt)
	ax22.set_yticks([])
	
	X10 = 0.1*(lp2[imax]-lp2[0])
	ax22.set_xlim(lp2[0]-X10, lp2[imax]+X10)
	ax22.set_ylim(0, max_1D)
	
	ax22.set_xticklabels('')
	ax22.set_yticklabels('')
	
	ax22.set_title(r'$f_{\rm *}$', fontsize=FS)
	
	

	ax23.imshow(np.flipud(Prob_all[4]/np.max(Prob_all[4])), interpolation=INTERP, aspect=(lp2[4]-lp2[0])/(lp3[4]-lp3[0]), extent=E23, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax23.contour(lp2, lp3, Prob_limits_all[4], colors=['k', 'k'], levels=[contour_level_95, contour_level_68], linestyles=['--', '-'], linewidths=[2,2])
	
	#xt = [lp2[0], (1/4)*(lp2[-1]-lp2[0])+lp2[0], (2/4)*(lp2[-1]-lp2[0])+lp2[0], (3/4)*(lp2[-1]-lp2[0])+lp2[0], lp2[-1]]
	#yt = [lp3[0], (1/4)*(lp3[-1]-lp3[0])+lp3[0], (2/4)*(lp3[-1]-lp3[0])+lp3[0], (3/4)*(lp3[-1]-lp3[0])+lp3[0], lp3[-1]]
	yt = [lp3[0], (1/3)*(lp3[-1]-lp3[0])+lp3[0], (2/3)*(lp3[-1]-lp3[0])+lp3[0], lp3[-1]]

	ax23.set_xticks(xt)
	ax23.set_yticks(yt)
	
	ax23.set_xticklabels('')	
	ax23.set_yticklabels('') #np.round(yt,2), rotation=45)	

	X10 = 0.1*(lp2[imax]-lp2[0])
	Y10 = 0.1*(lp3[imax]-lp3[0])
	ax23.set_xlim(lp2[0]-X10, lp2[imax]+X10)
	ax23.set_ylim(lp3[0]-Y10, lp3[imax]+Y10)	

	ax23.set_xlabel('')
	ax23.set_ylabel('')
	


	

	ax24.imshow(np.flipud(Prob_all[5]/np.max(Prob_all[5])), interpolation=INTERP, aspect=(lp2[4]-lp2[0])/(p4[4]-p4[0]), extent=E24, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax24.contour(lp2, p4, Prob_limits_all[5], colors=['k', 'k'], levels=[contour_level_95, contour_level_68], linestyles=['--', '-'], linewidths=[2,2])
	
	#xt = [lp2[0], (1/4)*(lp2[-1]-lp2[0])+lp2[0], (2/4)*(lp2[-1]-lp2[0])+lp2[0], (3/4)*(lp2[-1]-lp2[0])+lp2[0], lp2[-1]]
	#yt = [p4[0], (1/4)*(p4[-1]-p4[0])+p4[0], (2/4)*(p4[-1]-p4[0])+p4[0], (3/4)*(p4[-1]-p4[0])+p4[0], p4[-1]]
	yt = [p4[0], (1/3)*(p4[-1]-p4[0])+p4[0], (2/3)*(p4[-1]-p4[0])+p4[0], p4[-1]]

	ax24.set_xticks(xt)
	ax24.set_yticks(yt)
	
	ax24.set_xticklabels('') #np.round(xt,2), rotation=45)
	ax24.set_yticklabels('') #np.round(yt,2), rotation=45)	

	X10 = 0.1*(lp2[imax]-lp2[0])
	Y10 = 0.1*(p4[imax] -p4[0])
	ax24.set_xlim(lp2[0]-X10, lp2[imax]+X10)
	ax24.set_ylim(p4[0]-Y10,  p4[imax]+Y10)	        ################################################### 	

	ax24.set_xlabel('') #r'$\log_{10}(\rm V_c)$ [km/s]', fontsize=FS)
	ax24.set_ylabel('')
	
	
	
	
	
	ax25.imshow(np.flipud(Prob_all[6]/np.max(Prob_all[6])), interpolation=INTERP, aspect=(lp2[4]-lp2[0])/(p5[4]-p5[0]), extent=E25, cmap=color_map, vmin=min_prob, vmax=max_prob)
	ax25.contour(lp2, p5, Prob_limits_all[6], colors=['k', 'k'], levels=[contour_level_95, contour_level_68], linestyles=['--', '-'], linewidths=[2,2])
	
	#xt = [lp2[0], (1/4)*(lp2[-1]-lp2[0])+lp2[0], (2/4)*(lp2[-1]-lp2[0])+lp2[0], (3/4)*(lp2[-1]-lp2[0])+lp2[0], lp2[-1]]
	#yt = [p5[0], (1/4)*(p5[-1]-p4[0])+p5[0], (2/4)*(p5[-1]-p5[0])+p5[0], (3/4)*(p5[-1]-p5[0])+p5[0], p5[-1]]
	yt = [p5[0], (1/3)*(p5[-1]-p5[0])+p5[0], (2/3)*(p5[-1]-p5[0])+p5[0], p5[-1]]

	ax25.set_xticks(xt)
	ax25.set_yticks(yt)
	
	ax25.set_xticklabels(np.round(10**np.array(xt),3), rotation=45)
	ax25.set_yticklabels('') #np.round(yt,2), rotation=45)	

	X10 = 0.1*(lp2[imax]-lp2[0])
	Y10 = 0.1*(p5[imax] -p5[0])
	ax25.set_xlim(lp2[0]-X10, lp2[imax]+X10)
	ax25.set_ylim(p5[0]-Y10,  p5[imax]+Y10)	

	ax25.set_xlabel(r'$f_{\rm *}$', fontsize=FS)
	ax25.set_ylabel('')
	
	
	
	
	
	
	
	
	
	
		
	




	# Column 3
	PN = Prob_par3_all[1]/np.max(Prob_par3_all[1])
	ix = np.argsort(PN)
	total_area = np.sum(PN)
	
	acc_area = 0
	prob = np.zeros(len(PN))
	for i in range(len(ix)):
		acc_area = acc_area + PN[ix[i]]
		if acc_area <= 0.05 * total_area:
			prob[ix[i]] = 0
			
		elif (0.05 * total_area <= acc_area <= 0.32 * total_area):
			prob[ix[i]] = 1
			
		elif (acc_area >= 0.32 * total_area):
			prob[ix[i]] = 2
						
	ax33.bar(lp3[prob==0], PN[prob==0], width=np.abs(lp3[0]-lp3[1]), color=[1,1,1], hatch=hatch_pattern)         #
	ax33.bar(lp3[prob==1], PN[prob==1], width=np.abs(lp3[0]-lp3[1]), color=limit_1D_color_95)   #
	ax33.bar(lp3[prob==2], PN[prob==2], width=np.abs(lp3[0]-lp3[1]), color=limit_1D_color_68)
	ax33.plot(lp3, PN, 'b', linewidth=3)

	# Printing limits of parameter 3
	print(' ')
	print(' ')
	print(' Parameter 3 ')
	print('-----------------------')
	for i in range(len(lp3)):
		if i == 0:
			print(np.round(10**lp3[i],5))
		
		elif (i > 0) and (i < (len(lp3)-1)) and (prob[i] != prob[i+1]):
			limit = lp3[i] + (lp3[i+1] - lp3[i])/2
			print(np.round(10**limit,5))
			
		if i == (len(lp3)-1):
			print(np.round(10**lp3[i],5))





	
	#xt = [lp3[0], (1/4)*(lp3[-1]-lp3[0])+lp3[0], (2/4)*(lp3[-1]-lp3[0])+lp3[0], (3/4)*(lp3[-1]-lp3[0])+lp3[0], lp3[-1]]
	xt = [lp3[0], (1/3)*(lp3[-1]-lp3[0])+lp3[0], (2/3)*(lp3[-1]-lp3[0])+lp3[0], lp3[-1]]
	ax33.set_xticks(xt)
	ax33.set_yticks([])
	
	X10 = 0.1*(lp3[imax]-lp3[0])
	ax33.set_xlim(lp3[0]-X10, lp3[imax]+X10)
	ax33.set_ylim(0, max_1D)
	
	ax33.set_xticklabels('')
	ax33.set_yticklabels('')
	
	ax33.set_title(r'$f_{\rm X}$', fontsize=FS)
	
	
	

	IMAGE_MAP = ax34.imshow(np.flipud(Prob_all[7]/np.max(Prob_all[7])), interpolation=INTERP, aspect=(lp3[4]-lp3[0])/(p4[4]-p4[0]), extent=E34, cmap=color_map, vmin=min_prob, vmax=max_prob)  #
	ax34.contour(lp3, p4, Prob_limits_all[7], colors=['k', 'k'], levels=[contour_level_95, contour_level_68], linestyles=['--', '-'], linewidths=[2,2])
	
	#xt = [lp3[0], (1/4)*(lp3[-1]-lp3[0])+lp3[0], (2/4)*(lp3[-1]-lp3[0])+lp3[0], (3/4)*(lp3[-1]-lp3[0])+lp3[0], lp3[-1]]
	#yt = [p4[0], (1/4)*(p4[-1]-p4[0])+p4[0], (2/4)*(p4[-1]-p4[0])+p4[0], (3/4)*(p4[-1]-p4[0])+p4[0], p4[-1]]
	yt = [p4[0], (1/3)*(p4[-1]-p4[0])+p4[0], (2/3)*(p4[-1]-p4[0])+p4[0], p4[-1]]

	ax34.set_xticks(xt)
	ax34.set_yticks(yt)
	
	ax34.set_xticklabels('') #np.round(xt,2), rotation=45)
	ax34.set_yticklabels('') #np.round(yt,2), rotation=45)	

	X10 = 0.1*(lp3[imax]-lp3[0])
	Y10 = 0.1*(p4[imax] -p4[0])
	ax34.set_xlim(lp3[0]-X10, lp3[imax]+X10)
	ax34.set_ylim(p4[0]-Y10, p4[imax]+Y10)	        ###################################################	

	ax34.set_xlabel('') #r'$\log_{10}(f_X)$', fontsize=FS)
	ax34.set_ylabel('')
	
	
	

	ax35.imshow(np.flipud(Prob_all[8]/np.max(Prob_all[8])), interpolation=INTERP, aspect=(lp3[4]-lp3[0])/(p5[4]-p5[0]), extent=E35, cmap=color_map, vmin=min_prob, vmax=max_prob)  #
	ax35.contour(lp3, p5, Prob_limits_all[8], colors=['k', 'k'], levels=[contour_level_95, contour_level_68], linestyles=['--', '-'], linewidths=[2,2])
	
	#xt = [lp3[0], (1/4)*(lp3[-1]-lp3[0])+lp3[0], (2/4)*(lp3[-1]-lp3[0])+lp3[0], (3/4)*(lp3[-1]-lp3[0])+lp3[0], lp3[-1]]
	#yt = [p5[0], (1/4)*(p5[-1]-p5[0])+p5[0], (2/4)*(p5[-1]-p5[0])+p5[0], (3/4)*(p5[-1]-p5[0])+p5[0], p5[-1]]
	yt = [p5[0], (1/3)*(p5[-1]-p5[0])+p5[0], (2/3)*(p5[-1]-p5[0])+p5[0], p5[-1]]

	ax35.set_xticks(xt)
	ax35.set_yticks(yt)
	
	ax35.set_xticklabels(np.round(10**np.array(xt),5), rotation=45)
	ax35.set_yticklabels('') #np.round(yt,2), rotation=45)	

	X10 = 0.1*(lp3[imax]-lp3[0])
	Y10 = 0.1*(p5[imax] -p5[0])
	ax35.set_xlim(lp3[0]-X10, lp3[imax]+X10)
	ax35.set_ylim(p5[0]-Y10,  p5[imax]+Y10)	

	ax35.set_xlabel(r'$f_{\rm X}$', fontsize=FS)
	ax35.set_ylabel('')
	














	# Column 4
	PN = Prob_par4_all[1]/np.max(Prob_par4_all[1])
	ix = np.argsort(PN)
	total_area = np.sum(PN)
	
	acc_area = 0
	prob = np.zeros(len(PN))
	for i in range(len(ix)):
		acc_area = acc_area + PN[ix[i]]
		if acc_area <= 0.05 * total_area:
			prob[ix[i]] = 0
			
		elif (0.05 * total_area <= acc_area <= 0.32 * total_area):
			prob[ix[i]] = 1
			
		elif (acc_area >= 0.32 * total_area):
			prob[ix[i]] = 2
						
	ax44.bar(p4[prob==0], PN[prob==0], width=np.abs(p4[0]-p4[1]), color=[1,1,1], hatch=hatch_pattern)          #
	ax44.bar(p4[prob==1], PN[prob==1], width=np.abs(p4[0]-p4[1]), color=limit_1D_color_95)    
	ax44.bar(p4[prob==2], PN[prob==2], width=np.abs(p4[0]-p4[1]), color=limit_1D_color_68)    
	ax44.plot(p4, PN, 'b', linewidth=3)


	# Printing limits of parameter 4
	print(' ')
	print(' ')
	print(' Parameter 4 ')
	print('-----------------------')
	for i in range(len(p4)):
		if i == 0:
			print(np.round(p4[i],3))
		
		elif (i > 0) and (i < (len(p4)-1)) and (prob[i] != prob[i+1]):
			limit = p4[i] + (p4[i+1] - p4[i])/2
			print(np.round(limit,3))
			
		if i == (len(p4)-1):
			print(np.round(p4[i],3))
			
			
			
			
			



	
	#xt = [p4[0], (1/4)*(p4[-1]-p4[0])+p4[0], (2/4)*(p4[-1]-p4[0])+p4[0], (3/4)*(p4[-1]-p4[0])+p4[0], p4[-1]]
	xt = [p4[0], (1/3)*(p4[-1]-p4[0])+p4[0], (2/3)*(p4[-1]-p4[0])+p4[0], p4[-1]]
	ax44.set_xticks(xt)
	ax44.set_yticks([])
	
	X10 = 0.1*(p4[imax]-p4[0])
	ax44.set_xlim(p4[0]-X10, p4[imax]+X10)
	ax44.set_ylim(0, max_1D)
	
	ax44.set_xticklabels('') #np.round(xt,2), rotation=45)
	ax44.set_yticklabels('')
	
	if case < 20:
		ax44.set_title(r'$\tau_{\rm e}$', fontsize=FS)
		
	elif case >= 20:
		ax44.set_title(r'$\nu_{\rm min}$ [keV]', fontsize=FS)		









	ax45.imshow(np.flipud(Prob_all[9]/np.max(Prob_all[9])), interpolation=INTERP, aspect=(p4[4]-p4[0])/(p5[4]-p5[0]), extent=E45, cmap=color_map, vmin=min_prob, vmax=max_prob)  #
	ax45.contour(p4, p5, Prob_limits_all[9], colors=['k', 'k'], levels=[contour_level_95, contour_level_68], linestyles=['--', '-'], linewidths=[2,2])
	
	#xt = [p4[0], (1/4)*(p4[-1]-p4[0])+p4[0], (2/4)*(p4[-1]-p4[0])+p4[0], (3/4)*(p4[-1]-p4[0])+p4[0], p4[-1]]
	#yt = [p5[0], (1/4)*(p5[-1]-p5[0])+p5[0], (2/4)*(p5[-1]-p5[0])+p5[0], (3/4)*(p5[-1]-p5[0])+p5[0], p5[-1]]
	yt = [p5[0], (1/3)*(p5[-1]-p5[0])+p5[0], (2/3)*(p5[-1]-p5[0])+p5[0], p5[-1]]

	ax45.set_xticks(xt)
	ax45.set_yticks(yt)
	
	ax45.set_yticklabels('') #np.round(yt,2), rotation=45)	

	X10 = 0.1*(p4[imax] -p4[0])
	Y10 = 0.1*(p5[imax] -p5[0])
	ax45.set_xlim(p4[0]-X10, p4[imax]+X10)
	ax45.set_ylim(p5[0]-Y10, p5[imax]+Y10)	

	ax45.set_ylabel('')
	
	if case < 20:
		ax45.set_xlabel(r'$\tau_{\rm e}$', fontsize=FS)
		ax45.set_xticklabels(np.round(xt,3), rotation=45)
		
	elif case >= 20:
		ax45.set_xlabel(r'$\nu_{\rm min}$ [keV]', fontsize=FS)
		ax45.set_xticklabels(np.round(xt,2), rotation=45)






	# Column 5
	PN = Prob_par5_all[1]/np.max(Prob_par5_all[1])
	ix = np.argsort(PN)
	total_area = np.sum(PN)
	
	acc_area = 0
	prob = np.zeros(len(PN))
	for i in range(len(ix)):
		acc_area = acc_area + PN[ix[i]]
		if acc_area <= 0.05 * total_area:
			prob[ix[i]] = 0
			
		elif (0.05 * total_area <= acc_area <= 0.32 * total_area):
			prob[ix[i]] = 1
			
		elif (acc_area >= 0.32 * total_area):
			prob[ix[i]] = 2
						
	ax55.bar(p5[prob==0], PN[prob==0], width=np.abs(p5[0]-p5[1]), color=[1,1,1], hatch=hatch_pattern)          #
	ax55.bar(p5[prob==1], PN[prob==1], width=np.abs(p5[0]-p5[1]), color=limit_1D_color_95)    
	ax55.bar(p5[prob==2], PN[prob==2], width=np.abs(p5[0]-p5[1]), color=limit_1D_color_68)    
	ax55.plot(p5, PN, 'b', linewidth=3)
	
	
	# Printing limits of parameter 5
	print(' ')
	print(' ')
	print(' Parameter 5 ')
	print('-----------------------')
	for i in range(len(p5)):
		if i == 0:
			print(np.round(p5[i],2))
		
		elif (i > 0) and (i < (len(p5)-1)) and (prob[i] != prob[i+1]):
			limit = p5[i] + (p5[i+1] - p5[i])/2
			print(np.round(limit,2))
			
		if i == (len(p5)-1):
			print(np.round(p5[i],2))
			
			
			
	
			
	
	#xt = [p5[0], (1/4)*(p5[-1]-p5[0])+p5[0], (2/4)*(p5[-1]-p5[0])+p5[0], (3/4)*(p5[-1]-p5[0])+p5[0], p5[-1]]
	xt = [p5[0], (1/3)*(p5[-1]-p5[0])+p5[0], (2/3)*(p5[-1]-p5[0])+p5[0], p5[-1]]
	ax55.set_xticks(xt)
	ax55.set_yticks([])
	
	X10 = 0.1*(p5[imax]-p5[0])
	ax55.set_xlim(p5[0]-X10, p5[imax]+X10)
	ax55.set_ylim(0, max_1D)

	ax55.set_yticklabels('')
	
	if case < 20:
		ax55.set_xlabel(r'$R_{\rm mfp}$ [Mpc]', fontsize=FS)
		ax55.set_title(r'$R_{\rm mfp}$ [Mpc]', fontsize=FS)
		ax55.set_xticklabels(np.round(xt,1), rotation=45)
		
	elif case >= 20:
		ax55.set_xlabel(r'$\tau_{\rm e}$', fontsize=FS)
		ax55.set_title(r'$\tau_{\rm e}$', fontsize=FS)
		ax55.set_xticklabels(np.round(xt,3), rotation=45)
	
	
	
	
	


	# Legend 
	# ------------------------
	ax_legend.set_xlim(0, 1)
	ax_legend.set_ylim(0, 1)
	lab1  = ax_legend.bar([-0.2, -0.1], [0, 0], width=1.5, color=limit_1D_color_68)
	lab2  = ax_legend.bar([-0.2, -0.1], [0, 0], width=1.5, color=limit_1D_color_95)
	lab3  = ax_legend.bar([-0.2, -0.1], [0, 0], width=1.5, color=[1,1,1], hatch=hatch_pattern)
	lab4, = ax_legend.plot([-0.2, -0.1], [0, 0], 'k',   linewidth=2)
	lab5, = ax_legend.plot([-0.2, -0.1], [0, 0], 'k--', linewidth=2)
	ax_legend.legend([lab1, lab2, lab3, lab4, lab5], ['68%', '95%', '>95%', '68%', '95%'], loc=1, fontsize=13)
	ax_legend.axis('off')





	# Colorbar
	# ------------------------
	cb_x0 = 0.5
	cb_y0 = 0.93
	cb_dx = 0.25
	cb_dy = 0.02
	min_prob = 0
	max_prob = 1
	
	cax1 = f1.add_axes([cb_x0, cb_y0, cb_dx, cb_dy])
	cbar = plt.colorbar(IMAGE_MAP, cax=cax1, orientation="horizontal", ticks=[0, 0.25, 0.5, 0.75, 1])#np.arange(min_prob, max_prob+0.005, 0.1))
	cbar.ax.set_xticklabels([0, 0.25, 0.50, 0.75, 1], rotation=45)
	cbar.ax.set_xlabel(r'normalized probability density', fontsize=12)
	cbar.ax.tick_params(labelsize=12)






	if plot_save == 'yes':
		plt.savefig(path_plot_save + plot_file_name, bbox_inches='tight')
		plt.close()
		plt.close()



	return 0
















































































def fialkov_paper_signal_figure_one(save='no'):



	# Frequency vector
	z_raw = np.arange(5,50.05,0.1)
	freq  = redshift2frequency(z_raw)


	file_name     = home_folder + '/DATA/EDGES_old/global_21cm_models/fialkov/Global21cmV5/signals_for_figure/signals_for_figure.mat'
	mat           = sio.loadmat(file_name)
	model_nominal = mat['sn'][0]  # in mK
	model_p1      = mat['s1']     # in mK
	model_p2      = mat['s2']     # in mK
	model_p3      = mat['s3']     # in mK
	model_p4      = mat['s4']     # in mK
	model_p6      = mat['s6']     # in mK
	model_p7      = mat['s7']     # in mK


	par_nominal   = mat['set_nominal']   
	par1          = mat['set_p1']
	par2          = mat['set_p2']
	par3          = mat['set_p3']
	par4          = mat['set_p4']
	par6          = mat['set_p6']
	par7          = mat['set_p7']
	
	
	print('Nominal parameters: ')
	print(par_nominal)




	


	
	sx = 6
	sy = 6.5
	
	x0 = 0.13
	y0 = 0.08
	
	dx = 0.395
	dy = 0.25
	
	FS_labels = 13
	
	

	plt.close()
	plt.close()
	plt.close()
	plt.close()
	fig  = plt.figure(num=1, figsize=(sx, sy))
	cc = 'r'

	

	
	
	
	ax   = fig.add_axes([x0, 1.4*1.7*y0+2*dy, dx, dy])	
	ax.plot(freq, model_nominal, color=cc)
	for i in range(20):
		ax.plot(freq, model_p2[i,:], color=[(i/25), (i/25), (i/25)])
	ax.plot(freq, model_nominal, color=cc)
	#ax.plot([90, 90], [-300, 100], '--c')
	#ax.plot([190, 190], [-300, 100], '--c')
	ax.set_xlim([40, 200])
	ax.set_ylim([-250, 20])
	ax.set_yticks([-200, -100, 0])
	ax.set_ylabel('brightness\n temperature [mK]', fontsize=FS_labels)
	plt.text(50, -210, r'$\rm V_{\rm c}$', fontsize=16)
	

	ax2 = ax.twiny()
	ax2.set_xlabel(r'$z$', fontsize=FS_labels+2)
	z0 = frequency2redshift(40)
	ax2.set_xticks(np.array((np.abs(redshift2frequency(30)-40), np.abs(redshift2frequency(22)-40), np.abs(redshift2frequency(17)-40), np.abs(redshift2frequency(14)-40), np.abs(redshift2frequency(12)-40), np.abs(redshift2frequency(10)-40), np.abs(redshift2frequency(9)-40), np.abs(redshift2frequency(8)-40), np.abs(redshift2frequency(7)-40), np.abs(202-40))))
	ax2.set_xticklabels(['30', '22', '17', '14', '12', '10', '9', '8', '7', '6'])
	
		
	
	
	ax   = fig.add_axes([x0, 1.7*y0+1*dy, dx, dy])	
	ax.plot(freq, model_nominal, color=cc)
	for i in range(20):
		ax.plot(freq, model_p3[i,:], color=[(i/25), (i/25), (i/25)])
	ax.plot(freq, model_nominal, color=cc)
	#ax.plot([90, 90], [-300, 100], '--c')
	#ax.plot([190, 190], [-300, 100], '--c')
	ax.set_xlim([40, 200])
	ax.set_ylim([-250, 20])
	ax.set_yticks([-200, -100, 0])
	ax.set_ylabel('brightness\n temperature [mK]', fontsize=FS_labels)
	plt.text(50, -210, r'$f_{\rm X}$', fontsize=16)
	


		
	ax   = fig.add_axes([x0, y0, dx, dy])
	ax.plot(freq, model_nominal, color=cc)
	for i in range(20):
		ax.plot(freq, model_p4[i,:], color=[(i/25), (i/25), (i/25)])
	ax.plot(freq, model_nominal, color=cc)
	#ax.plot([90, 90], [-300, 100], '--c')
	#ax.plot([190, 190], [-300, 100], '--c')
	ax.set_xlim([40, 200])
	ax.set_ylim([-250, 20])
	ax.set_yticks([-200, -100, 0])	
	ax.set_ylabel('brightness\n temperature [mK]', fontsize=FS_labels)
	ax.set_xlabel('frequency [MHz]', fontsize=FS_labels)
	plt.text(50, -210, r'$\tau_{\rm e}$', fontsize=16)
	
# 




	


	ax   = fig.add_axes([1.4*x0+dx, 1.4*1.7*y0+2*dy, dx, dy])
	ax.plot(freq, model_nominal, color=cc)
	for i in range(20):
		ax.plot(freq, model_p1[i,:], color=[(i/25), (i/25), (i/25)])
	ax.plot(freq, model_nominal, color=cc)
	#ax.plot([90, 90], [-300, 100], '--c')
	#ax.plot([190, 190], [-300, 100], '--c')
	ax.set_xlim([40, 200])
	ax.set_ylim([-250, 20])
	ax.set_yticks([-200, -100, 0])
	ax.set_yticklabels(['','',''])
	plt.text(50, -210, r'$f_*$', fontsize=16)
	
	ax2 = ax.twiny()
	ax2.set_xlabel(r'$z$', fontsize=FS_labels+2)
	z0 = frequency2redshift(40)
	ax2.set_xticks(np.array((np.abs(redshift2frequency(30)-40), np.abs(redshift2frequency(22)-40), np.abs(redshift2frequency(17)-40), np.abs(redshift2frequency(14)-40), np.abs(redshift2frequency(12)-40), np.abs(redshift2frequency(10)-40), np.abs(redshift2frequency(9)-40), np.abs(redshift2frequency(8)-40), np.abs(redshift2frequency(7)-40), np.abs(202-40))))
	ax2.set_xticklabels(['30', '22', '17', '14', '12', '10', '9', '8', '7', '6'])
	
	
	
		
	ax   = fig.add_axes([1.4*x0+dx, 1.7*y0+1*dy, dx, dy])
	ax.plot(freq, model_nominal, color=cc)
	for i in range(20):
		ax.plot(freq, model_p6[i,:], color=[(i/25), (i/25), (i/25)])
	ax.plot(freq, model_nominal, color=cc)
	#ax.plot([90, 90], [-300, 100], '--c')
	#ax.plot([190, 190], [-300, 100], '--c')
	ax.set_xlim([40, 200])
	ax.set_ylim([-250, 20])
	ax.set_yticks([-200, -100, 0])
	ax.set_yticklabels(['','',''])
	plt.text(50, -210, r'$\nu_{\rm min}$', fontsize=16)




	ax   = fig.add_axes([1.4*x0+dx, y0, dx, dy])
	ax.plot(freq, model_nominal, color=cc)
	for i in range(20):
		ax.plot(freq, model_p7[i,:], color=[(i/25), (i/25), (i/25)])
	ax.plot(freq, model_nominal, color=cc)
	#ax.plot([90, 90], [-300, 100], '--c')
	#ax.plot([190, 190], [-300, 100], '--c')
	ax.set_xlim([40, 200])
	ax.set_ylim([-250, 20])
	ax.set_yticks([-200, -100, 0])
	ax.set_yticklabels(['','',''])
	plt.text(50, -210, r'$R_{\rm mfp}$', fontsize=16)
	ax.set_xlabel('frequency [MHz]', fontsize=FS_labels)





	if save == 'yes':
		plt.savefig(home_folder + '/DATA/EDGES_old/results/plots/20190128/fialkov_models_sample_cuec.pdf', bbox_inches='tight')
		plt.close()

	return 0















def fialkov_paper_signal_figure_two(save='no'):



	# Frequency vector
	z_raw = np.arange(5,50.05,0.1)
	freq  = redshift2frequency(z_raw)


	file_name     = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/Global21cmV5/signals_for_figure/signals_for_figure_highest_fX.mat'
	mat           = sio.loadmat(file_name)
	model_nominal = mat['sn'][0]  # in mK
	model_p1      = mat['s1']     # in mK
	model_p2      = mat['s2']     # in mK
	model_p3      = mat['s3']     # in mK
	model_p4      = mat['s4']     # in mK
	model_p6      = mat['s6']     # in mK
	model_p7      = mat['s7']     # in mK


	par_nominal   = mat['set_nominal']   
	par1          = mat['set_p1']
	par2          = mat['set_p2']
	par3          = mat['set_p3']
	par4          = mat['set_p4']
	par6          = mat['set_p6']
	par7          = mat['set_p7']
	
	
	print('Nominal parameters: ')
	#print(par_nominal)
	
	print(par6[0:5,5])




	


	
	sx = 4.3
	sy = 3.5
	
	x0 = 0.13
	y0 = 0.08
	
	dx = 0.84
	dy = 0.85
	
	FS_labels = 13
	
	

	plt.close()
	plt.close()
	plt.close()
	plt.close()
	fig  = plt.figure(num=1, figsize=(sx, sy))
	cc = 'r'

	
	
	
	ax   = fig.add_axes([x0, y0, dx, dy])	
	#ax.plot(freq, model_nominal, color=cc)
	
	ax.plot(freq, model_p6[0,:], '--')#, color=[(i/5), (i/5), (i/5)])
	ax.plot(freq, model_p6[1,:], 'k-')#, color=[(i/5), (i/5), (i/5)])
	#ax.plot(freq, model_p6[2,:], '.-')#, color=[(i/5), (i/5), (i/5)])
	ax.plot(freq, model_p6[2,:], '-')#, color=[(i/5), (i/5), (i/5)])
	ax.plot(freq, model_p6[3,:], '-.')#, color=[(i/5), (i/5), (i/5)])
	ax.plot(freq, model_p6[4,:], ':')#, color=[(i/5), (i/5), (i/5)])
		
	#ax.plot(freq, model_nominal, color=cc)
	ax.set_xlim([90, 150])
	ax.set_ylim([-60, 20])
	#ax.set_yticks([-200, -100, 0])
	ax.set_ylabel('brightness temperature [mK]', fontsize=FS_labels)
	ax.set_xlabel('frequency [MHz]', fontsize=FS_labels)
	#plt.text(50, -210, r'$f_*$', fontsize=16)
	ax.legend(['0.10 keV','0.25 keV','0.40 keV','0.56 keV','0.71 keV'])

	ax2 = ax.twiny()
	ax2.set_xlabel(r'$z$', fontsize=FS_labels+2)
	#z0 = frequency2redshift(40)
	ax2.set_xticks(np.array((np.abs(redshift2frequency(14)-90), np.abs(redshift2frequency(13)-90), np.abs(redshift2frequency(12)-90), np.abs(redshift2frequency(11)-90), np.abs(redshift2frequency(10)-90), np.abs(redshift2frequency(9)-90), np.abs(150-90))))
	ax2.set_xticklabels(['14', '13', '12', '11', '10', '9', ' '])
	
	




	if save == 'yes':
		plt.savefig(home_folder + '/DATA/EDGES/results/plots/20180925/fialkov_models_vmin.pdf', bbox_inches='tight')
		plt.close()
		
		
	
	return 0

















def fialkov_paper_external_constraints(save='no'):
	
	tau   = np.arange(0.055, 0.091, 0.001)
	# L_tau = likelihood_tau_planck(tau, tau0=0.058, sigma=0.012)
	L_tau = likelihood_tau_planck(tau, tau0=0.056, sigma=0.007)
	
	xHI = np.arange(0,1.001,0.001)
	L_xHI59, L_xHI708, L_xHI754_N, L_xHI754_C = likelihood_xHI(xHI, xHI, xHI)
	L_mason = likelihood_xHI_mason2018(xHI)




	sx  = 5
	sy  = 7
	
	x0 = 0.13
	y0 = 0.08
	
	dx = 0.9
	dy = 0.39
	
	
	fig = plt.figure(num=1, figsize=(sx, sy))

	ax   = fig.add_axes([x0, 3.2*y0+dy, dx, dy])
	ax.plot(tau, L_tau, 'k', linewidth=3)
	ax.set_xlim([0.055, 0.09])
	ax.set_ylim([0, 1.1])
	ax.set_xlabel(r'$\tau_e$', fontsize=16)
	ax.set_ylabel('normalized PDF', fontsize=16)
	
	ax.set_xticks(np.arange(0.055, 0.091, 0.005))
	ax.set_xticklabels(['0.055', '0.060', '0.065', '0.070', '0.075', '0.080', '0.085', '0.090'], fontsize=12, rotation=45)
	
	ax.set_yticks(np.arange(0, 1.1, 0.2))
	ax.set_yticklabels(['0.0', '0.2', '0.4', '0.6', '0.8', '1.0'], fontsize=12)
	
	
	
	#ax.legend([r'CMB+BAO'], loc=0, fontsize=8)
	
	# plt.subplot(1,2,1)
	# plt.plot(tau, L_tau, 'k', linewidth=2)
	# plt.xlim([0.055, 0.09])
	# plt.ylim([0, 1.8])
	# plt.xlabel(r'$\tau_e$', fontsize=15)
	# plt.ylabel('normalized PDF', fontsize=14)
	# plt.legend([r'CMB+BAO'], loc=0, fontsize=8) #'upper center', bbox_to_anchor=[0, 1.3, 1, 0.2], fontsize=8)



	ax   = fig.add_axes([x0, y0, dx, dy])
	h1, = ax.plot(xHI, L_xHI59, '-', linewidth=3)
	h2, = ax.plot(xHI, L_xHI708, '--', linewidth=3)
	h3, = ax.plot(xHI, L_xHI754_C, ':', linewidth=3)
	h4, = ax.plot(xHI, L_mason, '-', linewidth=3)
	ax.set_xlim([0, 1])
	ax.set_ylim([0, 1.1])
	ax.set_xlabel(r'$\bar{x}_{\mathrm{HI}}$', fontsize=16)
	ax.set_ylabel('normalized PDF', fontsize=16)	
	l1 = ax.legend([h1, h2, h3, h4], [r'quasars $z=5.9$', r'quasar $z=7.08$', r'quasar $z=7.54$', r'galaxies $z=7$'], loc=1, bbox_to_anchor=(0.755,0.35), ncol=1, fontsize=9.5, frameon=False)
	
	ax.set_xticks(np.arange(0, 1.1, 0.2))
	ax.set_xticklabels(['0.0', '0.2', '0.4', '0.6', '0.8', '1.0'], fontsize=12)
	
	ax.set_yticks(np.arange(0, 1.1, 0.2))
	ax.set_yticklabels(['0.0', '0.2', '0.4', '0.6', '0.8', '1.0'], fontsize=12)	
	
	
	
	
	
	
	
	
	
	#l2 = ax.legend([h4], [r'galaxies $z=7$'], loc=1, ncol=2, fontsize=8, frameon=False)
	#ax.add_artist(l1)
	
	
	# plt.subplot(1,2,2)
	# plt.plot(xHI, L_xHI59, '-', linewidth=2)
	# plt.plot(xHI, L_xHI708, '--', linewidth=2)
	# plt.plot(xHI, L_xHI754_C, ':', linewidth=2)
	# plt.plot(xHI, L_mason, '-', linewidth=2)
	# plt.xticks([0, 0.25, 0.5, 0.75, 1], ['0', '0.25', '0.50', '0.75', '1'])
	# plt.yticks([0, 0.5, 1.0, 1.5], ['','','',''])
	# plt.legend([r'quasar $z=5.9$', r'quasar $z=7.08$', r'quasar $z=7.54$', r'galaxies $z=7$'], loc=0, fontsize=8)
	# plt.xlim([0, 1.0])
	# plt.ylim([0, 1.8])
	# plt.xlabel(r'$\bar{x}_{\mathrm{HI}}$', fontsize=15)
	
	if save == 'yes':
		plt.savefig(home_folder + '/DATA/EDGES/results/plots/20180925/fialkov_external_constraints.pdf', bbox_inches='tight')
		plt.close()	
	
	return 0







































def phenomenological_parameters(freq, model):
	

	# Peak amplitude
	TC = np.min(model)
	
	
	# Peak frequency and redshift
	fC = freq[model == TC]
	zC = frequency2redshift(fC)
	
	#print(fC)
	
	
	# Full width at half max (FWHM)
	flim1 = np.nan
	flim2 = np.nan
	
	# Sweeping from low to high frequency
	for i in range(len(freq)-1):
		
		# Low-frequency descending slope
		if (model[i] >= (TC/2)) and (model[i+1] < (TC/2)) and (freq[i] < fC[0]):
			flim1 = freq[i]
			
		# High-frequency ascending slope
		if (model[i] <= (TC/2)) and (model[i+1] > (TC/2)) and (freq[i] > fC[-1]):
			flim2 = freq[i]
			print
			
		
	
	
	if (np.isnan(flim1) == False) and (np.isnan(flim2) == False):
		dfC = flim2 - flim1                                            # FWHM in frequency
		dzC = frequency2redshift(flim1) - frequency2redshift(flim2)    # FHWM in redshift
		
		
	elif (np.isnan(flim1) == True) and (np.isnan(flim2) == False):
		
		dfC = 1
		dzC = 1
		
	
	elif (np.isnan(flim1) == False) and (np.isnan(flim2) == True):
		
		flim2 = fC + (fC-flim1)
		dfC = flim2 - flim1
		dzC = frequency2redshift(flim1) - frequency2redshift(flim2)	
		

	elif (np.isnan(flim1) == True) and (np.isnan(flim2) == True):
		
		dfC = 3
		dzC = 3	
		


	return TC, fC[0], zC[0], dfC, dzC










def phenomenological_parameters_mesinger():
	
	f = np.arange(41, 198, 0.01)
	
	
	TC_all  = np.zeros(10000)
	fC_all  = np.zeros(10000)
	zC_all  = np.zeros(10000)
	dfC_all = np.zeros(10000)
	dzC_all = np.zeros(10000)
	model_number = np.arange(10000)
	
	for i in range(10000):
		
		#print(i)
		
		m, ao                = model_eor_mesinger(i, f, interpolation_kind='linear')
		TC, fC, zC, dfC, dzC = phenomenological_parameters(f, m)
		
		
		TC_all[i]  = TC
		fC_all[i]  = fC
		zC_all[i]  = zC
		dfC_all[i] = dfC
		dzC_all[i] = dzC
	
	
	# Results array
	outT = np.array([model_number, fC_all, zC_all, TC_all, dfC_all, dzC_all])
	out  = outT.T
	

	# Saving results		
	path_file = home_folder + '/DATA/EDGES/results/high_band/products/model_rejection/mesinger/likelihood/phenomenological_parameters_10000models_20171110.txt'

	header = 'model_number\tpeak_freq [MHz]\tpeak_z [redshift]\tpeak_amplitude [K]\tFWHM [MHz]\tFWHM [redshift]'
	np.savetxt(path_file, out, header=header)

	print('File saved to: ' + path_file)		


	
	
	return fC_all, zC_all, TC_all, dfC_all, dzC_all

































def mid_band_s11_calibration_measurements_120MHz_2017_11_25C(flow, fhigh, save='no', flag=''):

	"""

	Nov 13, 2017

	"""


	# Data paths
	main_path    = home_folder + '/DATA/EDGES/calibration/receiver_calibration/mid_band/2017_11_15C_25C_35C/data/s11/raw/25C/'

	path_LNA     = main_path + 'Receiver/m35dBm/'
	path_ambient = main_path + 'Ambient/'
	path_hot     = main_path + 'HotLoad/'
	path_open    = main_path + 'LongCableOpen/'
	path_shorted = main_path + 'LongCableShort/'
	path_sim2    = main_path + 'AntSim2/'



	# ------- Receiver S11 ------------------------

	# Reading measurements
	o,   fr0  = rc.s1p_read(path_LNA + 'Open01.s1p')           # 2nd repetition is a little better
	s,   fr0  = rc.s1p_read(path_LNA + 'Short01.s1p')
	l,   fr0  = rc.s1p_read(path_LNA + 'Match01.s1p')
	LNA0, fr0 = rc.s1p_read(path_LNA + 'Receiver01.s1p')


	# Models of standards
	resistance_of_match = 49.99 # female
	md = 1
	oa, sa, la = rc.agilent_85033E(fr0, resistance_of_match, md)

	# Correction of measurements
	LNAc, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA0)

	LNA = LNAc[(fr0/1e6>=flow) & (fr0/1e6<=fhigh)]
	fr  = fr0[(fr0/1e6>=flow) & (fr0/1e6<=fhigh)]






	# Calibration loads
	# ---------------------------------------------------------------------------------------------------

	# Ambient load
	# -------------------
	o_m,  f_a = rc.s1p_read(path_ambient + 'Open.s1p')         # 2nd repetition is a little better
	s_m,  f_a = rc.s1p_read(path_ambient + 'Short.s1p')
	l_m,  f_a = rc.s1p_read(path_ambient + 'Match.s1p')
	a_m,  f_a = rc.s1p_read(path_ambient + 'External.s1p')

	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_a))
	s_sw = -1 * np.ones(len(f_a))
	l_sw =  0 * np.ones(len(f_a))

	# Correction at switch
	a_sw_c, x1, x2, x3 = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, a_m)

	# Correction at receiver input
	a_cc = mid_band_switch_correction_120MHz_2017_11(a_sw_c, f_in = f_a)
	a_c  = a_cc[0]

	a  = a_c[(f_a/1e6>=flow) & (f_a/1e6<=fhigh)]
	fa = f_a[(f_a/1e6>=flow) & (f_a/1e6<=fhigh)]






	# Hot load
	# -------------------
	o_m,  f_h = rc.s1p_read(path_hot + 'Open.s1p')          # 2nd repetition is a little better
	s_m,  f_h = rc.s1p_read(path_hot + 'Short.s1p')
	l_m,  f_h = rc.s1p_read(path_hot + 'Match.s1p')
	h_m,  f_h = rc.s1p_read(path_hot + 'External.s1p')

	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_h))
	s_sw = -1 * np.ones(len(f_h))
	l_sw =  0 * np.ones(len(f_h))

	# Correction at switch
	h_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, h_m)

	# Correction at receiver input
	h_cc = mid_band_switch_correction_120MHz_2017_11(h_sw_c, f_in = f_a)
	h_c  = h_cc[0]

	h  = h_c[(f_h/1e6>=flow) & (f_h/1e6<=fhigh)]
	fh = f_h[(f_h/1e6>=flow) & (f_h/1e6<=fhigh)]










	# Open Cable 
	# -------------------
	o_m,  f_oc = rc.s1p_read(path_open + 'Open.s1p')        # Using 2nd repetition for consistency
	s_m,  f_oc = rc.s1p_read(path_open + 'Short.s1p')
	l_m,  f_oc = rc.s1p_read(path_open + 'Match.s1p')
	oc_m, f_oc = rc.s1p_read(path_open + 'External.s1p')

	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_oc))
	s_sw = -1 * np.ones(len(f_oc))
	l_sw =  0 * np.ones(len(f_oc))

	# Correction at switch
	oc_sw_c, x1, x2, x3 = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, oc_m)

	# Correction at receiver input
	oc_cc = mid_band_switch_correction_120MHz_2017_11(oc_sw_c, f_in = f_oc)
	oc_c  = oc_cc[0]

	oc  = oc_c[(f_oc/1e6>=flow) & (f_oc/1e6<=fhigh)]
	foc = f_oc[(f_oc/1e6>=flow) & (f_oc/1e6<=fhigh)]








	# Shorted Cable
	# -------------------
	o_m,  f_sc = rc.s1p_read(path_shorted + 'Open.s1p')        # Using 2nd repetition for consistency
	s_m,  f_sc = rc.s1p_read(path_shorted + 'Short.s1p')
	l_m,  f_sc = rc.s1p_read(path_shorted + 'Match.s1p')
	sc_m, f_sc = rc.s1p_read(path_shorted + 'External.s1p')

	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_sc))
	s_sw = -1 * np.ones(len(f_sc))
	l_sw =  0 * np.ones(len(f_sc))

	# Correction at switch
	sc_sw_c, x1, x2, x3 = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, sc_m)

	# Correction at receiver input
	sc_cc = mid_band_switch_correction_120MHz_2017_11(sc_sw_c, f_in = f_sc)
	sc_c  = sc_cc[0]

	sc  = sc_c[(f_sc/1e6>=flow) & (f_sc/1e6<=fhigh)]
	fsc = f_sc[(f_sc/1e6>=flow) & (f_sc/1e6<=fhigh)]







	# Antenna Simulator 2 before               
	# --------------------------
	o_m,  f_q2 = rc.s1p_read(path_sim2 + 'Open.s1p')          # Using 2nd repetition for consistency
	s_m,  f_q2 = rc.s1p_read(path_sim2 + 'Short.s1p')
	l_m,  f_q2 = rc.s1p_read(path_sim2 + 'Match.s1p')
	q2_m, f_q2 = rc.s1p_read(path_sim2 + 'External.s1p')

	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f_q2))
	s_sw = -1 * np.ones(len(f_q2))
	l_sw =  0 * np.ones(len(f_q2))

	# Correction at switch
	q2_sw_c, x1, x2, x3  = rc.de_embed(o_sw, s_sw, l_sw, o_m, s_m, l_m, q2_m)

	# Correction at receiver input
	q2_cc = mid_band_switch_correction_120MHz_2017_11(q2_sw_c, f_in = f_q2)
	q2_c  = q2_cc[0]

	q2  = q2_c[(f_q2/1e6>=flow) & (f_q2/1e6<=fhigh)]
	fq2 = f_q2[(f_q2/1e6>=flow) & (f_q2/1e6<=fhigh)]










	# Loading S-parameters of semi-rigid cable (they are at 1 MHz)
	# --------------------------------------------------------------
	spar0      = np.genfromtxt(home_folder + '/DATA/EDGES/calibration/receiver_calibration/high_band1/2015_03_25C/data/S11/corrected_delay/semi_rigid_s_parameters.txt')
	f_sr0      = spar0[:, 0]
	spar       = spar0[(f_sr0>=flow) & (f_sr0<=fhigh), :]

	xf_sr       = spar[:, 0]
	xs11_srr    = spar[:, 1]
	xs11_sri    = spar[:, 2]
	xs12s21_srr = spar[:, 3]
	xs12s21_sri = spar[:, 4]
	xs22_srr    = spar[:, 5]
	xs22_sri    = spar[:, 6]

	# Best fit is with 5 terms over 40-120 MHz
	pp = np.polyfit(xf_sr, xs11_srr, 4);     s11r    = np.polyval(pp, fr/1e6)
	pp = np.polyfit(xf_sr, xs11_sri, 4);     s11i    = np.polyval(pp, fr/1e6)
	pp = np.polyfit(xf_sr, xs12s21_srr, 4);  s12s21r = np.polyval(pp, fr/1e6)
	pp = np.polyfit(xf_sr, xs12s21_sri, 4);  s12s21i = np.polyval(pp, fr/1e6)
	pp = np.polyfit(xf_sr, xs22_srr, 4);     s22r    = np.polyval(pp, fr/1e6)
	pp = np.polyfit(xf_sr, xs22_sri, 4);     s22i    = np.polyval(pp, fr/1e6)




	# Now, saving data
	temp = np.array([ fr/1e6, 
                          np.real(LNA),  np.imag(LNA),
                          np.real(a),    np.imag(a),    np.real(h),    np.imag(h),
                          np.real(oc),   np.imag(oc),   np.real(sc),   np.imag(sc),
                          s11r,          s11i,          s12s21r,       s12s21i,        s22r,         s22i,
                          np.real(q2),  np.imag(q2)])

	output_file     = temp.T
	
	
	# Saving
	# ---------------------------------------------
	if save == 'yes':	
		save_path       = home_folder + '/DATA/EDGES/calibration/receiver_calibration/mid_band/2017_11_15C_25C_35C/data/s11/corrected/'
		temperature_LNA = '25degC'
		output_file_str = save_path + 's11_calibration_mid_band_LNA' + temperature_LNA + '_' + tt.strftime('%Y-%m-%d-%H-%M-%S') + flag + '.txt'

		header = 'freq [MHz]\tre(receiver)\tim(receiver)\tre(amb)\tim(amb)\tre(hot)\tim(hot)\tre(open)\tim(open)\tre(shorted)\tim(shorted)\tre(semirigid_s11)\tim(semirigid_s11)\tre(semirigid_s12s21)\tim(semirigid_s12s21)\tre(semirigid_s22)\tim(semirigid_s22)\tre(antsim2)\tim(antsim2)'
		np.savetxt(output_file_str, output_file, header=header)

		print('File saved to: ' + output_file_str)

	


	return output_file











def mid_band_switch_correction_120MHz_2017_11(ant_s11, f_in = np.zeros([0,1])):  

	"""

	November 22, 2017
	
	This is a function for the temporary, incorrect, calibration of Mid-Band, over 40-120 MHz.
	
	Focusing only on 25degC for now.

	"""



	# Loading measurements
	path_folder     = home_folder + '/DATA/EDGES/calibration/receiver_calibration/mid_band/2017_11_15C_25C_35C/data/s11/raw/25C/SP4T/'
	

	# Internal standards
	oi_25, f = rc.s1p_read(path_folder + 'Open01.s1p')
	si_25, f = rc.s1p_read(path_folder + 'Short01.s1p')
	mi_25, f = rc.s1p_read(path_folder + 'Match01.s1p')
	
	# External standards
	oe_25, f = rc.s1p_read(path_folder + 'Ext_Open01.s1p')
	se_25, f = rc.s1p_read(path_folder + 'Ext_Short01.s1p')
	me_25, f = rc.s1p_read(path_folder + 'Ext_Match01.s1p')
	


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f))
	s_sw = -1 * np.ones(len(f))
	m_sw =  0 * np.ones(len(f))


	# Correction at the switch
	oe_sw_25, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, m_sw, oi_25, si_25, mi_25, oe_25)
	se_sw_25, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, m_sw, oi_25, si_25, mi_25, se_25)
	me_sw_25, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, m_sw, oi_25, si_25, mi_25, me_25)




	
	
	# Agilent reflections
	resistance_of_match_25 = 50.12
	md = 1
		
	oa_25, sa_25, ma_25 = rc.agilent_85033E(f, resistance_of_match_25, md)
	
	
	# Computation of S-parameters to the receiver input
	xx, s11_25, s12s21_25, s22_25 = rc.de_embed(oa_25, sa_25, ma_25, oe_sw_25, se_sw_25, me_sw_25, oe_sw_25)




	# Polynomial fit of S-parameters from "f" to input frequency vector "f_in"
	# ------------------------------------------------------------------------

	# Frequency normalization
	fn = f/75e6

	if len(f_in) > 10:
		if f_in[0] > 1e5:
			fn_in = f_in/75e6
		elif f_in[-1] < 300:
			fn_in = f_in/75
	else:
		fn_in = np.copy(fn)



	# Real-Imaginary parts of the S-parameters (just at 25degC for now)
	real_s11    = np.real(s11_25)
	imag_s11    = np.imag(s11_25)
	real_s12s21 = np.real(s12s21_25)
	imag_s12s21 = np.imag(s12s21_25)
	real_s22    = np.real(s22_25)
	imag_s22    = np.imag(s22_25)




	# Polynomial fits
	N_poly_terms = 10     # 10 is the best number over 40-120 MHz

	p = np.polyfit(fn, real_s11, N_poly_terms-1)
	fit_real_s11 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s11, N_poly_terms-1)
	fit_imag_s11 = np.polyval(p, fn_in)



	p = np.polyfit(fn, real_s12s21, N_poly_terms-1)
	fit_real_s12s21 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s12s21, N_poly_terms-1)
	fit_imag_s12s21 = np.polyval(p, fn_in)



	p = np.polyfit(fn, real_s22, N_poly_terms-1)
	fit_real_s22 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s22, N_poly_terms-1)
	fit_imag_s22 = np.polyval(p, fn_in)



	fit_s11    = fit_real_s11    + 1j*fit_imag_s11
	fit_s12s21 = fit_real_s12s21 + 1j*fit_imag_s12s21
	fit_s22    = fit_real_s22    + 1j*fit_imag_s22




	# Corrected antenna S11
	corr_ant_s11 = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, ant_s11)





	return (corr_ant_s11, fit_s11, fit_s12s21, fit_s22)   #, f, s11_25, s12s21_25, s22_25











def mid_band_s11_calibration_measurements_200MHz_2017_11_25C(flow=50, fhigh=200, case=3, save='no', flag=''):

	"""

	Dic 01, 2017

	"""


	# Data paths
	path_LNA = home_folder + '/DATA/EDGES/calibration/receiver_calibration/mid_band/2017_11_15C_25C_35C/data/s11/raw/25C/receiver_MRO_fieldfox_40-200MHz/'
	
	path_all = home_folder + '/DATA/EDGES/calibration/receiver_calibration/mid_band/2017_11_15C_25C_35C/data/s11/raw/25C/S11_Loads_25C_direct_40_to_200MHz/'	
	
	



	# ------- Receiver S11 ------------------------

	# Reading measurements
	if case == 1:
		o,   fr0  = rc.s1p_read(path_LNA + 'A1.s1p')          # -35dBm, NOT fully stabilized receiver at 25degC
		s,   fr0  = rc.s1p_read(path_LNA + 'A2.s1p')   
		l,   fr0  = rc.s1p_read(path_LNA + 'A3.s1p')   
		LNA0, fr0 = rc.s1p_read(path_LNA + 'A4.s1p')   

	elif case == 2:
		o,   fr0  = rc.s1p_read(path_LNA + 'A5.s1p')          # -35 dBm, NOT fully stabilized receiver at 25degC
		s,   fr0  = rc.s1p_read(path_LNA + 'A6.s1p')   
		l,   fr0  = rc.s1p_read(path_LNA + 'A7.s1p')   
		LNA0, fr0 = rc.s1p_read(path_LNA + 'A8.s1p')   

	elif case == 3:
		o,   fr0  = rc.s1p_read(path_LNA + 'B1.s1p')          # -35dBm, stable receiver at 25degC     BEST CASE
		s,   fr0  = rc.s1p_read(path_LNA + 'B2.s1p')   
		l,   fr0  = rc.s1p_read(path_LNA + 'B3.s1p')   
		LNA0, fr0 = rc.s1p_read(path_LNA + 'B4.s1p')    
				
	elif case == 4:
		o,   fr0  = rc.s1p_read(path_LNA + 'B5.s1p')          # -35dBm, stable receiver at 25degC     BEST CASE
		s,   fr0  = rc.s1p_read(path_LNA + 'B6.s1p')   
		l,   fr0  = rc.s1p_read(path_LNA + 'B7.s1p')   
		LNA0, fr0 = rc.s1p_read(path_LNA + 'B8.s1p')   
		
	elif case == 5:
		o,   fr0  = rc.s1p_read(path_LNA + 'C1.s1p')          # -30dBm, stable receiver at 25degC
		s,   fr0  = rc.s1p_read(path_LNA + 'C2.s1p')   
		l,   fr0  = rc.s1p_read(path_LNA + 'C3.s1p')   
		LNA0, fr0 = rc.s1p_read(path_LNA + 'C4.s1p')   	

	elif case == 6:
		o,   fr0  = rc.s1p_read(path_LNA + 'C5.s1p')          # -30dBm, stable receiver at 25degC
		s,   fr0  = rc.s1p_read(path_LNA + 'C6.s1p')   
		l,   fr0  = rc.s1p_read(path_LNA + 'C7.s1p')   
		LNA0, fr0 = rc.s1p_read(path_LNA + 'C8.s1p')   		
		




	# Models of standards
	resistance_of_match = 49.7 # female 49.6   49.99
	md = 1
	oa, sa, la = rc.agilent_85033E(fr0, resistance_of_match, md)

	# Correction of measurements
	LNAc, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA0)

	LNA = LNAc[(fr0/1e6>=flow) & (fr0/1e6<=fhigh)]
	fr  = fr0[(fr0/1e6>=flow) & (fr0/1e6<=fhigh)]

	# Output array
	temp = np.array([ fr/1e6, np.real(LNA), np.imag(LNA) ])
	output_file_LNA  = temp.T











	# Calibration loads
	# ---------------------------------------------------------------------------------------------------

	# Standards
	o_m,  fx = rc.s1p_read(path_all + 'Open01.s1p')         # 2nd repetition is a little better
	s_m,  fx = rc.s1p_read(path_all + 'Short01.s1p')
	l_m,  fx = rc.s1p_read(path_all + 'Match01.s1p')


	# Models of standards
	resistance_of_match = 50.02 # male from Phil's calibration kit
	md = 1
	oa, sa, la = rc.agilent_85033E(fx, resistance_of_match, md)
	


	# Ambient load
	a_m,  fy = rc.s1p_read(path_all + 'Amb01.s1p')
	
	# Correction of measurement
	a_c, x1, x2, x3 = rc.de_embed(oa, sa, la, o_m, s_m, l_m, a_m)

	# Range cut
	a  = a_c[(fx/1e6>=flow) & (fx/1e6<=fhigh)]
	
	
	
	
	# Hot load
	h_m,  fy = rc.s1p_read(path_all + 'HotLoad01a.s1p')
	
	# Correction of measurement
	h_c, x1, x2, x3 = rc.de_embed(oa, sa, la, o_m, s_m, l_m, h_m)

	# Range cut
	h  = h_c[(fx/1e6>=flow) & (fx/1e6<=fhigh)]
	
	
	
	
	# Open Cable
	oc_m,  fy = rc.s1p_read(path_all + 'LongCable_Open01.s1p')
	
	# Correction of measurement
	oc_c, x1, x2, x3 = rc.de_embed(oa, sa, la, o_m, s_m, l_m, oc_m)

	# Range cut
	oc  = oc_c[(fx/1e6>=flow) & (fx/1e6<=fhigh)]
	


	# Short Cable
	sc_m,  fy = rc.s1p_read(path_all + 'LongCable_Shorted01.s1p')
	
	# Correction of measurement
	sc_c, x1, x2, x3 = rc.de_embed(oa, sa, la, o_m, s_m, l_m, sc_m)

	# Range cut
	sc  = sc_c[(fx/1e6>=flow) & (fx/1e6<=fhigh)]
	
	
	
	
	
	# AntSim 2
	q2_m,  fy = rc.s1p_read(path_all + 'AntSim2_01.s1p')
	
	# Correction of measurement
	q2_c, x1, x2, x3 = rc.de_embed(oa, sa, la, o_m, s_m, l_m, q2_m)

	# Range cut
	q2  = q2_c[(fx/1e6>=flow) & (fx/1e6<=fhigh)]
	
	
	
	
	
	
	# Frequency cut
	fxx = fx[(fx/1e6>=flow) & (fx/1e6<=fhigh)]
	
	







	# Loading S-parameters of semi-rigid cable (they are at 1 MHz)
	# --------------------------------------------------------------
	spar0      = np.genfromtxt(home_folder + '/DATA/EDGES/calibration/receiver_calibration/high_band1/2015_03_25C/data/S11/corrected_delay/semi_rigid_s_parameters.txt')
	f_sr0      = spar0[:, 0]
	spar       = spar0[(f_sr0>=flow) & (f_sr0<=fhigh), :]

	xf_sr       = spar[:, 0]
	xs11_srr    = spar[:, 1]
	xs11_sri    = spar[:, 2]
	xs12s21_srr = spar[:, 3]
	xs12s21_sri = spar[:, 4]
	xs22_srr    = spar[:, 5]
	xs22_sri    = spar[:, 6]

	# Best fit is with 5 terms over 50-200 MHz
	pp = np.polyfit(xf_sr, xs11_srr, 4);     s11r    = np.polyval(pp, fxx/1e6)
	pp = np.polyfit(xf_sr, xs11_sri, 4);     s11i    = np.polyval(pp, fxx/1e6)
	pp = np.polyfit(xf_sr, xs12s21_srr, 4);  s12s21r = np.polyval(pp, fxx/1e6)
	pp = np.polyfit(xf_sr, xs12s21_sri, 4);  s12s21i = np.polyval(pp, fxx/1e6)
	pp = np.polyfit(xf_sr, xs22_srr, 4);     s22r    = np.polyval(pp, fxx/1e6)
	pp = np.polyfit(xf_sr, xs22_sri, 4);     s22i    = np.polyval(pp, fxx/1e6)




	# Now, saving data
	temp = np.array([ fxx/1e6,
                          np.real(a),    np.imag(a),    np.real(h),    np.imag(h),
                          np.real(oc),   np.imag(oc),   np.real(sc),   np.imag(sc),
                          s11r,          s11i,          s12s21r,       s12s21i,        s22r,         s22i,
                          np.real(q2),  np.imag(q2)])

	output_file_calibrators     = temp.T
	





	
	# Saving (TWO FILES)
	# ---------------------------------------------
	if save == 'yes':	
		save_path       = home_folder + '/DATA/EDGES/calibration/receiver_calibration/mid_band/2017_11_15C_25C_35C/data/s11/corrected/'
		temperature_LNA = '25degC'

		
		output_file_LNA_str = save_path + 's11_calibration_mid_band_50-200MHz_LNA_' + temperature_LNA + '_' + tt.strftime('%Y-%m-%d-%H-%M-%S') + flag + '.txt'
		output_file_calibrators_str     = save_path + 's11_calibration_mid_band_50-200MHz_calibrators_' + temperature_LNA + '_' + tt.strftime('%Y-%m-%d-%H-%M-%S') + flag + '.txt'

			
		header_LNA = 'freq [MHz]\tre(receiver)\tim(receiver)'
		header_calibrators = 'freq [MHz]\tre(amb)\tim(amb)\tre(hot)\tim(hot)\tre(open)\tim(open)\tre(shorted)\tim(shorted)\tre(semirigid_s11)\tim(semirigid_s11)\tre(semirigid_s12s21)\tim(semirigid_s12s21)\tre(semirigid_s22)\tim(semirigid_s22)\tre(antsim2)\tim(antsim2)'
		
		
		np.savetxt(output_file_LNA_str, output_file_LNA, header=header_LNA)			
		np.savetxt(output_file_calibrators_str, output_file_calibrators, header=header_calibrators)

		print('File saved to: ' + output_file_calibrators_str)

	




	return output_file_LNA, output_file_calibrators










def mid_band_switch_correction_200MHz_2017_11(ant_s11, f_in = np.zeros([0,1]), DC = 49.85):  

	"""

	November 23, 2017


	"""



	# Loading measurements
	#path_folder     = home_folder + '/DATA/EDGES/calibration/receiver_calibration/mid_band/MRO_preliminary/data/s11/raw/25C/'
	path_folder = home_folder + '/DATA/EDGES/calibration/receiver_calibration/mid_band/2017_11_15C_25C_35C/data/s11/raw/25C/receiver_MRO_fieldfox_40-200MHz/'
	

	# Internal standards
	oi_25, f = rc.s1p_read(path_folder + 'B15.s1p')     # A9 or  A15  or  B9  or  B15
	si_25, f = rc.s1p_read(path_folder + 'B16.s1p')    # A16
	mi_25, f = rc.s1p_read(path_folder + 'B17.s1p')    # A17
	
	# External standards
	oe_25, f = rc.s1p_read(path_folder + 'B18.s1p')    # A18
	se_25, f = rc.s1p_read(path_folder + 'B19.s1p')    # A19
	me_25, f = rc.s1p_read(path_folder + 'B20.s1p')    # A20 
	


	# Standards assumed at the switch
	o_sw =  1 * np.ones(len(f))
	s_sw = -1 * np.ones(len(f))
	m_sw =  0 * np.ones(len(f))


	# Correction at the switch
	oe_sw_25, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, m_sw, oi_25, si_25, mi_25, oe_25)
	se_sw_25, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, m_sw, oi_25, si_25, mi_25, se_25)
	me_sw_25, xx1, xx2, xx3 = rc.de_embed(o_sw, s_sw, m_sw, oi_25, si_25, mi_25, me_25)




	
	
	# Agilent reflections
	resistance_of_match_25 = np.copy(DC)   #49.85#49.8 #99
	md = 1
		
	oa_25, sa_25, ma_25 = rc.agilent_85033E(f, resistance_of_match_25, md)
	
	
	# Computation of S-parameters to the receiver input
	xx, s11_25, s12s21_25, s22_25 = rc.de_embed(oa_25, sa_25, ma_25, oe_sw_25, se_sw_25, me_sw_25, oe_sw_25)




	# Polynomial fit of S-parameters from "f" to input frequency vector "f_in"
	# ------------------------------------------------------------------------

	# Frequency normalization
	fn = f/75e6

	if len(f_in) > 10:
		if f_in[0] > 1e5:
			fn_in = f_in/75e6
		elif f_in[-1] < 300:
			fn_in = f_in/75
	else:
		fn_in = np.copy(fn)



	# Real-Imaginary parts of the S-parameters (just at 25degC for now)
	real_s11    = np.real(s11_25)
	imag_s11    = np.imag(s11_25)
	real_s12s21 = np.real(s12s21_25)
	imag_s12s21 = np.imag(s12s21_25)
	real_s22    = np.real(s22_25)
	imag_s22    = np.imag(s22_25)




	# Polynomial fits
	N_poly_terms = 10     # is 10 the best number ??

	p = np.polyfit(fn, real_s11, N_poly_terms-1)
	fit_real_s11 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s11, N_poly_terms-1)
	fit_imag_s11 = np.polyval(p, fn_in)



	p = np.polyfit(fn, real_s12s21, N_poly_terms-1)
	fit_real_s12s21 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s12s21, N_poly_terms-1)
	fit_imag_s12s21 = np.polyval(p, fn_in)



	p = np.polyfit(fn, real_s22, N_poly_terms-1)
	fit_real_s22 = np.polyval(p, fn_in)

	p = np.polyfit(fn, imag_s22, N_poly_terms-1)
	fit_imag_s22 = np.polyval(p, fn_in)


	fit_s11    = fit_real_s11    + 1j*fit_imag_s11
	fit_s12s21 = fit_real_s12s21 + 1j*fit_imag_s12s21
	fit_s22    = fit_real_s22    + 1j*fit_imag_s22



	# Corrected antenna S11
	corr_ant_s11 = rc.gamma_de_embed(fit_s11, fit_s12s21, fit_s22, ant_s11)


	return (corr_ant_s11, fit_s11, fit_s12s21, fit_s22)












def mid_band_antenna_s11_tuning(case):
	
	"""
	
	November 24, 2017
	
	"""
	

	# Loading measurements
	path_folder     = home_folder + '/DATA/EDGES/calibration/antenna_s11/mid_band/s11/raw/2017-11-mid-tune/'
	
	# Internal standards
	if case == 1:
		oi, f = rc.s1p_read(path_folder + '2017_328_03_52_30_input1.s1p')	
		si, f = rc.s1p_read(path_folder + '2017_328_03_52_30_input2.s1p')
		li, f = rc.s1p_read(path_folder + '2017_328_03_52_30_input3.s1p')
		ai, f = rc.s1p_read(path_folder + '2017_328_03_52_30_input4.s1p')
		
	elif case == 2:
		oi, f = rc.s1p_read(path_folder + '2017_328_03_54_42_input1.s1p')	
		si, f = rc.s1p_read(path_folder + '2017_328_03_54_42_input2.s1p')
		li, f = rc.s1p_read(path_folder + '2017_328_03_54_42_input3.s1p')
		ai, f = rc.s1p_read(path_folder + '2017_328_03_54_42_input4.s1p')	

	elif case == 3:
		oi, f = rc.s1p_read(path_folder + '2017_328_04_06_27_input1.s1p')	
		si, f = rc.s1p_read(path_folder + '2017_328_04_06_27_input2.s1p')
		li, f = rc.s1p_read(path_folder + '2017_328_04_06_27_input3.s1p')
		ai, f = rc.s1p_read(path_folder + '2017_328_04_06_27_input4.s1p')	

	elif case == 4:
		oi, f = rc.s1p_read(path_folder + '2017_328_04_14_20_input1.s1p')	
		si, f = rc.s1p_read(path_folder + '2017_328_04_14_20_input2.s1p')
		li, f = rc.s1p_read(path_folder + '2017_328_04_14_20_input3.s1p')
		ai, f = rc.s1p_read(path_folder + '2017_328_04_14_20_input4.s1p')	

	elif case == 5:
		oi, f = rc.s1p_read(path_folder + '2017_328_04_18_13_input1.s1p')	
		si, f = rc.s1p_read(path_folder + '2017_328_04_18_13_input2.s1p')
		li, f = rc.s1p_read(path_folder + '2017_328_04_18_13_input3.s1p')
		ai, f = rc.s1p_read(path_folder + '2017_328_04_18_13_input4.s1p')	
	
	elif case == 6:
		oi, f = rc.s1p_read(path_folder + '2017_328_04_21_35_input1.s1p')	
		si, f = rc.s1p_read(path_folder + '2017_328_04_21_35_input2.s1p')
		li, f = rc.s1p_read(path_folder + '2017_328_04_21_35_input3.s1p')
		ai, f = rc.s1p_read(path_folder + '2017_328_04_21_35_input4.s1p')	
	
	
	# reflection references
	oref =  1*np.ones(len(f))
	sref = -1*np.ones(len(f))
	lref =  0*np.ones(len(f))



	# first correction
	aic  = rc.de_embed(oref, sref, lref, oi, si, li, ai)
		
		
	aicc = low_band1_switch_correction_2017_08_15C_25C_35C(aic[0], f_in = f, Tswitch = 25)



	return f/1e6, aic[0], aicc[0]









def mid_band_antenna_s11(case, save='no'):
	
	
	# Loading measurements	
	if case == '2017_330':
		path_folder     = home_folder + '/DATA/EDGES/calibration/antenna_s11/mid_band/s11/raw/2017_330/'
		oi, f = rc.s1p_read(path_folder + '2017_330_12_28_15_input1.s1p')	
		si, f = rc.s1p_read(path_folder + '2017_330_12_28_15_input2.s1p')
		li, f = rc.s1p_read(path_folder + '2017_330_12_28_15_input3.s1p')
		ai, f = rc.s1p_read(path_folder + '2017_330_12_28_15_input4.s1p')
		
		
	elif case == '2017_335':  # There are 4 repetitions of this measurement, but they are all within the noise
		path_folder     = home_folder + '/DATA/EDGES/calibration/antenna_s11/mid_band/s11/raw/2017_335/'
		oi, f = rc.s1p_read(path_folder + '2017_335_15_05_59_input1.s1p')
		si, f = rc.s1p_read(path_folder + '2017_335_15_05_59_input2.s1p')
		li, f = rc.s1p_read(path_folder + '2017_335_15_05_59_input3.s1p')
		ai, f = rc.s1p_read(path_folder + '2017_335_15_05_59_input4.s1p')		
			

	elif case == '2017_341':  # There are 3 repetitions of this measurement, but they are all within the noise
		path_folder     = home_folder + '/DATA/EDGES/calibration/antenna_s11/mid_band/s11/raw/2017_341_after_michael/'
		oi, f = rc.s1p_read(path_folder + '2017_341_15_33_30_input1.s1p')
		si, f = rc.s1p_read(path_folder + '2017_341_15_33_30_input2.s1p')
		li, f = rc.s1p_read(path_folder + '2017_341_15_33_30_input3.s1p')
		ai, f = rc.s1p_read(path_folder + '2017_341_15_33_30_input4.s1p')
		
		
	elif case == '2018_025':  # There are 4 repetitions of this measurement, but they are all within the noise
		path_folder     = home_folder + '/DATA/EDGES/calibration/antenna_s11/mid_band/s11/raw/2018_025_no_balun_shield/'
		
		oi, f = rc.s1p_read(path_folder + '2018_025_15_44_28_input1.s1p')
		si, f = rc.s1p_read(path_folder + '2018_025_15_44_28_input2.s1p')
		li, f = rc.s1p_read(path_folder + '2018_025_15_44_28_input3.s1p')
		ai, f = rc.s1p_read(path_folder + '2018_025_15_44_28_input4.s1p')

		
	elif case == '2018_046':  # There are 3 repetitions of this measurement, but they are all within the noise
		path_folder     = home_folder + '/DATA/EDGES/calibration/antenna_s11/mid_band/s11/raw/2018_046_no_balun_shield/'
		
		oi, f = rc.s1p_read(path_folder + '2018_046_15_58_14_input1.s1p')
		si, f = rc.s1p_read(path_folder + '2018_046_15_58_14_input2.s1p')
		li, f = rc.s1p_read(path_folder + '2018_046_15_58_14_input3.s1p')
		ai, f = rc.s1p_read(path_folder + '2018_046_15_58_14_input4.s1p')
		
	
		
		
		
		
	# reflection references
	oref =  1*np.ones(len(f))
	sref = -1*np.ones(len(f))
	lref =  0*np.ones(len(f))



	# first correction
	aic  = rc.de_embed(oref, sref, lref, oi, si, li, ai)
	rc_x  = aic[0]	
	


	# Cutting the data to useful range
	fr     = np.copy(f) #/1e6
	flow   = 50 * 1e6
	fhigh1 = 120 * 1e6
	fhigh2 = 200 * 1e6
	
	fy1    = fr[(fr>=flow) & (fr<=fhigh1)]
	rc1_y  = rc_x[(fr>=flow) & (fr<=fhigh1)]
	
	fy2    = fr[(fr>=flow) & (fr<=fhigh2)]
	rc2_y  = rc_x[(fr>=flow) & (fr<=fhigh2)]
	
	
	
	# Absolute calibration using two sets of measurements
	
	# Lab measurements (E5072A)
	rc1_X = mid_band_switch_correction_120MHz_2017_11(rc1_y, f_in=fy1)
	rc1   = rc1_X[0]
	
	# Field measurements (Fieldfox)
	rc21_X = mid_band_switch_correction_200MHz_2017_11(rc2_y, f_in=fy2, DC=49.90)
	rc22_X = mid_band_switch_correction_200MHz_2017_11(rc2_y, f_in=fy2, DC=49.85)
	rc23_X = mid_band_switch_correction_200MHz_2017_11(rc2_y, f_in=fy2, DC=49.80)
	
	
	rc21 = rc21_X[0]
	rc22 = rc22_X[0]
	rc23 = rc23_X[0]
	
	
	
	# Output variables
	out1_T  = np.array([fy1, np.real(rc1),  np.imag(rc1)])
	out21_T = np.array([fy2, np.real(rc21), np.imag(rc21)])
	out22_T = np.array([fy2, np.real(rc22), np.imag(rc22)])
	out23_T = np.array([fy2, np.real(rc23), np.imag(rc23)])
	
	out1  = out1_T.T
	out21 = out21_T.T
	out22 = out22_T.T
	out23 = out23_T.T
	
	
	
	# Saving
	if save == 'yes':
		
		# creating folder if necessary
		path_save = home_folder + '/DATA/EDGES/calibration/antenna_s11/mid_band/s11/corrected/' + case + '/'
		
		if not exists(path_save):
			makedirs(path_save)
		
		
		
		
		header = 'freq [Hz]\tre(antenna_s11)\tim(antenna_s11)'
		
		filename1  = 'S11_blade_mid_band_' + case + '_lab_switch_parameters_50-120MHz.txt'
		filename21 = 'S11_blade_mid_band_' + case + '_field_switch_parameters_49.90ohm_50-200MHz.txt'
		filename22 = 'S11_blade_mid_band_' + case + '_field_switch_parameters_49.85ohm_50-200MHz.txt'
		filename23 = 'S11_blade_mid_band_' + case + '_field_switch_parameters_49.80ohm_50-200MHz.txt'
		
		np.savetxt(path_save + filename1,  out1,  header=header)
		np.savetxt(path_save + filename21, out21, header=header)
		np.savetxt(path_save + filename22, out22, header=header)
		np.savetxt(path_save + filename23, out23, header=header)
		
		
	
	return out1, out21, out22, out23























def low_band2_antenna_s11(case, save='no'):
	
	
	# Loading measurements	
	if case == '2017_290':	  # There are 8 repetitions of this measurement, but they very consistent
		path_folder     = home_folder + '/DATA/EDGES/calibration/antenna_s11/low_band2/s11/raw/low2_oct_2017_a/'
		oi, f = rc.s1p_read(path_folder + 'run_0001_input1_20171018_211921.s1p')	
		si, f = rc.s1p_read(path_folder + 'run_0001_input2_20171018_211929.s1p')
		li, f = rc.s1p_read(path_folder + 'run_0001_input3_20171018_211937.s1p')
		ai, f = rc.s1p_read(path_folder + 'run_0001_input4_20171018_211945.s1p')
		
		
	elif case == '2018_046_a':  # There are 4 repetitions of this measurement, but they are all within the noise
				
		path_folder     = home_folder + '/DATA/EDGES/calibration/antenna_s11/low_band2/s11/raw/low2-2018-02-15-a/'
		oi, f = rc.s1p_read(path_folder + '2018_046_16_06_13_input1.s1p')
		si, f = rc.s1p_read(path_folder + '2018_046_16_06_13_input2.s1p')
		li, f = rc.s1p_read(path_folder + '2018_046_16_06_13_input3.s1p')
		ai, f = rc.s1p_read(path_folder + '2018_046_16_06_13_input4.s1p')

	elif case == '2018_046_e':
		path_folder     = home_folder + '/DATA/EDGES/calibration/antenna_s11/low_band2/s11/raw/low2-2018-02-15-e/'
		oi, f = rc.s1p_read(path_folder + '2018_046_16_19_35_input1.s1p')
		si, f = rc.s1p_read(path_folder + '2018_046_16_19_35_input2.s1p')
		li, f = rc.s1p_read(path_folder + '2018_046_16_19_35_input3.s1p')
		ai, f = rc.s1p_read(path_folder + '2018_046_16_19_35_input4.s1p')		
		
		
			
				
	# Reflection references
	oref =  1*np.ones(len(f))
	sref = -1*np.ones(len(f))
	lref =  0*np.ones(len(f))


	# First correction
	aic  = rc.de_embed(oref, sref, lref, oi, si, li, ai)
	rcA  = aic[0]	
	

	# Cutting the data to useful range
	fr     = np.copy(f) #/1e6
	flow   = 50 * 1e6
	fhigh  = 200 * 1e6
	
	fc   = fr[(fr>=flow) & (fr<=fhigh)]
	rcB  = rcA[(fr>=flow) & (fr<=fhigh)]
	
		
	# Absolute calibration
	rcC = low_band_switch_correction_june_2016(rcB, f_in = fc)
	rcD = rcC[0]
	
		
	# Output variables
	outT = np.array([fc, np.real(rcD),  np.imag(rcD)])
	out  = outT.T
	
	
	# Saving
	if save == 'yes':
		
		# creating folder if necessary
		path_save = home_folder + '/DATA/EDGES/calibration/antenna_s11/low_band2/s11/corrected/' + case + '/'
		
		if not exists(path_save):
			makedirs(path_save)
				
		header   = 'freq [Hz]\tre(antenna_s11)\tim(antenna_s11)'		
		filename = 'S11_blade_low_band2_' + case + '.txt'	
		np.savetxt(path_save + filename,  out,  header=header)
		
		
	
	return out

































def low_band1_s11_calibration_measurements_200MHz_2017_11_25C(case, flow, fhigh, save='no', flag=''):

	"""

	Nov 27, 2017

	"""


	# Data paths
	path_LNA = home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band1/2017_11_25C_fieldfox/data/s11/raw/Receiver/'
	
	#main_path    = home_folder + '/DATA/EDGES/calibration/receiver_calibration/mid_band/MRO/data/s11/raw/25C/'	
	#path_ambient = main_path + 'Ambient/'
	#path_hot     = main_path + 'HotLoad/'
	#path_open    = main_path + 'LongCableOpen/'
	#path_shorted = main_path + 'LongCableShort/'
	#path_sim2    = main_path + 'AntSim2/'



	# ------- Receiver S11 ------------------------

	# Reading measurements
	if case == 1:
		o,   fr0  = rc.s1p_read(path_LNA + 'D1.s1p')   # A5        # 2nd repetition is a little better
		s,   fr0  = rc.s1p_read(path_LNA + 'D2.s1p')   # A6
		l,   fr0  = rc.s1p_read(path_LNA + 'D3.s1p')   # A7
		LNA0, fr0 = rc.s1p_read(path_LNA + 'D4.s1p')   # A8

	elif case == 2:
		o,   fr0  = rc.s1p_read(path_LNA + 'D5.s1p')   # A5        # 2nd repetition is a little better
		s,   fr0  = rc.s1p_read(path_LNA + 'D6.s1p')   # A6
		l,   fr0  = rc.s1p_read(path_LNA + 'D7.s1p')   # A7
		LNA0, fr0 = rc.s1p_read(path_LNA + 'D8.s1p')   # A8

	elif case == 3:
		o,   fr0  = rc.s1p_read(path_LNA + 'E1.s1p')   # A5        # 2nd repetition is a little better
		s,   fr0  = rc.s1p_read(path_LNA + 'E2.s1p')   # A6
		l,   fr0  = rc.s1p_read(path_LNA + 'E3.s1p')   # A7
		LNA0, fr0 = rc.s1p_read(path_LNA + 'E4.s1p')   # A8
				
	elif case == 4:
		o,   fr0  = rc.s1p_read(path_LNA + 'E5.s1p')   # A5        # 2nd repetition is a little better
		s,   fr0  = rc.s1p_read(path_LNA + 'E6.s1p')   # A6
		l,   fr0  = rc.s1p_read(path_LNA + 'E7.s1p')   # A7
		LNA0, fr0 = rc.s1p_read(path_LNA + 'E8.s1p')   # A8
		



	# Models of standards
	resistance_of_match = 49.7 # female 49.6   49.99
	md = 1
	oa, sa, la = rc.agilent_85033E(fr0, resistance_of_match, md)

	# Correction of measurements
	LNAc, x1, x2, x3   = rc.de_embed(oa, sa, la, o, s, l, LNA0)

	LNA = LNAc[(fr0/1e6>=flow) & (fr0/1e6<=fhigh)]
	fr  = fr0[(fr0/1e6>=flow) & (fr0/1e6<=fhigh)]





	# Output variables
	out_T = np.array([fr, np.real(LNA),  np.imag(LNA)])
	
	out0 = out_T.T
	out  = out0[(fr>=50e6) & (fr<=200e6),:]
	
	
	header   = 'freq [Hz]\tre(receiver_s11)\tim(receiver_s11)'	
	filename = 'S11_low_band1_2017_11_25C_field_rep' + str(int(case)) + '_50-200MHz.txt'	
	np.savetxt(home_folder + '/DATA/EDGES/calibration/receiver_calibration/low_band1/2017_11_25C_fieldfox/data/s11/corrected/Receiver/' + filename,  out,  header=header)
	

	return fr, LNA










































def calibration_processing_mid_band_2017_11_25C(flow, fhigh, save='no', save_folder=0):


	"""

	Modification: November 27, 2017.

	"""


	# Main folder
	main_folder     = home_folder + '/DATA/EDGES/calibration/receiver_calibration/mid_band/2017_11_15C_25C_35C/'


	# Paths for source data
	path_spectra    = main_folder + 'data/spectra/300_350/'
	path_resistance = main_folder + 'data/resistance/corrected/'
	path_s11        = main_folder + 'data/s11/corrected/'


	# Creating output folders
	if save == 'yes':

		if not exists(main_folder + 'results/' + save_folder + '/temp/'):
			makedirs(main_folder + 'results/' + save_folder + '/temp/')

		if not exists(main_folder + 'results/' + save_folder + '/spectra/'):
			makedirs(main_folder + 'results/' + save_folder + '/spectra/')

		if not exists(main_folder + 'results/' + save_folder + '/s11/'):
			makedirs(main_folder + 'results/' + save_folder + '/s11/')

		if not exists(main_folder + 'results/' + save_folder + '/data/'):
			makedirs(main_folder + 'results/' + save_folder + '/data/')

		if not exists(main_folder + 'results/' + save_folder + '/calibration_files/'):
			makedirs(main_folder + 'results/' + save_folder + '/calibration_files/')			

		if not exists(main_folder + 'results/' + save_folder + '/plots/'):
			makedirs(main_folder + 'results/' + save_folder + '/plots/')


		# Output folders
		path_par_temp    = main_folder + 'results/' + save_folder + '/temp/'
		path_par_spectra = main_folder + 'results/' + save_folder + '/spectra/'
		path_par_s11     = main_folder + 'results/' + save_folder + '/s11/'
		path_data        = main_folder + 'results/' + save_folder + '/data/'




	# Spectra/resistance files
	file_ambient1 = path_spectra + 'level1_Ambient_25C_2017_286_00_300_350.mat'
	file_ambient2 = path_spectra + 'level1_Ambient_25C_2017_287_00_300_350.mat'
	spec_ambient  = [file_ambient1, file_ambient2]
	res_ambient   = path_resistance + 'ambient.txt'


	# Hot
	file_hot1 = path_spectra + 'level1_HotLoad_25C_2017_288_00_300_350.mat'	
	file_hot2 = path_spectra + 'level1_HotLoad_25C_2017_289_00_300_350.mat'
	spec_hot  = [file_hot1, file_hot2]
	res_hot   = path_resistance + 'hot.txt'


	# Open Cable
	file_open1 = path_spectra + 'level1_Longcable_Open_25C_2017_294_00_300_350.mat'
	spec_open  = [file_open1]  # 
	res_open   = path_resistance + 'open_cable.txt'


	# Shorted Cable
	file_shorted1 = path_spectra + 'level1_Longcable_Short_25C_2017_292_00_300_350.mat'
	file_shorted2 = path_spectra + 'level1_Longcable_Short_25C_2017_293_00_300_350.mat'
	spec_shorted  = [file_shorted1, file_shorted2] #  
	res_shorted   = path_resistance + 'shorted_cable.txt'


	# Antenna Simulator 2
	file_sim21  = path_spectra + 'level1_AntSim2_25C_2017_295_00_300_350.mat'
	file_sim22  = path_spectra + 'level1_AntSim2_25C_2017_296_00_300_350.mat'
	spec_sim2   = [file_sim21, file_sim22]
	res_sim2    = path_resistance + 'antenna_simulator2.txt'






	# Average calibration spectra / physical temperature
	# Percentage of initial data to leave out
	percent = 5 # 5%
	ssa,    phys_temp_ambient    = average_calibration_spectrum(spec_ambient,    res_ambient, 1*percent, plot='no')
	ssh,    phys_temp_hot        = average_calibration_spectrum(spec_hot,        res_hot,     2*percent, plot='no')
	sso,    phys_temp_open       = average_calibration_spectrum(spec_open,       res_open,    1*percent, plot='no')
	sss,    phys_temp_shorted    = average_calibration_spectrum(spec_shorted,    res_shorted, 1*percent, plot='no')
	sss1,   phys_temp_sim1       = average_calibration_spectrum(spec_sim2,       res_sim2,    1*percent, plot='no')
	sss2,   phys_temp_sim2       = average_calibration_spectrum(spec_sim2,       res_sim2,    1*percent, plot='no')






	# Select frequency range
	ff, ilow, ihigh = frequency_edges(flow, fhigh)
	fe    = ff[ilow:ihigh+1]
	sa    = ssa[ilow:ihigh+1]
	sh    = ssh[ilow:ihigh+1]
	so    = sso[ilow:ihigh+1]
	ss    = sss[ilow:ihigh+1]
	ss1   = sss1[ilow:ihigh+1]
	ss2   = sss2[ilow:ihigh+1]



	## RFI cleaning of cable measurements at raw resolution
	#Nsigma    = 3.5
	#Nterms_fg = 45
	#wo     = RFI_cleaning_spectrum_raw(fe, so, np.ones(len(fe)), Nterms_fg=Nterms_fg, Nsigma=Nsigma)   # 45 terms for 50-120 MHz
	#ws     = RFI_cleaning_spectrum_raw(fe, ss, np.ones(len(fe)), Nterms_fg=Nterms_fg, Nsigma=Nsigma)   # 45 terms for 50-120 MHz




	# Spectra modeling
	fen = (fe-75)/25
	fit_spec_ambient    = fit_polynomial_fourier('fourier',    fen, sa,     9,  plot='no')
	fit_spec_hot        = fit_polynomial_fourier('fourier',    fen, sh,     9,  plot='no')
	# fit_spec_open       = fit_polynomial_fourier('fourier',    fen, so,    31,  Weights=wo, plot='no')
	# fit_spec_shorted    = fit_polynomial_fourier('fourier',    fen, ss,    31,  Weights=ws, plot='no')
	fit_spec_open       = fit_polynomial_fourier('fourier',    fen, so,    31,  plot='no')
	fit_spec_shorted    = fit_polynomial_fourier('fourier',    fen, ss,    31,  plot='no')	
	fit_spec_sim1       = fit_polynomial_fourier('fourier',    fen, ss1,   15,  plot='no')
	fit_spec_sim2       = fit_polynomial_fourier('fourier',    fen, ss2,   15,  plot='no')




	## Second layer of RFI cleanning
	#model_open    = fit_spec_open[1]
	#model_shorted = fit_spec_shorted[1]	
	#wo2 = RFI_cleaning_spectrum_raw(fe, so-model_open,    wo, Nterms_fg=1, Nsigma=2.5)
	#ws2 = RFI_cleaning_spectrum_raw(fe, ss-model_shorted, ws, Nterms_fg=1, Nsigma=2.5)

	## Replacing channels with RFI with models
	#for i in range(len(fe)):
		#if wo2[i] == 0:
			#so[i] = model_open[i]

		#if ws2[i] == 0:
			#ss[i] = model_shorted[i]	






	# Loading S11 data (both files produce same results)
	s11 = np.genfromtxt(path_s11 + 's11_calibration_mid_band_LNA25degC_2017-11-22-18-38-14.txt')

	for i in range(len(s11[:,0])-1):
		if (s11[i,0] <= flow) and (s11[i+1,0] > flow):
			index_low = i
		if (s11[i,0] < fhigh) and (s11[i+1,0] >= fhigh):
			index_high = i+1
	index_s11 = np.arange(index_low, index_high+1)

	# Frequency / complex data
	f_s11       = s11[index_s11, 0]
	s11_LNA     = s11[index_s11, 1]  + 1j*s11[index_s11, 2]
	s11_amb     = s11[index_s11, 3]  + 1j*s11[index_s11, 4]
	s11_hot     = s11[index_s11, 5]  + 1j*s11[index_s11, 6]
	s11_open    = s11[index_s11, 7]  + 1j*s11[index_s11, 8]
	s11_shorted = s11[index_s11, 9]  + 1j*s11[index_s11, 10]
	s11_sr      = s11[index_s11, 11] + 1j*s11[index_s11, 12]
	s12s21_sr   = s11[index_s11, 13] + 1j*s11[index_s11, 14]
	s22_sr      = s11[index_s11, 15] + 1j*s11[index_s11, 16]
	s11_simu2   = s11[index_s11, 17] + 1j*s11[index_s11, 18]
	s11_simu1   = np.copy(s11_simu2)




	# Magnitude / Angle

	# LNA
	s11_LNA_mag     = np.abs(s11_LNA)
	s11_LNA_ang     = np.unwrap(np.angle(s11_LNA))

	# Ambient
	s11_amb_mag     = np.abs(s11_amb)
	s11_amb_ang     = np.unwrap(np.angle(s11_amb))

	# Hot
	s11_hot_mag     = np.abs(s11_hot)
	s11_hot_ang     = np.unwrap(np.angle(s11_hot))

	# Open
	s11_open_mag    = np.abs(s11_open)
	s11_open_ang    = np.unwrap(np.angle(s11_open))

	# Shorted
	s11_shorted_mag = np.abs(s11_shorted)
	s11_shorted_ang = np.unwrap(np.angle(s11_shorted))

	# sr-s11
	s11_sr_mag      = np.abs(s11_sr)
	s11_sr_ang      = np.unwrap(np.angle(s11_sr))

	# sr-s12s21
	s12s21_sr_mag   = np.abs(s12s21_sr)
	s12s21_sr_ang   = np.unwrap(np.angle(s12s21_sr))

	# sr-s22
	s22_sr_mag      = np.abs(s22_sr)
	s22_sr_ang      = np.unwrap(np.angle(s22_sr))

	# Simu1
	s11_simu1_mag   = np.abs(s11_simu1)
	s11_simu1_ang   = np.unwrap(np.angle(s11_simu1))

	# Simu2
	s11_simu2_mag   = np.abs(s11_simu2)
	s11_simu2_ang   = np.unwrap(np.angle(s11_simu2))	





	# Modeling S11

	f_s11n = (f_s11-75)/25

	fit_s11_LNA_mag     = fit_polynomial_fourier('fourier',    f_s11n, s11_LNA_mag,     27, plot='no') # 15
	fit_s11_LNA_ang     = fit_polynomial_fourier('fourier',    f_s11n, s11_LNA_ang,     27, plot='no') # 15

	fit_s11_amb_mag     = fit_polynomial_fourier('fourier',    f_s11n, s11_amb_mag,     27, plot='no') 
	fit_s11_amb_ang     = fit_polynomial_fourier('fourier',    f_s11n, s11_amb_ang,     27, plot='no') 

	fit_s11_hot_mag     = fit_polynomial_fourier('fourier',    f_s11n, s11_hot_mag,     27, plot='no')  
	fit_s11_hot_ang     = fit_polynomial_fourier('fourier',    f_s11n, s11_hot_ang,     27, plot='no') 

	fit_s11_open_mag    = fit_polynomial_fourier('fourier',    f_s11n, s11_open_mag,    27, plot='no')
	fit_s11_open_ang    = fit_polynomial_fourier('fourier',    f_s11n, s11_open_ang,    27, plot='no')

	fit_s11_shorted_mag = fit_polynomial_fourier('fourier',    f_s11n, s11_shorted_mag, 27, plot='no')
	fit_s11_shorted_ang = fit_polynomial_fourier('fourier',    f_s11n, s11_shorted_ang, 27, plot='no')

	fit_s11_sr_mag      = fit_polynomial_fourier('polynomial', f_s11n, s11_sr_mag,       5, plot='no') 
	fit_s11_sr_ang      = fit_polynomial_fourier('polynomial', f_s11n, s11_sr_ang,       5, plot='no') 

	fit_s12s21_sr_mag   = fit_polynomial_fourier('polynomial', f_s11n, s12s21_sr_mag,    5, plot='no') 
	fit_s12s21_sr_ang   = fit_polynomial_fourier('polynomial', f_s11n, s12s21_sr_ang,    5, plot='no') 

	fit_s22_sr_mag      = fit_polynomial_fourier('polynomial', f_s11n, s22_sr_mag,       5, plot='no') 
	fit_s22_sr_ang      = fit_polynomial_fourier('polynomial', f_s11n, s22_sr_ang,       5, plot='no') 

	fit_s11_simu1_mag   = fit_polynomial_fourier('fourier',    f_s11n, s11_simu1_mag,    19, plot='no')
	fit_s11_simu1_ang   = fit_polynomial_fourier('fourier',    f_s11n, s11_simu1_ang,    19, plot='no')

	fit_s11_simu2_mag   = fit_polynomial_fourier('fourier',    f_s11n, s11_simu2_mag,    19, plot='no')
	fit_s11_simu2_ang   = fit_polynomial_fourier('fourier',    f_s11n, s11_simu2_ang,    19, plot='no')



	# Saving output parameters
	if save == 'yes':


		# Average spectra data in frequency range selected
		spectra = np.array([fe, sa, sh, so, ss, ss1, ss2]).T		

		# RMS residuals
		RMS_spectra = np.zeros((6,1))
		RMS_s11     = np.zeros((20,1))

		# Spectra
		RMS_spectra[0, 0] = fit_spec_ambient[2]
		RMS_spectra[1, 0] = fit_spec_hot[2]
		RMS_spectra[2, 0] = fit_spec_open[2]
		RMS_spectra[3, 0] = fit_spec_shorted[2]
		RMS_spectra[4, 0] = fit_spec_sim1[2]
		RMS_spectra[5, 0] = fit_spec_sim2[2]


		# S11
		RMS_s11[0, 0]  = fit_s11_LNA_mag[2]
		RMS_s11[1, 0]  = fit_s11_LNA_ang[2]
		RMS_s11[2, 0]  = fit_s11_amb_mag[2]
		RMS_s11[3, 0]  = fit_s11_amb_ang[2]
		RMS_s11[4, 0]  = fit_s11_hot_mag[2]
		RMS_s11[5, 0]  = fit_s11_hot_ang[2]
		RMS_s11[6, 0]  = fit_s11_open_mag[2]
		RMS_s11[7, 0]  = fit_s11_open_ang[2]
		RMS_s11[8, 0]  = fit_s11_shorted_mag[2]
		RMS_s11[9, 0]  = fit_s11_shorted_ang[2]
		RMS_s11[10, 0] = fit_s11_sr_mag[2]
		RMS_s11[11, 0] = fit_s11_sr_ang[2]
		RMS_s11[12, 0] = fit_s12s21_sr_mag[2]
		RMS_s11[13, 0] = fit_s12s21_sr_ang[2]
		RMS_s11[14, 0] = fit_s22_sr_mag[2]
		RMS_s11[15, 0] = fit_s22_sr_ang[2]
		RMS_s11[16, 0] = fit_s11_simu1_mag[2]
		RMS_s11[17, 0] = fit_s11_simu1_ang[2]
		RMS_s11[18, 0] = fit_s11_simu2_mag[2]
		RMS_s11[19, 0] = fit_s11_simu2_ang[2]



		# Formatting fit parameters

		# Physical temperature
		phys_temp = np.zeros((6,1))
		phys_temp[0,0] = phys_temp_ambient
		phys_temp[1,0] = phys_temp_hot
		phys_temp[2,0] = phys_temp_open
		phys_temp[3,0] = phys_temp_shorted
		phys_temp[4,0] = phys_temp_sim1
		phys_temp[5,0] = phys_temp_sim2		


		# Spectra
		par_spec_ambient    = np.reshape(fit_spec_ambient[0],    (-1,1))
		par_spec_hot        = np.reshape(fit_spec_hot[0],        (-1,1))
		par_spec_open       = np.reshape(fit_spec_open[0],       (-1,1))
		par_spec_shorted    = np.reshape(fit_spec_shorted[0],    (-1,1))
		par_spec_sim1       = np.reshape(fit_spec_sim1[0],       (-1,1))
		par_spec_sim2       = np.reshape(fit_spec_sim2[0],       (-1,1))


		# S11
		par_s11_LNA_mag     = np.reshape(fit_s11_LNA_mag[0],     (-1,1))
		par_s11_LNA_ang     = np.reshape(fit_s11_LNA_ang[0],     (-1,1))
		par_s11_amb_mag     = np.reshape(fit_s11_amb_mag[0],     (-1,1))
		par_s11_amb_ang     = np.reshape(fit_s11_amb_ang[0],     (-1,1))
		par_s11_hot_mag     = np.reshape(fit_s11_hot_mag[0],     (-1,1))
		par_s11_hot_ang     = np.reshape(fit_s11_hot_ang[0],     (-1,1))
		par_s11_open_mag    = np.reshape(fit_s11_open_mag[0],    (-1,1))
		par_s11_open_ang    = np.reshape(fit_s11_open_ang[0],    (-1,1))
		par_s11_shorted_mag = np.reshape(fit_s11_shorted_mag[0], (-1,1))
		par_s11_shorted_ang = np.reshape(fit_s11_shorted_ang[0], (-1,1))

		par_s11_sr_mag      = np.reshape(fit_s11_sr_mag[0],      (-1,1))
		par_s11_sr_ang      = np.reshape(fit_s11_sr_ang[0],      (-1,1))
		par_s12s21_sr_mag   = np.reshape(fit_s12s21_sr_mag[0],   (-1,1))
		par_s12s21_sr_ang   = np.reshape(fit_s12s21_sr_ang[0],   (-1,1))
		par_s22_sr_mag      = np.reshape(fit_s22_sr_mag[0],      (-1,1))
		par_s22_sr_ang      = np.reshape(fit_s22_sr_ang[0],      (-1,1))

		par_s11_simu1_mag   = np.reshape(fit_s11_simu1_mag[0],   (-1,1))
		par_s11_simu1_ang   = np.reshape(fit_s11_simu1_ang[0],   (-1,1))
		par_s11_simu2_mag   = np.reshape(fit_s11_simu2_mag[0],   (-1,1))
		par_s11_simu2_ang   = np.reshape(fit_s11_simu2_ang[0],   (-1,1))




		# Saving

		np.savetxt(path_data + 'average_spectra_300_350.txt', spectra)

		np.savetxt(path_par_temp    + 'physical_temperatures.txt', phys_temp)

		np.savetxt(path_par_spectra + 'par_spec_amb.txt',     par_spec_ambient)
		np.savetxt(path_par_spectra + 'par_spec_hot.txt',     par_spec_hot)
		np.savetxt(path_par_spectra + 'par_spec_open.txt',    par_spec_open)
		np.savetxt(path_par_spectra + 'par_spec_shorted.txt', par_spec_shorted)
		np.savetxt(path_par_spectra + 'par_spec_simu1.txt',   par_spec_sim1)
		np.savetxt(path_par_spectra + 'par_spec_simu2.txt',   par_spec_sim2)
		np.savetxt(path_par_spectra + 'RMS_spec.txt',         RMS_spectra)

		np.savetxt(path_par_s11 + 'par_s11_LNA_mag.txt',      par_s11_LNA_mag)
		np.savetxt(path_par_s11 + 'par_s11_LNA_ang.txt',      par_s11_LNA_ang)
		np.savetxt(path_par_s11 + 'par_s11_amb_mag.txt',      par_s11_amb_mag)
		np.savetxt(path_par_s11 + 'par_s11_amb_ang.txt',      par_s11_amb_ang)
		np.savetxt(path_par_s11 + 'par_s11_hot_mag.txt',      par_s11_hot_mag)
		np.savetxt(path_par_s11 + 'par_s11_hot_ang.txt',      par_s11_hot_ang)
		np.savetxt(path_par_s11 + 'par_s11_open_mag.txt',     par_s11_open_mag)
		np.savetxt(path_par_s11 + 'par_s11_open_ang.txt',     par_s11_open_ang)
		np.savetxt(path_par_s11 + 'par_s11_shorted_mag.txt',  par_s11_shorted_mag)
		np.savetxt(path_par_s11 + 'par_s11_shorted_ang.txt',  par_s11_shorted_ang)

		np.savetxt(path_par_s11 + 'par_s11_sr_mag.txt',       par_s11_sr_mag)
		np.savetxt(path_par_s11 + 'par_s11_sr_ang.txt',       par_s11_sr_ang)
		np.savetxt(path_par_s11 + 'par_s12s21_sr_mag.txt',    par_s12s21_sr_mag)
		np.savetxt(path_par_s11 + 'par_s12s21_sr_ang.txt',    par_s12s21_sr_ang)
		np.savetxt(path_par_s11 + 'par_s22_sr_mag.txt',       par_s22_sr_mag)
		np.savetxt(path_par_s11 + 'par_s22_sr_ang.txt',       par_s22_sr_ang)

		np.savetxt(path_par_s11 + 'par_s11_simu1_mag.txt',    par_s11_simu1_mag)
		np.savetxt(path_par_s11 + 'par_s11_simu1_ang.txt',    par_s11_simu1_ang)
		np.savetxt(path_par_s11 + 'par_s11_simu2_mag.txt',    par_s11_simu2_mag)
		np.savetxt(path_par_s11 + 'par_s11_simu2_ang.txt',    par_s11_simu2_ang)


		np.savetxt(path_par_s11 + 'RMS_s11.txt',       	      RMS_s11)


	# End
	print('Files processed.')

	return 1










def foreground_marginalization_parameters_and_models(Npix = 30):
	
	
	# High-Band data (just to get the frequency vector)
	d = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/products/average_spectrum/high_band_2015_LST_0.26_6.26_dates_2015_250_299_nominal.txt')
	v  = d[:,0]


	# Miscellaneous parameters
	v0   = 140
	Npar = 5


	# Range of parameters (observed ranges plus/minus 50% of range)
	
	# Values obtained from least squares fits to EDGES High-Band spectrum after removing each 21-cm model from 21cmFAST
	a0_low  =  310 - (330-310)/2
	a0_high =  330 + (330-310)/2

	a1_low  =   75 - (175-75)/2
	a1_high =  175 + (175-75)/2

	a2_low  = -320 - (-160 + 320)/2
	a2_high = -160 + (-160 + 320)/2
			
	a3_low  =  100 - (225-100)/2
	a3_high =  225 + (225-100)/2
			
	a4_low  =  -49 - (-23+49)/2
	a4_high =  -23 + (-23+49)/2
			
	
	# Parameter arrays
	a0 = np.linspace(a0_low, a0_high, Npix)
	a1 = np.linspace(a1_low, a1_high, Npix)
	a2 = np.linspace(a2_low, a2_high, Npix)
	a3 = np.linspace(a3_low, a3_high, Npix)
	a4 = np.linspace(a4_low, a4_high, Npix)
	
	
	# Initializing output arrays
	Nlength = Npix**Npar
	parameters_fg = np.random.normal(size=(Nlength, Npar))  # #parameters_fg = np.zeros((Nlength, Npar))
	models_fg     = np.random.normal(size=(Nlength, len(v)))     # np.zeros((Nlength, len(v)))
	
	
	# Storing parameters and foreground models
	index   = -1
	for i_a0 in range(Npix):
		print(i_a0)
		for i_a1 in range(Npix):
			for i_a2 in range(Npix):
				for i_a3 in range(Npix):
					for i_a4 in range(Npix):
						
						index = index + 1

						par_fg = np.array([a0[i_a0], a1[i_a1], a2[i_a2], a3[i_a3], a4[i_a4]])
						parameters_fg[index, :] = par_fg
						models_fg[index, :]     = model_evaluate('EDGES_polynomial', par_fg, v/v0)
	
	
	# Saving output arrays
	save_file = home_folder + '/DATA/EDGES/global_21cm_models/mesinger3/foreground_models/foreground_models_Npix' + str(Npix) + '.hdf5'
	with h5py.File(save_file, 'w') as hf:


		print('hola')


		hf.create_dataset('a0', data = a0)
		hf.create_dataset('a1', data = a1)
		hf.create_dataset('a2', data = a2)
		hf.create_dataset('a3', data = a3)
		hf.create_dataset('a4', data = a4)
		hf.create_dataset('parameters_fg',  data = parameters_fg)
		hf.create_dataset('models_fg',      data = models_fg)
	
	return a0, a1, a2, a3, a4, parameters_fg, models_fg











def read_foreground_parameters_and_models():
	
	# Likelihood results
	file_name = home_folder + '/DATA/EDGES/global_21cm_models/mesinger3/foreground_models/foreground_models_Npix10.hdf5'
	with h5py.File(file_name, 'r') as hf:

		X  = hf.get('a0')
		a0 = np.array(X)
		
		X  = hf.get('a1')
		a1 = np.array(X)
		
		X  = hf.get('a2')
		a2 = np.array(X)
		
		X  = hf.get('a3')
		a3 = np.array(X)
		
		X  = hf.get('a4')
		a4 = np.array(X)
		
		X             = hf.get('parameters_fg')
		parameters_fg = np.array(X)

		X         = hf.get('models_fg')
		models_fg = np.array(X)
		
		
		
	return a0, a1, a2, a3, a4, parameters_fg, models_fg














def EDGES_high_band_data(save='no', save_suffix='_test', simulated='no', residual_fraction=0.5):


	"""
	Dec 26, 2017
	"""


	# Loading High-band data
	data = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/products/average_spectrum/high_band_2015_LST_0.26_6.26_dates_2015_250_299_nominal.txt')
	
	vv = data[:,0]
	tt = data[:,1]
	ww = data[:,2]
	
	# Full length weight vector
	full_ww = np.copy(ww)  # this is provided to evaluate 21cm and fg models that were created for the full frequency vector	
	
	
	## Keeping only channels with data
	# Using full original arrays
	v = vv #[ww>0]
	t = tt #[ww>0]
	w = ww #[ww>0]
	


	# Computing noise standard deviation.
	# We divide the antenna temperature by sqrt(weights), and scale this division to enclose 68% of data after fitting and removing a polynomal and differencing from channel to channel
	Nk = 16
	par = fit_polynomial_fourier('EDGES_polynomial', v/140, t, Nk, Weights=w)
	model = par[1]
	res   = t-model

	diff    = np.zeros(len(v))
	weights = np.zeros(len(v))
	for i in range(len(v)-1):
		diff[i+1]    = res[i+1] - res[i]
		if np.abs(diff[i+1]) < 0.1:
			weights[i+1] = 1


	profile_not_normalized = t/np.sqrt(w)
	profile = profile_not_normalized/np.max(profile_not_normalized[w>0])
	max_diff = np.max(np.abs(diff[weights>0]))
	resolution = 10*max_diff/1e4
	scale = np.arange(0, 10*max_diff, resolution)
	error = 1e6
	for i in range(len(scale)):
		full = (np.abs(diff) - scale[i]*profile)[weights==1]
		len_full  = len(full)
		len_below = len(full[full<0])
		error_new = np.abs((len_below/len_full)-0.68)
		if error_new < error:
			error = np.copy(error_new)
			correct_scale_diff = scale[i]


	# Noise standard deviation	
	noise_std_profile = correct_scale_diff*profile/np.sqrt(2)
	
	# Change nans for 0
	noise_std_profile[ww==0]=0



	# Covariance matrix of noise
	#cov_noise = np.diag(noise_std_profile**2)

	## Covariance matrix of systematics
	#syst_std = 0.035 # mK
	#cov_syst = (syst_std**2)*np.eye(len(v))

	## Total covariance matrix
	#cov_total     = cov_noise + cov_syst
	#inv_cov_total = np.linalg.inv(cov_total)	

	
	

		
	if simulated == 'yes_just_noise':
		fit_out          = fit_polynomial_fourier('EDGES_polynomial', v, t, 5, Weights=w)
		model            = fit_out[1]
		simulated_noise  = np.random.normal(np.zeros(len(vv)), noise_std_profile)
		model_with_noise = model + simulated_noise
		model_with_noise[tt==0] = 0
		tt = np.copy(model_with_noise)
		
		
	if simulated == 'yes_above_125':
		fit_out          = fit_polynomial_fourier('EDGES_polynomial', v, t, 5, Weights=w)
		model            = fit_out[1]
		simulated_noise  = np.random.normal(np.zeros(len(vv)), noise_std_profile)
		model_with_noise = model + simulated_noise
		model_with_noise[vv<=125] = tt[vv<=125]
		model_with_noise[tt==0]   = 0
		tt = np.copy(model_with_noise)
		

	if simulated == 'yes_above_145':
		fit_out          = fit_polynomial_fourier('EDGES_polynomial', v, t, 5, Weights=w)
		model            = fit_out[1]
		simulated_noise  = np.random.normal(np.zeros(len(vv)), noise_std_profile)
		model_with_noise = model + simulated_noise
		model_with_noise[vv<=145] = tt[vv<=145]
		model_with_noise[tt==0]   = 0
		tt = np.copy(model_with_noise)




	if simulated == 'yes_noise_plus_ripples':
		fit_out          = fit_polynomial_fourier('EDGES_polynomial', v, t, 5, Weights=w)
		model            = fit_out[1]
		residuals        = t - model
		simulated_noise  = np.random.normal(np.zeros(len(vv)), noise_std_profile)
		model_with_noise = model + residual_fraction*residuals + (1-residual_fraction)*simulated_noise
		model_with_noise[tt==0] = 0
		tt = np.copy(model_with_noise)
		
		print('HOLA!! ' + str(residual_fraction) + '%')
		
		
		
	
	if save == 'yes':
		out = np.array([vv, tt, ww, noise_std_profile]).T
		np.savetxt(home_folder + '/DATA/EDGES/results/high_band/products/average_spectrum/high_band_2015_LST_0.26_6.26_dates_2015_250_299' + save_suffix + '.txt', out, header='freq [MHz]\t\ttemp [K]\t\tweights [#]\t\tnoise std [K]')

		

	
	return vv, tt, ww, noise_std_profile # these arrays have the original length of EDGES High-Band vector


















def likelihood_21cm_model(v, t, cov_total, inv_cov_total, model_21cm, model_fg):

	# Amplitude of likelihood
	amplitude    = 1/(np.sqrt(((2*np.pi)**len(v))*np.linalg.det(90*cov_total)))
	
	# Full data model
	model_full   = model_21cm + model_fg
	
	# Computing chi square
	diff         = np.reshape(t-model_full, (1, -1))
	left_dot     = np.dot(diff, inv_cov_total)
	chi_sq       = np.dot(left_dot, diff.T )
	
	print(np.exp(-(1/2)*chi_sq[0,0]))

	# Likelihood
	Likelihood   = amplitude * np.exp(-(1/2)*chi_sq[0,0])
	
	return Likelihood, diff #[0,0]








def likelihood_foreground_marginalization():
	
	# Loading EDGES High-Band data
	v, t, cov_total, inv_cov_total, ww = EDGES_high_band_data_and_covariance_matrix()
	
	
	# Fixed 21cm model for testing
	model21, aux = model_eor_mesinger(0, v, interpolation_kind='linear')
	
	# Foreground models
	a0, a1, a2, a3, a4, parameters_fg, models_fg = read_foreground_parameters_and_models()
	
	# For Loop over foreground models
	N_models_fg = len(models_fg[:,0])
	L = np.random.normal(size=(N_models_fg))
	for i in range(N_models_fg):
		print(i)
		L[i] = likelihood_21cm_model(v, t, cov_total, inv_cov_total, model21, models_fg[i,ww>0])
	
	
	return L






















	

























def plot_fialkov_likelihood_best_fit_model():
	
	file_name1 = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/Global21cmV5/results/results_Npar4_Npix20_syst_0mK_Nfg5.hdf5'
	file_name2 = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/Global21cmV5/results/results_Npar4_Npix20_syst_5mK_Nfg5.hdf5'
	
	v, signals1, par_21, p1, p2, p3, p4, p5, p6, p7, flags, xHI59, xHI754, Zeta, LE1, chi_sq, par_fg = read_likelihood_fialkov(file_name1)	
	v, signals2, par_21, p1, p2, p3, p4, p5, p6, p7, flags, xHI59, xHI754, Zeta, LE2, chi_sq, par_fg = read_likelihood_fialkov(file_name2)

	bf1 = signals1[LE1==np.max(LE1),:][0]
	bf2 = signals2[LE2==np.max(LE2),:][0]
	

	
	
	d = EDGES_high_band_data(save='no', save_suffix='_test', simulated='no', residual_fraction=0.5)
	
	k0       = fit_polynomial_fourier('EDGES_polynomial', d[0], d[1], 5, Weights=d[2])
	model_0  = k0[1]
	
	k1       = fit_polynomial_fourier('EDGES_polynomial', d[0], d[1]-bf1, 5, Weights=d[2])
	model_1  = k1[1]	
	
	k2       = fit_polynomial_fourier('EDGES_polynomial', d[0], d[1]-bf2, 5, Weights=d[2])
	model_2  = k2[1]
	
	
	plt.figure(1)
	
	#plt.subplot(2,1,1)
	#plt.plot(d[0][d[2]>0], 1000*(d[1]-model_0)[d[2]>0])
	#plt.plot(d[0][d[2]>0], 1000*(d[1]-bf1-model_1)[d[2]>0])
	#plt.plot(d[0][d[2]>0], 1000*(d[1]-bf2-model_2)[d[2]>0])
	#plt.ylim([-300, 300])
	
	#plt.subplot(2,1,2)
	plt.plot(v, 1000*bf1)
	plt.plot(v, 1000*bf2)	
	plt.plot(d[0][d[2]>0], 0+1000*(d[1]-model_0)[d[2]>0])
	plt.plot(d[0][d[2]>0], 0+1000*(d[1]-bf1-model_1)[d[2]>0])
	plt.plot(d[0][d[2]>0], 0+1000*(d[1]-bf2-model_2)[d[2]>0])	
	plt.ylim([-400,100])
	plt.xlabel('frequency [MHz]')
	plt.ylabel('temperature [mK]')
	plt.grid()
	plt.legend(['best fit 1, syst 0 mK','best fit 2, syst 5 mK', 'residuals just foreground model', 'residuals foreground model + best fit 1', 'residuals foreground model + best fit 2'])
	
	
	
	
	
	return v, signals1, signals2, LE1, LE2














def low_band_DM_TRY1_amplitude_fit(model_type_low='Physical_model', model_type_high='EDGES_polynomial', sigma_low=0.025, sigma_high=0.017, remove_camel_signal='no', low_band_data_case=2, filename='test'):
	
	# Load Models
	m     = sio.loadmat(home_folder + '/DATA/EDGES/global_21cm_models/fialkov/low_band_DM/models/global_all.mat')
	GL    = m['GL']
	v_raw = GL[0,:,0]
			
	# Load EDGES data
	# Nominal flattened Gaussian parameters:  -0.53, 78.1, 18.7, 7
	v_low,  t_low,  w_low,  res1, res2, t21   = alan_low_band_spectrum(case = low_band_data_case)
	
	if remove_camel_signal == 'yes':
		T21   = model_eor_flattened_gaussian(v_low, model_type=1, T21=-0.53, vr=78.1, dv=18.7, tau0=7, tilt=0)
		t_low = t_low - T21
		print('NO CAMEL SIGNAL')
	
	
	v_high, t_high, w_high, noise_std_profile = EDGES_high_band_data(save='no', save_suffix='_test', simulated='no', residual_fraction=0.5)



	if model_type_low == 'Physical_model':
		model_type_low_amplitude_fit='Physical_model_plus_external'
	elif model_type_low == 'EDGES_polynomial':
		model_type_low_amplitude_fit='EDGES_polynomial_plus_external'
	
	if model_type_high == 'Physical_model':
		model_type_high_amplitude_fit='Physical_model_plus_external'
	elif model_type_high == 'EDGES_polynomial':
		model_type_high_amplitude_fit='EDGES_polynomial_plus_external'
		
		
	print(model_type_low)
	print(model_type_low_amplitude_fit)
	
	print(model_type_high)
	print(model_type_high_amplitude_fit)	
		
		
		
	
	Nfg_low         = 5
	Nfg_high        = 5
	
		
	L_ASTR  = len(GL[:,0,0])
	L_DM    = len(GL[0,0,3::])
	Nmodels = L_ASTR * L_DM
	
	
	# Initializing arrays
	model21_low_all    = np.zeros((Nmodels, len(v_low)))
	model21_high_all   = np.zeros((Nmodels, len(v_high)))
	results_all        = np.zeros((Nmodels, 10))
	
	
	#sigma_high_all = np.zeros(Nmodels)	
	#par_low_all    = np.zeros((Nmodels, 6))
	#par_high_all   = np.zeros((Nmodels, 6))
	
	RMS_all  = np.zeros(Nmodels)
	

	# Evaluate models
	for j in range(L_ASTR):  # (10):     #   
		
		print(str(j+1) + ' out of ' + str(L_ASTR))
		for i in range(L_DM):
			
			
			#print(str(j) + ' ' + str(i))
			
			if remove_camel_signal == 'yes':
				print('NO CAMEL SIGNAL ----------')
			
			
			index_model = (j*L_DM) + i
			
			
			# Interpolate model to Low-Band range
			model_raw_K     = GL[j,:,3+i]/1000
			func_model      = spi.interp1d(v_raw, model_raw_K, kind='linear')
			
			# 21-cm models
			model21_low_K   = func_model(v_low)
			model21_high_K  = func_model(v_high)
			
			

				
			if (j == 2814) and (i == 0):
				a21_low = 0
				s21_low = 0
				RMS_low = 0
				
				a21_high = 0
				s21_high = 0
				RMS_high = 0
					
					
					
			else:
				
				# Parameter fitting
				plow  = fit_polynomial_fourier(model_type_low_amplitude_fit,  v_low/200,  t_low,  Nfg_low,  Weights=w_low,  external_model_in_K=model21_low_K)	
				phigh = fit_polynomial_fourier(model_type_high_amplitude_fit, v_high/200, t_high, Nfg_high, Weights=w_high, external_model_in_K=model21_high_K)	
				
				
				
				# Full Models
				full_model_low  = plow[1]
				full_model_high = phigh[1]
					
				# RMS		
				RMS_low     = np.std((t_low  - full_model_low)[w_low>0])
				RMS_high    = np.std((t_high - full_model_high)[w_high>0])
				
				# 21cm Amplitudes and Uncertainties
				a21_low = plow[0][-1]
				s21_low = np.sqrt(np.diag(plow[3])[-1])
				
				a21_high = phigh[0][-1]
				s21_high = np.sqrt(np.diag(phigh[3])[-1])
				
				# Chi Squares
				syst_low  = 0.0001 #0.025 #0.100 # K
				syst_high = 0.0001 #0.035 # K
				#noise_std_profile
				Ll, parl, chi_sq_low  = likelihood_21cm_V2(v_low,  t_low,  w_low,  sigma_low,  syst_low,  model21_low_K,  5, 200, foreground_model=model_type_low)
				Lh, parh, chi_sq_high = likelihood_21cm_V2(v_high, t_high, w_high, sigma_high, syst_high, model21_high_K, 5, 200, foreground_model=model_type_high)

				
				

							
			# Storing models and fit parameters
			model21_low_all[index_model, :]   = model21_low_K
			model21_high_all[index_model, :]  = model21_high_K
			
			results_all[index_model, 0] = j   +1    # Astrophysical model index
			results_all[index_model, 1] = 3+i +1    # DM model index
			
			results_all[index_model, 2] = a21_low   # best-fit of 21cm amplitude
			results_all[index_model, 3] = s21_low     # uncertainty of 21cm amplitude
			results_all[index_model, 4] = RMS_low
			results_all[index_model, 5] = chi_sq_low
			
			results_all[index_model, 6] = a21_high   # best-fit of 21cm amplitude
			results_all[index_model, 7] = s21_high     # uncertainty of 21cm amplitude
			results_all[index_model, 8] = RMS_high
			results_all[index_model, 9] = chi_sq_high
						
			#print(str(a21_fit) + ' +/- ' + str(sigma))
					

	# Saving text file
	np.savetxt(home_folder + '/DATA/EDGES/global_21cm_models/fialkov/low_band_DM/results/' + filename + '.txt', results_all, 
	           header='index ASTRO\t index DM\t a21_low\t s21_low\t RMS_low\t chi_sq_low\t a21_high\t s21_high\t RMS_high\t chi_sq_high')
			


	# # Saving output arrays
	# save_file = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/low_band_DM/results/final_models_20180327_NO_camel_signal_total_low_0.025K_total_high_0.017K.hdf5'
	# with h5py.File(save_file, 'w') as hf:

		# hf.create_dataset('models_low',   data = model21_low_all)
		# hf.create_dataset('models_high',  data = model21_high_all)
	
	return model21_low_all, model21_high_all, results_all












def low_band_DM_analysis():
	
	
	d = np.genfromtxt(home_folder + '/DATA/EDGES/global_21cm_models/fialkov/low_band_DM/results/final_results_20180307.txt')
	
	# Loading results
	path_file = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/low_band_DM/results/final_models_20180307.hdf5'
	with h5py.File(path_file,'r') as hf:

		hfx    = hf.get('models_low')
		ml     = np.array(hfx)
		
		hfx    = hf.get('models_high')
		mh     = np.array(hfx)
		
		
	sl  = np.abs(d[:,2]-1)/d[:,3]
	sh = np.abs(d[:,6]-1)/d[:,7]
	
	
	
	index = np.arange(len(d[:,1]))
	
	il = index[(d[:,1]==4)]
	ih = index[(d[:,1]==4)]
	
	
	iXl = il[sl[il]<1] 
	iXh = ih[sh[ih]<1]
	iX_1sigma  = np.intersect1d(iXl, iXh)
	
	
	kk  = sl[il]
	kkk = kk[kk!=np.inf]
	plt.hist(kkk,100)
	
	
	
	# Load Models
	m  = sio.loadmat(home_folder + '/DATA/EDGES/global_21cm_models/fialkov/low_band_DM/models/global_all.mat')
	GL = m['GL']
	v_raw = GL[0,:,0]
	
	
	
	

	
	
	
	
	
	
	
	
	return d, ml, mh, sl, sh, il, ih, iXl, iXh, iX_1sigma, GL








































def low_band_DM_TRY2_likelihood():
	
	# Load Models
	m  = sio.loadmat('/home/ramo7131/DATA/EDGES/global_21cm_models/fialkov/low_band_DM/models/global_all.mat')
	GL = m['GL']
	v_raw = GL[0,:,0]
			
	# Load EDGES data
	v_low, t_low, w_low = alan_low_band_spectrum()
	v_high, t_high, w_high, noise_std_profile = EDGES_high_band_data(save='no', save_suffix='_test', simulated='no', residual_fraction=0.5)


	L_ASTR  = len(GL[:, 0, 0])
	L_DM    = len(GL[0, 0, 3::])
	Nmodels = L_ASTR * L_DM
	
	
	# Initializing arrays
	index_array     = np.zeros((Nmodels, 2))
	
	model21_low_all = np.zeros((Nmodels, len(v_low)))	
	L_low_all       = np.zeros((Nmodels, 2))
	par_fg_low_all  = np.zeros((Nmodels, 5))
	chi_sq_low_all  = np.zeros(Nmodels)
	
	model21_high_all = np.zeros((Nmodels, len(v_high)))
	L_high_all       = np.zeros((Nmodels, 2))
	par_fg_high_all  = np.zeros((Nmodels, 5))
	chi_sq_high_all  = np.zeros(Nmodels)	
	
	

	# Evaluate models
	for j in range(L_ASTR):     # (10): #
		for i in range(L_DM):
			
			index_model = (j*L_DM) + i
			
			
			# Interpolate model to Low-Band range
			model_raw_K    = GL[j,:,3+i]/1000
			func_model     = spi.interp1d(v_raw, model_raw_K, kind='linear')
			
			model21_low_K   = func_model(v_low)
			model21_high_K  = func_model(v_high)
			
	
	
	
			index_array[index_model, 0] = j   +1
			index_array[index_model, 1] = 3+i +1
	
	
			
			# Low Band
			L, parX, chi_sq = likelihood_21cm_V2(v_low, t_low, w_low, 0.025, 0.0001, model21_low_K, 5, 200, foreground_model='Physical_model')
			
			model21_low_all[index_model, :] = model21_low_K
			L_low_all[index_model, 0]       = index_model
			L_low_all[index_model, 1]       = L
			par_fg_low_all[index_model, :]  = parX
			chi_sq_low_all[index_model]     = chi_sq
		
			
			
			# High Band
			L, parX, chi_sq = likelihood_21cm_V2(v_high, t_high, w_high, noise_std_profile, 0.035, model21_high_K, 5, 200, foreground_model='EDGES_polynomial')
			
			model21_high_all[index_model, :] = model21_high_K
			L_high_all[index_model, 0]       = index_model
			L_high_all[index_model, 1]       = L
			par_fg_high_all[index_model, :]  = parX
			chi_sq_high_all[index_model]     = chi_sq

			
			print(index_model+1)
			

		
	# Saving text file
	out_txt_T = np.array([index_array[:,0], index_array[:,1], chi_sq_low_all, chi_sq_high_all])
	out_txt   = out_txt_T.T
	np.savetxt(home_folder + '/DATA/EDGES/global_21cm_models/fialkov/low_band_DM/results/chi_sq_results.txt', out_txt, header='index ASTRO\tindex DM\tchi_sq_Low-Band\tchi_sq_High-Band')
	
	
	# Saving output arrays
	save_file = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/low_band_DM/results/chi_sq_results.hdf5'
	with h5py.File(save_file, 'w') as hf:

		print('hola')

		hf.create_dataset('index_array',  data = index_array)	
		hf.create_dataset('v_low',        data = v_low)
		hf.create_dataset('models_low',   data = model21_low_all)
		hf.create_dataset('chi_sq_low',   data = chi_sq_low_all)
		hf.create_dataset('v_high',       data = v_high)
		hf.create_dataset('models_high',  data = model21_high_all)
		hf.create_dataset('chi_sq_high',  data = chi_sq_high_all)
		

					
	return index_array, v_low, model21_low_all, chi_sq_low_all, v_high, model21_high_all, chi_sq_high_all, out_txt




















def low_band_DM_TRY2_chi_square():
	
	# Load Models
	m  = sio.loadmat('/home/ramo7131/DATA/EDGES/global_21cm_models/fialkov/low_band_DM/models/global_all.mat')
	GL = m['GL']
	v_raw = GL[0,:,0]
			
	# Load EDGES data
	v_low, t_low, w_low = alan_low_band_spectrum()
	v_high, t_high, w_high, noise_std_profile = EDGES_high_band_data(save='no', save_suffix='_test', simulated='no', residual_fraction=0.5)


	# Low-Band Signature
	T21 = model_eor_flattened_gaussian(v_low, model_type=1, T21=-0.5, vr=78, dv=19, tau0=7, tilt=0)
	

	# Covariance Matrix of Signature (total = systematics + noise)
	COV_low = flattened_gaussian_covariance(v_low)
	inv_COV_low = np.linalg.inv(COV_low)


	L_ASTR  = len(GL[:, 0, 0])
	L_DM    = len(GL[0, 0, 3::])
	Nmodels = L_ASTR * L_DM
	
	
	# Initializing arrays
	index_array     = np.zeros((Nmodels, 2))
	
	residuals_low_all = np.zeros((Nmodels, len(v_low)))
	model21_low_all   = np.zeros((Nmodels, len(v_low)))
	chi_sq_low_all    = np.zeros(Nmodels)
	
	residuals_high_all = np.zeros((Nmodels, len(v_high)))
	model21_high_all = np.zeros((Nmodels, len(v_high)))
	chi_sq_high_all  = np.zeros(Nmodels)	
	
	

	# Evaluate models
	for j in range(L_ASTR):  # 
		for i in range(L_DM):
			
			index_model = (j*L_DM) + i
			
			
			# Interpolate model to Low-Band range
			model_raw_K    = GL[j,:,3+i]/1000
			func_model     = spi.interp1d(v_raw, model_raw_K, kind='linear')
			
			model21_low_K   = func_model(v_low)
			model21_high_K  = func_model(v_high)
			
	
	
	
			index_array[index_model, 0] = j   +1
			index_array[index_model, 1] = 3+i +1
	
	
			
			# Low Band
			residuals = np.reshape(model21_low_K - T21, (1,-1))
			residuals_low_all[index_model, :] = residuals
			model21_low_all[index_model, :]   = model21_low_K
			
			
			
			#chi_sq    = np.dot(np.dot(residuals, inv_COV_low), residuals.T)[0,0]
			#chi_sq_low_all[index_model]      = chi_sq
		
			
			
			# High Band
			par          = fit_polynomial_fourier('EDGES_polynomial', v_high/200, model21_high_K, 5)
			model_5terms = par[1]
			residuals    = np.reshape(model21_high_K - model_5terms, (1,-1))
			residuals_high_all[index_model, :] = residuals
			model21_high_all[index_model, :]   = model21_high_K
			
			
			#L, parX, chi_sq = likelihood_21cm_V2(v_high, t_high, w_high, noise_std_profile, 0.035, model21_high_K, 5, 200, foreground_model='EDGES_polynomial')
			#chi_sq_high_all[index_model]     = chi_sq
			
			
			
			print(index_model+1)
			

	# RMS
	rms_low_all  = np.std(residuals_low_all, axis=1)
	rms_high_all = np.std(residuals_high_all, axis=1)
	
		
	# Saving text file
	out_txt_T = np.array([index_array[:,0], index_array[:,1], rms_low_all, rms_high_all])
	out_txt   = out_txt_T.T
	
	np.savetxt(home_folder + '/DATA/EDGES/global_21cm_models/fialkov/low_band_DM/results/rms_results.txt', out_txt, header='index ASTRO\tindex DM\tRMS_Low-Band\tRMS_High-Band')
	
	
	# Saving output arrays
	save_file = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/low_band_DM/results/rms_results.hdf5'
	with h5py.File(save_file, 'w') as hf:

		print('hola')

		hf.create_dataset('index_array',  data = index_array)	
		hf.create_dataset('v_low',        data = v_low)
		hf.create_dataset('models_low',   data = model21_low_all)
		hf.create_dataset('rms_low',      data = rms_low_all)
		hf.create_dataset('v_high',       data = v_high)
		hf.create_dataset('models_high',  data = model21_high_all)
		hf.create_dataset('rms_high',     data = rms_high_all)
		

					
	return index_array, v_low, model21_low_all, rms_low_all, v_high, model21_high_all, rms_high_all, out_txt




















def low_band_DM_TRY2_likelihood_plot():
	
	# Load Models
	m  = sio.loadmat('/home/ramo7131/DATA/EDGES/global_21cm_models/fialkov/low_band_DM/models/global_all.mat')
	GL = m['GL']
	v_raw = GL[0,:,0]
	
		
	d = np.genfromtxt('/home/ramo7131/DATA/EDGES/global_21cm_models/fialkov/low_band_DM/results/chi_sq_results.txt')
	
	ix_low          = np.argsort(d[:,2])
	ix_high         = np.argsort(d[:,3])
	
	ix_all          = np.argsort(d[:,2]+d[:,3])
	
	
	ix_low_1percent  = ix_low[0:10000]    #0:int(0.0005*len(d[:,0]))]
	ix_high_1percent = ix_high[0:10000]   #0:int(0.0005*len(d[:,0]))]
	ix_all_1percent  = ix_all[0:10000]    #0:int(0.0005*len(d[:,0]))]
	
	











	
	k = 0
	for i in range(len(ix_low_1percent)):
		print(i)
		
		if k == 0:
			models_low = GL[int(d[ix_low_1percent[i],0]-1),:,int(d[ix_low_1percent[i],1]-1)]
			k = 1
			
		else:
			models_low = np.vstack((models_low, GL[int(d[ix_low_1percent[i],0]-1),:,int(d[ix_low_1percent[i],1]-1)]))
	




	k = 0
	for i in range(len(ix_high_1percent)):
		print(i)
		
		if k == 0:
			models_high = GL[int(d[ix_high_1percent[i],0]-1),:,int(d[ix_high_1percent[i],1]-1)]
			k = 1
			
		else:
			models_high = np.vstack((models_high, GL[int(d[ix_high_1percent[i],0]-1),:,int(d[ix_high_1percent[i],1]-1)]))
	


	k = 0
	for i in range(len(ix_all_1percent)):
		print(i)
		
		if k == 0:
			models_all = GL[int(d[ix_all_1percent[i],0]-1),:,int(d[ix_all_1percent[i],1]-1)]
			k = 1
			
		else:
			models_all = np.vstack((models_all, GL[int(d[ix_all_1percent[i],0]-1),:,int(d[ix_all_1percent[i],1]-1)]))






	
	#plt.plot()

	
	
	plt.figure(1)
	
	plt.subplot(3,1,1)	
	plt.plot(v_raw, models_low.T)
	plt.xticks([0,25,50,75,100,125,150,175,200],[''])
	plt.title('Favored by Low-Band Only')
	plt.ylabel('temperature [mK]')
	plt.ylim([-2000, 100])
	plt.plot([50,50],[-2000, 100], 'b--', linewidth=2)
	plt.plot([100,100],[-2000, 100], 'b--', linewidth=2)
	
	
	
	
	plt.subplot(3,1,2)
	plt.plot(v_raw, models_high.T)
	plt.xticks([0,25,50,75,100,125,150,175,200],[''])
	plt.title('Favored by High-Band Only')
	plt.ylabel('temperature [mK]')
	plt.ylim([-2000, 100])
	plt.plot([90,90],[-2000, 100], 'r--', linewidth=2)
	plt.plot([190,190],[-2000, 100], 'r--', linewidth=2)	
	
	
	plt.subplot(3,1,3)
	plt.plot(v_raw, models_all.T)
	plt.title('Favored by Low-Band AND High-Band')
	plt.xticks([0,25,50,75,100,125,150,175,200])
	plt.xlabel('frequency [MHz]')
	plt.ylabel('temperature [mK]')
	plt.ylim([-2000, 100])
	plt.plot([50,50],[-2000, 100], 'b--', linewidth=2)
	plt.plot([100,100],[-2000, 100], 'b--', linewidth=2)
	plt.plot([90,90],[-2000, 100], 'r--', linewidth=2)
	plt.plot([190,190],[-2000, 100], 'r--', linewidth=2)	
	
	
	
	
	#np.savetxt('/home/ramo7131/DATA/EDGES/global_21cm_models/fialkov/low_band_DM/results/index_total_chi_sq_low_to_high.txt', d[ix_all,:], header='index ASTRO\tindex DM\tchi_sq_Low-Band\tchi_sq_High-Band')
	
	return d[ix_all,:]










def low_band_DM_TRY2_part2():
	
	# Load Models
	m  = sio.loadmat('/home/ramo7131/DATA/EDGES/global_21cm_models/fialkov/low_band_DM/models/global_all.mat')
	GL = m['GL']
	v_raw = GL[0,:,0]
			
	# Load EDGES data
	v_low, t_low, w_low = alan_low_band_spectrum()
	T21 = model_eor_flattened_gaussian(v_low, model_type=1, T21=-0.5, vr=78, dv=19, tau0=7, tilt=0)	
	v_high, t_high, w_high, noise_std_profile = EDGES_high_band_data(save='no', save_suffix='_test', simulated='no', residual_fraction=0.5)


	
	# Loading results
	path_file = '/home/ramo7131/DATA/EDGES/global_21cm_models/fialkov/low_band_DM/results/chi_sq_results.hdf5'
	with h5py.File(path_file,'r') as hf:

		print('hola')

		hfx          = hf.get('index_array')
		index_array  = np.array(hfx)
		
		hfx          = hf.get('v_low')
		v_low        = np.array(hfx)
		
		hfx          = hf.get('models_low')
		models_low   = np.array(hfx)
		
		hfx          = hf.get('chi_sq_low')
		chi_sq_low   = np.array(hfx)
		
		hfx          = hf.get('v_high')
		v_high       = np.array(hfx)
		
		hfx          = hf.get('models_high')
		models_high  = np.array(hfx)
		
		hfx          = hf.get('chi_sq_high')
		chi_sq_high  = np.array(hfx)
		

	diff = models_low - T21 
	kk   = np.std(diff, axis=1)
	
	ix = np.argsort(kk)
	plt.plot(v_low, models_low[ix[0:100],:].T)







					
	return T21, index_array, v_low, models_low, chi_sq_low, v_high, models_high, chi_sq_high









def flattened_gaussian_covariance(v):

	# Covariance matrix of parameters
	# -------------------------------------------
	
	# Variance of parameters
	A         = 0.5
	sigma_A   = (0.2+((0.5-0.2)/2))/3
	
	v0        = 78
	sigma_v0  = 1/3
	
	w         = 19
	sigma_w   = (2+(4-2)/2)/3
	
	tau       = 7
	sigma_tau = (3+(5-3)/2)/3
	
	
	# Covariance between A and tau estimated from MCMC fit
	MCMC = read_low_band_MCMC('/home/ramo7131/DATA/EDGES/results/low_band/products/MCMC_results/mcmc_edges_polynomial_nfg_5_flattened_gaussian_n21_4_noise_std_13mK.hdf5')
	k    = MCMC[7][:,0::]
	COVARIACE_MATRIX_A_tau = np.cov(np.array([k[:,5]/1000, k[:,8]]))   # Amplitude in K
	sigma_A_tau = COVARIACE_MATRIX_A_tau[0,1]	
	#print(sigma_A_tau)
	
	
	# Covariance matrix of parameters
	COV       = np.array([[sigma_A**2, 0, 0, sigma_A_tau], [0, sigma_v0**2, 0, 0], [0, 0, sigma_w**2, 0], [sigma_A_tau, 0, 0, sigma_tau**2]])
	
	


	# Jacobian Matrix
	# ---------------------------------------
	
	# Derivatives with respect to parameters
	B = 4*((v-v0)**2)/(w**2) * np.log( (-1/tau) * np.log((1+np.exp(-tau))/2) )
	T21 = -A * ((1-np.exp(-tau*np.exp(B))) / (1-np.exp(-tau)))
	
	dT21_dA  = -(1-np.exp(-tau*np.exp(B)))/(1-np.exp(-tau))

	dT21_dv0 = (2*(v-v0)) * ((tau*A)/(1-np.exp(-tau))) * np.exp(B-tau*np.exp(B)) * (4/(w**2)) * np.log((-1/tau) * np.log((1+np.exp(-tau))/(2)))
	
	dT21_dw  = (2/(w**3)) * ((tau*A)/(1-np.exp(-tau))) * np.exp(B-tau*np.exp(B)) * 4*((v-v0)**2) * np.log( (-1/tau) * np.log((1+np.exp(-tau))/2) )
	
	dB_dtau  = ((4*(v-v0)**2)/(w**2)) * ((-tau)/(np.log((1+np.exp(-tau))/2))) * (((1/tau)*((np.exp(-tau))/(1+np.exp(-tau)))) + (((1)/(tau**2))*np.log((1+np.exp(-tau))/(2))))
	
	dT21_dtau = (-A) * (((np.exp(-tau*np.exp(B))*np.exp(B)*(1+tau*dB_dtau))/(1-np.exp(-tau))) - ((np.exp(-tau))*(1-np.exp(-tau*np.exp(B)))/((1-np.exp(-tau))**2)))
	
		
	# Jacobian Matrix
	J         = np.array([dT21_dA, dT21_dv0, dT21_dw, dT21_dtau])
	
	
	
	# Covariance Matrix in Frequency from Parameter Uncertainties
	# -------------------------------------------------------------
	COV_freq_par   = np.dot( np.dot(J.T, COV), J )
	
	
	
	# Covariance Matrix from Noise
	# ---------------------------------
	noise_std      = 0.025 # K
	COV_freq_noise = np.diag((noise_std**2)*np.ones(len(v)))
	
	
	
	
	# Total Covariance Matrix
	# ------------------------------
	COV_freq = COV_freq_par + COV_freq_noise
	
	
	
	return COV_freq










def plot_21cmFAST_models():

	
	## Settings for Figures
	## ---------------------------
	#size_x = 12
	#size_y = 9

	#dx     = 0.39
	#dy     = 0.26	
	#x0     = 0.08  #0.056
	#y0     = 0.075  #0.059
	#x00    = 0.005
	#y00    = 0.007
	
	
	#FS = 12
	#FS_title = 16
	
	#vlow  =  30
	#vhigh = 210
	
	#tlow  = -320
	#thigh =   60
	
	#xt = np.arange(40,201,20)
	#yt = np.arange(-280,41,40)



	
	#f1     = plt.figure(num=1, figsize=(size_x, size_y))
	
	#ax11   = f1.add_axes([1*x0 + 0*(dx+x00), 1*y0 + 0*(dy+y00), dx, dy])
	#ax21   = f1.add_axes([1*x0 + 0*(dx+x00), 1*y0 + 1*(dy+y00), dx, dy])
	#ax31   = f1.add_axes([1*x0 + 0*(dx+x00), 1*y0 + 2*(dy+y00), dx, dy])
	
	#ax12   = f1.add_axes([1*x0 + 1*(dx+x00), 1*y0 + 0*(dy+y00), dx, dy])
	#ax22   = f1.add_axes([1*x0 + 1*(dx+x00), 1*y0 + 1*(dy+y00), dx, dy])
	#ax32   = f1.add_axes([1*x0 + 1*(dx+x00), 1*y0 + 2*(dy+y00), dx, dy])
	
	#ax11.set_xlim(vlow, vhigh)
	#ax11.set_ylim(tlow, thigh)

	#ax21.set_xlim(vlow, vhigh)
	#ax21.set_ylim(tlow, thigh)
	
	#ax31.set_xlim(vlow, vhigh)
	#ax31.set_ylim(tlow, thigh)
	
	#ax12.set_xlim(vlow, vhigh)
	#ax12.set_ylim(tlow, thigh)
	
	#ax22.set_xlim(vlow, vhigh)
	#ax22.set_ylim(tlow, thigh)
	
	#ax32.set_xlim(vlow, vhigh)
	#ax32.set_ylim(tlow, thigh)
	
	
	
	#ax11.set_xticks(xt)
	#ax21.set_xticks(xt)
	#ax31.set_xticks(xt)
	
	#ax12.set_xticks(xt)
	#ax22.set_xticks(xt)
	#ax32.set_xticks(xt)
		
	#ax11.set_yticks(yt)
	#ax21.set_yticks(yt)
	#ax31.set_yticks(yt)
	
	#ax12.set_yticks(yt)
	#ax22.set_yticks(yt)
	#ax32.set_yticks(yt)
	
	
	#ax21.set_xticklabels('')
	#ax31.set_xticklabels('')
	
	#ax22.set_xticklabels('')
	#ax32.set_xticklabels('')
	
	#ax12.set_yticklabels('')
	#ax22.set_yticklabels('')
	#ax32.set_yticklabels('')


	#ax31.set_title('EDGES Data Only', fontsize=FS_title)
	#ax32.set_title('Combined Constraints', fontsize=FS_title)

	#ax11.set_ylabel(r'temperature [mK]', fontsize=FS)
	#ax21.set_ylabel(r'temperature [mK]', fontsize=FS)
	#ax31.set_ylabel(r'temperature [mK]', fontsize=FS)
	
	#ax11.set_xlabel(r'frequency [MHz]', fontsize=FS)
	#ax12.set_xlabel(r'frequency [MHz]', fontsize=FS)	


	## Colorbar
	## ------------------------
	#cb_x0 = 0.93
	#cb_y0 = 0.1
	
	#cb_dx = 0.02
	#cb_dy = 0.2
	
	#min_prob = 0
	#max_prob = 1
	
	#cax1 = f1.add_axes([cb_x0, y0 + 0.5*dy - cb_dy/2, cb_dx, cb_dy])
	#cax2 = f1.add_axes([cb_x0, y0 + 1.5*dy + 1*y00 - cb_dy/2, cb_dx, cb_dy])
	#cax3 = f1.add_axes([cb_x0, y0 + 2.5*dy + 2*y00 - cb_dy/2, cb_dx, cb_dy])
	




	plt.close()
	plt.close()



	size_x = 7
	size_y = 8

	dx     = 0.75
	dy     = 0.41	
	x0     = 0.12  #0.056
	y0     = 0.06  #0.059
	x00    = 0.005
	y00    = 0.06
	
	
	FS = 12
	FS_title = 16
	
	vlow  =  40
	vhigh = 202
	
	tlow  = -340
	thigh =   60
	
	xt = np.arange(50,191,20)
	yt = np.arange(-320,41,40)


	f2     = plt.figure(num=2, figsize=(size_x, size_y))

	ax_top = f2.add_axes([1*x0 + 0*(dx+x00), 1*y0 + 1*(dy+y00), dx, dy])
	ax_top.set_xlim(vlow, vhigh)
	ax_top.set_ylim(tlow, thigh)
	ax_top.set_xticks(xt)
	ax_top.set_yticks(yt)
	ax_top.text(42, 20, '(a)', fontsize=18)


	ax_bot = f2.add_axes([1*x0 + 0*(dx+x00), 1*y0 + 0*(dy+y00), dx, dy])
	ax_bot.set_xlim(vlow, vhigh)
	ax_bot.set_ylim(tlow, thigh)
	ax_bot.set_xticks(xt)
	ax_bot.set_yticks(yt)
	ax_bot.text(42, 20, '(b)', fontsize=18)
	

	ax_top.set_ylabel(r'temperature [mK]', fontsize=FS)
	ax_bot.set_ylabel(r'temperature [mK]', fontsize=FS)
	ax_bot.set_xlabel(r'frequency [MHz]', fontsize=FS)




	ax2 = ax_top.twiny()
	ax2.set_xlabel(r'$z$', fontsize=14)
	v0 = 40
	#z0 = frequency2redshift(v0)
	ax2.set_xticks(np.array((np.abs(redshift2frequency(28)-v0), np.abs(redshift2frequency(24)-v0), np.abs(redshift2frequency(20)-v0), np.abs(redshift2frequency(18)-v0), np.abs(redshift2frequency(16)-v0), np.abs(redshift2frequency(14)-v0), np.abs(redshift2frequency(12)-v0), np.abs(redshift2frequency(10)-v0), np.abs(redshift2frequency(9)-v0), np.abs(redshift2frequency(8)-v0), np.abs(redshift2frequency(7)-v0), np.abs(202-v0))))
	ax2.set_xticklabels(['28', '24', '20', '18', '16', '14', '12', '10', '9', '8', '7', '6'])	
	
	
	


	# Colorbar
	# ------------------------
	cb_x0 = 0.89
	cb_y0 = 0.2
	
	cb_dx = 0.02
	cb_dy = 0.35
	
	min_prob = 0
	max_prob = 1
	
	cbar = f2.add_axes([cb_x0, 0.5 - cb_dy/2, cb_dx, cb_dy])





















	# Load 21-cm signals and likelihoods
	# ---------------------------------------

	
	v = np.arange(41,199,1)
	models = np.ones((10000, len(v)))
	for i in range(10000):
		print(i)
		model, aux = model_eor_mesinger(i, v, interpolation_kind='linear')
		models[i,:] = 1000*model
				
	LLnp = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/products/model_rejection/mesinger/likelihood/likelihood_10000models_new_method_20171230.txt')
	Lnp  = LLnp[:,1]/np.max(LLnp[:,1])
	
	LLp  = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/products/model_rejection/mesinger/likelihood/likelihood_10000models_withPriors_NotNormalised_20180225.txt')
	Lp   = LLp[:,1]/np.max(LLp[:,1])
	

	NR = 50
	index_random = np.random.randint(0, 10000, NR)
	
	models2 = models[index_random, :]
	Lnp2    = Lnp[index_random]
	Lp2     = Lp[index_random]	
	
	ix_np  = np.flip(np.argsort(Lnp2), axis=0)
	ix_p   = np.argsort(Lp2)
	
	Lx_np  = Lnp2[ix_np]
	Lx_p   = Lp2[ix_p]
	Mx_np  = models2[ix_np,:]
	Mx_p   = models2[ix_p,:]
	
	
	
	
	
	
	
	#MxA = Mx[(Lx>=10**(-1))  & (Lx<=10**(-0)), :]
	#MxB = Mx[(Lx>=10**(-2))  & (Lx<=10**(-1)), :]
	#MxC = Mx[(Lx>=10**(-12)) & (Lx<=10**(-2)), :]
	
	#LxA = Lx[(Lx>=10**(-1))   & (Lx<=10**(-0))]
	#LxB = Lx[(Lx>=10**(-2))   & (Lx<=10**(-1))]
	#LxC = Lx[(Lx>=10**(-12))  & (Lx<=10**(-2))]
	
	
	#ixA  = np.flip(np.argsort(LxA), axis=0)  # index for decreasing likelihood
	#ixB  = np.flip(np.argsort(LxB), axis=0)  # index for decreasing likelihood
	#ixC  = np.flip(np.argsort(LxC), axis=0)  # index for decreasing likelihood
	
	#Lx_high = LxA[ixA]
	#Mx_high = MxA[ixA,:]
	
	#Lx_mid = LxB[ixB]
	#Mx_mid = MxB[ixB,:]	
	
	#Lx_low = LxC[ixC]
	#Mx_low = MxC[ixC,:]
	







	

	#max_log_like_high =  0
	#min_log_like_high =  -4
	
	#max_log_like_mid = -0
	#min_log_like_mid = -4	
	
	#max_log_like_low = -0
	#min_log_like_low = -4	
	




	max_log_like =  0
	min_log_like = -3 #-1	

	CMAP   = cm.viridis_r # copper_r # #cm.gnuplot
	XY = [[0,0],[0,0]]
	levels = np.arange(min_log_like, max_log_like+0.001, 0.001)
	IMAGE_MAP = plt.contourf(XY, levels, cmap=CMAP, vmin=min_log_like, vmax=max_log_like)
	
	
	
	for i in range(len(ix_np)):
		log_like = np.log10(Lx_np[i])
		norm_log_like = (log_like - min_log_like) / (max_log_like - min_log_like)
		c = CMAP(norm_log_like)
		print(log_like)
		ax_top.plot(v, Mx_np[i,:], color=c, linewidth=1.0)
		
	ax_top.plot([90,90], [-340, 60], '--m', linewidth=3)
	ax_top.plot([190,190], [-340, 60], '--m', linewidth=3)		
	


	
	for i in range(len(ix_p)):
		log_like = np.log10(Lx_p[i])
		norm_log_like = (log_like - min_log_like) / (max_log_like - min_log_like)
		c = CMAP(norm_log_like)
		print(log_like)
		ax_bot.plot(v, Mx_p[i,:], color=c, linewidth=1.0)

	#ax_bot.plot([90,90], [-340, 60], '--', c=[0,0.7,0], linewidth=3)
	#ax_bot.plot([190,190], [-340, 60], '--', c=[0,0.7,0], linewidth=3)
	#ax_bot.arrow(90, -320, 90, 0,   fc=[0,0.7,0], ec=[0,0.7,0], head_width=15, head_length=9,   linewidth=1, zorder=6)
	#ax_bot.arrow(190, -320, -90, 0, fc=[0,0.7,0], ec=[0,0.7,0], head_width=15, head_length=9,   linewidth=1, zorder=6)		
	#ax_bot.text(111, -315, 'EDGES High-Band', fontsize=15, color=[0,0.7,0])
	
	ax_bot.plot([90,90], [-340, 60], '--m', linewidth=3)
	ax_bot.plot([190,190], [-340, 60], '--m', linewidth=3)
	ax_bot.arrow(90, -320, 90, 0,   fc='m', ec='m', head_width=15, head_length=9,   linewidth=1, zorder=6)
	ax_bot.arrow(190, -320, -90, 0, fc='m', ec='m', head_width=15, head_length=9,   linewidth=1, zorder=6)		
	ax_bot.text(111, -315, 'EDGES High-Band', fontsize=15, color='m')

	colbar = plt.colorbar(IMAGE_MAP, cax=cbar, ticks=np.arange(min_log_like, max_log_like+0.1, 1))
	colbar.ax.set_ylabel(r'${\rm log}_{10}(P/P_{\rm max})$', fontsize=12)



	plt.savefig(home_folder + '/DATA/EDGES/results/plots/20180310/signals_21cmFAST_likelihood.pdf', bbox_inches='tight')


	plt.close()
	plt.close()
	        




	#for i in range(len(ixA)):
		#log_like_high = np.log10(Lx_high[i])
		#norm_log_like_high = (log_like_high - min_log_like_high) / (max_log_like_high - min_log_like_high)
		#c = CMAP(norm_log_like_high)
		##print(log_like_high)
		#ax31.plot(v, Mx_high[i], color=c, linewidth=0.2)
		
		
	#for i in range(len(ixB)):
		#log_like_mid = np.log10(Lx_mid[i])
		#norm_log_like_mid = (log_like_mid - min_log_like_mid) / (max_log_like_mid - min_log_like_mid)
		#c = CMAP(norm_log_like_mid)
		##print(log_like_high)
		#ax21.plot(v, Mx_mid[i], color=c, linewidth=0.2)		


	#for i in range(len(ixC)):
		#log_like_low = np.log10(Lx_low[i])
		#norm_log_like_low = (log_like_low - min_log_like_low) / (max_log_like_low - min_log_like_low)
		#c = CMAP(norm_log_like_low)
		##print(log_like_high)
		#ax11.plot(v, Mx_low[i], color=c, linewidth=0.2)	



		
	#MAP1 = ax11.plot(v, Mx_low.T, linewidth=0.2, cmap=color_map, vmin=min_prob, vmax=max_prob)
	#MAP2 = ax21.plot(v, Mx_middle.T, linewidth=0.2)
	#MAP3 = ax31.plot(v, Mx_high.T, linewidth=0.2)
	
	#cbar1 = plt.colorbar(MAP1, cax=cax1, orientation="vertical", ticks=[0, 0.25, 0.5, 0.75, 1])
	#cbar2 = plt.colorbar(MAP2, cax=cax2, orientation="vertical", ticks=[0, 0.25, 0.5, 0.75, 1])
	#cbar3 = plt.colorbar(MAP3, cax=cax3, orientation="vertical", ticks=[0, 0.25, 0.5, 0.75, 1])

	return 0   #Mx, Lx














def plot_21cmFAST_models_combined_analysis():


	plt.close()
	plt.close()
	


	# Load 21-cm signals and likelihoods
	# ---------------------------------------

	
	v = np.arange(41,199,1)
	models = np.ones((10000, len(v)))
	for i in range(10000):
		print(i)
		model, aux = model_eor_mesinger(i, v, interpolation_kind='linear')
		models[i,:] = 1000*model
				
	LLnp = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/products/model_rejection/mesinger/likelihood/likelihood_10000models_new_method_20171230.txt')
	Lnp  = LLnp[:,1]/np.max(LLnp[:,1])
	
	LLp  = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/products/model_rejection/mesinger/likelihood/likelihood_10000models_withPriors_NotNormalised_20180225.txt')
	Lp   = LLp[:,1]/np.max(LLp[:,1])
	
	#LLp  = np.genfromtxt(home_folder + '/DATA/EDGES/results/high_band/products/model_rejection/mesinger/likelihood/likelihood_10000models_withPriors_NotNormalised_90-190MHz.txt')
	#Lp   = LLp[:,1]/np.max(LLp[:,1])
	
	
	
	
	L_thres=0.34
	
	



	size_x = 8
	size_y = 4.5

	dx     = 0.70
	dy     = 0.80	
	x0     = 0.12  #0.056
	y0     = 0.1  #0.059
		
	f1     = plt.figure(num=1, figsize=(size_x, size_y))

	ax = f1.add_axes([x0, y0, dx, dy])

	#ax.plot(v, models[Lp==np.min(Lp),:][0]-1000, c=[0.5, 0.5, 0.5], linewidth=5)
	#ax.plot(v, models[Lp==np.max(Lp),:][0]-1000, 'b', linewidth=5)
	
	ax.plot(v, models[Lp<L_thres,:].T, c=[0.5, 0.5, 0.5], linewidth=0.1)
	
	
	
	# Likelihood and models organized from low to high likelihood
	Lp_high     = Lp[Lp>=L_thres]
	models_high = models[Lp>=L_thres,:]
	ix = np.argsort(Lp_high)
	Lx = Lp_high[ix]
	Mx = models_high[ix,:]




	max_log_like =  0
	min_log_like = -0.5   #0.5 #-1	

	CMAP   = cm.viridis_r # copper_r # #cm.gnuplot
	XY = [[0,0],[0,0]]
	levels = np.arange(min_log_like, max_log_like+0.001, 0.001)
	IMAGE_MAP = plt.contourf(XY, levels, cmap=CMAP, vmin=min_log_like, vmax=max_log_like)
	


	
	for i in range(len(ix)):   # (10): # 
		log_like = np.log10(Lx[i])
		norm_log_like = (log_like - min_log_like) / (max_log_like - min_log_like)
		c = CMAP(norm_log_like)
		#print(log_like)
		ax.plot(v, Mx[i,:], color=c, linewidth=0.1)






	# Colorbar
	# ------------------------
	cb_x0 = 0.85
	cb_y0 = 0.2
	
	cb_dx = 0.02
	cb_dy = 0.7
	
	#min_prob = 0
	#max_prob = 1
	
	cbar = f1.add_axes([cb_x0, 0.5 - cb_dy/2, cb_dx, cb_dy])



	colbar = plt.colorbar(IMAGE_MAP, cax=cbar, ticks=np.arange(min_log_like, max_log_like+0.01, 0.1))
	colbar.ax.set_ylabel(r'${\rm log}_{10}(P/P_{\rm max})$', fontsize=12)
	
	
	
	
	ax.plot([90, 90], [-400, 100], '--m', linewidth=3)
	ax.plot([190, 190], [-400, 100], '--m', linewidth=3)
	ax.arrow(90, -340, 90, 0,   fc='m', ec='m', head_width=15, head_length=9,   linewidth=1, zorder=6)
	ax.arrow(190, -340, -90, 0, fc='m', ec='m', head_width=15, head_length=9,   linewidth=1, zorder=6)		
	ax.text(114.1, -335, 'EDGES High-Band', fontsize=15, color='m')	
	
	#ax.plot([90, 90], [-400, 100], '--', c=[0,0.7,0], linewidth=3)
	#ax.plot([190, 190], [-400, 100], '--', c=[0,0.7,0], linewidth=3)
	#ax.arrow(90, -340, 90, 0,   fc=[0,0.7,0], ec=[0,0.7,0], head_width=15, head_length=9,   linewidth=1, zorder=6)
	#ax.arrow(190, -340, -90, 0, fc=[0,0.7,0], ec=[0,0.7,0], head_width=15, head_length=9,   linewidth=1, zorder=6)		
	#ax.text(114.1, -335, 'EDGES High-Band', fontsize=15, color=[0,0.7,0])
	
	
	
	#ax.legend([r'($\frac{L}{L_{\rm max}}$)$<$0.5',r'($\frac{L}{L_{\rm max}}$)$\geq$0.5'], fontsize=12)
	ax.set_xlabel('frequency [MHz]')
	ax.set_ylabel('temperature [mK]')

	vlow  =  40
	vhigh = 202
	
	tlow  = -380
	thigh =   60
	
	xt = np.arange(50,191,20)
	yt = np.arange(-360,41,40)
	
	ax.set_xlim(vlow, vhigh)
	ax.set_ylim(tlow, thigh)
	ax.set_xticks(xt)
	ax.set_yticks(yt)	
	
	
	ax2 = ax.twiny()
	ax2.set_xlabel(r'$z$', fontsize=14)
	v0 = 40
	ax2.set_xticks(np.array((np.abs(redshift2frequency(28)-v0), np.abs(redshift2frequency(24)-v0), np.abs(redshift2frequency(20)-v0), np.abs(redshift2frequency(18)-v0), np.abs(redshift2frequency(16)-v0), np.abs(redshift2frequency(14)-v0), np.abs(redshift2frequency(12)-v0), np.abs(redshift2frequency(10)-v0), np.abs(redshift2frequency(9)-v0), np.abs(redshift2frequency(8)-v0), np.abs(redshift2frequency(7)-v0), np.abs(202-v0))))
	ax2.set_xticklabels(['28', '24', '20', '18', '16', '14', '12', '10', '9', '8', '7', '6'])	
	
	
	plt.savefig(home_folder + '/DATA/EDGES/results/plots/20180310/signals_21cmFAST_likelihood_combined.pdf', bbox_inches='tight')
	#plt.savefig(home_folder + '/DATA/EDGES/results/plots/20180310/signals_21cmFAST_likelihood_combined_SIMULATION.pdf', bbox_inches='tight')


	plt.close()
	plt.close()
	
	
	return v, models, Lnp, Lp

















def fialkov_analysis_chi_square_Npar5_Npix20(save_filename_suffix, vlow, vhigh, low_band_data_case=2, foreground_model='Physical_model', Nfg=5):
	
	"""
	
	April 17, 2018
	
	"""
	
	
	# Loading Low-band data
	v_full, t_full, w_full, res1, res2, t21 = alan_low_band_spectrum(case=low_band_data_case)	
	
	if low_band_data_case==2:
		sigma_data = 0.025  # K
		
		
		
	#v_full, t_full, w_full, noise_full = EDGES_high_band_data(save='no', save_suffix='_test', simulated=simulated_data, residual_fraction=simulated_residual_fraction)
	
	
	# Cutting frequency
	v                 = v_full[(v_full>=vlow) & (v_full<=vhigh)]
	t                 = t_full[(v_full>=vlow) & (v_full<=vhigh)]
	w                 = w_full[(v_full>=vlow) & (v_full<=vhigh)]
	#noise_std_profile = noise_full[(v_full>=vlow) & (v_full<=vhigh)]
	
	print('Number of channels: ' + str(len(v)))
	
	
	# Frequency vector
	z_raw    = np.arange(5,50.05,0.1)
	freq_raw = redshift2frequency(z_raw)

	# Initializing output array with random numbers, as a worst case scenario
	sz = 20**5    # 3,200,000
	
	out_signals  = np.random.normal(size=(sz, len(v)))
	out_par_21   = np.random.normal(size=(sz, 7))
	out_flags    = np.random.normal(size=(sz, 4))
	out_xHI59    = np.random.normal(size=(sz))
	out_xHI754   = np.random.normal(size=(sz))	
	out_Zeta     = np.random.normal(size=(sz))

	out_L        = np.random.normal(size=(sz))
	out_chi_sq   = np.random.normal(size=(sz))
	out_par_fg   = np.random.normal(size=(sz, Nfg))
	


	k = 0
	for j in range(320):

		# Loading models, parameters, and Likelihoods
		file_name            = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/Global21cmV5/output_files/Npar5_tau_0.055-0.090/grid_Npar5_Npix20_' + str(j+1) + '.mat'
		#file_name            = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/Global21cmV5/output_files2/Npar5_vmin_instead_of_Rmfp/grid_Npar5_Npix20_' + str(j+1) + '.mat'
		mat                  = sio.loadmat(file_name)

		models = mat['Signal']/1000  # in K
		xHI59  = mat['xHI59'][0]
		xHI754 = mat['xHI754'][0]
		v011   = mat['v011'][0]
		v016   = mat['v016'][0]
		Zeta   = mat['Zeta'][0]
		par    = mat['parameters_21cm_set']		
		pp1    = mat['p1']; p1 = pp1[0,:]
		pp2    = mat['p2']; p2 = pp2[0,:]
		pp3    = mat['p3']; p3 = pp3[0,:]
		pp4    = mat['p4']; p4 = pp4[0,:]
		pp5    = mat['p5']; p5 = pp5[0,:]
		pp6    = mat['p6']; p6 = pp6[0,:]
		pp7    = mat['p7']; p7 = pp7[0,:]
		flags  = mat['flag']
	
		Nmodels = len(models[:,0])
		
		for i in range(Nmodels):
			
			# Raw model
			model21_raw = models[i,:]
		
			# Interpolation of model
			func_model  = spi.interp1d(freq_raw, model21_raw, kind='linear')
			model21     = func_model(v)
		
			# Storing models
			out_signals[k,:] = model21	


			# Storing parameter values
			out_par_21[k,:] = par[i,:]
		
			# Storing flags
			out_flags[k,:]  = flags[i,:]
		
			# Storing xHI
			out_xHI59[k]  = xHI59[i]
			out_xHI754[k] = xHI754[i]
			
			# Storing Zeta
			out_Zeta[k]   = Zeta[i]			
		
			print(k)
			
			# Computing and storing the chi square
			XXX       = fit_polynomial_fourier(foreground_model, v/200, t-model21, Nfg, Weights=w)
			par_fg    = XXX[0]
			model_fg  = XXX[1]
			chi_sq    = np.sum(((((t-model21) - model_fg)[w>0])/sigma_data)**2)
				
				
			out_L[k]        = 0
			out_chi_sq[k]   = chi_sq
			out_par_fg[k,:] = par_fg
									
			k = k + 1
		

	# Saving		
	save_file = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/Global21cmV5/results/low_band_Npar5_tau_0.055-0.090/results_Npar5_Npix20' + save_filename_suffix + '.hdf5'
	#save_file = home_folder + '/DATA/EDGES/global_21cm_models/fialkov/Global21cmV5/results/Npar5_vmin_instead_of_Rmfp/results_Npar5_Npix20' + save_filename_suffix + '.hdf5'
	with h5py.File(save_file, 'w') as hf:
		
		hf.create_dataset('frequency',         data = v)
		hf.create_dataset('signals',           data = out_signals)
		hf.create_dataset('parameters_21cm',   data = out_par_21)
		hf.create_dataset('p1',                data = p1)
		hf.create_dataset('p2',                data = p2)
		hf.create_dataset('p3',                data = p3)
		hf.create_dataset('p4',                data = p4)
		hf.create_dataset('p5',                data = p5)
		hf.create_dataset('p6',                data = p6)
		hf.create_dataset('p7',                data = p7)		
		hf.create_dataset('flags',             data = out_flags)
		hf.create_dataset('xHI59',             data = out_xHI59)
		hf.create_dataset('xHI754',            data = out_xHI754)
		hf.create_dataset('Zeta',              data = out_Zeta)
		hf.create_dataset('likelihood_EDGES',  data = out_L)
		hf.create_dataset('chi_sq',            data = out_chi_sq)
		hf.create_dataset('parameters_fg',     data = out_par_fg)
		
		

	return 0 #out_chi_sq, v, out_signals



